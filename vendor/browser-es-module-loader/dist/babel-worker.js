(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeFrameColumns = codeFrameColumns;
exports.default = _default;

function _highlight() {
  var data = _interopRequireWildcard(require("@babel/highlight"));

  _highlight = function _highlight() {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

var deprecationWarningShown = false;

function getDefs(chalk) {
  return {
    gutter: chalk.grey,
    marker: chalk.red.bold,
    message: chalk.red.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

function getMarkerLines(loc, source, opts) {
  var startLoc = Object.assign({
    column: 0,
    line: -1
  }, loc.start);
  var endLoc = Object.assign({}, startLoc, loc.end);

  var _ref = opts || {},
      _ref$linesAbove = _ref.linesAbove,
      linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
      _ref$linesBelow = _ref.linesBelow,
      linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

  var startLine = startLoc.line;
  var startColumn = startLoc.column;
  var endLine = endLoc.line;
  var endColumn = endLoc.column;
  var start = Math.max(startLine - (linesAbove + 1), 0);
  var end = Math.min(source.length, endLine + linesBelow);

  if (startLine === -1) {
    start = 0;
  }

  if (endLine === -1) {
    end = source.length;
  }

  var lineDiff = endLine - startLine;
  var markerLines = {};

  if (lineDiff) {
    for (var i = 0; i <= lineDiff; i++) {
      var lineNumber = i + startLine;

      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        var sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        var _sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, _sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }

  return {
    start: start,
    end: end,
    markerLines: markerLines
  };
}

function codeFrameColumns(rawLines, loc) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight().shouldHighlight)(opts);
  var chalk = (0, _highlight().getChalk)(opts);
  var defs = getDefs(chalk);

  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };

  var lines = rawLines.split(NEWLINE);

  var _getMarkerLines = getMarkerLines(loc, lines, opts),
      start = _getMarkerLines.start,
      end = _getMarkerLines.end,
      markerLines = _getMarkerLines.markerLines;

  var hasColumns = loc.start && typeof loc.start.column === "number";
  var numberMaxWidth = String(end).length;
  var highlightedLines = highlighted ? (0, _highlight().default)(rawLines, opts) : rawLines;
  var frame = highlightedLines.split(NEWLINE).slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
    var gutter = " ".concat(paddedNumber, " | ");
    var hasMarker = markerLines[number];
    var lastMarkerLine = !markerLines[number + 1];

    if (hasMarker) {
      var markerLine = "";

      if (Array.isArray(hasMarker)) {
        var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        var numberOfMarkers = hasMarker[1] || 1;
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

        if (lastMarkerLine && opts.message) {
          markerLine += " " + maybeHighlight(defs.message, opts.message);
        }
      }

      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line);
    }
  }).join("\n");

  if (opts.message && !hasColumns) {
    frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
  }

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
}

function _default(rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!deprecationWarningShown) {
    deprecationWarningShown = true;
    var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

    if (process.emitWarning) {
      process.emitWarning(message, "DeprecationWarning");
    } else {
      var deprecationError = new Error(message);
      deprecationError.name = "DeprecationWarning";
      console.warn(new Error(message));
    }
  }

  colNumber = Math.max(colNumber, 0);
  var location = {
    start: {
      column: colNumber,
      line: lineNumber
    }
  };
  return codeFrameColumns(rawLines, location, opts);
}

}).call(this,require('_process'))
},{"@babel/highlight":88,"_process":1054}],2:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStrongCache = makeStrongCache;
exports.makeWeakCache = makeWeakCache;
exports.assertSimpleType = assertSimpleType;

function makeStrongCache(handler) {
  return makeCachedFunction(new Map(), handler);
}

function makeWeakCache(handler) {
  return makeCachedFunction(new WeakMap(), handler);
}

function makeCachedFunction(callCache, handler) {
  return function cachedFunction(arg, data) {
    var cachedValue = callCache.get(arg);

    if (cachedValue) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cachedValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;
          var _value = _ref.value,
              valid = _ref.valid;
          if (valid(data)) return _value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    var cache = new CacheConfigurator(data);
    var value = handler(arg, cache);
    if (!cache.configured()) cache.forever();
    cache.deactivate();

    switch (cache.mode()) {
      case "forever":
        cachedValue = [{
          value: value,
          valid: function valid() {
            return true;
          }
        }];
        callCache.set(arg, cachedValue);
        break;

      case "invalidate":
        cachedValue = [{
          value: value,
          valid: cache.validator()
        }];
        callCache.set(arg, cachedValue);
        break;

      case "valid":
        if (cachedValue) {
          cachedValue.push({
            value: value,
            valid: cache.validator()
          });
        } else {
          cachedValue = [{
            value: value,
            valid: cache.validator()
          }];
          callCache.set(arg, cachedValue);
        }

    }

    return value;
  };
}

var CacheConfigurator =
/*#__PURE__*/
function () {
  function CacheConfigurator(data) {
    _classCallCheck(this, CacheConfigurator);

    this._active = true;
    this._never = false;
    this._forever = false;
    this._invalidate = false;
    this._configured = false;
    this._pairs = [];
    this._data = data;
  }

  _createClass(CacheConfigurator, [{
    key: "simple",
    value: function simple() {
      return makeSimpleConfigurator(this);
    }
  }, {
    key: "mode",
    value: function mode() {
      if (this._never) return "never";
      if (this._forever) return "forever";
      if (this._invalidate) return "invalidate";
      return "valid";
    }
  }, {
    key: "forever",
    value: function forever() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never) {
        throw new Error("Caching has already been configured with .never()");
      }

      this._forever = true;
      this._configured = true;
    }
  }, {
    key: "never",
    value: function never() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._forever) {
        throw new Error("Caching has already been configured with .forever()");
      }

      this._never = true;
      this._configured = true;
    }
  }, {
    key: "using",
    value: function using(handler) {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }

      this._configured = true;
      var key = handler(this._data);

      this._pairs.push([key, handler]);

      return key;
    }
  }, {
    key: "invalidate",
    value: function invalidate(handler) {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }

      this._invalidate = true;
      this._configured = true;
      var key = handler(this._data);

      this._pairs.push([key, handler]);

      return key;
    }
  }, {
    key: "validator",
    value: function validator() {
      var pairs = this._pairs;
      return function (data) {
        return pairs.every(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              key = _ref3[0],
              fn = _ref3[1];

          return key === fn(data);
        });
      };
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this._active = false;
    }
  }, {
    key: "configured",
    value: function configured() {
      return this._configured;
    }
  }]);

  return CacheConfigurator;
}();

function makeSimpleConfigurator(cache) {
  function cacheFn(val) {
    if (typeof val === "boolean") {
      if (val) cache.forever();else cache.never();
      return;
    }

    return cache.using(function () {
      return assertSimpleType(val());
    });
  }

  cacheFn.forever = function () {
    return cache.forever();
  };

  cacheFn.never = function () {
    return cache.never();
  };

  cacheFn.using = function (cb) {
    return cache.using(function () {
      return assertSimpleType(cb());
    });
  };

  cacheFn.invalidate = function (cb) {
    return cache.invalidate(function () {
      return assertSimpleType(cb());
    });
  };

  return cacheFn;
}

function assertSimpleType(value) {
  if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
  }

  return value;
}

},{}],3:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPresetChain = buildPresetChain;
exports.buildRootChain = buildRootChain;
exports.buildPresetChainWalker = void 0;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

var _options = require("./validation/options");

var _patternToRegex = _interopRequireDefault(require("./pattern-to-regex"));

var _files = require("./files");

var _caching = require("./caching");

var _configDescriptors = require("./config-descriptors");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var debug = (0, _debug().default)("babel:config:config-chain");

function buildPresetChain(arg, context) {
  var chain = buildPresetChainWalker(arg, context);
  if (!chain) return null;
  return {
    plugins: dedupDescriptors(chain.plugins),
    presets: dedupDescriptors(chain.presets),
    options: chain.options.map(function (o) {
      return normalizeOptions(o);
    })
  };
}

var buildPresetChainWalker = makeChainWalker({
  init: function init(arg) {
    return arg;
  },
  root: function root(preset) {
    return loadPresetDescriptors(preset);
  },
  env: function env(preset, envName) {
    return loadPresetEnvDescriptors(preset)(envName);
  },
  overrides: function overrides(preset, index) {
    return loadPresetOverridesDescriptors(preset)(index);
  },
  overridesEnv: function overridesEnv(preset, index, envName) {
    return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
  }
});
exports.buildPresetChainWalker = buildPresetChainWalker;
var loadPresetDescriptors = (0, _caching.makeWeakCache)(function (preset) {
  return buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors);
});
var loadPresetEnvDescriptors = (0, _caching.makeWeakCache)(function (preset) {
  return (0, _caching.makeStrongCache)(function (envName) {
    return buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName);
  });
});
var loadPresetOverridesDescriptors = (0, _caching.makeWeakCache)(function (preset) {
  return (0, _caching.makeStrongCache)(function (index) {
    return buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index);
  });
});
var loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCache)(function (preset) {
  return (0, _caching.makeStrongCache)(function (index) {
    return (0, _caching.makeStrongCache)(function (envName) {
      return buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName);
    });
  });
});

function buildRootChain(opts, context) {
  var programmaticChain = loadProgrammaticChain({
    options: opts,
    dirname: context.cwd
  }, context);
  if (!programmaticChain) return null;
  var configFile;

  if (typeof opts.configFile === "string") {
    configFile = (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);
  } else if (opts.configFile !== false) {
    configFile = (0, _files.findRootConfig)(context.root, context.envName, context.caller);
  }

  var babelrc = opts.babelrc,
      babelrcRoots = opts.babelrcRoots;
  var babelrcRootsDirectory = context.cwd;
  var configFileChain = emptyChain();

  if (configFile) {
    var validatedFile = validateConfigFile(configFile);
    var result = loadFileChain(validatedFile, context);
    if (!result) return null;

    if (babelrc === undefined) {
      babelrc = validatedFile.options.babelrc;
    }

    if (babelrcRoots === undefined) {
      babelrcRootsDirectory = validatedFile.dirname;
      babelrcRoots = validatedFile.options.babelrcRoots;
    }

    mergeChain(configFileChain, result);
  }

  var pkgData = typeof context.filename === "string" ? (0, _files.findPackageData)(context.filename) : null;
  var ignoreFile, babelrcFile;
  var fileChain = emptyChain();

  if ((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
    var _ref = (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller);

    ignoreFile = _ref.ignore;
    babelrcFile = _ref.config;

    if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
      return null;
    }

    if (babelrcFile) {
      var _result = loadFileChain(validateBabelrcFile(babelrcFile), context);

      if (!_result) return null;
      mergeChain(fileChain, _result);
    }
  }

  var chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
  return {
    plugins: dedupDescriptors(chain.plugins),
    presets: dedupDescriptors(chain.presets),
    options: chain.options.map(function (o) {
      return normalizeOptions(o);
    }),
    ignore: ignoreFile || undefined,
    babelrc: babelrcFile || undefined,
    config: configFile || undefined
  };
}

function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
  if (typeof babelrcRoots === "boolean") return babelrcRoots;
  var absoluteRoot = context.root;

  if (babelrcRoots === undefined) {
    return pkgData.directories.indexOf(absoluteRoot) !== -1;
  }

  var babelrcPatterns = babelrcRoots;
  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
  babelrcPatterns = babelrcPatterns.map(function (pat) {
    return typeof pat === "string" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;
  });

  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
    return pkgData.directories.indexOf(absoluteRoot) !== -1;
  }

  return babelrcPatterns.some(function (pat) {
    if (typeof pat === "string") {
      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);
    }

    return pkgData.directories.some(function (directory) {
      return matchPattern(pat, babelrcRootsDirectory, directory, context);
    });
  });
}

var validateConfigFile = (0, _caching.makeWeakCache)(function (file) {
  return {
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("configfile", file.options)
  };
});
var validateBabelrcFile = (0, _caching.makeWeakCache)(function (file) {
  return {
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("babelrcfile", file.options)
  };
});
var validateExtendFile = (0, _caching.makeWeakCache)(function (file) {
  return {
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("extendsfile", file.options)
  };
});
var loadProgrammaticChain = makeChainWalker({
  root: function root(input) {
    return buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors);
  },
  env: function env(input, envName) {
    return buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName);
  },
  overrides: function overrides(input, index) {
    return buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index);
  },
  overridesEnv: function overridesEnv(input, index, envName) {
    return buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index, envName);
  }
});
var loadFileChain = makeChainWalker({
  root: function root(file) {
    return loadFileDescriptors(file);
  },
  env: function env(file, envName) {
    return loadFileEnvDescriptors(file)(envName);
  },
  overrides: function overrides(file, index) {
    return loadFileOverridesDescriptors(file)(index);
  },
  overridesEnv: function overridesEnv(file, index, envName) {
    return loadFileOverridesEnvDescriptors(file)(index)(envName);
  }
});
var loadFileDescriptors = (0, _caching.makeWeakCache)(function (file) {
  return buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors);
});
var loadFileEnvDescriptors = (0, _caching.makeWeakCache)(function (file) {
  return (0, _caching.makeStrongCache)(function (envName) {
    return buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName);
  });
});
var loadFileOverridesDescriptors = (0, _caching.makeWeakCache)(function (file) {
  return (0, _caching.makeStrongCache)(function (index) {
    return buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index);
  });
});
var loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCache)(function (file) {
  return (0, _caching.makeStrongCache)(function (index) {
    return (0, _caching.makeStrongCache)(function (envName) {
      return buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName);
    });
  });
});

function buildRootDescriptors(_ref2, alias, descriptors) {
  var dirname = _ref2.dirname,
      options = _ref2.options;
  return descriptors(dirname, options, alias);
}

function buildEnvDescriptors(_ref3, alias, descriptors, envName) {
  var dirname = _ref3.dirname,
      options = _ref3.options;
  var opts = options.env && options.env[envName];
  return opts ? descriptors(dirname, opts, "".concat(alias, ".env[\"").concat(envName, "\"]")) : null;
}

function buildOverrideDescriptors(_ref4, alias, descriptors, index) {
  var dirname = _ref4.dirname,
      options = _ref4.options;
  var opts = options.overrides && options.overrides[index];
  if (!opts) throw new Error("Assertion failure - missing override");
  return descriptors(dirname, opts, "".concat(alias, ".overrides[").concat(index, "]"));
}

function buildOverrideEnvDescriptors(_ref5, alias, descriptors, index, envName) {
  var dirname = _ref5.dirname,
      options = _ref5.options;
  var override = options.overrides && options.overrides[index];
  if (!override) throw new Error("Assertion failure - missing override");
  var opts = override.env && override.env[envName];
  return opts ? descriptors(dirname, opts, "".concat(alias, ".overrides[").concat(index, "].env[\"").concat(envName, "\"]")) : null;
}

function makeChainWalker(_ref6) {
  var root = _ref6.root,
      env = _ref6.env,
      overrides = _ref6.overrides,
      overridesEnv = _ref6.overridesEnv;
  return function (input, context) {
    var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var dirname = input.dirname;
    var flattenedConfigs = [];
    var rootOpts = root(input);

    if (configIsApplicable(rootOpts, dirname, context)) {
      flattenedConfigs.push(rootOpts);
      var envOpts = env(input, context.envName);

      if (envOpts && configIsApplicable(envOpts, dirname, context)) {
        flattenedConfigs.push(envOpts);
      }

      (rootOpts.options.overrides || []).forEach(function (_, index) {
        var overrideOps = overrides(input, index);

        if (configIsApplicable(overrideOps, dirname, context)) {
          flattenedConfigs.push(overrideOps);
          var overrideEnvOpts = overridesEnv(input, index, context.envName);

          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
            flattenedConfigs.push(overrideEnvOpts);
          }
        }
      });
    }

    if (flattenedConfigs.some(function (_ref7) {
      var _ref7$options = _ref7.options,
          ignore = _ref7$options.ignore,
          only = _ref7$options.only;
      return shouldIgnore(context, ignore, only, dirname);
    })) {
      return null;
    }

    var chain = emptyChain();

    for (var _i = 0, _flattenedConfigs = flattenedConfigs; _i < _flattenedConfigs.length; _i++) {
      var op = _flattenedConfigs[_i];

      if (!mergeExtendsChain(chain, op.options, dirname, context, files)) {
        return null;
      }

      mergeChainOpts(chain, op);
    }

    return chain;
  };
}

function mergeExtendsChain(chain, opts, dirname, context, files) {
  if (opts.extends === undefined) return true;
  var file = (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);

  if (files.has(file)) {
    throw new Error("Configuration cycle detected loading ".concat(file.filepath, ".\n") + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
      return " - ".concat(file.filepath);
    }).join("\n"));
  }

  files.add(file);
  var fileChain = loadFileChain(validateExtendFile(file), context, files);
  files.delete(file);
  if (!fileChain) return false;
  mergeChain(chain, fileChain);
  return true;
}

function mergeChain(target, source) {
  var _target$options, _target$plugins, _target$presets;

  (_target$options = target.options).push.apply(_target$options, _toConsumableArray(source.options));

  (_target$plugins = target.plugins).push.apply(_target$plugins, _toConsumableArray(source.plugins));

  (_target$presets = target.presets).push.apply(_target$presets, _toConsumableArray(source.presets));

  return target;
}

function mergeChainOpts(target, _ref8) {
  var _target$plugins2, _target$presets2;

  var options = _ref8.options,
      plugins = _ref8.plugins,
      presets = _ref8.presets;
  target.options.push(options);

  (_target$plugins2 = target.plugins).push.apply(_target$plugins2, _toConsumableArray(plugins()));

  (_target$presets2 = target.presets).push.apply(_target$presets2, _toConsumableArray(presets()));

  return target;
}

function emptyChain() {
  return {
    options: [],
    presets: [],
    plugins: []
  };
}

function normalizeOptions(opts) {
  var options = Object.assign({}, opts);
  delete options.extends;
  delete options.env;
  delete options.overrides;
  delete options.plugins;
  delete options.presets;
  delete options.passPerPreset;
  delete options.ignore;
  delete options.only;
  delete options.test;
  delete options.include;
  delete options.exclude;

  if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
    options.sourceMaps = options.sourceMap;
    delete options.sourceMap;
  }

  return options;
}

function dedupDescriptors(items) {
  var map = new Map();
  var descriptors = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;

      if (typeof item.value === "function") {
        var fnKey = item.value;
        var nameMap = map.get(fnKey);

        if (!nameMap) {
          nameMap = new Map();
          map.set(fnKey, nameMap);
        }

        var desc = nameMap.get(item.name);

        if (!desc) {
          desc = {
            value: item
          };
          descriptors.push(desc);
          if (!item.ownPass) nameMap.set(item.name, desc);
        } else {
          desc.value = item;
        }
      } else {
        descriptors.push({
          value: item
        });
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return descriptors.reduce(function (acc, desc) {
    acc.push(desc.value);
    return acc;
  }, []);
}

function configIsApplicable(_ref9, dirname, context) {
  var options = _ref9.options;
  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
}

function configFieldIsApplicable(context, test, dirname) {
  var patterns = Array.isArray(test) ? test : [test];
  return matchesPatterns(context, patterns, dirname);
}

function shouldIgnore(context, ignore, only, dirname) {
  if (ignore && matchesPatterns(context, ignore, dirname)) {
    debug("Ignored %o because it matched one of %O from %o", context.filename, ignore, dirname);
    return true;
  }

  if (only && !matchesPatterns(context, only, dirname)) {
    debug("Ignored %o because it failed to match one of %O from %o", context.filename, only, dirname);
    return true;
  }

  return false;
}

function matchesPatterns(context, patterns, dirname) {
  return patterns.some(function (pattern) {
    return matchPattern(pattern, dirname, context.filename, context);
  });
}

function matchPattern(pattern, dirname, pathToTest, context) {
  if (typeof pattern === "function") {
    return !!pattern(pathToTest, {
      dirname: dirname,
      envName: context.envName,
      caller: context.caller
    });
  }

  if (typeof pathToTest !== "string") {
    throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
  }

  if (typeof pattern === "string") {
    pattern = (0, _patternToRegex.default)(pattern, dirname);
  }

  return pattern.test(pathToTest);
}

},{"./caching":2,"./config-descriptors":4,"./files":5,"./pattern-to-regex":12,"./validation/options":16,"debug":34,"path":1052}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCachedDescriptors = createCachedDescriptors;
exports.createUncachedDescriptors = createUncachedDescriptors;
exports.createDescriptor = createDescriptor;

var _files = require("./files");

var _item = require("./item");

var _caching = require("./caching");

function isEqualDescriptor(a, b) {
  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
}

function createCachedDescriptors(dirname, options, alias) {
  var plugins = options.plugins,
      presets = options.presets,
      passPerPreset = options.passPerPreset;
  return {
    options: options,
    plugins: plugins ? function () {
      return createCachedPluginDescriptors(plugins, dirname)(alias);
    } : function () {
      return [];
    },
    presets: presets ? function () {
      return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
    } : function () {
      return [];
    }
  };
}

function createUncachedDescriptors(dirname, options, alias) {
  var _plugins;

  var _presets;

  return {
    options: options,
    plugins: function plugins() {
      if (!_plugins) {
        _plugins = createPluginDescriptors(options.plugins || [], dirname, alias);
      }

      return _plugins;
    },
    presets: function presets() {
      if (!_presets) {
        _presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);
      }

      return _presets;
    }
  };
}

var PRESET_DESCRIPTOR_CACHE = new WeakMap();
var createCachedPresetDescriptors = (0, _caching.makeWeakCache)(function (items, cache) {
  var dirname = cache.using(function (dir) {
    return dir;
  });
  return (0, _caching.makeStrongCache)(function (alias) {
    return (0, _caching.makeStrongCache)(function (passPerPreset) {
      return createPresetDescriptors(items, dirname, alias, passPerPreset).map(function (desc) {
        return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
      });
    });
  });
});
var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
var createCachedPluginDescriptors = (0, _caching.makeWeakCache)(function (items, cache) {
  var dirname = cache.using(function (dir) {
    return dir;
  });
  return (0, _caching.makeStrongCache)(function (alias) {
    return createPluginDescriptors(items, dirname, alias).map(function (desc) {
      return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
    });
  });
});
var DEFAULT_OPTIONS = {};

function loadCachedDescriptor(cache, desc) {
  var value = desc.value,
      _desc$options = desc.options,
      options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
  if (options === false) return desc;
  var cacheByOptions = cache.get(value);

  if (!cacheByOptions) {
    cacheByOptions = new WeakMap();
    cache.set(value, cacheByOptions);
  }

  var possibilities = cacheByOptions.get(options);

  if (!possibilities) {
    possibilities = [];
    cacheByOptions.set(options, possibilities);
  }

  if (possibilities.indexOf(desc) === -1) {
    var matches = possibilities.filter(function (possibility) {
      return isEqualDescriptor(possibility, desc);
    });

    if (matches.length > 0) {
      return matches[0];
    }

    possibilities.push(desc);
  }

  return desc;
}

function createPresetDescriptors(items, dirname, alias, passPerPreset) {
  return createDescriptors("preset", items, dirname, alias, passPerPreset);
}

function createPluginDescriptors(items, dirname, alias) {
  return createDescriptors("plugin", items, dirname, alias);
}

function createDescriptors(type, items, dirname, alias, ownPass) {
  var descriptors = items.map(function (item, index) {
    return createDescriptor(item, dirname, {
      type: type,
      alias: "".concat(alias, "$").concat(index),
      ownPass: !!ownPass
    });
  });
  assertNoDuplicates(descriptors);
  return descriptors;
}

function createDescriptor(pair, dirname, _ref) {
  var type = _ref.type,
      alias = _ref.alias,
      ownPass = _ref.ownPass;
  var desc = (0, _item.getItemDescriptor)(pair);

  if (desc) {
    return desc;
  }

  var name;
  var options;
  var value = pair;

  if (Array.isArray(value)) {
    if (value.length === 3) {
      var _value = value;

      var _value2 = _slicedToArray(_value, 3);

      value = _value2[0];
      options = _value2[1];
      name = _value2[2];
    } else {
      var _value3 = value;

      var _value4 = _slicedToArray(_value3, 2);

      value = _value4[0];
      options = _value4[1];
    }
  }

  var file = undefined;
  var filepath = null;

  if (typeof value === "string") {
    if (typeof type !== "string") {
      throw new Error("To resolve a string-based item, the type of item must be given");
    }

    var resolver = type === "plugin" ? _files.loadPlugin : _files.loadPreset;
    var request = value;

    var _resolver = resolver(value, dirname);

    filepath = _resolver.filepath;
    value = _resolver.value;
    file = {
      request: request,
      resolved: filepath
    };
  }

  if (!value) {
    throw new Error("Unexpected falsy value: ".concat(String(value)));
  }

  if (_typeof(value) === "object" && value.__esModule) {
    if (value.default) {
      value = value.default;
    } else {
      throw new Error("Must export a default export when using ES6 modules.");
    }
  }

  if (_typeof(value) !== "object" && typeof value !== "function") {
    throw new Error("Unsupported format: ".concat(_typeof(value), ". Expected an object or a function."));
  }

  if (filepath !== null && _typeof(value) === "object" && value) {
    throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In ".concat(filepath));
  }

  return {
    name: name,
    alias: filepath || alias,
    value: value,
    options: options,
    dirname: dirname,
    ownPass: ownPass,
    file: file
  };
}

function assertNoDuplicates(items) {
  var map = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var item = _step.value;
      if (typeof item.value !== "function") return "continue";
      var nameMap = map.get(item.value);

      if (!nameMap) {
        nameMap = new Set();
        map.set(item.value, nameMap);
      }

      if (nameMap.has(item.name)) {
        var conflicts = items.filter(function (i) {
          return i.value === item.value;
        });
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "".concat(JSON.stringify(conflicts, null, 2))].join("\n"));
      }

      nameMap.add(item.name);
    };

    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

},{"./caching":2,"./files":5,"./item":10}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findConfigUpwards = findConfigUpwards;
exports.findPackageData = findPackageData;
exports.findRelativeConfig = findRelativeConfig;
exports.findRootConfig = findRootConfig;
exports.loadConfig = loadConfig;
exports.resolvePlugin = resolvePlugin;
exports.resolvePreset = resolvePreset;
exports.loadPlugin = loadPlugin;
exports.loadPreset = loadPreset;

function findConfigUpwards(rootDir) {
  return null;
}

function findPackageData(filepath) {
  return {
    filepath: filepath,
    directories: [],
    pkg: null,
    isPackage: false
  };
}

function findRelativeConfig(pkgData, envName, caller) {
  return {
    pkg: null,
    config: null,
    ignore: null
  };
}

function findRootConfig(dirname, envName, caller) {
  return null;
}

function loadConfig(name, dirname, envName, caller) {
  throw new Error("Cannot load ".concat(name, " relative to ").concat(dirname, " in a browser"));
}

function resolvePlugin(name, dirname) {
  return null;
}

function resolvePreset(name, dirname) {
  return null;
}

function loadPlugin(name, dirname) {
  throw new Error("Cannot load plugin ".concat(name, " relative to ").concat(dirname, " in a browser"));
}

function loadPreset(name, dirname) {
  throw new Error("Cannot load preset ".concat(name, " relative to ").concat(dirname, " in a browser"));
}

},{}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadFullConfig;

var _util = require("./util");

var context = _interopRequireWildcard(require("../index"));

var _plugin = _interopRequireDefault(require("./plugin"));

var _item = require("./item");

var _configChain = require("./config-chain");

function _traverse() {
  var data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

var _caching = require("./caching");

var _options = require("./validation/options");

var _plugins = require("./validation/plugins");

var _configApi = _interopRequireDefault(require("./helpers/config-api"));

var _partial = _interopRequireDefault(require("./partial"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function loadFullConfig(inputOpts) {
  var result = (0, _partial.default)(inputOpts);

  if (!result) {
    return null;
  }

  var options = result.options,
      context = result.context;
  var optionDefaults = {};
  var passes = [[]];

  try {
    var plugins = options.plugins,
        presets = options.presets;

    if (!plugins || !presets) {
      throw new Error("Assertion failure - plugins and presets exist");
    }

    var ignored = function recurseDescriptors(config, pass) {
      var plugins = config.plugins.reduce(function (acc, descriptor) {
        if (descriptor.options !== false) {
          acc.push(loadPluginDescriptor(descriptor, context));
        }

        return acc;
      }, []);
      var presets = config.presets.reduce(function (acc, descriptor) {
        if (descriptor.options !== false) {
          acc.push({
            preset: loadPresetDescriptor(descriptor, context),
            pass: descriptor.ownPass ? [] : pass
          });
        }

        return acc;
      }, []);

      if (presets.length > 0) {
        passes.splice.apply(passes, [1, 0].concat(_toConsumableArray(presets.map(function (o) {
          return o.pass;
        }).filter(function (p) {
          return p !== pass;
        }))));
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = presets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ref = _step.value;
            var preset = _ref.preset,
                _pass = _ref.pass;
            if (!preset) return true;

            var _ignored = recurseDescriptors({
              plugins: preset.plugins,
              presets: preset.presets
            }, _pass);

            if (_ignored) return true;
            preset.options.forEach(function (opts) {
              (0, _util.mergeOptions)(optionDefaults, opts);
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (plugins.length > 0) {
        pass.unshift.apply(pass, _toConsumableArray(plugins));
      }
    }({
      plugins: plugins.map(function (item) {
        var desc = (0, _item.getItemDescriptor)(item);

        if (!desc) {
          throw new Error("Assertion failure - must be config item");
        }

        return desc;
      }),
      presets: presets.map(function (item) {
        var desc = (0, _item.getItemDescriptor)(item);

        if (!desc) {
          throw new Error("Assertion failure - must be config item");
        }

        return desc;
      })
    }, passes[0]);

    if (ignored) return null;
  } catch (e) {
    if (!/^\[BABEL\]/.test(e.message)) {
      e.message = "[BABEL] ".concat(context.filename || "unknown", ": ").concat(e.message);
    }

    throw e;
  }

  var opts = optionDefaults;
  (0, _util.mergeOptions)(opts, options);
  opts.plugins = passes[0];
  opts.presets = passes.slice(1).filter(function (plugins) {
    return plugins.length > 0;
  }).map(function (plugins) {
    return {
      plugins: plugins
    };
  });
  opts.passPerPreset = opts.presets.length > 0;
  return {
    options: opts,
    passes: passes
  };
}

var loadDescriptor = (0, _caching.makeWeakCache)(function (_ref2, cache) {
  var value = _ref2.value,
      options = _ref2.options,
      dirname = _ref2.dirname,
      alias = _ref2.alias;
  if (options === false) throw new Error("Assertion failure");
  options = options || {};
  var item = value;

  if (typeof value === "function") {
    var api = Object.assign({}, context, {}, (0, _configApi.default)(cache));

    try {
      item = value(api, options, dirname);
    } catch (e) {
      if (alias) {
        e.message += " (While processing: ".concat(JSON.stringify(alias), ")");
      }

      throw e;
    }
  }

  if (!item || _typeof(item) !== "object") {
    throw new Error("Plugin/Preset did not return an object.");
  }

  if (typeof item.then === "function") {
    throw new Error("You appear to be using an async plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
  }

  return {
    value: item,
    options: options,
    dirname: dirname,
    alias: alias
  };
});

function loadPluginDescriptor(descriptor, context) {
  if (descriptor.value instanceof _plugin.default) {
    if (descriptor.options) {
      throw new Error("Passed options to an existing Plugin instance will not work.");
    }

    return descriptor.value;
  }

  return instantiatePlugin(loadDescriptor(descriptor, context), context);
}

var instantiatePlugin = (0, _caching.makeWeakCache)(function (_ref3, cache) {
  var value = _ref3.value,
      options = _ref3.options,
      dirname = _ref3.dirname,
      alias = _ref3.alias;
  var pluginObj = (0, _plugins.validatePluginObject)(value);
  var plugin = Object.assign({}, pluginObj);

  if (plugin.visitor) {
    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));
  }

  if (plugin.inherits) {
    var inheritsDescriptor = {
      name: undefined,
      alias: "".concat(alias, "$inherits"),
      value: plugin.inherits,
      options: options,
      dirname: dirname
    };
    var inherits = cache.invalidate(function (data) {
      return loadPluginDescriptor(inheritsDescriptor, data);
    });
    plugin.pre = chain(inherits.pre, plugin.pre);
    plugin.post = chain(inherits.post, plugin.post);
    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);
  }

  return new _plugin.default(plugin, options, alias);
});

var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
  if (options.test || options.include || options.exclude) {
    var formattedPresetName = descriptor.name ? "\"".concat(descriptor.name, "\"") : "/* your preset */";
    throw new Error(["Preset ".concat(formattedPresetName, " requires a filename to be set when babel is called directly,"), "```", "babel.transform(code, { filename: 'file.ts', presets: [".concat(formattedPresetName, "] });"), "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
  }
};

var validatePreset = function validatePreset(preset, context, descriptor) {
  if (!context.filename) {
    var options = preset.options;
    validateIfOptionNeedsFilename(options, descriptor);

    if (options.overrides) {
      options.overrides.forEach(function (overrideOptions) {
        return validateIfOptionNeedsFilename(overrideOptions, descriptor);
      });
    }
  }
};

var loadPresetDescriptor = function loadPresetDescriptor(descriptor, context) {
  var preset = instantiatePreset(loadDescriptor(descriptor, context));
  validatePreset(preset, context, descriptor);
  return (0, _configChain.buildPresetChain)(preset, context);
};

var instantiatePreset = (0, _caching.makeWeakCache)(function (_ref4) {
  var value = _ref4.value,
      dirname = _ref4.dirname,
      alias = _ref4.alias;
  return {
    options: (0, _options.validate)("preset", value),
    alias: alias,
    dirname: dirname
  };
});

function chain(a, b) {
  var fns = [a, b].filter(Boolean);
  if (fns.length <= 1) return fns[0];
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = fns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var fn = _step2.value;
        fn.apply(this, args);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  };
}

},{"../index":19,"./caching":2,"./config-chain":3,"./helpers/config-api":7,"./item":10,"./partial":11,"./plugin":13,"./util":14,"./validation/options":16,"./validation/plugins":17,"@babel/traverse":176}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeAPI;

function _semver() {
  var data = _interopRequireDefault(require("semver"));

  _semver = function _semver() {
    return data;
  };

  return data;
}

var _ = require("../../");

var _caching = require("../caching");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function makeAPI(cache) {
  var env = function env(value) {
    return cache.using(function (data) {
      if (typeof value === "undefined") return data.envName;

      if (typeof value === "function") {
        return (0, _caching.assertSimpleType)(value(data.envName));
      }

      if (!Array.isArray(value)) value = [value];
      return value.some(function (entry) {
        if (typeof entry !== "string") {
          throw new Error("Unexpected non-string value");
        }

        return entry === data.envName;
      });
    });
  };

  var caller = function caller(cb) {
    return cache.using(function (data) {
      return (0, _caching.assertSimpleType)(cb(data.caller));
    });
  };

  return {
    version: _.version,
    cache: cache.simple(),
    env: env,
    async: function async() {
      return false;
    },
    caller: caller,
    assertVersion: assertVersion,
    tokTypes: undefined
  };
}

function assertVersion(range) {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }

    range = "^".concat(range, ".0.0-0");
  }

  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }

  if (_semver().default.satisfies(_.version, range)) return;
  var limit = Error.stackTraceLimit;

  if (typeof limit === "number" && limit < 25) {
    Error.stackTraceLimit = 25;
  }

  var err = new Error("Requires Babel \"".concat(range, "\", but was loaded with \"").concat(_.version, "\". ") + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }

  throw Object.assign(err, {
    code: "BABEL_VERSION_UNSUPPORTED",
    version: _.version,
    range: range
  });
}

},{"../../":19,"../caching":2,"semver":1070}],8:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEnv = getEnv;

function getEnv() {
  var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "development";
  return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
}

}).call(this,require('_process'))
},{"_process":1054}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadOptions = loadOptions;
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _full.default;
  }
});
Object.defineProperty(exports, "loadPartialConfig", {
  enumerable: true,
  get: function get() {
    return _partial.loadPartialConfig;
  }
});

var _full = _interopRequireDefault(require("./full"));

var _partial = require("./partial");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function loadOptions(opts) {
  var config = (0, _full.default)(opts);
  return config ? config.options : null;
}

},{"./full":6,"./partial":11}],10:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createItemFromDescriptor = createItemFromDescriptor;
exports.createConfigItem = createConfigItem;
exports.getItemDescriptor = getItemDescriptor;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

var _configDescriptors = require("./config-descriptors");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function createItemFromDescriptor(desc) {
  return new ConfigItem(desc);
}

function createConfigItem(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$dirname = _ref.dirname,
      dirname = _ref$dirname === void 0 ? "." : _ref$dirname,
      type = _ref.type;

  var descriptor = (0, _configDescriptors.createDescriptor)(value, _path().default.resolve(dirname), {
    type: type,
    alias: "programmatic item"
  });
  return createItemFromDescriptor(descriptor);
}

function getItemDescriptor(item) {
  if (item instanceof ConfigItem) {
    return item._descriptor;
  }

  return undefined;
}

var ConfigItem = function ConfigItem(descriptor) {
  _classCallCheck(this, ConfigItem);

  this._descriptor = descriptor;
  Object.defineProperty(this, "_descriptor", {
    enumerable: false
  });
  this.value = this._descriptor.value;
  this.options = this._descriptor.options;
  this.dirname = this._descriptor.dirname;
  this.name = this._descriptor.name;
  this.file = this._descriptor.file ? {
    request: this._descriptor.file.request,
    resolved: this._descriptor.file.resolved
  } : undefined;
  Object.freeze(this);
};

Object.freeze(ConfigItem.prototype);

},{"./config-descriptors":4,"path":1052}],11:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadPrivatePartialConfig;
exports.loadPartialConfig = loadPartialConfig;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

var _plugin = _interopRequireDefault(require("./plugin"));

var _util = require("./util");

var _item = require("./item");

var _configChain = require("./config-chain");

var _environment = require("./helpers/environment");

var _options = require("./validation/options");

var _files = require("./files");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function resolveRootMode(rootDir, rootMode) {
  switch (rootMode) {
    case "root":
      return rootDir;

    case "upward-optional":
      {
        var upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
        return upwardRootDir === null ? rootDir : upwardRootDir;
      }

    case "upward":
      {
        var _upwardRootDir = (0, _files.findConfigUpwards)(rootDir);

        if (_upwardRootDir !== null) return _upwardRootDir;
        throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + "be found when searching upward from \"".concat(rootDir, "\"")), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: rootDir
        });
      }

    default:
      throw new Error("Assertion failure - unknown rootMode value");
  }
}

function loadPrivatePartialConfig(inputOpts) {
  if (inputOpts != null && (_typeof(inputOpts) !== "object" || Array.isArray(inputOpts))) {
    throw new Error("Babel options must be an object, null, or undefined");
  }

  var args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
  var _args$envName = args.envName,
      envName = _args$envName === void 0 ? (0, _environment.getEnv)() : _args$envName,
      _args$cwd = args.cwd,
      cwd = _args$cwd === void 0 ? "." : _args$cwd,
      _args$root = args.root,
      rootDir = _args$root === void 0 ? "." : _args$root,
      _args$rootMode = args.rootMode,
      rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode,
      caller = args.caller;

  var absoluteCwd = _path().default.resolve(cwd);

  var absoluteRootDir = resolveRootMode(_path().default.resolve(absoluteCwd, rootDir), rootMode);
  var context = {
    filename: typeof args.filename === "string" ? _path().default.resolve(cwd, args.filename) : undefined,
    cwd: absoluteCwd,
    root: absoluteRootDir,
    envName: envName,
    caller: caller
  };
  var configChain = (0, _configChain.buildRootChain)(args, context);
  if (!configChain) return null;
  var options = {};
  configChain.options.forEach(function (opts) {
    (0, _util.mergeOptions)(options, opts);
  });
  options.babelrc = false;
  options.configFile = false;
  options.passPerPreset = false;
  options.envName = context.envName;
  options.cwd = context.cwd;
  options.root = context.root;
  options.filename = typeof context.filename === "string" ? context.filename : undefined;
  options.plugins = configChain.plugins.map(function (descriptor) {
    return (0, _item.createItemFromDescriptor)(descriptor);
  });
  options.presets = configChain.presets.map(function (descriptor) {
    return (0, _item.createItemFromDescriptor)(descriptor);
  });
  return {
    options: options,
    context: context,
    ignore: configChain.ignore,
    babelrc: configChain.babelrc,
    config: configChain.config
  };
}

function loadPartialConfig(inputOpts) {
  var result = loadPrivatePartialConfig(inputOpts);
  if (!result) return null;
  var options = result.options,
      babelrc = result.babelrc,
      ignore = result.ignore,
      config = result.config;
  (options.plugins || []).forEach(function (item) {
    if (item.value instanceof _plugin.default) {
      throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
    }
  });
  return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined);
}

var PartialConfig =
/*#__PURE__*/
function () {
  function PartialConfig(options, babelrc, ignore, config) {
    _classCallCheck(this, PartialConfig);

    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    Object.freeze(this);
  }

  _createClass(PartialConfig, [{
    key: "hasFilesystemConfig",
    value: function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    }
  }]);

  return PartialConfig;
}();

Object.freeze(PartialConfig.prototype);

},{"./config-chain":3,"./files":5,"./helpers/environment":8,"./item":10,"./plugin":13,"./util":14,"./validation/options":16,"path":1052}],12:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathToPattern;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _escapeRegExp() {
  var data = _interopRequireDefault(require("lodash/escapeRegExp"));

  _escapeRegExp = function _escapeRegExp() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var sep = "\\".concat(_path().default.sep);
var endSep = "(?:".concat(sep, "|$)");
var substitution = "[^".concat(sep, "]+");
var starPat = "(?:".concat(substitution).concat(sep, ")");
var starPatLast = "(?:".concat(substitution).concat(endSep, ")");
var starStarPat = "".concat(starPat, "*?");
var starStarPatLast = "".concat(starPat, "*?").concat(starPatLast, "?");

function pathToPattern(pattern, dirname) {
  var parts = _path().default.resolve(dirname, pattern).split(_path().default.sep);

  return new RegExp(["^"].concat(_toConsumableArray(parts.map(function (part, i) {
    var last = i === parts.length - 1;
    if (part === "**") return last ? starStarPatLast : starStarPat;
    if (part === "*") return last ? starPatLast : starPat;

    if (part.indexOf("*.") === 0) {
      return substitution + (0, _escapeRegExp().default)(part.slice(1)) + (last ? endSep : sep);
    }

    return (0, _escapeRegExp().default)(part) + (last ? endSep : sep);
  }))).join(""));
}

},{"lodash/escapeRegExp":1009,"path":1052}],13:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var Plugin = function Plugin(plugin, options, key) {
  _classCallCheck(this, Plugin);

  this.key = plugin.name || key;
  this.manipulateOptions = plugin.manipulateOptions;
  this.post = plugin.post;
  this.pre = plugin.pre;
  this.visitor = plugin.visitor || {};
  this.parserOverride = plugin.parserOverride;
  this.generatorOverride = plugin.generatorOverride;
  this.options = options;
};

exports.default = Plugin;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeOptions = mergeOptions;

function mergeOptions(target, source) {
  for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
    var k = _Object$keys[_i];

    if (k === "parserOpts" && source.parserOpts) {
      var parserOpts = source.parserOpts;
      var targetObj = target.parserOpts = target.parserOpts || {};
      mergeDefaultFields(targetObj, parserOpts);
    } else if (k === "generatorOpts" && source.generatorOpts) {
      var generatorOpts = source.generatorOpts;

      var _targetObj = target.generatorOpts = target.generatorOpts || {};

      mergeDefaultFields(_targetObj, generatorOpts);
    } else {
      var val = source[k];
      if (val !== undefined) target[k] = val;
    }
  }
}

function mergeDefaultFields(target, source) {
  for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
    var k = _Object$keys2[_i2];
    var val = source[k];
    if (val !== undefined) target[k] = val;
  }
}

},{}],15:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.msg = msg;
exports.access = access;
exports.assertRootMode = assertRootMode;
exports.assertSourceMaps = assertSourceMaps;
exports.assertCompact = assertCompact;
exports.assertSourceType = assertSourceType;
exports.assertCallerMetadata = assertCallerMetadata;
exports.assertInputSourceMap = assertInputSourceMap;
exports.assertString = assertString;
exports.assertFunction = assertFunction;
exports.assertBoolean = assertBoolean;
exports.assertObject = assertObject;
exports.assertArray = assertArray;
exports.assertIgnoreList = assertIgnoreList;
exports.assertConfigApplicableTest = assertConfigApplicableTest;
exports.assertConfigFileSearch = assertConfigFileSearch;
exports.assertBabelrcSearch = assertBabelrcSearch;
exports.assertPluginList = assertPluginList;

function msg(loc) {
  switch (loc.type) {
    case "root":
      return "";

    case "env":
      return "".concat(msg(loc.parent), ".env[\"").concat(loc.name, "\"]");

    case "overrides":
      return "".concat(msg(loc.parent), ".overrides[").concat(loc.index, "]");

    case "option":
      return "".concat(msg(loc.parent), ".").concat(loc.name);

    case "access":
      return "".concat(msg(loc.parent), "[").concat(JSON.stringify(loc.name), "]");

    default:
      throw new Error("Assertion failure: Unknown type ".concat(loc.type));
  }
}

function access(loc, name) {
  return {
    type: "access",
    name: name,
    parent: loc
  };
}

function assertRootMode(loc, value) {
  if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
    throw new Error("".concat(msg(loc), " must be a \"root\", \"upward\", \"upward-optional\" or undefined"));
  }

  return value;
}

function assertSourceMaps(loc, value) {
  if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
    throw new Error("".concat(msg(loc), " must be a boolean, \"inline\", \"both\", or undefined"));
  }

  return value;
}

function assertCompact(loc, value) {
  if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
    throw new Error("".concat(msg(loc), " must be a boolean, \"auto\", or undefined"));
  }

  return value;
}

function assertSourceType(loc, value) {
  if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
    throw new Error("".concat(msg(loc), " must be \"module\", \"script\", \"unambiguous\", or undefined"));
  }

  return value;
}

function assertCallerMetadata(loc, value) {
  var obj = assertObject(loc, value);

  if (obj) {
    if (typeof obj["name"] !== "string") {
      throw new Error("".concat(msg(loc), " set but does not contain \"name\" property string"));
    }

    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];
      var propLoc = access(loc, prop);
      var _value = obj[prop];

      if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
        throw new Error("".concat(msg(propLoc), " must be null, undefined, a boolean, a string, or a number."));
      }
    }
  }

  return value;
}

function assertInputSourceMap(loc, value) {
  if (value !== undefined && typeof value !== "boolean" && (_typeof(value) !== "object" || !value)) {
    throw new Error("".concat(msg(loc), " must be a boolean, object, or undefined"));
  }

  return value;
}

function assertString(loc, value) {
  if (value !== undefined && typeof value !== "string") {
    throw new Error("".concat(msg(loc), " must be a string, or undefined"));
  }

  return value;
}

function assertFunction(loc, value) {
  if (value !== undefined && typeof value !== "function") {
    throw new Error("".concat(msg(loc), " must be a function, or undefined"));
  }

  return value;
}

function assertBoolean(loc, value) {
  if (value !== undefined && typeof value !== "boolean") {
    throw new Error("".concat(msg(loc), " must be a boolean, or undefined"));
  }

  return value;
}

function assertObject(loc, value) {
  if (value !== undefined && (_typeof(value) !== "object" || Array.isArray(value) || !value)) {
    throw new Error("".concat(msg(loc), " must be an object, or undefined"));
  }

  return value;
}

function assertArray(loc, value) {
  if (value != null && !Array.isArray(value)) {
    throw new Error("".concat(msg(loc), " must be an array, or undefined"));
  }

  return value;
}

function assertIgnoreList(loc, value) {
  var arr = assertArray(loc, value);

  if (arr) {
    arr.forEach(function (item, i) {
      return assertIgnoreItem(access(loc, i), item);
    });
  }

  return arr;
}

function assertIgnoreItem(loc, value) {
  if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
    throw new Error("".concat(msg(loc), " must be an array of string/Function/RegExp values, or undefined"));
  }

  return value;
}

function assertConfigApplicableTest(loc, value) {
  if (value === undefined) return value;

  if (Array.isArray(value)) {
    value.forEach(function (item, i) {
      if (!checkValidTest(item)) {
        throw new Error("".concat(msg(access(loc, i)), " must be a string/Function/RegExp."));
      }
    });
  } else if (!checkValidTest(value)) {
    throw new Error("".concat(msg(loc), " must be a string/Function/RegExp, or an array of those"));
  }

  return value;
}

function checkValidTest(value) {
  return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
}

function assertConfigFileSearch(loc, value) {
  if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
    throw new Error("".concat(msg(loc), " must be a undefined, a boolean, a string, ") + "got ".concat(JSON.stringify(value)));
  }

  return value;
}

function assertBabelrcSearch(loc, value) {
  if (value === undefined || typeof value === "boolean") return value;

  if (Array.isArray(value)) {
    value.forEach(function (item, i) {
      if (!checkValidTest(item)) {
        throw new Error("".concat(msg(access(loc, i)), " must be a string/Function/RegExp."));
      }
    });
  } else if (!checkValidTest(value)) {
    throw new Error("".concat(msg(loc), " must be a undefined, a boolean, a string/Function/RegExp ") + "or an array of those, got ".concat(JSON.stringify(value)));
  }

  return value;
}

function assertPluginList(loc, value) {
  var arr = assertArray(loc, value);

  if (arr) {
    arr.forEach(function (item, i) {
      return assertPluginItem(access(loc, i), item);
    });
  }

  return arr;
}

function assertPluginItem(loc, value) {
  if (Array.isArray(value)) {
    if (value.length === 0) {
      throw new Error("".concat(msg(loc), " must include an object"));
    }

    if (value.length > 3) {
      throw new Error("".concat(msg(loc), " may only be a two-tuple or three-tuple"));
    }

    assertPluginTarget(access(loc, 0), value[0]);

    if (value.length > 1) {
      var opts = value[1];

      if (opts !== undefined && opts !== false && (_typeof(opts) !== "object" || Array.isArray(opts) || opts === null)) {
        throw new Error("".concat(msg(access(loc, 1)), " must be an object, false, or undefined"));
      }
    }

    if (value.length === 3) {
      var name = value[2];

      if (name !== undefined && typeof name !== "string") {
        throw new Error("".concat(msg(access(loc, 2)), " must be a string, or undefined"));
      }
    }
  } else {
    assertPluginTarget(loc, value);
  }

  return value;
}

function assertPluginTarget(loc, value) {
  if ((_typeof(value) !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
    throw new Error("".concat(msg(loc), " must be a string, object, function"));
  }

  return value;
}

},{}],16:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;

var _plugin = _interopRequireDefault(require("../plugin"));

var _removed = _interopRequireDefault(require("./removed"));

var _optionAssertions = require("./option-assertions");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var ROOT_VALIDATORS = {
  cwd: _optionAssertions.assertString,
  root: _optionAssertions.assertString,
  rootMode: _optionAssertions.assertRootMode,
  configFile: _optionAssertions.assertConfigFileSearch,
  caller: _optionAssertions.assertCallerMetadata,
  filename: _optionAssertions.assertString,
  filenameRelative: _optionAssertions.assertString,
  code: _optionAssertions.assertBoolean,
  ast: _optionAssertions.assertBoolean,
  envName: _optionAssertions.assertString
};
var BABELRC_VALIDATORS = {
  babelrc: _optionAssertions.assertBoolean,
  babelrcRoots: _optionAssertions.assertBabelrcSearch
};
var NONPRESET_VALIDATORS = {
  extends: _optionAssertions.assertString,
  ignore: _optionAssertions.assertIgnoreList,
  only: _optionAssertions.assertIgnoreList
};
var COMMON_VALIDATORS = {
  inputSourceMap: _optionAssertions.assertInputSourceMap,
  presets: _optionAssertions.assertPluginList,
  plugins: _optionAssertions.assertPluginList,
  passPerPreset: _optionAssertions.assertBoolean,
  env: assertEnvSet,
  overrides: assertOverridesList,
  test: _optionAssertions.assertConfigApplicableTest,
  include: _optionAssertions.assertConfigApplicableTest,
  exclude: _optionAssertions.assertConfigApplicableTest,
  retainLines: _optionAssertions.assertBoolean,
  comments: _optionAssertions.assertBoolean,
  shouldPrintComment: _optionAssertions.assertFunction,
  compact: _optionAssertions.assertCompact,
  minified: _optionAssertions.assertBoolean,
  auxiliaryCommentBefore: _optionAssertions.assertString,
  auxiliaryCommentAfter: _optionAssertions.assertString,
  sourceType: _optionAssertions.assertSourceType,
  wrapPluginVisitorMethod: _optionAssertions.assertFunction,
  highlightCode: _optionAssertions.assertBoolean,
  sourceMaps: _optionAssertions.assertSourceMaps,
  sourceMap: _optionAssertions.assertSourceMaps,
  sourceFileName: _optionAssertions.assertString,
  sourceRoot: _optionAssertions.assertString,
  getModuleId: _optionAssertions.assertFunction,
  moduleRoot: _optionAssertions.assertString,
  moduleIds: _optionAssertions.assertBoolean,
  moduleId: _optionAssertions.assertString,
  parserOpts: _optionAssertions.assertObject,
  generatorOpts: _optionAssertions.assertObject
};

function getSource(loc) {
  return loc.type === "root" ? loc.source : getSource(loc.parent);
}

function validate(type, opts) {
  return validateNested({
    type: "root",
    source: type
  }, opts);
}

function validateNested(loc, opts) {
  var type = getSource(loc);
  assertNoDuplicateSourcemap(opts);
  Object.keys(opts).forEach(function (key) {
    var optLoc = {
      type: "option",
      name: key,
      parent: loc
    };

    if (type === "preset" && NONPRESET_VALIDATORS[key]) {
      throw new Error("".concat((0, _optionAssertions.msg)(optLoc), " is not allowed in preset options"));
    }

    if (type !== "arguments" && ROOT_VALIDATORS[key]) {
      throw new Error("".concat((0, _optionAssertions.msg)(optLoc), " is only allowed in root programmatic options"));
    }

    if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
      if (type === "babelrcfile" || type === "extendsfile") {
        throw new Error("".concat((0, _optionAssertions.msg)(optLoc), " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, ") + "or babel.config.js/config file options");
      }

      throw new Error("".concat((0, _optionAssertions.msg)(optLoc), " is only allowed in root programmatic options, or babel.config.js/config file options"));
    }

    var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
    validator(optLoc, opts[key]);
  });
  return opts;
}

function throwUnknownError(loc) {
  var key = loc.name;

  if (_removed.default[key]) {
    var _removed$default$key = _removed.default[key],
        message = _removed$default$key.message,
        _removed$default$key$ = _removed$default$key.version,
        version = _removed$default$key$ === void 0 ? 5 : _removed$default$key$;
    throw new ReferenceError("Using removed Babel ".concat(version, " option: ").concat((0, _optionAssertions.msg)(loc), " - ").concat(message));
  } else {
    var unknownOptErr = "Unknown option: ".concat((0, _optionAssertions.msg)(loc), ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
    throw new ReferenceError(unknownOptErr);
  }
}

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function assertNoDuplicateSourcemap(opts) {
  if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
}

function assertEnvSet(loc, value) {
  if (loc.parent.type === "env") {
    throw new Error("".concat((0, _optionAssertions.msg)(loc), " is not allowed inside of another .env block"));
  }

  var parent = loc.parent;
  var obj = (0, _optionAssertions.assertObject)(loc, value);

  if (obj) {
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var envName = _Object$keys[_i];
      var env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
      if (!env) continue;
      var envLoc = {
        type: "env",
        name: envName,
        parent: parent
      };
      validateNested(envLoc, env);
    }
  }

  return obj;
}

function assertOverridesList(loc, value) {
  if (loc.parent.type === "env") {
    throw new Error("".concat((0, _optionAssertions.msg)(loc), " is not allowed inside an .env block"));
  }

  if (loc.parent.type === "overrides") {
    throw new Error("".concat((0, _optionAssertions.msg)(loc), " is not allowed inside an .overrides block"));
  }

  var parent = loc.parent;
  var arr = (0, _optionAssertions.assertArray)(loc, value);

  if (arr) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = arr.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            index = _step$value[0],
            item = _step$value[1];

        var objLoc = (0, _optionAssertions.access)(loc, index);
        var env = (0, _optionAssertions.assertObject)(objLoc, item);
        if (!env) throw new Error("".concat((0, _optionAssertions.msg)(objLoc), " must be an object"));
        var overridesLoc = {
          type: "overrides",
          index: index,
          parent: parent
        };
        validateNested(overridesLoc, env);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return arr;
}

},{"../plugin":13,"./option-assertions":15,"./removed":18}],17:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validatePluginObject = validatePluginObject;

var _optionAssertions = require("./option-assertions");

var VALIDATORS = {
  name: _optionAssertions.assertString,
  manipulateOptions: _optionAssertions.assertFunction,
  pre: _optionAssertions.assertFunction,
  post: _optionAssertions.assertFunction,
  inherits: _optionAssertions.assertFunction,
  visitor: assertVisitorMap,
  parserOverride: _optionAssertions.assertFunction,
  generatorOverride: _optionAssertions.assertFunction
};

function assertVisitorMap(key, value) {
  var obj = (0, _optionAssertions.assertObject)(key, value);

  if (obj) {
    Object.keys(obj).forEach(function (prop) {
      return assertVisitorHandler(prop, obj[prop]);
    });

    if (obj.enter || obj.exit) {
      throw new Error(".".concat(key, " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes."));
    }
  }

  return obj;
}

function assertVisitorHandler(key, value) {
  if (value && _typeof(value) === "object") {
    Object.keys(value).forEach(function (handler) {
      if (handler !== "enter" && handler !== "exit") {
        throw new Error(".visitor[\"".concat(key, "\"] may only have .enter and/or .exit handlers."));
      }
    });
  } else if (typeof value !== "function") {
    throw new Error(".visitor[\"".concat(key, "\"] must be a function"));
  }

  return value;
}

function validatePluginObject(obj) {
  var rootPath = {
    type: "root",
    source: "plugin"
  };
  Object.keys(obj).forEach(function (key) {
    var validator = VALIDATORS[key];
    var optLoc = {
      type: "option",
      name: key,
      parent: rootPath
    };
    if (validator) validator(optLoc, obj[key]);else throw new Error(".".concat(key, " is not a valid Plugin property"));
  });
  return obj;
}

},{"./option-assertions":15}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  auxiliaryComment: {
    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
  },
  blacklist: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  breakConfig: {
    message: "This is not a necessary option in Babel 6"
  },
  experimental: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  externalHelpers: {
    message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
  },
  extra: {
    message: ""
  },
  jsxPragma: {
    message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
  },
  loose: {
    message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
  },
  metadataUsedHelpers: {
    message: "Not required anymore as this is enabled by default"
  },
  modules: {
    message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
  },
  nonStandard: {
    message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
  },
  optional: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  sourceMapName: {
    message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
  },
  stage: {
    message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
  },
  whitelist: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  resolveModuleSource: {
    version: 6,
    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
  },
  metadata: {
    version: 6,
    message: "Generated plugin metadata is always included in the output result"
  },
  sourceMapTarget: {
    version: 6,
    message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
  }
};
exports.default = _default;

},{}],19:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plugin = Plugin;
Object.defineProperty(exports, "File", {
  enumerable: true,
  get: function get() {
    return _file.default;
  }
});
Object.defineProperty(exports, "buildExternalHelpers", {
  enumerable: true,
  get: function get() {
    return _buildExternalHelpers.default;
  }
});
Object.defineProperty(exports, "resolvePlugin", {
  enumerable: true,
  get: function get() {
    return _files.resolvePlugin;
  }
});
Object.defineProperty(exports, "resolvePreset", {
  enumerable: true,
  get: function get() {
    return _files.resolvePreset;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function get() {
    return _package.version;
  }
});
Object.defineProperty(exports, "getEnv", {
  enumerable: true,
  get: function get() {
    return _environment.getEnv;
  }
});
Object.defineProperty(exports, "tokTypes", {
  enumerable: true,
  get: function get() {
    return _parser().tokTypes;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function get() {
    return _traverse().default;
  }
});
Object.defineProperty(exports, "template", {
  enumerable: true,
  get: function get() {
    return _template().default;
  }
});
Object.defineProperty(exports, "createConfigItem", {
  enumerable: true,
  get: function get() {
    return _item.createConfigItem;
  }
});
Object.defineProperty(exports, "loadPartialConfig", {
  enumerable: true,
  get: function get() {
    return _config.loadPartialConfig;
  }
});
Object.defineProperty(exports, "loadOptions", {
  enumerable: true,
  get: function get() {
    return _config.loadOptions;
  }
});
Object.defineProperty(exports, "transform", {
  enumerable: true,
  get: function get() {
    return _transform.transform;
  }
});
Object.defineProperty(exports, "transformSync", {
  enumerable: true,
  get: function get() {
    return _transform.transformSync;
  }
});
Object.defineProperty(exports, "transformAsync", {
  enumerable: true,
  get: function get() {
    return _transform.transformAsync;
  }
});
Object.defineProperty(exports, "transformFile", {
  enumerable: true,
  get: function get() {
    return _transformFile.transformFile;
  }
});
Object.defineProperty(exports, "transformFileSync", {
  enumerable: true,
  get: function get() {
    return _transformFile.transformFileSync;
  }
});
Object.defineProperty(exports, "transformFileAsync", {
  enumerable: true,
  get: function get() {
    return _transformFile.transformFileAsync;
  }
});
Object.defineProperty(exports, "transformFromAst", {
  enumerable: true,
  get: function get() {
    return _transformAst.transformFromAst;
  }
});
Object.defineProperty(exports, "transformFromAstSync", {
  enumerable: true,
  get: function get() {
    return _transformAst.transformFromAstSync;
  }
});
Object.defineProperty(exports, "transformFromAstAsync", {
  enumerable: true,
  get: function get() {
    return _transformAst.transformFromAstAsync;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function get() {
    return _parse.parseSync;
  }
});
Object.defineProperty(exports, "parseAsync", {
  enumerable: true,
  get: function get() {
    return _parse.parseAsync;
  }
});
exports.types = exports.OptionManager = exports.DEFAULT_EXTENSIONS = void 0;

var _file = _interopRequireDefault(require("./transformation/file/file"));

var _buildExternalHelpers = _interopRequireDefault(require("./tools/build-external-helpers"));

var _files = require("./config/files");

var _package = require("../package.json");

var _environment = require("./config/helpers/environment");

function _types() {
  var data = _interopRequireWildcard(require("@babel/types"));

  _types = function _types() {
    return data;
  };

  return data;
}

Object.defineProperty(exports, "types", {
  enumerable: true,
  get: function get() {
    return _types();
  }
});

function _parser() {
  var data = require("@babel/parser");

  _parser = function _parser() {
    return data;
  };

  return data;
}

function _traverse() {
  var data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

function _template() {
  var data = _interopRequireDefault(require("@babel/template"));

  _template = function _template() {
    return data;
  };

  return data;
}

var _item = require("./config/item");

var _config = require("./config");

var _transform = require("./transform");

var _transformFile = require("./transform-file");

var _transformAst = require("./transform-ast");

var _parse = require("./parse");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs"]);
exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;

var OptionManager =
/*#__PURE__*/
function () {
  function OptionManager() {
    _classCallCheck(this, OptionManager);
  }

  _createClass(OptionManager, [{
    key: "init",
    value: function init(opts) {
      return (0, _config.loadOptions)(opts);
    }
  }]);

  return OptionManager;
}();

exports.OptionManager = OptionManager;

function Plugin(alias) {
  throw new Error("The (".concat(alias, ") Babel 5 plugin is being run with an unsupported Babel version."));
}

},{"../package.json":37,"./config":9,"./config/files":5,"./config/helpers/environment":8,"./config/item":10,"./parse":20,"./tools/build-external-helpers":21,"./transform":24,"./transform-ast":22,"./transform-file":23,"./transformation/file/file":26,"@babel/parser":89,"@babel/template":167,"@babel/traverse":176,"@babel/types":242}],20:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;
exports.parseAsync = parseAsync;
exports.parse = void 0;

var _config = _interopRequireDefault(require("./config"));

var _normalizeFile = _interopRequireDefault(require("./transformation/normalize-file"));

var _normalizeOpts = _interopRequireDefault(require("./transformation/normalize-opts"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var parse = function parse(code, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }

  if (callback === undefined) return parseSync(code, opts);
  var config = (0, _config.default)(opts);

  if (config === null) {
    return null;
  }

  var cb = callback;
  process.nextTick(function () {
    var ast = null;

    try {
      var cfg = (0, _config.default)(opts);
      if (cfg === null) return cb(null, null);
      ast = (0, _normalizeFile.default)(cfg.passes, (0, _normalizeOpts.default)(cfg), code).ast;
    } catch (err) {
      return cb(err);
    }

    cb(null, ast);
  });
};

exports.parse = parse;

function parseSync(code, opts) {
  var config = (0, _config.default)(opts);

  if (config === null) {
    return null;
  }

  return (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code).ast;
}

function parseAsync(code, opts) {
  return new Promise(function (res, rej) {
    parse(code, opts, function (err, result) {
      if (err == null) res(result);else rej(err);
    });
  });
}

}).call(this,require('_process'))
},{"./config":9,"./transformation/normalize-file":30,"./transformation/normalize-opts":31,"_process":1054}],21:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function helpers() {
  var data = _interopRequireWildcard(require("@babel/helpers"));

  helpers = function helpers() {
    return data;
  };

  return data;
}

function _generator() {
  var data = _interopRequireDefault(require("@babel/generator"));

  _generator = function _generator() {
    return data;
  };

  return data;
}

function _template() {
  var data = _interopRequireDefault(require("@babel/template"));

  _template = function _template() {
    return data;
  };

  return data;
}

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var buildUmdWrapper = function buildUmdWrapper(replacements) {
  return _template().default(_templateObject())(replacements);
};

function buildGlobal(whitelist) {
  var namespace = t().identifier("babelHelpers");
  var body = [];
  var container = t().functionExpression(null, [t().identifier("global")], t().blockStatement(body));
  var tree = t().program([t().expressionStatement(t().callExpression(container, [t().conditionalExpression(t().binaryExpression("===", t().unaryExpression("typeof", t().identifier("global")), t().stringLiteral("undefined")), t().identifier("self"), t().identifier("global"))]))]);
  body.push(t().variableDeclaration("var", [t().variableDeclarator(namespace, t().assignmentExpression("=", t().memberExpression(t().identifier("global"), namespace), t().objectExpression([])))]));
  buildHelpers(body, namespace, whitelist);
  return tree;
}

function buildModule(whitelist) {
  var body = [];
  var refs = buildHelpers(body, null, whitelist);
  body.unshift(t().exportNamedDeclaration(null, Object.keys(refs).map(function (name) {
    return t().exportSpecifier(t().cloneNode(refs[name]), t().identifier(name));
  })));
  return t().program(body, [], "module");
}

function buildUmd(whitelist) {
  var namespace = t().identifier("babelHelpers");
  var body = [];
  body.push(t().variableDeclaration("var", [t().variableDeclarator(namespace, t().identifier("global"))]));
  buildHelpers(body, namespace, whitelist);
  return t().program([buildUmdWrapper({
    FACTORY_PARAMETERS: t().identifier("global"),
    BROWSER_ARGUMENTS: t().assignmentExpression("=", t().memberExpression(t().identifier("root"), namespace), t().objectExpression([])),
    COMMON_ARGUMENTS: t().identifier("exports"),
    AMD_ARGUMENTS: t().arrayExpression([t().stringLiteral("exports")]),
    FACTORY_BODY: body,
    UMD_ROOT: t().identifier("this")
  })]);
}

function buildVar(whitelist) {
  var namespace = t().identifier("babelHelpers");
  var body = [];
  body.push(t().variableDeclaration("var", [t().variableDeclarator(namespace, t().objectExpression([]))]));
  var tree = t().program(body);
  buildHelpers(body, namespace, whitelist);
  body.push(t().expressionStatement(namespace));
  return tree;
}

function buildHelpers(body, namespace, whitelist) {
  var getHelperReference = function getHelperReference(name) {
    return namespace ? t().memberExpression(namespace, t().identifier(name)) : t().identifier("_".concat(name));
  };

  var refs = {};
  helpers().list.forEach(function (name) {
    if (whitelist && whitelist.indexOf(name) < 0) return;
    var ref = refs[name] = getHelperReference(name);

    var _helpers$get = helpers().get(name, getHelperReference, ref),
        nodes = _helpers$get.nodes;

    body.push.apply(body, _toConsumableArray(nodes));
  });
  return refs;
}

function _default(whitelist) {
  var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "global";
  var tree;
  var build = {
    global: buildGlobal,
    module: buildModule,
    umd: buildUmd,
    var: buildVar
  }[outputType];

  if (build) {
    tree = build(whitelist);
  } else {
    throw new Error("Unsupported output type ".concat(outputType));
  }

  return (0, _generator().default)(tree).code;
}

},{"@babel/generator":51,"@babel/helpers":87,"@babel/template":167,"@babel/types":242}],22:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformFromAstSync = transformFromAstSync;
exports.transformFromAstAsync = transformFromAstAsync;
exports.transformFromAst = void 0;

var _config = _interopRequireDefault(require("./config"));

var _transformation = require("./transformation");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var transformFromAst = function transformFromAst(ast, code, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }

  if (callback === undefined) return transformFromAstSync(ast, code, opts);
  var cb = callback;
  process.nextTick(function () {
    var cfg;

    try {
      cfg = (0, _config.default)(opts);
      if (cfg === null) return cb(null, null);
    } catch (err) {
      return cb(err);
    }

    if (!ast) return cb(new Error("No AST given"));
    (0, _transformation.runAsync)(cfg, code, ast, cb);
  });
};

exports.transformFromAst = transformFromAst;

function transformFromAstSync(ast, code, opts) {
  var config = (0, _config.default)(opts);
  if (config === null) return null;
  if (!ast) throw new Error("No AST given");
  return (0, _transformation.runSync)(config, code, ast);
}

function transformFromAstAsync(ast, code, opts) {
  return new Promise(function (res, rej) {
    transformFromAst(ast, code, opts, function (err, result) {
      if (err == null) res(result);else rej(err);
    });
  });
}

}).call(this,require('_process'))
},{"./config":9,"./transformation":29,"_process":1054}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformFileSync = transformFileSync;
exports.transformFileAsync = transformFileAsync;
exports.transformFile = void 0;

var transformFile = function transformFile(filename, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
  }

  callback(new Error("Transforming files is not supported in browsers"), null);
};

exports.transformFile = transformFile;

function transformFileSync() {
  throw new Error("Transforming files is not supported in browsers");
}

function transformFileAsync() {
  return Promise.reject(new Error("Transforming files is not supported in browsers"));
}

},{}],24:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformSync = transformSync;
exports.transformAsync = transformAsync;
exports.transform = void 0;

var _config = _interopRequireDefault(require("./config"));

var _transformation = require("./transformation");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var transform = function transform(code, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }

  if (callback === undefined) return transformSync(code, opts);
  var cb = callback;
  process.nextTick(function () {
    var cfg;

    try {
      cfg = (0, _config.default)(opts);
      if (cfg === null) return cb(null, null);
    } catch (err) {
      return cb(err);
    }

    (0, _transformation.runAsync)(cfg, code, null, cb);
  });
};

exports.transform = transform;

function transformSync(code, opts) {
  var config = (0, _config.default)(opts);
  if (config === null) return null;
  return (0, _transformation.runSync)(config, code);
}

function transformAsync(code, opts) {
  return new Promise(function (res, rej) {
    transform(code, opts, function (err, result) {
      if (err == null) res(result);else rej(err);
    });
  });
}

}).call(this,require('_process'))
},{"./config":9,"./transformation":29,"_process":1054}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadBlockHoistPlugin;

function _sortBy() {
  var data = _interopRequireDefault(require("lodash/sortBy"));

  _sortBy = function _sortBy() {
    return data;
  };

  return data;
}

var _config = _interopRequireDefault(require("../config"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var LOADED_PLUGIN;

function loadBlockHoistPlugin() {
  if (!LOADED_PLUGIN) {
    var config = (0, _config.default)({
      babelrc: false,
      configFile: false,
      plugins: [blockHoistPlugin]
    });
    LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
    if (!LOADED_PLUGIN) throw new Error("Assertion failure");
  }

  return LOADED_PLUGIN;
}

var blockHoistPlugin = {
  name: "internal.blockHoist",
  visitor: {
    Block: {
      exit: function exit(_ref) {
        var node = _ref.node;
        var hasChange = false;

        for (var i = 0; i < node.body.length; i++) {
          var bodyNode = node.body[i];

          if (bodyNode && bodyNode._blockHoist != null) {
            hasChange = true;
            break;
          }
        }

        if (!hasChange) return;
        node.body = (0, _sortBy().default)(node.body, function (bodyNode) {
          var priority = bodyNode && bodyNode._blockHoist;
          if (priority == null) priority = 1;
          if (priority === true) priority = 2;
          return -1 * priority;
        });
      }
    }
  }
};

},{"../config":9,"lodash/sortBy":1040}],26:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function helpers() {
  var data = _interopRequireWildcard(require("@babel/helpers"));

  helpers = function helpers() {
    return data;
  };

  return data;
}

function _traverse() {
  var data = _interopRequireWildcard(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

function _codeFrame() {
  var data = require("@babel/code-frame");

  _codeFrame = function _codeFrame() {
    return data;
  };

  return data;
}

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _semver() {
  var data = _interopRequireDefault(require("semver"));

  _semver = function _semver() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var errorVisitor = {
  enter: function enter(path, state) {
    var loc = path.node.loc;

    if (loc) {
      state.loc = loc;
      path.stop();
    }
  }
};

var File =
/*#__PURE__*/
function () {
  function File(options, _ref) {
    var _this = this;

    var code = _ref.code,
        ast = _ref.ast,
        inputMap = _ref.inputMap;

    _classCallCheck(this, File);

    this._map = new Map();
    this.declarations = {};
    this.path = null;
    this.ast = {};
    this.metadata = {};
    this.code = "";
    this.inputMap = null;
    this.hub = {
      file: this,
      getCode: function getCode() {
        return _this.code;
      },
      getScope: function getScope() {
        return _this.scope;
      },
      addHelper: this.addHelper.bind(this),
      buildError: this.buildCodeFrameError.bind(this)
    };
    this.opts = options;
    this.code = code;
    this.ast = ast;
    this.inputMap = inputMap;
    this.path = _traverse().NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: this.ast,
      container: this.ast,
      key: "program"
    }).setContext();
    this.scope = this.path.scope;
  }

  _createClass(File, [{
    key: "set",
    value: function set(key, val) {
      if (key === "helpersNamespace") {
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
      }

      this._map.set(key, val);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._map.get(key);
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._map.has(key);
    }
  }, {
    key: "getModuleName",
    value: function getModuleName() {
      var _this$opts = this.opts,
          filename = _this$opts.filename,
          _this$opts$filenameRe = _this$opts.filenameRelative,
          filenameRelative = _this$opts$filenameRe === void 0 ? filename : _this$opts$filenameRe,
          moduleId = _this$opts.moduleId,
          _this$opts$moduleIds = _this$opts.moduleIds,
          moduleIds = _this$opts$moduleIds === void 0 ? !!moduleId : _this$opts$moduleIds,
          getModuleId = _this$opts.getModuleId,
          sourceRootTmp = _this$opts.sourceRoot,
          _this$opts$moduleRoot = _this$opts.moduleRoot,
          moduleRoot = _this$opts$moduleRoot === void 0 ? sourceRootTmp : _this$opts$moduleRoot,
          _this$opts$sourceRoot = _this$opts.sourceRoot,
          sourceRoot = _this$opts$sourceRoot === void 0 ? moduleRoot : _this$opts$sourceRoot;
      if (!moduleIds) return null;

      if (moduleId != null && !getModuleId) {
        return moduleId;
      }

      var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

      if (filenameRelative) {
        var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
        moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
      }

      moduleName = moduleName.replace(/\\/g, "/");

      if (getModuleId) {
        return getModuleId(moduleName) || moduleName;
      } else {
        return moduleName;
      }
    }
  }, {
    key: "addImport",
    value: function addImport() {
      throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
    }
  }, {
    key: "availableHelper",
    value: function availableHelper(name, versionRange) {
      var minVersion;

      try {
        minVersion = helpers().minVersion(name);
      } catch (err) {
        if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
        return false;
      }

      if (typeof versionRange !== "string") return true;
      if (_semver().default.valid(versionRange)) versionRange = "^".concat(versionRange);
      return !_semver().default.intersects("<".concat(minVersion), versionRange) && !_semver().default.intersects(">=8.0.0", versionRange);
    }
  }, {
    key: "addHelper",
    value: function addHelper(name) {
      var _this2 = this;

      var declar = this.declarations[name];
      if (declar) return t().cloneNode(declar);
      var generator = this.get("helperGenerator");

      if (generator) {
        var res = generator(name);
        if (res) return res;
      }

      helpers().ensure(name);
      var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
      var dependencies = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = helpers().getDependencies(name)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dep = _step.value;
          dependencies[dep] = this.addHelper(dep);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _helpers$get = helpers().get(name, function (dep) {
        return dependencies[dep];
      }, uid, Object.keys(this.scope.getAllBindings())),
          nodes = _helpers$get.nodes,
          globals = _helpers$get.globals;

      globals.forEach(function (name) {
        if (_this2.path.scope.hasBinding(name, true)) {
          _this2.path.scope.rename(name);
        }
      });
      nodes.forEach(function (node) {
        node._compact = true;
      });
      this.path.unshiftContainer("body", nodes);
      this.path.get("body").forEach(function (path) {
        if (nodes.indexOf(path.node) === -1) return;
        if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
      });
      return uid;
    }
  }, {
    key: "addTemplateObject",
    value: function addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }
  }, {
    key: "buildCodeFrameError",
    value: function buildCodeFrameError(node, msg) {
      var Error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SyntaxError;
      var loc = node && (node.loc || node._loc);

      if (!loc && node) {
        var state = {
          loc: null
        };
        (0, _traverse().default)(node, errorVisitor, this.scope, state);
        loc = state.loc;
        var txt = "This is an error on an internal node. Probably an internal error.";
        if (loc) txt += " Location has been estimated.";
        msg += " (".concat(txt, ")");
      }

      if (loc) {
        var _this$opts$highlightC = this.opts.highlightCode,
            highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
        msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
          start: {
            line: loc.start.line,
            column: loc.start.column + 1
          },
          end: loc.end && loc.start.line === loc.end.line ? {
            line: loc.end.line,
            column: loc.end.column + 1
          } : undefined
        }, {
          highlightCode: highlightCode
        });
      }

      return new Error(msg);
    }
  }, {
    key: "shebang",
    get: function get() {
      var interpreter = this.path.node.interpreter;
      return interpreter ? interpreter.value : "";
    },
    set: function set(value) {
      if (value) {
        this.path.get("interpreter").replaceWith(t().interpreterDirective(value));
      } else {
        this.path.get("interpreter").remove();
      }
    }
  }]);

  return File;
}();

exports.default = File;

},{"@babel/code-frame":1,"@babel/helpers":87,"@babel/traverse":176,"@babel/types":242,"semver":1070}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateCode;

function _convertSourceMap() {
  var data = _interopRequireDefault(require("convert-source-map"));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _generator() {
  var data = _interopRequireDefault(require("@babel/generator"));

  _generator = function _generator() {
    return data;
  };

  return data;
}

var _mergeMap = _interopRequireDefault(require("./merge-map"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function generateCode(pluginPasses, file) {
  var opts = file.opts,
      ast = file.ast,
      code = file.code,
      inputMap = file.inputMap;
  var results = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var plugins = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var plugin = _step2.value;
          var generatorOverride = plugin.generatorOverride;

          if (generatorOverride) {
            var _result2 = generatorOverride(ast, opts.generatorOpts, code, _generator().default);

            if (_result2 !== undefined) results.push(_result2);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var result;

  if (results.length === 0) {
    result = (0, _generator().default)(ast, opts.generatorOpts, code);
  } else if (results.length === 1) {
    result = results[0];

    if (typeof result.then === "function") {
      throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
    }
  } else {
    throw new Error("More than one plugin attempted to override codegen.");
  }

  var _result = result,
      outputCode = _result.code,
      outputMap = _result.map;

  if (outputMap && inputMap) {
    outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap);
  }

  if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
    outputCode += "\n" + _convertSourceMap().default.fromObject(outputMap).toComment();
  }

  if (opts.sourceMaps === "inline") {
    outputMap = null;
  }

  return {
    outputCode: outputCode,
    outputMap: outputMap
  };
}

},{"./merge-map":28,"@babel/generator":51,"convert-source-map":302}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeSourceMap;

function _sourceMap() {
  var data = _interopRequireDefault(require("source-map"));

  _sourceMap = function _sourceMap() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function mergeSourceMap(inputMap, map) {
  var input = buildMappingData(inputMap);
  var output = buildMappingData(map);
  var mergedGenerator = new (_sourceMap().default.SourceMapGenerator)();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = input.sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;
      var source = _ref.source;

      if (typeof source.content === "string") {
        mergedGenerator.setSourceContent(source.path, source.content);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (output.sources.length === 1) {
    var defaultSource = output.sources[0];
    var insertedMappings = new Map();
    eachInputGeneratedRange(input, function (generated, original, source) {
      eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
        var key = makeMappingKey(item);
        if (insertedMappings.has(key)) return;
        insertedMappings.set(key, item);
        mergedGenerator.addMapping({
          source: source.path,
          original: {
            line: original.line,
            column: original.columnStart
          },
          generated: {
            line: item.line,
            column: item.columnStart
          },
          name: original.name
        });
      });
    });
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = insertedMappings.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var item = _step2.value;

        if (item.columnEnd === Infinity) {
          continue;
        }

        var clearItem = {
          line: item.line,
          columnStart: item.columnEnd
        };
        var key = makeMappingKey(clearItem);

        if (insertedMappings.has(key)) {
          continue;
        }

        mergedGenerator.addMapping({
          generated: {
            line: clearItem.line,
            column: clearItem.columnStart
          }
        });
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var result = mergedGenerator.toJSON();

  if (typeof input.sourceRoot === "string") {
    result.sourceRoot = input.sourceRoot;
  }

  return result;
}

function makeMappingKey(item) {
  return "".concat(item.line, "/").concat(item.columnStart);
}

function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
  var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = overlappingOriginal[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _ref2 = _step3.value;
      var generated = _ref2.generated;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = generated[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var item = _step4.value;
          callback(item);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
}

function filterApplicableOriginalRanges(_ref5, _ref6) {
  var mappings = _ref5.mappings;
  var line = _ref6.line,
      columnStart = _ref6.columnStart,
      columnEnd = _ref6.columnEnd;
  return filterSortedArray(mappings, function (_ref7) {
    var outOriginal = _ref7.original;
    if (line > outOriginal.line) return -1;
    if (line < outOriginal.line) return 1;
    if (columnStart >= outOriginal.columnEnd) return -1;
    if (columnEnd <= outOriginal.columnStart) return 1;
    return 0;
  });
}

function eachInputGeneratedRange(map, callback) {
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = map.sources[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var _ref3 = _step5.value;
      var source = _ref3.source,
          mappings = _ref3.mappings;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = mappings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _ref4 = _step6.value;
          var original = _ref4.original,
              generated = _ref4.generated;
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = generated[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var item = _step7.value;
              callback(item, original, source);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }
}

function buildMappingData(map) {
  var consumer = new (_sourceMap().default.SourceMapConsumer)(Object.assign({}, map, {
    sourceRoot: null
  }));
  var sources = new Map();
  var mappings = new Map();
  var last = null;
  consumer.computeColumnSpans();
  consumer.eachMapping(function (m) {
    if (m.originalLine === null) return;
    var source = sources.get(m.source);

    if (!source) {
      source = {
        path: m.source,
        content: consumer.sourceContentFor(m.source, true)
      };
      sources.set(m.source, source);
    }

    var sourceData = mappings.get(source);

    if (!sourceData) {
      sourceData = {
        source: source,
        mappings: []
      };
      mappings.set(source, sourceData);
    }

    var obj = {
      line: m.originalLine,
      columnStart: m.originalColumn,
      columnEnd: Infinity,
      name: m.name
    };

    if (last && last.source === source && last.mapping.line === m.originalLine) {
      last.mapping.columnEnd = m.originalColumn;
    }

    last = {
      source: source,
      mapping: obj
    };
    sourceData.mappings.push({
      original: obj,
      generated: consumer.allGeneratedPositionsFor({
        source: m.source,
        line: m.originalLine,
        column: m.originalColumn
      }).map(function (item) {
        return {
          line: item.line,
          columnStart: item.column,
          columnEnd: item.lastColumn + 1
        };
      })
    });
  }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);
  return {
    file: map.file,
    sourceRoot: map.sourceRoot,
    sources: Array.from(mappings.values())
  };
}

function findInsertionLocation(array, callback) {
  var left = 0;
  var right = array.length;

  while (left < right) {
    var mid = Math.floor((left + right) / 2);
    var item = array[mid];
    var result = callback(item);

    if (result === 0) {
      left = mid;
      break;
    }

    if (result >= 0) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }

  var i = left;

  if (i < array.length) {
    while (i >= 0 && callback(array[i]) >= 0) {
      i--;
    }

    return i + 1;
  }

  return i;
}

function filterSortedArray(array, callback) {
  var start = findInsertionLocation(array, callback);
  var results = [];

  for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
    results.push(array[i]);
  }

  return results;
}

},{"source-map":1081}],29:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runAsync = runAsync;
exports.runSync = runSync;

function _traverse() {
  var data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

var _pluginPass = _interopRequireDefault(require("./plugin-pass"));

var _blockHoistPlugin = _interopRequireDefault(require("./block-hoist-plugin"));

var _normalizeOpts = _interopRequireDefault(require("./normalize-opts"));

var _normalizeFile = _interopRequireDefault(require("./normalize-file"));

var _generate = _interopRequireDefault(require("./file/generate"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function runAsync(config, code, ast, callback) {
  var result;

  try {
    result = runSync(config, code, ast);
  } catch (err) {
    return callback(err);
  }

  return callback(null, result);
}

function runSync(config, code, ast) {
  var file = (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);
  var opts = file.opts;

  try {
    transformFile(file, config.passes);
  } catch (e) {
    var _opts$filename;

    e.message = "".concat((_opts$filename = opts.filename) !== null && _opts$filename !== void 0 ? _opts$filename : "unknown", ": ").concat(e.message);

    if (!e.code) {
      e.code = "BABEL_TRANSFORM_ERROR";
    }

    throw e;
  }

  var outputCode, outputMap;

  try {
    if (opts.code !== false) {
      var _ref = (0, _generate.default)(config.passes, file);

      outputCode = _ref.outputCode;
      outputMap = _ref.outputMap;
    }
  } catch (e) {
    var _opts$filename2;

    e.message = "".concat((_opts$filename2 = opts.filename) !== null && _opts$filename2 !== void 0 ? _opts$filename2 : "unknown", ": ").concat(e.message);

    if (!e.code) {
      e.code = "BABEL_GENERATE_ERROR";
    }

    throw e;
  }

  return {
    metadata: file.metadata,
    options: opts,
    ast: opts.ast === true ? file.ast : null,
    code: outputCode === undefined ? null : outputCode,
    map: outputMap === undefined ? null : outputMap,
    sourceType: file.ast.program.sourceType
  };
}

function transformFile(file, pluginPasses) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var pluginPairs = _step.value;
      var passPairs = [];
      var passes = [];
      var visitors = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = pluginPairs.concat([(0, _blockHoistPlugin.default)()])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var plugin = _step2.value;
          var pass = new _pluginPass.default(file, plugin.key, plugin.options);
          passPairs.push([plugin, pass]);
          passes.push(pass);
          visitors.push(plugin.visitor);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      for (var _i = 0, _passPairs = passPairs; _i < _passPairs.length; _i++) {
        var _passPairs$_i = _slicedToArray(_passPairs[_i], 2),
            _plugin = _passPairs$_i[0],
            _pass = _passPairs$_i[1];

        var fn = _plugin.pre;

        if (fn) {
          var result = fn.call(_pass, file);

          if (isThenable(result)) {
            throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
          }
        }
      }

      var visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);

      (0, _traverse().default)(file.ast, visitor, file.scope);

      for (var _i2 = 0, _passPairs2 = passPairs; _i2 < _passPairs2.length; _i2++) {
        var _passPairs2$_i = _slicedToArray(_passPairs2[_i2], 2),
            _plugin2 = _passPairs2$_i[0],
            _pass2 = _passPairs2$_i[1];

        var _fn = _plugin2.post;

        if (_fn) {
          var _result = _fn.call(_pass2, file);

          if (isThenable(_result)) {
            throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function isThenable(val) {
  return !!val && (_typeof(val) === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
}

},{"./block-hoist-plugin":25,"./file/generate":27,"./normalize-file":30,"./normalize-opts":31,"./plugin-pass":32,"@babel/traverse":176}],30:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeFile;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _cloneDeep() {
  var data = _interopRequireDefault(require("lodash/cloneDeep"));

  _cloneDeep = function _cloneDeep() {
    return data;
  };

  return data;
}

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  var data = _interopRequireDefault(require("convert-source-map"));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _parser() {
  var data = require("@babel/parser");

  _parser = function _parser() {
    return data;
  };

  return data;
}

function _codeFrame() {
  var data = require("@babel/code-frame");

  _codeFrame = function _codeFrame() {
    return data;
  };

  return data;
}

var _file = _interopRequireDefault(require("./file/file"));

var _missingPluginHelper = _interopRequireDefault(require("./util/missing-plugin-helper"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var debug = (0, _debug().default)("babel:transform:file");

function normalizeFile(pluginPasses, options, code, ast) {
  code = "".concat(code || "");

  if (ast) {
    if (ast.type === "Program") {
      ast = t().file(ast, [], []);
    } else if (ast.type !== "File") {
      throw new Error("AST root must be a Program or File node");
    }

    ast = (0, _cloneDeep().default)(ast);
  } else {
    ast = parser(pluginPasses, options, code);
  }

  var inputMap = null;

  if (options.inputSourceMap !== false) {
    if (_typeof(options.inputSourceMap) === "object") {
      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);
    }

    if (!inputMap) {
      var lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

      if (lastComment) {
        try {
          inputMap = _convertSourceMap().default.fromComment(lastComment);
        } catch (err) {
          debug("discarding unknown inline input sourcemap", err);
        }
      }
    }

    if (!inputMap) {
      var _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

      if (typeof options.filename === "string" && _lastComment) {
        try {
          inputMap = _convertSourceMap().default.fromMapFileComment("//".concat(_lastComment), _path().default.dirname(options.filename));
        } catch (err) {
          debug("discarding unknown file input sourcemap", err);
        }
      } else if (_lastComment) {
        debug("discarding un-loadable file input sourcemap");
      }
    }
  }

  return new _file.default(options, {
    code: code,
    ast: ast,
    inputMap: inputMap
  });
}

function parser(pluginPasses, _ref, code) {
  var parserOpts = _ref.parserOpts,
      _ref$highlightCode = _ref.highlightCode,
      highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode,
      _ref$filename = _ref.filename,
      filename = _ref$filename === void 0 ? "unknown" : _ref$filename;

  try {
    var results = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var plugins = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var plugin = _step2.value;
            var parserOverride = plugin.parserOverride;

            if (parserOverride) {
              var ast = parserOverride(code, parserOpts, _parser().parse);
              if (ast !== undefined) results.push(ast);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (results.length === 0) {
      return (0, _parser().parse)(code, parserOpts);
    } else if (results.length === 1) {
      if (typeof results[0].then === "function") {
        throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
      }

      return results[0];
    }

    throw new Error("More than one plugin attempted to override parsing.");
  } catch (err) {
    if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
      err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
    }

    var loc = err.loc,
        missingPlugin = err.missingPlugin;

    if (loc) {
      var codeFrame = (0, _codeFrame().codeFrameColumns)(code, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      }, {
        highlightCode: highlightCode
      });

      if (missingPlugin) {
        err.message = "".concat(filename, ": ") + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);
      } else {
        err.message = "".concat(filename, ": ").concat(err.message, "\n\n") + codeFrame;
      }

      err.code = "BABEL_PARSE_ERROR";
    }

    throw err;
  }
}

var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=(?:[^\s'"`]+?)[ \t]*$/;

function extractCommentsFromList(regex, comments, lastComment) {
  if (comments) {
    comments = comments.filter(function (_ref2) {
      var value = _ref2.value;

      if (regex.test(value)) {
        lastComment = value;
        return false;
      }

      return true;
    });
  }

  return [comments, lastComment];
}

function extractComments(regex, ast) {
  var lastComment = null;
  t().traverseFast(ast, function (node) {
    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);

    node.leadingComments = _extractCommentsFromL2[0];
    lastComment = _extractCommentsFromL2[1];

    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);

    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);

    node.innerComments = _extractCommentsFromL4[0];
    lastComment = _extractCommentsFromL4[1];

    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);

    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);

    node.trailingComments = _extractCommentsFromL6[0];
    lastComment = _extractCommentsFromL6[1];
  });
  return lastComment;
}

},{"./file/file":26,"./util/missing-plugin-helper":33,"@babel/code-frame":1,"@babel/parser":89,"@babel/types":242,"convert-source-map":302,"debug":34,"lodash/cloneDeep":1005,"path":1052}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeOptions;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function normalizeOptions(config) {
  var _config$options = config.options,
      filename = _config$options.filename,
      cwd = _config$options.cwd,
      _config$options$filen = _config$options.filenameRelative,
      filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? _path().default.relative(cwd, filename) : "unknown" : _config$options$filen,
      _config$options$sourc = _config$options.sourceType,
      sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
      inputSourceMap = _config$options.inputSourceMap,
      _config$options$sourc2 = _config$options.sourceMaps,
      sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
      moduleRoot = _config$options.moduleRoot,
      _config$options$sourc3 = _config$options.sourceRoot,
      sourceRoot = _config$options$sourc3 === void 0 ? moduleRoot : _config$options$sourc3,
      _config$options$sourc4 = _config$options.sourceFileName,
      sourceFileName = _config$options$sourc4 === void 0 ? _path().default.basename(filenameRelative) : _config$options$sourc4,
      _config$options$comme = _config$options.comments,
      comments = _config$options$comme === void 0 ? true : _config$options$comme,
      _config$options$compa = _config$options.compact,
      compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
  var opts = config.options;
  var options = Object.assign({}, opts, {
    parserOpts: Object.assign({
      sourceType: _path().default.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
      sourceFileName: filename,
      plugins: []
    }, opts.parserOpts),
    generatorOpts: Object.assign({
      filename: filename,
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      retainLines: opts.retainLines,
      comments: comments,
      shouldPrintComment: opts.shouldPrintComment,
      compact: compact,
      minified: opts.minified,
      sourceMaps: sourceMaps,
      sourceRoot: sourceRoot,
      sourceFileName: sourceFileName
    }, opts.generatorOpts)
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = config.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var plugins = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var plugin = _step2.value;

          if (plugin.manipulateOptions) {
            plugin.manipulateOptions(options, options.parserOpts);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return options;
}

},{"path":1052}],32:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var PluginPass =
/*#__PURE__*/
function () {
  function PluginPass(file, key, options) {
    _classCallCheck(this, PluginPass);

    this._map = new Map();
    this.key = key;
    this.file = file;
    this.opts = options || {};
    this.cwd = file.opts.cwd;
    this.filename = file.opts.filename;
  }

  _createClass(PluginPass, [{
    key: "set",
    value: function set(key, val) {
      this._map.set(key, val);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._map.get(key);
    }
  }, {
    key: "availableHelper",
    value: function availableHelper(name, versionRange) {
      return this.file.availableHelper(name, versionRange);
    }
  }, {
    key: "addHelper",
    value: function addHelper(name) {
      return this.file.addHelper(name);
    }
  }, {
    key: "addImport",
    value: function addImport() {
      return this.file.addImport();
    }
  }, {
    key: "getModuleName",
    value: function getModuleName() {
      return this.file.getModuleName();
    }
  }, {
    key: "buildCodeFrameError",
    value: function buildCodeFrameError(node, msg, Error) {
      return this.file.buildCodeFrameError(node, msg, Error);
    }
  }]);

  return PluginPass;
}();

exports.default = PluginPass;

},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateMissingPluginMessage;
var pluginNameMap = {
  classProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://git.io/vb4yQ"
    },
    transform: {
      name: "@babel/plugin-proposal-class-properties",
      url: "https://git.io/vb4SL"
    }
  },
  decorators: {
    syntax: {
      name: "@babel/plugin-syntax-decorators",
      url: "https://git.io/vb4y9"
    },
    transform: {
      name: "@babel/plugin-proposal-decorators",
      url: "https://git.io/vb4ST"
    }
  },
  doExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-do-expressions",
      url: "https://git.io/vb4yh"
    },
    transform: {
      name: "@babel/plugin-proposal-do-expressions",
      url: "https://git.io/vb4S3"
    }
  },
  dynamicImport: {
    syntax: {
      name: "@babel/plugin-syntax-dynamic-import",
      url: "https://git.io/vb4Sv"
    }
  },
  exportDefaultFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-default-from",
      url: "https://git.io/vb4SO"
    },
    transform: {
      name: "@babel/plugin-proposal-export-default-from",
      url: "https://git.io/vb4yH"
    }
  },
  exportNamespaceFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-namespace-from",
      url: "https://git.io/vb4Sf"
    },
    transform: {
      name: "@babel/plugin-proposal-export-namespace-from",
      url: "https://git.io/vb4SG"
    }
  },
  flow: {
    syntax: {
      name: "@babel/plugin-syntax-flow",
      url: "https://git.io/vb4yb"
    },
    transform: {
      name: "@babel/plugin-transform-flow-strip-types",
      url: "https://git.io/vb49g"
    }
  },
  functionBind: {
    syntax: {
      name: "@babel/plugin-syntax-function-bind",
      url: "https://git.io/vb4y7"
    },
    transform: {
      name: "@babel/plugin-proposal-function-bind",
      url: "https://git.io/vb4St"
    }
  },
  functionSent: {
    syntax: {
      name: "@babel/plugin-syntax-function-sent",
      url: "https://git.io/vb4yN"
    },
    transform: {
      name: "@babel/plugin-proposal-function-sent",
      url: "https://git.io/vb4SZ"
    }
  },
  importMeta: {
    syntax: {
      name: "@babel/plugin-syntax-import-meta",
      url: "https://git.io/vbKK6"
    }
  },
  jsx: {
    syntax: {
      name: "@babel/plugin-syntax-jsx",
      url: "https://git.io/vb4yA"
    },
    transform: {
      name: "@babel/plugin-transform-react-jsx",
      url: "https://git.io/vb4yd"
    }
  },
  logicalAssignment: {
    syntax: {
      name: "@babel/plugin-syntax-logical-assignment-operators",
      url: "https://git.io/vAlBp"
    },
    transform: {
      name: "@babel/plugin-proposal-logical-assignment-operators",
      url: "https://git.io/vAlRe"
    }
  },
  nullishCoalescingOperator: {
    syntax: {
      name: "@babel/plugin-syntax-nullish-coalescing-operator",
      url: "https://git.io/vb4yx"
    },
    transform: {
      name: "@babel/plugin-proposal-nullish-coalescing-operator",
      url: "https://git.io/vb4Se"
    }
  },
  numericSeparator: {
    syntax: {
      name: "@babel/plugin-syntax-numeric-separator",
      url: "https://git.io/vb4Sq"
    },
    transform: {
      name: "@babel/plugin-proposal-numeric-separator",
      url: "https://git.io/vb4yS"
    }
  },
  optionalChaining: {
    syntax: {
      name: "@babel/plugin-syntax-optional-chaining",
      url: "https://git.io/vb4Sc"
    },
    transform: {
      name: "@babel/plugin-proposal-optional-chaining",
      url: "https://git.io/vb4Sk"
    }
  },
  pipelineOperator: {
    syntax: {
      name: "@babel/plugin-syntax-pipeline-operator",
      url: "https://git.io/vb4yj"
    },
    transform: {
      name: "@babel/plugin-proposal-pipeline-operator",
      url: "https://git.io/vb4SU"
    }
  },
  throwExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-throw-expressions",
      url: "https://git.io/vb4SJ"
    },
    transform: {
      name: "@babel/plugin-proposal-throw-expressions",
      url: "https://git.io/vb4yF"
    }
  },
  typescript: {
    syntax: {
      name: "@babel/plugin-syntax-typescript",
      url: "https://git.io/vb4SC"
    },
    transform: {
      name: "@babel/plugin-transform-typescript",
      url: "https://git.io/vb4Sm"
    }
  },
  asyncGenerators: {
    syntax: {
      name: "@babel/plugin-syntax-async-generators",
      url: "https://git.io/vb4SY"
    },
    transform: {
      name: "@babel/plugin-proposal-async-generator-functions",
      url: "https://git.io/vb4yp"
    }
  },
  objectRestSpread: {
    syntax: {
      name: "@babel/plugin-syntax-object-rest-spread",
      url: "https://git.io/vb4y5"
    },
    transform: {
      name: "@babel/plugin-proposal-object-rest-spread",
      url: "https://git.io/vb4Ss"
    }
  },
  optionalCatchBinding: {
    syntax: {
      name: "@babel/plugin-syntax-optional-catch-binding",
      url: "https://git.io/vb4Sn"
    },
    transform: {
      name: "@babel/plugin-proposal-optional-catch-binding",
      url: "https://git.io/vb4SI"
    }
  }
};

var getNameURLCombination = function getNameURLCombination(_ref) {
  var name = _ref.name,
      url = _ref.url;
  return "".concat(name, " (").concat(url, ")");
};

function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
  var helpMessage = "Support for the experimental syntax '".concat(missingPluginName, "' isn't currently enabled ") + "(".concat(loc.line, ":").concat(loc.column + 1, "):\n\n") + codeFrame;
  var pluginInfo = pluginNameMap[missingPluginName];

  if (pluginInfo) {
    var syntaxPlugin = pluginInfo.syntax,
        transformPlugin = pluginInfo.transform;

    if (syntaxPlugin) {
      if (transformPlugin) {
        var transformPluginInfo = getNameURLCombination(transformPlugin);
        helpMessage += "\n\nAdd ".concat(transformPluginInfo, " to the 'plugins' section of your Babel config ") + "to enable transformation.";
      } else {
        var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
        helpMessage += "\n\nAdd ".concat(syntaxPluginInfo, " to the 'plugins' section of your Babel config ") + "to enable parsing.";
      }
    }
  }

  return helpMessage;
}

},{}],34:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this,require('_process'))
},{"./common":35,"_process":1054}],35:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

},{"ms":36}],36:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],37:[function(require,module,exports){
module.exports={
  "_from": "@babel/core@*",
  "_id": "@babel/core@7.7.2",
  "_inBundle": false,
  "_integrity": "sha512-eeD7VEZKfhK1KUXGiyPFettgF3m513f8FoBSWiQ1xTvl1RAopLs42Wp9+Ze911I6H0N9lNqJMDgoZT7gHsipeQ==",
  "_location": "/@babel/core",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "@babel/core@*",
    "name": "@babel/core",
    "escapedName": "@babel%2fcore",
    "scope": "@babel",
    "rawSpec": "*",
    "saveSpec": null,
    "fetchSpec": "*"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/@babel/core/-/core-7.7.2.tgz",
  "_shasum": "ea5b99693bcfc058116f42fa1dd54da412b29d91",
  "_spec": "@babel/core@*",
  "_where": "/local/home/ossman/devel/noVNC",
  "author": {
    "name": "Sebastian McKenzie",
    "email": "sebmck@gmail.com"
  },
  "browser": {
    "./lib/config/files/index.js": "./lib/config/files/index-browser.js",
    "./lib/transform-file.js": "./lib/transform-file-browser.js"
  },
  "bundleDependencies": false,
  "dependencies": {
    "@babel/code-frame": "^7.5.5",
    "@babel/generator": "^7.7.2",
    "@babel/helpers": "^7.7.0",
    "@babel/parser": "^7.7.2",
    "@babel/template": "^7.7.0",
    "@babel/traverse": "^7.7.2",
    "@babel/types": "^7.7.2",
    "convert-source-map": "^1.7.0",
    "debug": "^4.1.0",
    "json5": "^2.1.0",
    "lodash": "^4.17.13",
    "resolve": "^1.3.2",
    "semver": "^5.4.1",
    "source-map": "^0.5.0"
  },
  "deprecated": false,
  "description": "Babel compiler core.",
  "devDependencies": {
    "@babel/helper-transform-fixture-test-runner": "^7.6.4"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "gitHead": "35f4d1276310bac6fede4a6f86a5c76f951e179e",
  "homepage": "https://babeljs.io/",
  "keywords": [
    "6to5",
    "babel",
    "classes",
    "const",
    "es6",
    "harmony",
    "let",
    "modules",
    "transpile",
    "transpiler",
    "var",
    "babel-core",
    "compiler"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "@babel/core",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel/tree/master/packages/babel-core"
  },
  "version": "7.7.2"
}

},{}],38:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var SPACES_RE = /^[ \t]+$/;

var Buffer =
/*#__PURE__*/
function () {
  function Buffer(map) {
    _classCallCheck(this, Buffer);

    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null
    };
    this._disallowedPop = null;
    this._map = map;
  }

  _createClass(Buffer, [{
    key: "get",
    value: function get() {
      this._flush();

      var map = this._map;
      var result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: map && map.getRawMappings()
      };

      if (map) {
        Object.defineProperty(result, "map", {
          configurable: true,
          enumerable: true,
          get: function get() {
            return this.map = map.get();
          },
          set: function set(value) {
            Object.defineProperty(this, "map", {
              value: value,
              writable: true
            });
          }
        });
      }

      return result;
    }
  }, {
    key: "append",
    value: function append(str) {
      this._flush();

      var _this$_sourcePosition = this._sourcePosition,
          line = _this$_sourcePosition.line,
          column = _this$_sourcePosition.column,
          filename = _this$_sourcePosition.filename,
          identifierName = _this$_sourcePosition.identifierName,
          force = _this$_sourcePosition.force;

      this._append(str, line, column, identifierName, filename, force);
    }
  }, {
    key: "queue",
    value: function queue(str) {
      if (str === "\n") {
        while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      var _this$_sourcePosition2 = this._sourcePosition,
          line = _this$_sourcePosition2.line,
          column = _this$_sourcePosition2.column,
          filename = _this$_sourcePosition2.filename,
          identifierName = _this$_sourcePosition2.identifierName,
          force = _this$_sourcePosition2.force;

      this._queue.unshift([str, line, column, identifierName, filename, force]);
    }
  }, {
    key: "_flush",
    value: function _flush() {
      var item;

      while (item = this._queue.pop()) {
        this._append.apply(this, _toConsumableArray(item));
      }
    }
  }, {
    key: "_append",
    value: function _append(str, line, column, identifierName, filename, force) {
      if (this._map && str[0] !== "\n") {
        this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
      }

      this._buf.push(str);

      this._last = str[str.length - 1];

      for (var i = 0; i < str.length; i++) {
        if (str[i] === "\n") {
          this._position.line++;
          this._position.column = 0;
        } else {
          this._position.column++;
        }
      }
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === "\n") {
        this._queue.shift();
      }
    }
  }, {
    key: "removeLastSemicolon",
    value: function removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ";") {
        this._queue.shift();
      }
    }
  }, {
    key: "endsWith",
    value: function endsWith(suffix) {
      if (suffix.length === 1) {
        var last;

        if (this._queue.length > 0) {
          var str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this._last;
        }

        return last === suffix;
      }

      var end = this._last + this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    }
  }, {
    key: "hasContent",
    value: function hasContent() {
      return this._queue.length > 0 || !!this._last;
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      this.source("start", loc, true);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    }
  }, {
    key: "source",
    value: function source(prop, loc, force) {
      if (prop && !loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition, force);
    }
  }, {
    key: "withSource",
    value: function withSource(prop, loc, cb) {
      if (!this._map) return cb();
      var originalLine = this._sourcePosition.line;
      var originalColumn = this._sourcePosition.column;
      var originalFilename = this._sourcePosition.filename;
      var originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._sourcePosition.force = false;
        this._disallowedPop = null;
      }
    }
  }, {
    key: "_disallowPop",
    value: function _disallowPop(prop, loc) {
      if (prop && !loc) return;
      this._disallowedPop = this._normalizePosition(prop, loc);
    }
  }, {
    key: "_normalizePosition",
    value: function _normalizePosition(prop, loc, targetObj, force) {
      var pos = loc ? loc[prop] : null;

      if (targetObj === undefined) {
        targetObj = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
          force: false
        };
      }

      var origLine = targetObj.line;
      var origColumn = targetObj.column;
      var origFilename = targetObj.filename;
      targetObj.identifierName = prop === "start" && loc && loc.identifierName || null;
      targetObj.line = pos ? pos.line : null;
      targetObj.column = pos ? pos.column : null;
      targetObj.filename = loc && loc.filename || null;

      if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
        targetObj.force = force;
      }

      return targetObj;
    }
  }, {
    key: "getCurrentColumn",
    value: function getCurrentColumn() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var lastIndex = extra.lastIndexOf("\n");
      return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    }
  }, {
    key: "getCurrentLine",
    value: function getCurrentLine() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var count = 0;

      for (var i = 0; i < extra.length; i++) {
        if (extra[i] === "\n") count++;
      }

      return this._position.line + count;
    }
  }]);

  return Buffer;
}();

exports.default = Buffer;

},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.File = File;
exports.Program = Program;
exports.BlockStatement = BlockStatement;
exports.Noop = Noop;
exports.Directive = Directive;
exports.DirectiveLiteral = DirectiveLiteral;
exports.InterpreterDirective = InterpreterDirective;
exports.Placeholder = Placeholder;

function File(node) {
  if (node.program) {
    this.print(node.program.interpreter, node);
  }

  this.print(node.program, node);
}

function Program(node) {
  this.printInnerComments(node, false);
  this.printSequence(node.directives, node);
  if (node.directives && node.directives.length) this.newline();
  this.printSequence(node.body, node);
}

function BlockStatement(node) {
  this.token("{");
  this.printInnerComments(node);
  var hasDirectives = node.directives && node.directives.length;

  if (node.body.length || hasDirectives) {
    this.newline();
    this.printSequence(node.directives, node, {
      indent: true
    });
    if (hasDirectives) this.newline();
    this.printSequence(node.body, node, {
      indent: true
    });
    this.removeTrailingNewline();
    this.source("end", node.loc);
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  } else {
    this.source("end", node.loc);
    this.token("}");
  }
}

function Noop() {}

function Directive(node) {
  this.print(node.value, node);
  this.semicolon();
}

var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

function DirectiveLiteral(node) {
  var raw = this.getPossibleRaw(node);

  if (raw != null) {
    this.token(raw);
    return;
  }

  var value = node.value;

  if (!unescapedDoubleQuoteRE.test(value)) {
    this.token("\"".concat(value, "\""));
  } else if (!unescapedSingleQuoteRE.test(value)) {
    this.token("'".concat(value, "'"));
  } else {
    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
  }
}

function InterpreterDirective(node) {
  this.token("#!".concat(node.value, "\n"));
}

function Placeholder(node) {
  this.token("%%");
  this.print(node.name);
  this.token("%%");

  if (node.expectedNode === "Statement") {
    this.semicolon();
  }
}

},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
exports.ClassBody = ClassBody;
exports.ClassProperty = ClassProperty;
exports.ClassPrivateProperty = ClassPrivateProperty;
exports.ClassMethod = ClassMethod;
exports.ClassPrivateMethod = ClassPrivateMethod;
exports._classMethodHead = _classMethodHead;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function ClassDeclaration(node, parent) {
  if (!this.format.decoratorsBeforeExport || !t.isExportDefaultDeclaration(parent) && !t.isExportNamedDeclaration(parent)) {
    this.printJoin(node.decorators, node);
  }

  if (node.declare) {
    this.word("declare");
    this.space();
  }

  if (node.abstract) {
    this.word("abstract");
    this.space();
  }

  this.word("class");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  }

  this.print(node.typeParameters, node);

  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }

  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

function ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);

  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();
    this.indent();
    this.printSequence(node.body, node);
    this.dedent();
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  }
}

function ClassProperty(node) {
  this.printJoin(node.decorators, node);
  this.tsPrintClassMemberModifiers(node, true);

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);

    this.print(node.key, node);
  }

  if (node.optional) {
    this.token("?");
  }

  if (node.definite) {
    this.token("!");
  }

  this.print(node.typeAnnotation, node);

  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }

  this.semicolon();
}

function ClassPrivateProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.print(node.key, node);
  this.print(node.typeAnnotation, node);

  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }

  this.semicolon();
}

function ClassMethod(node) {
  this._classMethodHead(node);

  this.space();
  this.print(node.body, node);
}

function ClassPrivateMethod(node) {
  this._classMethodHead(node);

  this.space();
  this.print(node.body, node);
}

function _classMethodHead(node) {
  this.printJoin(node.decorators, node);
  this.tsPrintClassMemberModifiers(node, false);

  this._methodHead(node);
}

},{"@babel/types":242}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnaryExpression = UnaryExpression;
exports.DoExpression = DoExpression;
exports.ParenthesizedExpression = ParenthesizedExpression;
exports.UpdateExpression = UpdateExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.NewExpression = NewExpression;
exports.SequenceExpression = SequenceExpression;
exports.ThisExpression = ThisExpression;
exports.Super = Super;
exports.Decorator = Decorator;
exports.OptionalMemberExpression = OptionalMemberExpression;
exports.OptionalCallExpression = OptionalCallExpression;
exports.CallExpression = CallExpression;
exports.Import = Import;
exports.EmptyStatement = EmptyStatement;
exports.ExpressionStatement = ExpressionStatement;
exports.AssignmentPattern = AssignmentPattern;
exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
exports.BindExpression = BindExpression;
exports.MemberExpression = MemberExpression;
exports.MetaProperty = MetaProperty;
exports.PrivateName = PrivateName;
exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
exports.AwaitExpression = exports.YieldExpression = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var n = _interopRequireWildcard(require("../node"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function UnaryExpression(node) {
  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }

  this.print(node.argument, node);
}

function DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}

function ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}

function UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.startTerminatorless(true);
    this.print(node.argument, node);
    this.endTerminatorless();
    this.token(node.operator);
  }
}

function ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}

function NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);

  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t.isCallExpression(parent, {
    callee: node
  }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) {
    return;
  }

  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);

  if (node.optional) {
    this.token("?.");
  }

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function SequenceExpression(node) {
  this.printList(node.expressions, node);
}

function ThisExpression() {
  this.word("this");
}

function Super() {
  this.word("super");
}

function Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}

function OptionalMemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;

  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }

  if (node.optional) {
    this.token("?.");
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    if (!node.optional) {
      this.token(".");
    }

    this.print(node.property, node);
  }
}

function OptionalCallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);

  if (node.optional) {
    this.token("?.");
  }

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function CallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function Import() {
  this.word("import");
}

function buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);

    if (node.delegate) {
      this.token("*");
    }

    if (node.argument) {
      this.space();
      var terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}

var YieldExpression = buildYieldAwait("yield");
exports.YieldExpression = YieldExpression;
var AwaitExpression = buildYieldAwait("await");
exports.AwaitExpression = AwaitExpression;

function EmptyStatement() {
  this.semicolon(true);
}

function ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}

function AssignmentPattern(node) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}

function AssignmentExpression(node, parent) {
  var parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);

  if (parens) {
    this.token("(");
  }

  this.print(node.left, node);
  this.space();

  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }

  this.space();
  this.print(node.right, node);

  if (parens) {
    this.token(")");
  }
}

function BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}

function MemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;

  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}

function MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}

function PrivateName(node) {
  this.token("#");
  this.print(node.id, node);
}

function V8IntrinsicIdentifier(node) {
  this.token("%");
  this.word(node.name);
}

},{"../node":52,"@babel/types":242}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareFunction = DeclareFunction;
exports.InferredPredicate = InferredPredicate;
exports.DeclaredPredicate = DeclaredPredicate;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareVariable = DeclareVariable;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.EnumDeclaration = EnumDeclaration;
exports.EnumBooleanBody = EnumBooleanBody;
exports.EnumNumberBody = EnumNumberBody;
exports.EnumStringBody = EnumStringBody;
exports.EnumSymbolBody = EnumSymbolBody;
exports.EnumDefaultedMember = EnumDefaultedMember;
exports.EnumBooleanMember = EnumBooleanMember;
exports.EnumNumberMember = EnumNumberMember;
exports.EnumStringMember = EnumStringMember;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypeParameter = TypeParameter;
exports.OpaqueType = OpaqueType;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _types2.NumericLiteral;
  }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _types2.StringLiteral;
  }
});

var t = _interopRequireWildcard(require("@babel/types"));

var _modules = require("./modules");

var _types2 = require("./types");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function AnyTypeAnnotation() {
  this.word("any");
}

function ArrayTypeAnnotation(node) {
  this.print(node.elementType, node);
  this.token("[");
  this.token("]");
}

function BooleanTypeAnnotation() {
  this.word("boolean");
}

function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteralTypeAnnotation() {
  this.word("null");
}

function DeclareClass(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("class");
  this.space();

  this._interfaceish(node);
}

function DeclareFunction(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);

  if (node.predicate) {
    this.space();
    this.print(node.predicate, node);
  }

  this.semicolon();
}

function InferredPredicate() {
  this.token("%");
  this.word("checks");
}

function DeclaredPredicate(node) {
  this.token("%");
  this.word("checks");
  this.token("(");
  this.print(node.value, node);
  this.token(")");
}

function DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}

function DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}

function DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.token(".");
  this.word("exports");
  this.print(node.typeAnnotation, node);
}

function DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}

function DeclareOpaqueType(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.OpaqueType(node);
}

function DeclareVariable(node, parent) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}

function DeclareExportDeclaration(node) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();

  if (node.default) {
    this.word("default");
    this.space();
  }

  FlowExportDeclaration.apply(this, arguments);
}

function DeclareExportAllDeclaration() {
  this.word("declare");
  this.space();

  _modules.ExportAllDeclaration.apply(this, arguments);
}

function EnumDeclaration(node) {
  var id = node.id,
      body = node.body;
  this.word("enum");
  this.space();
  this.print(id, node);
  this.print(body, node);
}

function enumExplicitType(context, name, hasExplicitType) {
  if (hasExplicitType) {
    context.space();
    context.word("of");
    context.space();
    context.word(name);
  }

  context.space();
}

function enumBody(context, node) {
  var members = node.members;
  context.token("{");
  context.indent();
  context.newline();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var member = _step.value;
      context.print(member, node);
      context.newline();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  context.dedent();
  context.token("}");
}

function EnumBooleanBody(node) {
  var explicitType = node.explicitType;
  enumExplicitType(this, "boolean", explicitType);
  enumBody(this, node);
}

function EnumNumberBody(node) {
  var explicitType = node.explicitType;
  enumExplicitType(this, "number", explicitType);
  enumBody(this, node);
}

function EnumStringBody(node) {
  var explicitType = node.explicitType;
  enumExplicitType(this, "string", explicitType);
  enumBody(this, node);
}

function EnumSymbolBody(node) {
  enumExplicitType(this, "symbol", true);
  enumBody(this, node);
}

function EnumDefaultedMember(node) {
  var id = node.id;
  this.print(id, node);
  this.token(",");
}

function enumInitializedMember(context, node) {
  var id = node.id,
      init = node.init;
  context.print(id, node);
  context.space();
  context.token("=");
  context.space();
  context.print(init, node);
  context.token(",");
}

function EnumBooleanMember(node) {
  enumInitializedMember(this, node);
}

function EnumNumberMember(node) {
  enumInitializedMember(this, node);
}

function EnumStringMember(node) {
  enumInitializedMember(this, node);
}

function FlowExportDeclaration(node) {
  if (node.declaration) {
    var declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    this.token("{");

    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers, node);
      this.space();
    }

    this.token("}");

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ExistsTypeAnnotation() {
  this.token("*");
}

function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node);

  if (node.rest) {
    if (node.params.length) {
      this.token(",");
      this.space();
    }

    this.token("...");
    this.print(node.rest, node);
  }

  this.token(")");

  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
    this.token(":");
  } else {
    this.space();
    this.token("=>");
  }

  this.space();
  this.print(node.returnType, node);
}

function FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.token("?");

  if (node.name) {
    this.token(":");
    this.space();
  }

  this.print(node.typeAnnotation, node);
}

function InterfaceExtends(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
}

function _interfaceish(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);

  if (node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }

  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }

  if (node.implements && node.implements.length) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

function _variance(node) {
  if (node.variance) {
    if (node.variance.kind === "plus") {
      this.token("+");
    } else if (node.variance.kind === "minus") {
      this.token("-");
    }
  }
}

function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();

  this._interfaceish(node);
}

function andSeparator() {
  this.space();
  this.token("&");
  this.space();
}

function InterfaceTypeAnnotation(node) {
  this.word("interface");

  if (node.extends && node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }

  this.space();
  this.print(node.body, node);
}

function IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: andSeparator
  });
}

function MixedTypeAnnotation() {
  this.word("mixed");
}

function EmptyTypeAnnotation() {
  this.word("empty");
}

function NullableTypeAnnotation(node) {
  this.token("?");
  this.print(node.typeAnnotation, node);
}

function NumberTypeAnnotation() {
  this.word("number");
}

function StringTypeAnnotation() {
  this.word("string");
}

function ThisTypeAnnotation() {
  this.word("this");
}

function TupleTypeAnnotation(node) {
  this.token("[");
  this.printList(node.types, node);
  this.token("]");
}

function TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}

function TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
  this.semicolon();
}

function TypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function TypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

function TypeParameter(node) {
  this._variance(node);

  this.word(node.name);

  if (node.bound) {
    this.print(node.bound, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function OpaqueType(node) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);

  if (node.supertype) {
    this.token(":");
    this.space();
    this.print(node.supertype, node);
  }

  if (node.impltype) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.impltype, node);
  }

  this.semicolon();
}

function ObjectTypeAnnotation(node) {
  var _this = this;

  if (node.exact) {
    this.token("{|");
  } else {
    this.token("{");
  }

  var props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

  if (props.length) {
    this.space();
    this.printJoin(props, node, {
      addNewlines: function addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },
      indent: true,
      statement: true,
      iterator: function iterator() {
        if (props.length !== 1 || node.inexact) {
          _this.token(",");

          _this.space();
        }
      }
    });
    this.space();
  }

  if (node.inexact) {
    this.indent();
    this.token("...");

    if (props.length) {
      this.newline();
    }

    this.dedent();
  }

  if (node.exact) {
    this.token("|}");
  } else {
    this.token("}");
  }
}

function ObjectTypeInternalSlot(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.token("[");
  this.token("[");
  this.print(node.id, node);
  this.token("]");
  this.token("]");
  if (node.optional) this.token("?");

  if (!node.method) {
    this.token(":");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this._variance(node);

  this.token("[");

  if (node.id) {
    this.print(node.id, node);
    this.token(":");
    this.space();
  }

  this.print(node.key, node);
  this.token("]");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ObjectTypeProperty(node) {
  if (node.proto) {
    this.word("proto");
    this.space();
  }

  if (node.static) {
    this.word("static");
    this.space();
  }

  this._variance(node);

  this.print(node.key, node);
  if (node.optional) this.token("?");

  if (!node.method) {
    this.token(":");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeSpreadProperty(node) {
  this.token("...");
  this.print(node.argument, node);
}

function QualifiedTypeIdentifier(node) {
  this.print(node.qualification, node);
  this.token(".");
  this.print(node.id, node);
}

function orSeparator() {
  this.space();
  this.token("|");
  this.space();
}

function UnionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: orSeparator
  });
}

function TypeCastExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function Variance(node) {
  if (node.kind === "plus") {
    this.token("+");
  } else {
    this.token("-");
  }
}

function VoidTypeAnnotation() {
  this.word("void");
}

},{"./modules":46,"./types":49,"@babel/types":242}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templateLiterals = require("./template-literals");

Object.keys(_templateLiterals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _templateLiterals[key];
    }
  });
});

var _expressions = require("./expressions");

Object.keys(_expressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _expressions[key];
    }
  });
});

var _statements = require("./statements");

Object.keys(_statements).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _statements[key];
    }
  });
});

var _classes = require("./classes");

Object.keys(_classes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _classes[key];
    }
  });
});

var _methods = require("./methods");

Object.keys(_methods).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _methods[key];
    }
  });
});

var _modules = require("./modules");

Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _modules[key];
    }
  });
});

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _flow = require("./flow");

Object.keys(_flow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _flow[key];
    }
  });
});

var _base = require("./base");

Object.keys(_base).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _base[key];
    }
  });
});

var _jsx = require("./jsx");

Object.keys(_jsx).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _jsx[key];
    }
  });
});

var _typescript = require("./typescript");

Object.keys(_typescript).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _typescript[key];
    }
  });
});

},{"./base":39,"./classes":40,"./expressions":41,"./flow":42,"./jsx":44,"./methods":45,"./modules":46,"./statements":47,"./template-literals":48,"./types":49,"./typescript":50}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSXAttribute = JSXAttribute;
exports.JSXIdentifier = JSXIdentifier;
exports.JSXNamespacedName = JSXNamespacedName;
exports.JSXMemberExpression = JSXMemberExpression;
exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.JSXExpressionContainer = JSXExpressionContainer;
exports.JSXSpreadChild = JSXSpreadChild;
exports.JSXText = JSXText;
exports.JSXElement = JSXElement;
exports.JSXOpeningElement = JSXOpeningElement;
exports.JSXClosingElement = JSXClosingElement;
exports.JSXEmptyExpression = JSXEmptyExpression;
exports.JSXFragment = JSXFragment;
exports.JSXOpeningFragment = JSXOpeningFragment;
exports.JSXClosingFragment = JSXClosingFragment;

function JSXAttribute(node) {
  this.print(node.name, node);

  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}

function JSXIdentifier(node) {
  this.word(node.name);
}

function JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}

function JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}

function JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}

function JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}

function JSXSpreadChild(node) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}

function JSXText(node) {
  var raw = this.getPossibleRaw(node);

  if (raw != null) {
    this.token(raw);
  } else {
    this.token(node.value);
  }
}

function JSXElement(node) {
  var open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;
  this.indent();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var child = _step.value;
      this.print(child, node);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  this.dedent();
  this.print(node.closingElement, node);
}

function spaceSeparator() {
  this.space();
}

function JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  this.print(node.typeParameters, node);

  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, {
      separator: spaceSeparator
    });
  }

  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}

function JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}

function JSXEmptyExpression(node) {
  this.printInnerComments(node);
}

function JSXFragment(node) {
  this.print(node.openingFragment, node);
  this.indent();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var child = _step2.value;
      this.print(child, node);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  this.dedent();
  this.print(node.closingFragment, node);
}

function JSXOpeningFragment() {
  this.token("<");
  this.token(">");
}

function JSXClosingFragment() {
  this.token("</");
  this.token(">");
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._params = _params;
exports._parameters = _parameters;
exports._param = _param;
exports._methodHead = _methodHead;
exports._predicate = _predicate;
exports._functionHead = _functionHead;
exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _params(node) {
  this.print(node.typeParameters, node);
  this.token("(");

  this._parameters(node.params, node);

  this.token(")");
  this.print(node.returnType, node);
}

function _parameters(parameters, parent) {
  for (var i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent);

    if (i < parameters.length - 1) {
      this.token(",");
      this.space();
    }
  }
}

function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter);
  this.print(parameter, parent);
  if (parameter.optional) this.token("?");
  this.print(parameter.typeAnnotation, parameter);
}

function _methodHead(node) {
  var kind = node.kind;
  var key = node.key;

  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }

  if (node.async) {
    this.word("async");
    this.space();
  }

  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }

  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }

  if (node.optional) {
    this.token("?");
  }

  this._params(node);
}

function _predicate(node) {
  if (node.predicate) {
    if (!node.returnType) {
      this.token(":");
    }

    this.space();
    this.print(node.predicate, node);
  }
}

function _functionHead(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  this.word("function");
  if (node.generator) this.token("*");
  this.space();

  if (node.id) {
    this.print(node.id, node);
  }

  this._params(node);

  this._predicate(node);
}

function FunctionExpression(node) {
  this._functionHead(node);

  this.space();
  this.print(node.body, node);
}

function ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  var firstParam = node.params[0];

  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
    if (this.format.retainLines && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {
      this.token("(");

      if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
        this.indent();
        this.print(firstParam, node);
        this.dedent();

        this._catchUp("start", node.body.loc);
      } else {
        this.print(firstParam, node);
      }

      this.token(")");
    } else {
      this.print(firstParam, node);
    }
  } else {
    this._params(node);
  }

  this._predicate(node);

  this.space();
  this.token("=>");
  this.space();
  this.print(node.body, node);
}

function hasTypes(node, param) {
  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
}

},{"@babel/types":242}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImportSpecifier = ImportSpecifier;
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
exports.ExportSpecifier = ExportSpecifier;
exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
exports.ExportAllDeclaration = ExportAllDeclaration;
exports.ExportNamedDeclaration = ExportNamedDeclaration;
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.ImportDeclaration = ImportDeclaration;
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function ImportSpecifier(node) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  this.print(node.imported, node);

  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}

function ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}

function ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}

function ExportSpecifier(node) {
  this.print(node.local, node);

  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}

function ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}

function ExportAllDeclaration(node) {
  this.word("export");
  this.space();

  if (node.exportKind === "type") {
    this.word("type");
    this.space();
  }

  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}

function ExportNamedDeclaration(node) {
  if (this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration)) {
    this.printJoin(node.declaration.decorators, node);
  }

  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDefaultDeclaration(node) {
  if (this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration)) {
    this.printJoin(node.declaration.decorators, node);
  }

  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDeclaration(node) {
  if (node.declaration) {
    var declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    var specifiers = node.specifiers.slice(0);
    var hasSpecial = false;

    while (true) {
      var first = specifiers[0];

      if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length || !specifiers.length && !hasSpecial) {
      this.token("{");

      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }

      this.token("}");
    }

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ImportDeclaration(node) {
  this.word("import");
  this.space();

  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  var specifiers = node.specifiers.slice(0);

  if (specifiers && specifiers.length) {
    while (true) {
      var first = specifiers[0];

      if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }

    this.space();
    this.word("from");
    this.space();
  }

  this.print(node.source, node);
  this.semicolon();
}

function ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}

},{"@babel/types":242}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WithStatement = WithStatement;
exports.IfStatement = IfStatement;
exports.ForStatement = ForStatement;
exports.WhileStatement = WhileStatement;
exports.DoWhileStatement = DoWhileStatement;
exports.LabeledStatement = LabeledStatement;
exports.TryStatement = TryStatement;
exports.CatchClause = CatchClause;
exports.SwitchStatement = SwitchStatement;
exports.SwitchCase = SwitchCase;
exports.DebuggerStatement = DebuggerStatement;
exports.VariableDeclaration = VariableDeclaration;
exports.VariableDeclarator = VariableDeclarator;
exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}

function IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();
  var needsBlock = node.alternate && t.isIfStatement(getLastStatement(node.consequent));

  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }

  this.printAndIndentOnComments(node.consequent, node);

  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }

  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}

function getLastStatement(statement) {
  if (!t.isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}

function ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");
  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");

  if (node.test) {
    this.space();
    this.print(node.test, node);
  }

  this.token(";");

  if (node.update) {
    this.space();
    this.print(node.update, node);
  }

  this.token(")");
  this.printBlock(node);
}

function WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}

var buildForXStatement = function buildForXStatement(op) {
  return function (node) {
    this.word("for");
    this.space();

    if (op === "of" && node.await) {
      this.word("await");
      this.space();
    }

    this.token("(");
    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};

var ForInStatement = buildForXStatement("in");
exports.ForInStatement = ForInStatement;
var ForOfStatement = buildForXStatement("of");
exports.ForOfStatement = ForOfStatement;

function DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}

function buildLabelStatement(prefix) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "label";
  return function (node) {
    this.word(prefix);
    var label = node[key];

    if (label) {
      this.space();
      var isLabel = key == "label";
      var terminatorState = this.startTerminatorless(isLabel);
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }

    this.semicolon();
  };
}

var ContinueStatement = buildLabelStatement("continue");
exports.ContinueStatement = ContinueStatement;
var ReturnStatement = buildLabelStatement("return", "argument");
exports.ReturnStatement = ReturnStatement;
var BreakStatement = buildLabelStatement("break");
exports.BreakStatement = BreakStatement;
var ThrowStatement = buildLabelStatement("throw", "argument");
exports.ThrowStatement = ThrowStatement;

function LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}

function TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();

  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }

  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}

function CatchClause(node) {
  this.word("catch");
  this.space();

  if (node.param) {
    this.token("(");
    this.print(node.param, node);
    this.token(")");
    this.space();
  }

  this.print(node.body, node);
}

function SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");
  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines: function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    }
  });
  this.token("}");
}

function SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }

  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, {
      indent: true
    });
  }
}

function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}

function variableDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
    this.space(true);
  }
}

function constDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
    this.space(true);
  }
}

function VariableDeclaration(node, parent) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }

  this.word(node.kind);
  this.space();
  var hasInits = false;

  if (!t.isFor(parent)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var declar = _step.value;

        if (declar.init) {
          hasInits = true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  var separator;

  if (hasInits) {
    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
  }

  this.printList(node.declarations, node, {
    separator: separator
  });

  if (t.isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }

  this.semicolon();
}

function VariableDeclarator(node) {
  this.print(node.id, node);
  if (node.definite) this.token("!");
  this.print(node.id.typeAnnotation, node);

  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}

},{"@babel/types":242}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.TemplateElement = TemplateElement;
exports.TemplateLiteral = TemplateLiteral;

function TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.typeParameters, node);
  this.print(node.quasi, node);
}

function TemplateElement(node, parent) {
  var isFirst = parent.quasis[0] === node;
  var isLast = parent.quasis[parent.quasis.length - 1] === node;
  var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
  this.token(value);
}

function TemplateLiteral(node) {
  var quasis = node.quasis;

  for (var i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);

    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Identifier = Identifier;
exports.ArgumentPlaceholder = ArgumentPlaceholder;
exports.SpreadElement = exports.RestElement = RestElement;
exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
exports.ObjectMethod = ObjectMethod;
exports.ObjectProperty = ObjectProperty;
exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
exports.RegExpLiteral = RegExpLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.NumericLiteral = NumericLiteral;
exports.StringLiteral = StringLiteral;
exports.BigIntLiteral = BigIntLiteral;
exports.PipelineTopicExpression = PipelineTopicExpression;
exports.PipelineBareFunction = PipelineBareFunction;
exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;

var t = _interopRequireWildcard(require("@babel/types"));

var _jsesc = _interopRequireDefault(require("jsesc"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function Identifier(node) {
  var _this = this;

  this.exactSource(node.loc, function () {
    _this.word(node.name);
  });
}

function ArgumentPlaceholder() {
  this.token("?");
}

function RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}

function ObjectExpression(node) {
  var props = node.properties;
  this.token("{");
  this.printInnerComments(node);

  if (props.length) {
    this.space();
    this.printList(props, node, {
      indent: true,
      statement: true
    });
    this.space();
  }

  this.token("}");
}

function ObjectMethod(node) {
  this.printJoin(node.decorators, node);

  this._methodHead(node);

  this.space();
  this.print(node.body, node);
}

function ObjectProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
      this.print(node.value, node);
      return;
    }

    this.print(node.key, node);

    if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {
      return;
    }
  }

  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ArrayExpression(node) {
  var elems = node.elements;
  var len = elems.length;
  this.token("[");
  this.printInnerComments(node);

  for (var i = 0; i < elems.length; i++) {
    var elem = elems[i];

    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }

  this.token("]");
}

function RegExpLiteral(node) {
  this.word("/".concat(node.pattern, "/").concat(node.flags));
}

function BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteral() {
  this.word("null");
}

function NumericLiteral(node) {
  var raw = this.getPossibleRaw(node);
  var value = node.value + "";

  if (raw == null) {
    this.number(value);
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}

function StringLiteral(node) {
  var raw = this.getPossibleRaw(node);

  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }

  var opts = this.format.jsescOption;

  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }

  var val = (0, _jsesc.default)(node.value, opts);
  return this.token(val);
}

function BigIntLiteral(node) {
  var raw = this.getPossibleRaw(node);

  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }

  this.token(node.value);
}

function PipelineTopicExpression(node) {
  this.print(node.expression, node);
}

function PipelineBareFunction(node) {
  this.print(node.callee, node);
}

function PipelinePrimaryTopicReference() {
  this.token("#");
}

},{"@babel/types":242,"jsesc":844}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSTypeAnnotation = TSTypeAnnotation;
exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
exports.TSTypeParameter = TSTypeParameter;
exports.TSParameterProperty = TSParameterProperty;
exports.TSDeclareFunction = TSDeclareFunction;
exports.TSDeclareMethod = TSDeclareMethod;
exports.TSQualifiedName = TSQualifiedName;
exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
exports.TSPropertySignature = TSPropertySignature;
exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
exports.TSMethodSignature = TSMethodSignature;
exports.TSIndexSignature = TSIndexSignature;
exports.TSAnyKeyword = TSAnyKeyword;
exports.TSBigIntKeyword = TSBigIntKeyword;
exports.TSUnknownKeyword = TSUnknownKeyword;
exports.TSNumberKeyword = TSNumberKeyword;
exports.TSObjectKeyword = TSObjectKeyword;
exports.TSBooleanKeyword = TSBooleanKeyword;
exports.TSStringKeyword = TSStringKeyword;
exports.TSSymbolKeyword = TSSymbolKeyword;
exports.TSVoidKeyword = TSVoidKeyword;
exports.TSUndefinedKeyword = TSUndefinedKeyword;
exports.TSNullKeyword = TSNullKeyword;
exports.TSNeverKeyword = TSNeverKeyword;
exports.TSThisType = TSThisType;
exports.TSFunctionType = TSFunctionType;
exports.TSConstructorType = TSConstructorType;
exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
exports.TSTypeReference = TSTypeReference;
exports.TSTypePredicate = TSTypePredicate;
exports.TSTypeQuery = TSTypeQuery;
exports.TSTypeLiteral = TSTypeLiteral;
exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
exports.tsPrintBraced = tsPrintBraced;
exports.TSArrayType = TSArrayType;
exports.TSTupleType = TSTupleType;
exports.TSOptionalType = TSOptionalType;
exports.TSRestType = TSRestType;
exports.TSUnionType = TSUnionType;
exports.TSIntersectionType = TSIntersectionType;
exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
exports.TSConditionalType = TSConditionalType;
exports.TSInferType = TSInferType;
exports.TSParenthesizedType = TSParenthesizedType;
exports.TSTypeOperator = TSTypeOperator;
exports.TSIndexedAccessType = TSIndexedAccessType;
exports.TSMappedType = TSMappedType;
exports.TSLiteralType = TSLiteralType;
exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
exports.TSInterfaceBody = TSInterfaceBody;
exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
exports.TSAsExpression = TSAsExpression;
exports.TSTypeAssertion = TSTypeAssertion;
exports.TSEnumDeclaration = TSEnumDeclaration;
exports.TSEnumMember = TSEnumMember;
exports.TSModuleDeclaration = TSModuleDeclaration;
exports.TSModuleBlock = TSModuleBlock;
exports.TSImportType = TSImportType;
exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
exports.TSExternalModuleReference = TSExternalModuleReference;
exports.TSNonNullExpression = TSNonNullExpression;
exports.TSExportAssignment = TSExportAssignment;
exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;

function TSTypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function TSTypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

function TSTypeParameter(node) {
  this.word(node.name);

  if (node.constraint) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.constraint, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function TSParameterProperty(node) {
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }

  if (node.readonly) {
    this.word("readonly");
    this.space();
  }

  this._param(node.parameter);
}

function TSDeclareFunction(node) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }

  this._functionHead(node);

  this.token(";");
}

function TSDeclareMethod(node) {
  this._classMethodHead(node);

  this.token(";");
}

function TSQualifiedName(node) {
  this.print(node.left, node);
  this.token(".");
  this.print(node.right, node);
}

function TSCallSignatureDeclaration(node) {
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}

function TSConstructSignatureDeclaration(node) {
  this.word("new");
  this.space();
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}

function TSPropertySignature(node) {
  var readonly = node.readonly,
      initializer = node.initializer;

  if (readonly) {
    this.word("readonly");
    this.space();
  }

  this.tsPrintPropertyOrMethodName(node);
  this.print(node.typeAnnotation, node);

  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }

  this.token(";");
}

function tsPrintPropertyOrMethodName(node) {
  if (node.computed) {
    this.token("[");
  }

  this.print(node.key, node);

  if (node.computed) {
    this.token("]");
  }

  if (node.optional) {
    this.token("?");
  }
}

function TSMethodSignature(node) {
  this.tsPrintPropertyOrMethodName(node);
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}

function TSIndexSignature(node) {
  var readonly = node.readonly;

  if (readonly) {
    this.word("readonly");
    this.space();
  }

  this.token("[");

  this._parameters(node.parameters, node);

  this.token("]");
  this.print(node.typeAnnotation, node);
  this.token(";");
}

function TSAnyKeyword() {
  this.word("any");
}

function TSBigIntKeyword() {
  this.word("bigint");
}

function TSUnknownKeyword() {
  this.word("unknown");
}

function TSNumberKeyword() {
  this.word("number");
}

function TSObjectKeyword() {
  this.word("object");
}

function TSBooleanKeyword() {
  this.word("boolean");
}

function TSStringKeyword() {
  this.word("string");
}

function TSSymbolKeyword() {
  this.word("symbol");
}

function TSVoidKeyword() {
  this.word("void");
}

function TSUndefinedKeyword() {
  this.word("undefined");
}

function TSNullKeyword() {
  this.word("null");
}

function TSNeverKeyword() {
  this.word("never");
}

function TSThisType() {
  this.word("this");
}

function TSFunctionType(node) {
  this.tsPrintFunctionOrConstructorType(node);
}

function TSConstructorType(node) {
  this.word("new");
  this.space();
  this.tsPrintFunctionOrConstructorType(node);
}

function tsPrintFunctionOrConstructorType(node) {
  var typeParameters = node.typeParameters,
      parameters = node.parameters;
  this.print(typeParameters, node);
  this.token("(");

  this._parameters(parameters, node);

  this.token(")");
  this.space();
  this.token("=>");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation, node);
}

function TSTypeReference(node) {
  this.print(node.typeName, node);
  this.print(node.typeParameters, node);
}

function TSTypePredicate(node) {
  if (node.asserts) {
    this.word("asserts");
    this.space();
  }

  this.print(node.parameterName);

  if (node.typeAnnotation) {
    this.space();
    this.word("is");
    this.space();
    this.print(node.typeAnnotation.typeAnnotation);
  }
}

function TSTypeQuery(node) {
  this.word("typeof");
  this.space();
  this.print(node.exprName);
}

function TSTypeLiteral(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
}

function tsPrintTypeLiteralOrInterfaceBody(members, node) {
  this.tsPrintBraced(members, node);
}

function tsPrintBraced(members, node) {
  this.token("{");

  if (members.length) {
    this.indent();
    this.newline();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var member = _step.value;
        this.print(member, node);
        this.newline();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.dedent();
    this.rightBrace();
  } else {
    this.token("}");
  }
}

function TSArrayType(node) {
  this.print(node.elementType, node);
  this.token("[]");
}

function TSTupleType(node) {
  this.token("[");
  this.printList(node.elementTypes, node);
  this.token("]");
}

function TSOptionalType(node) {
  this.print(node.typeAnnotation, node);
  this.token("?");
}

function TSRestType(node) {
  this.token("...");
  this.print(node.typeAnnotation, node);
}

function TSUnionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "|");
}

function TSIntersectionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "&");
}

function tsPrintUnionOrIntersectionType(node, sep) {
  this.printJoin(node.types, node, {
    separator: function separator() {
      this.space();
      this.token(sep);
      this.space();
    }
  });
}

function TSConditionalType(node) {
  this.print(node.checkType);
  this.space();
  this.word("extends");
  this.space();
  this.print(node.extendsType);
  this.space();
  this.token("?");
  this.space();
  this.print(node.trueType);
  this.space();
  this.token(":");
  this.space();
  this.print(node.falseType);
}

function TSInferType(node) {
  this.token("infer");
  this.space();
  this.print(node.typeParameter);
}

function TSParenthesizedType(node) {
  this.token("(");
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function TSTypeOperator(node) {
  this.token(node.operator);
  this.space();
  this.print(node.typeAnnotation, node);
}

function TSIndexedAccessType(node) {
  this.print(node.objectType, node);
  this.token("[");
  this.print(node.indexType, node);
  this.token("]");
}

function TSMappedType(node) {
  var readonly = node.readonly,
      typeParameter = node.typeParameter,
      optional = node.optional;
  this.token("{");
  this.space();

  if (readonly) {
    tokenIfPlusMinus(this, readonly);
    this.word("readonly");
    this.space();
  }

  this.token("[");
  this.word(typeParameter.name);
  this.space();
  this.word("in");
  this.space();
  this.print(typeParameter.constraint, typeParameter);
  this.token("]");

  if (optional) {
    tokenIfPlusMinus(this, optional);
    this.token("?");
  }

  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
  this.space();
  this.token("}");
}

function tokenIfPlusMinus(self, tok) {
  if (tok !== true) {
    self.token(tok);
  }
}

function TSLiteralType(node) {
  this.print(node.literal, node);
}

function TSExpressionWithTypeArguments(node) {
  this.print(node.expression, node);
  this.print(node.typeParameters, node);
}

function TSInterfaceDeclaration(node) {
  var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      extendz = node.extends,
      body = node.body;

  if (declare) {
    this.word("declare");
    this.space();
  }

  this.word("interface");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);

  if (extendz) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(extendz, node);
  }

  this.space();
  this.print(body, node);
}

function TSInterfaceBody(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
}

function TSTypeAliasDeclaration(node) {
  var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      typeAnnotation = node.typeAnnotation;

  if (declare) {
    this.word("declare");
    this.space();
  }

  this.word("type");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(typeAnnotation, node);
  this.token(";");
}

function TSAsExpression(node) {
  var expression = node.expression,
      typeAnnotation = node.typeAnnotation;
  this.print(expression, node);
  this.space();
  this.word("as");
  this.space();
  this.print(typeAnnotation, node);
}

function TSTypeAssertion(node) {
  var typeAnnotation = node.typeAnnotation,
      expression = node.expression;
  this.token("<");
  this.print(typeAnnotation, node);
  this.token(">");
  this.space();
  this.print(expression, node);
}

function TSEnumDeclaration(node) {
  var declare = node.declare,
      isConst = node.const,
      id = node.id,
      members = node.members;

  if (declare) {
    this.word("declare");
    this.space();
  }

  if (isConst) {
    this.word("const");
    this.space();
  }

  this.word("enum");
  this.space();
  this.print(id, node);
  this.space();
  this.tsPrintBraced(members, node);
}

function TSEnumMember(node) {
  var id = node.id,
      initializer = node.initializer;
  this.print(id, node);

  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }

  this.token(",");
}

function TSModuleDeclaration(node) {
  var declare = node.declare,
      id = node.id;

  if (declare) {
    this.word("declare");
    this.space();
  }

  if (!node.global) {
    this.word(id.type === "Identifier" ? "namespace" : "module");
    this.space();
  }

  this.print(id, node);

  if (!node.body) {
    this.token(";");
    return;
  }

  var body = node.body;

  while (body.type === "TSModuleDeclaration") {
    this.token(".");
    this.print(body.id, body);
    body = body.body;
  }

  this.space();
  this.print(body, node);
}

function TSModuleBlock(node) {
  this.tsPrintBraced(node.body, node);
}

function TSImportType(node) {
  var argument = node.argument,
      qualifier = node.qualifier,
      typeParameters = node.typeParameters;
  this.word("import");
  this.token("(");
  this.print(argument, node);
  this.token(")");

  if (qualifier) {
    this.token(".");
    this.print(qualifier, node);
  }

  if (typeParameters) {
    this.print(typeParameters, node);
  }
}

function TSImportEqualsDeclaration(node) {
  var isExport = node.isExport,
      id = node.id,
      moduleReference = node.moduleReference;

  if (isExport) {
    this.word("export");
    this.space();
  }

  this.word("import");
  this.space();
  this.print(id, node);
  this.space();
  this.token("=");
  this.space();
  this.print(moduleReference, node);
  this.token(";");
}

function TSExternalModuleReference(node) {
  this.token("require(");
  this.print(node.expression, node);
  this.token(")");
}

function TSNonNullExpression(node) {
  this.print(node.expression, node);
  this.token("!");
}

function TSExportAssignment(node) {
  this.word("export");
  this.space();
  this.token("=");
  this.space();
  this.print(node.expression, node);
  this.token(";");
}

function TSNamespaceExportDeclaration(node) {
  this.word("export");
  this.space();
  this.word("as");
  this.space();
  this.word("namespace");
  this.space();
  this.print(node.id, node);
}

function tsPrintSignatureDeclarationBase(node) {
  var typeParameters = node.typeParameters,
      parameters = node.parameters;
  this.print(typeParameters, node);
  this.token("(");

  this._parameters(parameters, node);

  this.token(")");
  this.print(node.typeAnnotation, node);
}

function tsPrintClassMemberModifiers(node, isField) {
  if (isField && node.declare) {
    this.word("declare");
    this.space();
  }

  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }

  if (node.static) {
    this.word("static");
    this.space();
  }

  if (node.abstract) {
    this.word("abstract");
    this.space();
  }

  if (isField && node.readonly) {
    this.word("readonly");
    this.space();
  }
}

},{}],51:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.CodeGenerator = void 0;

var _sourceMap = _interopRequireDefault(require("./source-map"));

var _printer = _interopRequireDefault(require("./printer"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var Generator =
/*#__PURE__*/
function (_printer$default) {
  _inherits(Generator, _printer$default);

  function Generator(ast) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var code = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, Generator);

    var format = normalizeOptions(code, opts);
    var map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Generator).call(this, format, map));
    _this.ast = ast;
    return _this;
  }

  _createClass(Generator, [{
    key: "generate",
    value: function generate() {
      return _get(_getPrototypeOf(Generator.prototype), "generate", this).call(this, this.ast);
    }
  }]);

  return Generator;
}(_printer.default);

function normalizeOptions(code, opts) {
  var format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: {
      adjustMultilineComment: true,
      style: "  ",
      base: 0
    },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: Object.assign({
      quotes: "double",
      wrap: true
    }, opts.jsescOption)
  };

  if (format.minified) {
    format.compact = true;

    format.shouldPrintComment = format.shouldPrintComment || function () {
      return format.comments;
    };
  } else {
    format.shouldPrintComment = format.shouldPrintComment || function (value) {
      return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
    };
  }

  if (format.compact === "auto") {
    format.compact = code.length > 500000;

    if (format.compact) {
      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + "".concat(opts.filename, " as it exceeds the max of ", "500KB", "."));
    }
  }

  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }

  return format;
}

var CodeGenerator =
/*#__PURE__*/
function () {
  function CodeGenerator(ast, opts, code) {
    _classCallCheck(this, CodeGenerator);

    this._generator = new Generator(ast, opts, code);
  }

  _createClass(CodeGenerator, [{
    key: "generate",
    value: function generate() {
      return this._generator.generate();
    }
  }]);

  return CodeGenerator;
}();

exports.CodeGenerator = CodeGenerator;

function _default(ast, opts, code) {
  var gen = new Generator(ast, opts, code);
  return gen.generate();
}

},{"./printer":55,"./source-map":56}],52:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.needsWhitespace = needsWhitespace;
exports.needsWhitespaceBefore = needsWhitespaceBefore;
exports.needsWhitespaceAfter = needsWhitespaceAfter;
exports.needsParens = needsParens;

var whitespace = _interopRequireWildcard(require("./whitespace"));

var parens = _interopRequireWildcard(require("./parentheses"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function expandAliases(obj) {
  var newObj = {};

  function add(type, func) {
    var fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) {
      var result = fn(node, parent, stack);
      return result == null ? func(node, parent, stack) : result;
    } : func;
  }

  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
    var type = _Object$keys[_i];
    var aliases = t.FLIPPED_ALIAS_KEYS[type];

    if (aliases) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var alias = _step.value;
          add(alias, obj[type]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      add(type, obj[type]);
    }
  }

  return newObj;
}

var expandedParens = expandAliases(parens);
var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
var expandedWhitespaceList = expandAliases(whitespace.list);

function find(obj, node, parent, printStack) {
  var fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}

function isOrHasCallExpression(node) {
  if (t.isCallExpression(node)) {
    return true;
  }

  if (t.isMemberExpression(node)) {
    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);
  } else {
    return false;
  }
}

function needsWhitespace(node, parent, type) {
  if (!node) return 0;

  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  var linesInfo = find(expandedWhitespaceNodes, node, parent);

  if (!linesInfo) {
    var items = find(expandedWhitespaceList, node, parent);

    if (items) {
      for (var i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }

  if (_typeof(linesInfo) === "object" && linesInfo !== null) {
    return linesInfo[type] || 0;
  }

  return 0;
}

function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}

function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}

function needsParens(node, parent, printStack) {
  if (!parent) return false;

  if (t.isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }

  if (t.isLogicalExpression(node) && parent.operator === "??") return true;
  return find(expandedParens, node, parent, printStack);
}

},{"./parentheses":53,"./whitespace":54,"@babel/types":242}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.UpdateExpression = UpdateExpression;
exports.ObjectExpression = ObjectExpression;
exports.DoExpression = DoExpression;
exports.Binary = Binary;
exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.TSAsExpression = TSAsExpression;
exports.TSTypeAssertion = TSTypeAssertion;
exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
exports.BinaryExpression = BinaryExpression;
exports.SequenceExpression = SequenceExpression;
exports.AwaitExpression = exports.YieldExpression = YieldExpression;
exports.ClassExpression = ClassExpression;
exports.UnaryLike = UnaryLike;
exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.OptionalMemberExpression = OptionalMemberExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.NewExpression = NewExpression;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10
};

var isClassExtendsClause = function isClassExtendsClause(node, parent) {
  return (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;
};

function NullableTypeAnnotation(node, parent) {
  return t.isArrayTypeAnnotation(parent);
}

function FunctionTypeAnnotation(node, parent, printStack) {
  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);
}

function UpdateExpression(node, parent) {
  return t.isMemberExpression(parent, {
    object: node
  }) || t.isCallExpression(parent, {
    callee: node
  }) || t.isNewExpression(parent, {
    callee: node
  }) || isClassExtendsClause(node, parent);
}

function ObjectExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerArrow: true
  });
}

function DoExpression(node, parent, printStack) {
  return isFirstInStatement(printStack);
}

function Binary(node, parent) {
  if (node.operator === "**" && t.isBinaryExpression(parent, {
    operator: "**"
  })) {
    return parent.left === node;
  }

  if (isClassExtendsClause(node, parent)) {
    return true;
  }

  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {
    return true;
  }

  if (t.isBinary(parent)) {
    var parentOp = parent.operator;
    var parentPos = PRECEDENCE[parentOp];
    var nodeOp = node.operator;
    var nodePos = PRECEDENCE[nodeOp];

    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {
      return true;
    }
  }

  return false;
}

function UnionTypeAnnotation(node, parent) {
  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);
}

function TSAsExpression() {
  return true;
}

function TSTypeAssertion() {
  return true;
}

function TSUnionType(node, parent) {
  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);
}

function BinaryExpression(node, parent) {
  return node.operator === "in" && (t.isVariableDeclarator(parent) || t.isFor(parent));
}

function SequenceExpression(node, parent) {
  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  return true;
}

function YieldExpression(node, parent) {
  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
}

function ClassExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerDefaultExports: true
  });
}

function UnaryLike(node, parent) {
  return t.isMemberExpression(parent, {
    object: node
  }) || t.isCallExpression(parent, {
    callee: node
  }) || t.isNewExpression(parent, {
    callee: node
  }) || t.isBinaryExpression(parent, {
    operator: "**",
    left: node
  }) || isClassExtendsClause(node, parent);
}

function FunctionExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerDefaultExports: true
  });
}

function ArrowFunctionExpression(node, parent) {
  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);
}

function ConditionalExpression(node, parent) {
  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {
    test: node
  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {
    return true;
  }

  return UnaryLike(node, parent);
}

function OptionalMemberExpression(node, parent) {
  return t.isCallExpression(parent) || t.isMemberExpression(parent);
}

function AssignmentExpression(node) {
  if (t.isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression.apply(void 0, arguments);
  }
}

function NewExpression(node, parent) {
  return isClassExtendsClause(node, parent);
}

function isFirstInStatement(printStack) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$considerArrow = _ref.considerArrow,
      considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,
      _ref$considerDefaultE = _ref.considerDefaultExports,
      considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;

  var i = printStack.length - 1;
  var node = printStack[i];
  i--;
  var parent = printStack[i];

  while (i > 0) {
    if (t.isExpressionStatement(parent, {
      expression: node
    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {
      declaration: node
    }) || considerArrow && t.isArrowFunctionExpression(parent, {
      body: node
    })) {
      return true;
    }

    if (t.isCallExpression(parent, {
      callee: node
    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {
      object: node
    }) || t.isConditional(parent, {
      test: node
    }) || t.isBinary(parent, {
      left: node
    }) || t.isAssignmentExpression(parent, {
      left: node
    })) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }

  return false;
}

},{"@babel/types":242}],54:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.list = exports.nodes = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function crawl(node) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (t.isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t.isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t.isFunction(node)) {
    state.hasFunction = true;
  } else if (t.isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }

  return state;
}

function isHelper(node) {
  if (t.isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t.isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t.isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
  } else {
    return false;
  }
}

function isType(node) {
  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
}

var nodes = {
  AssignmentExpression: function AssignmentExpression(node) {
    var state = crawl(node.right);

    if (state.hasCall && state.hasHelper || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true
      };
    }
  },
  SwitchCase: function SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node,
      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
    };
  },
  LogicalExpression: function LogicalExpression(node) {
    if (t.isFunction(node.left) || t.isFunction(node.right)) {
      return {
        after: true
      };
    }
  },
  Literal: function Literal(node) {
    if (node.value === "use strict") {
      return {
        after: true
      };
    }
  },
  CallExpression: function CallExpression(node) {
    if (t.isFunction(node.callee) || isHelper(node)) {
      return {
        before: true,
        after: true
      };
    }
  },
  VariableDeclaration: function VariableDeclaration(node) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];
      var enabled = isHelper(declar.id) && !isType(declar.init);

      if (!enabled) {
        var state = crawl(declar.init);
        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
      }

      if (enabled) {
        return {
          before: true,
          after: true
        };
      }
    }
  },
  IfStatement: function IfStatement(node) {
    if (t.isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true
      };
    }
  }
};
exports.nodes = nodes;

nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
  if (parent.properties[0] === node) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeCallProperty = function (node, parent) {
  if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeIndexer = function (node, parent) {
  if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeInternalSlot = function (node, parent) {
  if (parent.internalSlots[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length) && (!parent.indexers || !parent.indexers.length)) {
    return {
      before: true
    };
  }
};

var list = {
  VariableDeclaration: function VariableDeclaration(node) {
    return node.declarations.map(function (decl) {
      return decl.init;
    });
  },
  ArrayExpression: function ArrayExpression(node) {
    return node.elements;
  },
  ObjectExpression: function ObjectExpression(node) {
    return node.properties;
  }
};
exports.list = list;
[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      type = _ref2[0],
      amounts = _ref2[1];

  if (typeof amounts === "boolean") {
    amounts = {
      after: amounts,
      before: amounts
    };
  }

  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    nodes[type] = function () {
      return amounts;
    };
  });
});

},{"@babel/types":242}],55:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isInteger = _interopRequireDefault(require("lodash/isInteger"));

var _repeat = _interopRequireDefault(require("lodash/repeat"));

var _buffer = _interopRequireDefault(require("./buffer"));

var n = _interopRequireWildcard(require("./node"));

var t = _interopRequireWildcard(require("@babel/types"));

var generatorFunctions = _interopRequireWildcard(require("./generators"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var NON_DECIMAL_LITERAL = /^0[box]/;

var Printer =
/*#__PURE__*/
function () {
  function Printer(format, map) {
    _classCallCheck(this, Printer);

    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new WeakSet();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this.format = format || {};
    this._buf = new _buffer.default(map);
  }

  _createClass(Printer, [{
    key: "generate",
    value: function generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    }
  }, {
    key: "indent",
    value: function indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    }
  }, {
    key: "dedent",
    value: function dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this._maybeAddAuxComment();

      this._append(";", !force);
    }
  }, {
    key: "rightBrace",
    value: function rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    }
  }, {
    key: "space",
    value: function space() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    }
  }, {
    key: "word",
    value: function word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    }
  }, {
    key: "number",
    value: function number(str) {
      this.word(str);
      this._endsWithInteger = (0, _isInteger.default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    }
  }, {
    key: "token",
    value: function token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    }
  }, {
    key: "newline",
    value: function newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (var j = 0; j < i; j++) {
        this._newline();
      }
    }
  }, {
    key: "endsWith",
    value: function endsWith(str) {
      return this._buf.endsWith(str);
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    }
  }, {
    key: "source",
    value: function source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    }
  }, {
    key: "withSource",
    value: function withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    }
  }, {
    key: "_space",
    value: function _space() {
      this._append(" ", true);
    }
  }, {
    key: "_newline",
    value: function _newline() {
      this._append("\n", true);
    }
  }, {
    key: "_append",
    value: function _append(str) {
      var queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
  }, {
    key: "_maybeIndent",
    value: function _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    }
  }, {
    key: "_maybeAddParen",
    value: function _maybeAddParen(str) {
      var parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      this._parenPushNewlineState = null;
      var i;

      for (i = 0; i < str.length && str[i] === " "; i++) {
        continue;
      }

      if (i === str.length) return;
      var cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/") return;
        if (i + 1 === str.length) return;
        var chaPost = str[i + 1];
        if (chaPost !== "/" && chaPost !== "*") return;
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    }
  }, {
    key: "_catchUp",
    value: function _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      var pos = loc ? loc[prop] : null;

      if (pos && pos.line !== null) {
        var count = pos.line - this._buf.getCurrentLine();

        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    }
  }, {
    key: "_getIndent",
    value: function _getIndent() {
      return (0, _repeat.default)(this.format.indent.style, this._indent);
    }
  }, {
    key: "startTerminatorless",
    value: function startTerminatorless() {
      var isLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    }
  }, {
    key: "endTerminatorless",
    value: function endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state && state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    }
  }, {
    key: "print",
    value: function print(node, parent) {
      var _this = this;

      if (!node) return;
      var oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      var printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError("unknown node of type ".concat(JSON.stringify(node.type), " with constructor ").concat(JSON.stringify(node && node.constructor.name)));
      }

      this._printStack.push(node);

      var oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      var needsParens = n.needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens = true;
      }

      if (needsParens) this.token("(");

      this._printLeadingComments(node);

      var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
      this.withSource("start", loc, function () {
        printMethod.call(_this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    }
  }, {
    key: "_maybeAddAuxComment",
    value: function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }
  }, {
    key: "_printAuxBeforeComment",
    value: function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }
  }, {
    key: "_printAuxAfterComment",
    value: function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }
  }, {
    key: "getPossibleRaw",
    value: function getPossibleRaw(node) {
      var extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    }
  }, {
    key: "printJoin",
    value: function printJoin(nodes, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!nodes || !nodes.length) return;
      if (opts.indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    }
  }, {
    key: "printAndIndentOnComments",
    value: function printAndIndentOnComments(node, parent) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    }
  }, {
    key: "printBlock",
    value: function printBlock(parent) {
      var node = parent.body;

      if (!t.isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    }
  }, {
    key: "_printTrailingComments",
    value: function _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    }
  }, {
    key: "_printLeadingComments",
    value: function _printLeadingComments(node) {
      this._printComments(this._getComments(true, node));
    }
  }, {
    key: "printInnerComments",
    value: function printInnerComments(node) {
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!node.innerComments || !node.innerComments.length) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    }
  }, {
    key: "printSequence",
    value: function printSequence(nodes, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    }
  }, {
    key: "printList",
    value: function printList(items, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    }
  }, {
    key: "_printNewline",
    value: function _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      var lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    }
  }, {
    key: "_getComments",
    value: function _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    }
  }, {
    key: "_printComment",
    value: function _printComment(comment) {
      var _this2 = this;

      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      if (comment.start != null) {
        if (this._printedCommentStarts[comment.start]) return;
        this._printedCommentStarts[comment.start] = true;
      }

      var isBlockComment = comment.type === "CommentBlock";
      this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      var val = !isBlockComment && !this._noLineTerminator ? "//".concat(comment.value, "\n") : "/*".concat(comment.value, "*/");

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var offset = comment.loc && comment.loc.start.column;

        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n".concat((0, _repeat.default)(" ", indentSize)));
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, function () {
        _this2._append(val);
      });
      this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
    }
  }, {
    key: "_printComments",
    value: function _printComments(comments) {
      if (!comments || !comments.length) return;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var comment = _step.value;

          this._printComment(comment);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);

  return Printer;
}();

exports.default = Printer;
Object.assign(Printer.prototype, generatorFunctions);

function commaSeparator() {
  this.token(",");
  this.space();
}

},{"./buffer":38,"./generators":43,"./node":52,"@babel/types":242,"lodash/isInteger":1021,"lodash/repeat":1039}],56:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("source-map"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var SourceMap =
/*#__PURE__*/
function () {
  function SourceMap(opts, code) {
    _classCallCheck(this, SourceMap);

    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }

  _createClass(SourceMap, [{
    key: "get",
    value: function get() {
      if (!this._cachedMap) {
        var map = this._cachedMap = new _sourceMap.default.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        });
        var code = this._code;

        if (typeof code === "string") {
          map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
        } else if (_typeof(code) === "object") {
          Object.keys(code).forEach(function (sourceFileName) {
            map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          });
        }

        this._rawMappings.forEach(function (mapping) {
          return map.addMapping(mapping);
        }, map);
      }

      return this._cachedMap.toJSON();
    }
  }, {
    key: "getRawMappings",
    value: function getRawMappings() {
      return this._rawMappings.slice();
    }
  }, {
    key: "mark",
    value: function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      if (this._lastGenLine !== generatedLine && line === null) return;

      if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
        return;
      }

      this._cachedMap = null;
      this._lastGenLine = generatedLine;
      this._lastSourceLine = line;
      this._lastSourceColumn = column;

      this._rawMappings.push({
        name: identifierName || undefined,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: line == null ? undefined : {
          line: line,
          column: column
        }
      });
    }
  }]);

  return SourceMap;
}();

exports.default = SourceMap;

},{"source-map":1081}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = annotateAsPure;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var PURE_ANNOTATION = "#__PURE__";

var isPureAnnotated = function isPureAnnotated(_ref) {
  var leadingComments = _ref.leadingComments;
  return !!leadingComments && leadingComments.some(function (comment) {
    return /[@#]__PURE__/.test(comment.value);
  });
};

function annotateAsPure(pathOrNode) {
  var node = pathOrNode.node || pathOrNode;

  if (isPureAnnotated(node)) {
    return;
  }

  t.addComment(node, "leading", PURE_ANNOTATION);
}

},{"@babel/types":242}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _helperExplodeAssignableExpression = _interopRequireDefault(require("@babel/helper-explode-assignable-expression"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _default(opts) {
  var build = opts.build,
      operator = opts.operator;
  return {
    AssignmentExpression: function AssignmentExpression(path) {
      var node = path.node,
          scope = path.scope;
      if (node.operator !== operator + "=") return;
      var nodes = [];
      var exploded = (0, _helperExplodeAssignableExpression.default)(node.left, nodes, this, scope);
      nodes.push(t.assignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
      path.replaceWith(t.sequenceExpression(nodes));
    },
    BinaryExpression: function BinaryExpression(path) {
      var node = path.node;

      if (node.operator === operator) {
        path.replaceWith(build(node.left, node.right));
      }
    }
  };
}

},{"@babel/helper-explode-assignable-expression":65,"@babel/types":242}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _helperHoistVariables = _interopRequireDefault(require("@babel/helper-hoist-variables"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var visitor = {
  enter: function enter(path, state) {
    if (path.isThisExpression()) {
      state.foundThis = true;
    }

    if (path.isReferencedIdentifier({
      name: "arguments"
    })) {
      state.foundArguments = true;
    }
  },
  Function: function Function(path) {
    path.skip();
  }
};

function _default(path) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : path.scope;
  var node = path.node;
  var container = t.functionExpression(null, [], node.body, node.generator, node.async);
  var callee = container;
  var args = [];
  (0, _helperHoistVariables.default)(path, function (id) {
    return scope.push({
      id: id
    });
  });
  var state = {
    foundThis: false,
    foundArguments: false
  };
  path.traverse(visitor, state);

  if (state.foundArguments || state.foundThis) {
    callee = t.memberExpression(container, t.identifier("apply"));
    args = [];

    if (state.foundThis) {
      args.push(t.thisExpression());
    }

    if (state.foundArguments) {
      if (!state.foundThis) args.push(t.nullLiteral());
      args.push(t.identifier("arguments"));
    }
  }

  var call = t.callExpression(callee, args);
  if (node.generator) call = t.yieldExpression(call, true);
  return t.returnStatement(call);
}

},{"@babel/helper-hoist-variables":68,"@babel/types":242}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableFeature = enableFeature;
exports.hasFeature = hasFeature;
exports.runtimeKey = exports.featuresKey = exports.FEATURES = void 0;
var FEATURES = Object.freeze({
  unicodeFlag: 1 << 0,
  dotAllFlag: 1 << 1,
  unicodePropertyEscape: 1 << 2,
  namedCaptureGroups: 1 << 3
});
exports.FEATURES = FEATURES;
var featuresKey = "@babel/plugin-regexp-features/featuresKey";
exports.featuresKey = featuresKey;
var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
exports.runtimeKey = runtimeKey;

function enableFeature(features, feature) {
  return features | feature;
}

function hasFeature(features, feature) {
  return !!(features & feature);
}

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;

var _regexpuCore = _interopRequireDefault(require("regexpu-core"));

var _features = require("./features");

var _util = require("./util");

var _package = _interopRequireDefault(require("../package.json"));

var _core = require("@babel/core");

var _helperRegex = require("@babel/helper-regex");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var version = _package.default.version.split(".").reduce(function (v, x) {
  return v * 1e5 + +x;
}, 0);

var versionKey = "@babel/plugin-regexp-features/version";

function createRegExpFeaturePlugin(_ref) {
  var name = _ref.name,
      feature = _ref.feature,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
  return {
    name: name,
    pre: function pre() {
      var _file$get;

      var file = this.file;
      var features = (_file$get = file.get(_features.featuresKey)) !== null && _file$get !== void 0 ? _file$get : 0;
      var newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
      var useUnicodeFlag = options.useUnicodeFlag,
          _options$runtime = options.runtime,
          runtime = _options$runtime === void 0 ? true : _options$runtime;

      if (useUnicodeFlag === false) {
        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);
      }

      if (newFeatures !== features) {
        file.set(_features.featuresKey, newFeatures);
      }

      if (!runtime) {
        file.set(_features.runtimeKey, false);
      }

      if (!file.has(versionKey) || file.get(versionKey) < version) {
        file.set(versionKey, version);
      }
    },
    visitor: {
      RegExpLiteral: function RegExpLiteral(path) {
        var _file$get2;

        var node = path.node;
        var file = this.file;
        var features = file.get(_features.featuresKey);
        var runtime = (_file$get2 = file.get(_features.runtimeKey)) !== null && _file$get2 !== void 0 ? _file$get2 : true;
        var regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);

        if (regexpuOptions === null) {
          return;
        }

        var namedCaptureGroups = {};

        if (regexpuOptions.namedGroup) {
          regexpuOptions.onNamedGroup = function (name, index) {
            namedCaptureGroups[name] = index;
          };
        }

        node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions);

        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
          path.replaceWith(_core.types.callExpression(this.addHelper("wrapRegExp"), [node, _core.types.valueToNode(namedCaptureGroups)]));
        }

        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {
          (0, _helperRegex.pullFlag)(node, "u");
        }

        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {
          (0, _helperRegex.pullFlag)(node, "s");
        }
      }
    }
  };
}

function isRegExpTest(path) {
  return path.parentPath.isMemberExpression({
    object: path.node,
    computed: false
  }) && path.parentPath.get("property").isIdentifier({
    name: "test"
  });
}

},{"../package.json":63,"./features":60,"./util":62,"@babel/core":19,"@babel/helper-regex":80,"regexpu-core":1066}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateRegexpuOptions = generateRegexpuOptions;

var _features = require("./features");

function generateRegexpuOptions(node, features) {
  var useUnicodeFlag = false,
      dotAllFlag = false,
      unicodePropertyEscape = false,
      namedGroup = false;
  var flags = node.flags,
      pattern = node.pattern;
  var flagsIncludesU = flags.includes("u");

  if (flagsIncludesU) {
    if (!(0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {
      useUnicodeFlag = true;
    }

    if ((0, _features.hasFeature)(features, _features.FEATURES.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
      unicodePropertyEscape = true;
    }
  }

  if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag) && flags.indexOf("s") >= 0) {
    dotAllFlag = true;
  }

  if ((0, _features.hasFeature)(features, _features.FEATURES.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
    namedGroup = true;
  }

  if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
    return null;
  }

  if (flagsIncludesU && flags.indexOf("s") >= 0) {
    dotAllFlag = true;
  }

  return {
    useUnicodeFlag: useUnicodeFlag,
    onNamedGroup: function onNamedGroup() {},
    namedGroup: namedGroup,
    unicodePropertyEscape: unicodePropertyEscape,
    dotAllFlag: dotAllFlag,
    lookbehind: true
  };
}

},{"./features":60}],63:[function(require,module,exports){
module.exports={
  "_from": "@babel/helper-create-regexp-features-plugin@^7.7.0",
  "_id": "@babel/helper-create-regexp-features-plugin@7.7.2",
  "_inBundle": false,
  "_integrity": "sha512-pAil/ZixjTlrzNpjx+l/C/wJk002Wo7XbbZ8oujH/AoJ3Juv0iN/UTcPUHXKMFLqsfS0Hy6Aow8M31brUYBlQQ==",
  "_location": "/@babel/helper-create-regexp-features-plugin",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "@babel/helper-create-regexp-features-plugin@^7.7.0",
    "name": "@babel/helper-create-regexp-features-plugin",
    "escapedName": "@babel%2fhelper-create-regexp-features-plugin",
    "scope": "@babel",
    "rawSpec": "^7.7.0",
    "saveSpec": null,
    "fetchSpec": "^7.7.0"
  },
  "_requiredBy": [
    "/@babel/plugin-proposal-unicode-property-regex",
    "/@babel/plugin-transform-dotall-regex",
    "/@babel/plugin-transform-named-capturing-groups-regex",
    "/@babel/plugin-transform-unicode-regex"
  ],
  "_resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.7.2.tgz",
  "_shasum": "6f20443778c8fce2af2ff4206284afc0ced65db6",
  "_spec": "@babel/helper-create-regexp-features-plugin@^7.7.0",
  "_where": "/local/home/ossman/devel/noVNC/node_modules/@babel/plugin-proposal-unicode-property-regex",
  "author": {
    "name": "The Babel Team",
    "url": "https://babeljs.io/team"
  },
  "bugs": {
    "url": "https://github.com/babel/babel/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "@babel/helper-regex": "^7.4.4",
    "regexpu-core": "^4.6.0"
  },
  "deprecated": false,
  "description": "Compile ESNext Regular Expressions to ES5",
  "devDependencies": {
    "@babel/core": "^7.7.2",
    "@babel/helper-plugin-test-runner": "^7.0.0"
  },
  "gitHead": "35f4d1276310bac6fede4a6f86a5c76f951e179e",
  "homepage": "https://github.com/babel/babel#readme",
  "keywords": [
    "babel",
    "babel-plugin"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "@babel/helper-create-regexp-features-plugin",
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/babel/babel.git",
    "directory": "packages/babel-helper-create-regexp-features-plugin"
  },
  "version": "7.7.2"
}

},{}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.push = push;
exports.hasComputed = hasComputed;
exports.toComputedObjectFromClass = toComputedObjectFromClass;
exports.toClassObject = toClassObject;
exports.toDefineObject = toDefineObject;

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

var _has = _interopRequireDefault(require("lodash/has"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function toKind(node) {
  if (t.isClassMethod(node) || t.isObjectMethod(node)) {
    if (node.kind === "get" || node.kind === "set") {
      return node.kind;
    }
  }

  return "value";
}

function push(mutatorMap, node, kind, file, scope) {
  var alias = t.toKeyAlias(node);
  var map = {};
  if ((0, _has.default)(mutatorMap, alias)) map = mutatorMap[alias];
  mutatorMap[alias] = map;
  map._inherits = map._inherits || [];

  map._inherits.push(node);

  map._key = node.key;

  if (node.computed) {
    map._computed = true;
  }

  if (node.decorators) {
    var decorators = map.decorators = map.decorators || t.arrayExpression([]);
    decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
      return dec.expression;
    }).reverse());
  }

  if (map.value || map.initializer) {
    throw file.buildCodeFrameError(node, "Key conflict with sibling node");
  }

  var key, value;

  if (t.isObjectProperty(node) || t.isObjectMethod(node) || t.isClassMethod(node)) {
    key = t.toComputedKey(node, node.key);
  }

  if (t.isProperty(node)) {
    value = node.value;
  } else if (t.isObjectMethod(node) || t.isClassMethod(node)) {
    value = t.functionExpression(null, node.params, node.body, node.generator, node.async);
    value.returnType = node.returnType;
  }

  var inheritedKind = toKind(node);

  if (!kind || inheritedKind !== "value") {
    kind = inheritedKind;
  }

  if (scope && t.isStringLiteral(key) && (kind === "value" || kind === "initializer") && t.isFunctionExpression(value)) {
    value = (0, _helperFunctionName.default)({
      id: key,
      node: value,
      scope: scope
    });
  }

  if (value) {
    t.inheritsComments(value, node);
    map[kind] = value;
  }

  return map;
}

function hasComputed(mutatorMap) {
  for (var _i = 0, _Object$keys = Object.keys(mutatorMap); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (mutatorMap[key]._computed) {
      return true;
    }
  }

  return false;
}

function toComputedObjectFromClass(obj) {
  var objExpr = t.arrayExpression([]);

  for (var i = 0; i < obj.properties.length; i++) {
    var prop = obj.properties[i];
    var val = prop.value;
    val.properties.unshift(t.objectProperty(t.identifier("key"), t.toComputedKey(prop)));
    objExpr.elements.push(val);
  }

  return objExpr;
}

function toClassObject(mutatorMap) {
  var objExpr = t.objectExpression([]);
  Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
    var map = mutatorMap[mutatorMapKey];
    var mapNode = t.objectExpression([]);
    var propNode = t.objectProperty(map._key, mapNode, map._computed);
    Object.keys(map).forEach(function (key) {
      var node = map[key];
      if (key[0] === "_") return;
      var prop = t.objectProperty(t.identifier(key), node);
      t.inheritsComments(prop, node);
      t.removeComments(node);
      mapNode.properties.push(prop);
    });
    objExpr.properties.push(propNode);
  });
  return objExpr;
}

function toDefineObject(mutatorMap) {
  Object.keys(mutatorMap).forEach(function (key) {
    var map = mutatorMap[key];
    if (map.value) map.writable = t.booleanLiteral(true);
    map.configurable = t.booleanLiteral(true);
    map.enumerable = t.booleanLiteral(true);
  });
  return toClassObject(mutatorMap);
}

},{"@babel/helper-function-name":66,"@babel/types":242,"lodash/has":1012}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function getObjRef(node, nodes, file, scope) {
  var ref;

  if (t.isSuper(node)) {
    return node;
  } else if (t.isIdentifier(node)) {
    if (scope.hasBinding(node.name)) {
      return node;
    } else {
      ref = node;
    }
  } else if (t.isMemberExpression(node)) {
    ref = node.object;

    if (t.isSuper(ref) || t.isIdentifier(ref) && scope.hasBinding(ref.name)) {
      return ref;
    }
  } else {
    throw new Error("We can't explode this node type ".concat(node.type));
  }

  var temp = scope.generateUidIdentifierBasedOnNode(ref);
  scope.push({
    id: temp
  });
  nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(ref)));
  return temp;
}

function getPropRef(node, nodes, file, scope) {
  var prop = node.property;
  var key = t.toComputedKey(node, prop);
  if (t.isLiteral(key) && t.isPureish(key)) return key;
  var temp = scope.generateUidIdentifierBasedOnNode(prop);
  scope.push({
    id: temp
  });
  nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(prop)));
  return temp;
}

function _default(node, nodes, file, scope, allowedSingleIdent) {
  var obj;

  if (t.isIdentifier(node) && allowedSingleIdent) {
    obj = node;
  } else {
    obj = getObjRef(node, nodes, file, scope);
  }

  var ref, uid;

  if (t.isIdentifier(node)) {
    ref = t.cloneNode(node);
    uid = obj;
  } else {
    var prop = getPropRef(node, nodes, file, scope);
    var computed = node.computed || t.isLiteral(prop);
    uid = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);
    ref = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);
  }

  return {
    uid: uid,
    ref: ref
  };
}

},{"@babel/types":242}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _helperGetFunctionArity = _interopRequireDefault(require("@babel/helper-get-function-arity"));

var _template = _interopRequireDefault(require("@babel/template"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var buildPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
var buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
var visitor = {
  "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
    if (path.node.name !== state.name) return;
    var localDeclar = path.scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
  }
};

function getNameFromLiteralId(id) {
  if (t.isNullLiteral(id)) {
    return "null";
  }

  if (t.isRegExpLiteral(id)) {
    return "_".concat(id.pattern, "_").concat(id.flags);
  }

  if (t.isTemplateLiteral(id)) {
    return id.quasis.map(function (quasi) {
      return quasi.value.raw;
    }).join("");
  }

  if (id.value !== undefined) {
    return id.value + "";
  }

  return "";
}

function wrap(state, method, id, scope) {
  if (state.selfReference) {
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      scope.rename(id.name);
    } else {
      if (!t.isFunction(method)) return;
      var build = buildPropertyMethodAssignmentWrapper;

      if (method.generator) {
        build = buildGeneratorPropertyMethodAssignmentWrapper;
      }

      var template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
      }).expression;
      var params = template.callee.body.body[0].params;

      for (var i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }

      return template;
    }
  }

  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}

function visit(node, name, scope) {
  var state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    references: [],
    name: name
  };
  var binding = scope.getOwnBinding(name);

  if (binding) {
    if (binding.kind === "param") {
      state.selfReference = true;
    } else {}
  } else if (state.outerDeclar || scope.hasGlobal(name)) {
    scope.traverse(node, visitor, state);
  }

  return state;
}

function _default(_ref) {
  var node = _ref.node,
      parent = _ref.parent,
      scope = _ref.scope,
      id = _ref.id;
  var localBinding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (node.id) return;

  if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, {
    kind: "method"
  })) && (!parent.computed || t.isLiteral(parent.key))) {
    id = parent.key;
  } else if (t.isVariableDeclarator(parent)) {
    id = parent.id;

    if (t.isIdentifier(id) && !localBinding) {
      var binding = scope.parent.getBinding(id.name);

      if (binding && binding.constant && scope.getBinding(id.name) === binding) {
        node.id = t.cloneNode(id);
        node.id[t.NOT_LOCAL_BINDING] = true;
        return;
      }
    }
  } else if (t.isAssignmentExpression(parent)) {
    id = parent.left;
  } else if (!id) {
    return;
  }

  var name;

  if (id && t.isLiteral(id)) {
    name = getNameFromLiteralId(id);
  } else if (id && t.isIdentifier(id)) {
    name = id.name;
  }

  if (name === undefined) {
    return;
  }

  name = t.toBindingIdentifierName(name);
  id = t.identifier(name);
  id[t.NOT_LOCAL_BINDING] = true;
  var state = visit(node, name, scope);
  return wrap(state, node, id, scope) || node;
}

},{"@babel/helper-get-function-arity":67,"@babel/template":167,"@babel/types":242}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _default(node) {
  var params = node.params;

  for (var i = 0; i < params.length; i++) {
    var param = params[i];

    if (t.isAssignmentPattern(param) || t.isRestElement(param)) {
      return i;
    }
  }

  return params.length;
}

},{"@babel/types":242}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var visitor = {
  Scope: function Scope(path, state) {
    if (state.kind === "let") path.skip();
  },
  Function: function Function(path) {
    path.skip();
  },
  VariableDeclaration: function VariableDeclaration(path, state) {
    if (state.kind && path.node.kind !== state.kind) return;
    var nodes = [];
    var declarations = path.get("declarations");
    var firstId;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var declar = _step.value;
        firstId = declar.node.id;

        if (declar.node.init) {
          nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.node.id, declar.node.init)));
        }

        for (var _i = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          state.emit(t.identifier(name), name, declar.node.init !== null);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (path.parentPath.isFor({
      left: path.node
    })) {
      path.replaceWith(firstId);
    } else {
      path.replaceWithMultiple(nodes);
    }
  }
};

function _default(path, emit) {
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "var";
  path.traverse(visitor, {
    kind: kind,
    emit: emit
  });
}

},{"@babel/types":242}],69:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memberExpressionToFunctions;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var AssignmentMemoiser =
/*#__PURE__*/
function () {
  function AssignmentMemoiser() {
    _classCallCheck(this, AssignmentMemoiser);

    this._map = new WeakMap();
  }

  _createClass(AssignmentMemoiser, [{
    key: "has",
    value: function has(key) {
      return this._map.has(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      if (!this.has(key)) return;

      var record = this._map.get(key);

      var value = record.value;
      record.count--;

      if (record.count === 0) {
        return t.assignmentExpression("=", value, key);
      }

      return value;
    }
  }, {
    key: "set",
    value: function set(key, value, count) {
      return this._map.set(key, {
        count: count,
        value: value
      });
    }
  }]);

  return AssignmentMemoiser;
}();

var handle = {
  memoise: function memoise() {},
  handle: function handle(member) {
    var node = member.node,
        parent = member.parent,
        parentPath = member.parentPath;

    if (parentPath.isUpdateExpression({
      argument: node
    })) {
      var operator = parent.operator,
          prefix = parent.prefix;
      this.memoise(member, 2);
      var value = t.binaryExpression(operator[0], t.unaryExpression("+", this.get(member)), t.numericLiteral(1));

      if (prefix) {
        parentPath.replaceWith(this.set(member, value));
      } else {
        var scope = member.scope;
        var ref = scope.generateUidIdentifierBasedOnNode(node);
        scope.push({
          id: ref
        });
        value.left = t.assignmentExpression("=", t.cloneNode(ref), value.left);
        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));
      }

      return;
    }

    if (parentPath.isAssignmentExpression({
      left: node
    })) {
      var _operator = parent.operator,
          right = parent.right;
      var _value = right;

      if (_operator !== "=") {
        this.memoise(member, 2);
        _value = t.binaryExpression(_operator.slice(0, -1), this.get(member), _value);
      }

      parentPath.replaceWith(this.set(member, _value));
      return;
    }

    if (parentPath.isCallExpression({
      callee: node
    })) {
      var args = parent.arguments;
      parentPath.replaceWith(this.call(member, args));
      return;
    }

    if (parentPath.isObjectProperty({
      value: node
    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
      left: node
    }) && parentPath.parentPath.isObjectProperty({
      value: parent
    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
      left: node
    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
      member.replaceWith(this.destructureSet(member));
      return;
    }

    member.replaceWith(this.get(member));
  }
};

function memberExpressionToFunctions(path, visitor, state) {
  path.traverse(visitor, Object.assign({}, handle, {}, state, {
    memoiser: new AssignmentMemoiser()
  }));
}

},{"@babel/types":242}],70:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var ImportBuilder =
/*#__PURE__*/
function () {
  function ImportBuilder(importedSource, scope, hub) {
    _classCallCheck(this, ImportBuilder);

    this._statements = [];
    this._resultName = null;
    this._scope = null;
    this._hub = null;
    this._scope = scope;
    this._hub = hub;
    this._importedSource = importedSource;
  }

  _createClass(ImportBuilder, [{
    key: "done",
    value: function done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
  }, {
    key: "import",
    value: function _import() {
      this._statements.push(t.importDeclaration([], t.stringLiteral(this._importedSource)));

      return this;
    }
  }, {
    key: "require",
    value: function require() {
      this._statements.push(t.expressionStatement(t.callExpression(t.identifier("require"), [t.stringLiteral(this._importedSource)])));

      return this;
    }
  }, {
    key: "namespace",
    value: function namespace() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "namespace";
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      (0, _assert.default)(statement.type === "ImportDeclaration");
      (0, _assert.default)(statement.specifiers.length === 0);
      statement.specifiers = [t.importNamespaceSpecifier(name)];
      this._resultName = t.cloneNode(name);
      return this;
    }
  }, {
    key: "default",
    value: function _default(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      (0, _assert.default)(statement.type === "ImportDeclaration");
      (0, _assert.default)(statement.specifiers.length === 0);
      statement.specifiers = [t.importDefaultSpecifier(name)];
      this._resultName = t.cloneNode(name);
      return this;
    }
  }, {
    key: "named",
    value: function named(name, importName) {
      if (importName === "default") return this.default(name);
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      (0, _assert.default)(statement.type === "ImportDeclaration");
      (0, _assert.default)(statement.specifiers.length === 0);
      statement.specifiers = [t.importSpecifier(name, t.identifier(importName))];
      this._resultName = t.cloneNode(name);
      return this;
    }
  }, {
    key: "var",
    value: function _var(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];

      if (statement.type !== "ExpressionStatement") {
        (0, _assert.default)(this._resultName);
        statement = t.expressionStatement(this._resultName);

        this._statements.push(statement);
      }

      this._statements[this._statements.length - 1] = t.variableDeclaration("var", [t.variableDeclarator(name, statement.expression)]);
      this._resultName = t.cloneNode(name);
      return this;
    }
  }, {
    key: "defaultInterop",
    value: function defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
  }, {
    key: "wildcardInterop",
    value: function wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
  }, {
    key: "_interop",
    value: function _interop(callee) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = t.callExpression(callee, [statement.expression]);
      } else if (statement.type === "VariableDeclaration") {
        (0, _assert.default)(statement.declarations.length === 1);
        statement.declarations[0].init = t.callExpression(callee, [statement.declarations[0].init]);
      } else {
        _assert.default.fail("Unexpected type.");
      }

      return this;
    }
  }, {
    key: "prop",
    value: function prop(name) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = t.memberExpression(statement.expression, t.identifier(name));
      } else if (statement.type === "VariableDeclaration") {
        (0, _assert.default)(statement.declarations.length === 1);
        statement.declarations[0].init = t.memberExpression(statement.declarations[0].init, t.identifier(name));
      } else {
        _assert.default.fail("Unexpected type:" + statement.type);
      }

      return this;
    }
  }, {
    key: "read",
    value: function read(name) {
      this._resultName = t.memberExpression(this._resultName, t.identifier(name));
    }
  }]);

  return ImportBuilder;
}();

exports.default = ImportBuilder;

},{"@babel/types":242,"assert":278}],71:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var t = _interopRequireWildcard(require("@babel/types"));

var _importBuilder = _interopRequireDefault(require("./import-builder"));

var _isModule = _interopRequireDefault(require("./is-module"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var ImportInjector =
/*#__PURE__*/
function () {
  function ImportInjector(path, importedSource, opts) {
    _classCallCheck(this, ImportInjector);

    this._defaultOpts = {
      importedSource: null,
      importedType: "commonjs",
      importedInterop: "babel",
      importingInterop: "babel",
      ensureLiveReference: false,
      ensureNoContext: false
    };
    var programPath = path.find(function (p) {
      return p.isProgram();
    });
    this._programPath = programPath;
    this._programScope = programPath.scope;
    this._hub = programPath.hub;
    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
  }

  _createClass(ImportInjector, [{
    key: "addDefault",
    value: function addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    }
  }, {
    key: "addNamed",
    value: function addNamed(importName, importedSourceIn, opts) {
      (0, _assert.default)(typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
  }, {
    key: "addNamespace",
    value: function addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
  }, {
    key: "addSideEffect",
    value: function addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
    }
  }, {
    key: "_applyDefaults",
    value: function _applyDefaults(importedSource, opts) {
      var isInit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var optsList = [];

      if (typeof importedSource === "string") {
        optsList.push({
          importedSource: importedSource
        });
        optsList.push(opts);
      } else {
        (0, _assert.default)(!opts, "Unexpected secondary arguments.");
        optsList.push(importedSource);
      }

      var newOpts = Object.assign({}, this._defaultOpts);

      var _loop = function _loop() {
        var opts = _optsList[_i];
        if (!opts) return "continue";
        Object.keys(newOpts).forEach(function (key) {
          if (opts[key] !== undefined) newOpts[key] = opts[key];
        });

        if (!isInit) {
          if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
        }
      };

      for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return newOpts;
    }
  }, {
    key: "_generateImport",
    value: function _generateImport(opts, importName) {
      var isDefault = importName === "default";
      var isNamed = !!importName && !isDefault;
      var isNamespace = importName === null;
      var importedSource = opts.importedSource,
          importedType = opts.importedType,
          importedInterop = opts.importedInterop,
          importingInterop = opts.importingInterop,
          ensureLiveReference = opts.ensureLiveReference,
          ensureNoContext = opts.ensureNoContext,
          nameHint = opts.nameHint,
          blockHoist = opts.blockHoist;
      var name = nameHint || importName;
      var isMod = (0, _isModule.default)(this._programPath);
      var isModuleForNode = isMod && importingInterop === "node";
      var isModuleForBabel = isMod && importingInterop === "babel";
      var builder = new _importBuilder.default(importedSource, this._programScope, this._hub);

      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }

        builder.import();

        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error("Unexpected interopType \"".concat(importedType, "\""));
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          var es6Default = "".concat(importedSource, "$es6Default");
          builder.import();

          if (isNamespace) {
            builder.default(es6Default).var(name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
            } else {
              builder.default(es6Default).var(name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder.default(es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder.import();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder.var(name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder.var(name).read(importName);
              builder.defaultInterop();
            } else {
              builder.var(importedSource).read(importName);
            }
          } else if (isDefault) {
            builder.var(name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder.var(name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder.import();

          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.default(importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder.import();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder.var(name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder.var(importedSource).read(name);
            } else {
              builder.prop(importName).var(name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }

        if (isModuleForNode) {
          builder.import();

          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault) {
            builder.default(name);
          } else if (isNamed) {
            builder.default(importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder.import();

          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault) {
            builder.default(name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder.var(name || importedSource);
          } else if (isDefault) {
            builder.var(name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder.var(importedSource).read(name);
            } else {
              builder.var(name).prop(importName);
            }
          }
        }
      } else {
        throw new Error("Unknown importedInterop \"".concat(importedInterop, "\"."));
      }

      var _builder$done = builder.done(),
          statements = _builder$done.statements,
          resultName = _builder$done.resultName;

      this._insertStatements(statements, blockHoist);

      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return t.sequenceExpression([t.numericLiteral(0), resultName]);
      }

      return resultName;
    }
  }, {
    key: "_insertStatements",
    value: function _insertStatements(statements) {
      var blockHoist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
      statements.forEach(function (node) {
        node._blockHoist = blockHoist;
      });

      var targetPath = this._programPath.get("body").find(function (p) {
        var val = p.node._blockHoist;
        return Number.isFinite(val) && val < 4;
      });

      if (targetPath) {
        targetPath.insertBefore(statements);
      } else {
        this._programPath.unshiftContainer("body", statements);
      }
    }
  }]);

  return ImportInjector;
}();

exports.default = ImportInjector;

},{"./import-builder":70,"./is-module":73,"@babel/types":242,"assert":278}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDefault = addDefault;
exports.addNamed = addNamed;
exports.addNamespace = addNamespace;
exports.addSideEffect = addSideEffect;
Object.defineProperty(exports, "ImportInjector", {
  enumerable: true,
  get: function get() {
    return _importInjector.default;
  }
});
Object.defineProperty(exports, "isModule", {
  enumerable: true,
  get: function get() {
    return _isModule.default;
  }
});

var _importInjector = _interopRequireDefault(require("./import-injector"));

var _isModule = _interopRequireDefault(require("./is-module"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function addDefault(path, importedSource, opts) {
  return new _importInjector.default(path).addDefault(importedSource, opts);
}

function addNamed(path, name, importedSource, opts) {
  return new _importInjector.default(path).addNamed(name, importedSource, opts);
}

function addNamespace(path, importedSource, opts) {
  return new _importInjector.default(path).addNamespace(importedSource, opts);
}

function addSideEffect(path, importedSource, opts) {
  return new _importInjector.default(path).addSideEffect(importedSource, opts);
}

},{"./import-injector":71,"./is-module":73}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isModule;

function isModule(path) {
  var sourceType = path.node.sourceType;

  if (sourceType !== "module" && sourceType !== "script") {
    throw path.buildCodeFrameError("Unknown sourceType \"".concat(sourceType, "\", cannot transform."));
  }

  return path.node.sourceType === "module";
}

},{}],74:[function(require,module,exports){
"use strict";

function _templateObject11() {
  var data = _taggedTemplateLiteral(["EXPORTS.NAME = VALUE"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n        EXPORTS.__esModule = true;\n      "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n        enumerable: true,\n        get: function() {\n          return NAMESPACE.IMPORT_NAME;\n        },\n      });\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["EXPORTS.EXPORT_NAME = NAMESPACE.IMPORT_NAME;"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["EXPORTS.NAME = NAMESPACE;"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["var NAME = SOURCE;"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
exports.ensureStatementsHoisted = ensureStatementsHoisted;
exports.wrapInterop = wrapInterop;
exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
Object.defineProperty(exports, "isModule", {
  enumerable: true,
  get: function get() {
    return _helperModuleImports.isModule;
  }
});
Object.defineProperty(exports, "hasExports", {
  enumerable: true,
  get: function get() {
    return _normalizeAndLoadMetadata.hasExports;
  }
});
Object.defineProperty(exports, "isSideEffectImport", {
  enumerable: true,
  get: function get() {
    return _normalizeAndLoadMetadata.isSideEffectImport;
  }
});

var _assert = _interopRequireDefault(require("assert"));

var t = _interopRequireWildcard(require("@babel/types"));

var _template = _interopRequireDefault(require("@babel/template"));

var _chunk = _interopRequireDefault(require("lodash/chunk"));

var _helperModuleImports = require("@babel/helper-module-imports");

var _rewriteThis = _interopRequireDefault(require("./rewrite-this"));

var _rewriteLiveReferences = _interopRequireDefault(require("./rewrite-live-references"));

var _normalizeAndLoadMetadata = _interopRequireWildcard(require("./normalize-and-load-metadata"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
  var exportName = _ref.exportName,
      strict = _ref.strict,
      allowTopLevelThis = _ref.allowTopLevelThis,
      strictMode = _ref.strictMode,
      loose = _ref.loose,
      noInterop = _ref.noInterop,
      lazy = _ref.lazy,
      esNamespaceOnly = _ref.esNamespaceOnly;
  (0, _assert.default)((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script");
  path.node.sourceType = "script";
  var meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
    noInterop: noInterop,
    loose: loose,
    lazy: lazy,
    esNamespaceOnly: esNamespaceOnly
  });

  if (!allowTopLevelThis) {
    (0, _rewriteThis.default)(path);
  }

  (0, _rewriteLiveReferences.default)(path, meta);

  if (strictMode !== false) {
    var hasStrict = path.node.directives.some(function (directive) {
      return directive.value.value === "use strict";
    });

    if (!hasStrict) {
      path.unshiftContainer("directives", t.directive(t.directiveLiteral("use strict")));
    }
  }

  var headers = [];

  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
    headers.push(buildESModuleHeader(meta, loose));
  }

  var nameList = buildExportNameListDeclaration(path, meta);

  if (nameList) {
    meta.exportNameListName = nameList.name;
    headers.push(nameList.statement);
  }

  headers.push.apply(headers, _toConsumableArray(buildExportInitializationStatements(path, meta, loose)));
  return {
    meta: meta,
    headers: headers
  };
}

function ensureStatementsHoisted(statements) {
  statements.forEach(function (header) {
    header._blockHoist = 3;
  });
}

function wrapInterop(programPath, expr, type) {
  if (type === "none") {
    return null;
  }

  var helper;

  if (type === "default") {
    helper = "interopRequireDefault";
  } else if (type === "namespace") {
    helper = "interopRequireWildcard";
  } else {
    throw new Error("Unknown interop: ".concat(type));
  }

  return t.callExpression(programPath.hub.addHelper(helper), [expr]);
}

function buildNamespaceInitStatements(metadata, sourceMetadata) {
  var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var statements = [];
  var srcNamespace = t.identifier(sourceMetadata.name);
  if (sourceMetadata.lazy) srcNamespace = t.callExpression(srcNamespace, []);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sourceMetadata.importsNamespace[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var localName = _step.value;
      if (localName === sourceMetadata.name) continue;
      statements.push(_template.default.statement(_templateObject())({
        NAME: localName,
        SOURCE: t.cloneNode(srcNamespace)
      }));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (loose) {
    statements.push.apply(statements, _toConsumableArray(buildReexportsFromMeta(metadata, sourceMetadata, loose)));
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = sourceMetadata.reexportNamespace[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var exportName = _step2.value;
      statements.push((sourceMetadata.lazy ? _template.default.statement(_templateObject2()) : _template.default.statement(_templateObject3()))({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: t.cloneNode(srcNamespace)
      }));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (sourceMetadata.reexportAll) {
    var statement = buildNamespaceReexport(metadata, t.cloneNode(srcNamespace), loose);
    statement.loc = sourceMetadata.reexportAll.loc;
    statements.push(statement);
  }

  return statements;
}

var getTemplateForReexport = function getTemplateForReexport(loose) {
  return loose ? _template.default.statement(_templateObject4()) : _template.default(_templateObject5());
};

var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, loose) {
  var namespace = metadata.lazy ? t.callExpression(t.identifier(metadata.name), []) : t.identifier(metadata.name);
  var templateForCurrentMode = getTemplateForReexport(loose);
  return Array.from(metadata.reexports, function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        exportName = _ref3[0],
        importName = _ref3[1];

    return templateForCurrentMode({
      EXPORTS: meta.exportName,
      EXPORT_NAME: exportName,
      NAMESPACE: t.cloneNode(namespace),
      IMPORT_NAME: importName
    });
  });
};

function buildESModuleHeader(metadata) {
  var enumerable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (enumerable ? _template.default.statement(_templateObject6()) : _template.default.statement(_templateObject7()))({
    EXPORTS: metadata.exportName
  });
}

function buildNamespaceReexport(metadata, namespace, loose) {
  return (loose ? _template.default.statement(_templateObject8()) : _template.default.statement(_templateObject9()))({
    NAMESPACE: namespace,
    EXPORTS: metadata.exportName,
    VERIFY_NAME_LIST: metadata.exportNameListName ? _template.default(_templateObject10())({
      EXPORTS_LIST: metadata.exportNameListName
    }) : null
  });
}

function buildExportNameListDeclaration(programPath, metadata) {
  var exportedVars = Object.create(null);
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = metadata.local.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var data = _step3.value;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = data.names[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _name = _step5.value;
          exportedVars[_name] = true;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var hasReexport = false;
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = metadata.source.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _data = _step4.value;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = _data.reexports.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var exportName = _step6.value;
          exportedVars[exportName] = true;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = _data.reexportNamespace[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _exportName = _step7.value;
          exportedVars[_exportName] = true;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      hasReexport = hasReexport || _data.reexportAll;
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
  var name = programPath.scope.generateUidIdentifier("exportNames");
  delete exportedVars.default;
  return {
    name: name.name,
    statement: t.variableDeclaration("var", [t.variableDeclarator(name, t.valueToNode(exportedVars))])
  };
}

function buildExportInitializationStatements(programPath, metadata) {
  var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var initStatements = [];
  var exportNames = [];
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = metadata.local[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var _step8$value = _slicedToArray(_step8.value, 2),
          localName = _step8$value[0],
          data = _step8$value[1];

      if (data.kind === "import") {} else if (data.kind === "hoisted") {
        initStatements.push(buildInitStatement(metadata, data.names, t.identifier(localName)));
      } else {
        exportNames.push.apply(exportNames, _toConsumableArray(data.names));
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  var _iteratorNormalCompletion9 = true;
  var _didIteratorError9 = false;
  var _iteratorError9 = undefined;

  try {
    for (var _iterator9 = metadata.source.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
      var _data2 = _step9.value;

      if (!loose) {
        initStatements.push.apply(initStatements, _toConsumableArray(buildReexportsFromMeta(metadata, _data2, loose)));
      }

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = _data2.reexportNamespace[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var exportName = _step10.value;
          exportNames.push(exportName);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError9 = true;
    _iteratorError9 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
        _iterator9.return();
      }
    } finally {
      if (_didIteratorError9) {
        throw _iteratorError9;
      }
    }
  }

  initStatements.push.apply(initStatements, _toConsumableArray((0, _chunk.default)(exportNames, 100).map(function (members) {
    return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());
  })));
  return initStatements;
}

function buildInitStatement(metadata, exportNames, initExpr) {
  return t.expressionStatement(exportNames.reduce(function (acc, exportName) {
    return _template.default.expression(_templateObject11())({
      EXPORTS: metadata.exportName,
      NAME: exportName,
      VALUE: acc
    });
  }, initExpr));
}

},{"./normalize-and-load-metadata":75,"./rewrite-live-references":76,"./rewrite-this":77,"@babel/helper-module-imports":72,"@babel/template":167,"@babel/types":242,"assert":278,"lodash/chunk":1003}],75:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasExports = hasExports;
exports.isSideEffectImport = isSideEffectImport;
exports.default = normalizeModuleAndLoadMetadata;

var _path = require("path");

var _helperSplitExportDeclaration = _interopRequireDefault(require("@babel/helper-split-export-declaration"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function hasExports(metadata) {
  return metadata.hasExports;
}

function isSideEffectImport(source) {
  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
}

function normalizeModuleAndLoadMetadata(programPath, exportName) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$noInterop = _ref.noInterop,
      noInterop = _ref$noInterop === void 0 ? false : _ref$noInterop,
      _ref$loose = _ref.loose,
      loose = _ref$loose === void 0 ? false : _ref$loose,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
      _ref$esNamespaceOnly = _ref.esNamespaceOnly,
      esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

  if (!exportName) {
    exportName = programPath.scope.generateUidIdentifier("exports").name;
  }

  nameAnonymousExports(programPath);

  var _getModuleMetadata = getModuleMetadata(programPath, {
    loose: loose,
    lazy: lazy
  }),
      local = _getModuleMetadata.local,
      source = _getModuleMetadata.source,
      hasExports = _getModuleMetadata.hasExports;

  removeModuleDeclarations(programPath);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          metadata = _step$value[1];

      if (metadata.importsNamespace.size > 0) {
        metadata.name = metadata.importsNamespace.values().next().value;
      }

      if (noInterop) metadata.interop = "none";else if (esNamespaceOnly) {
        if (metadata.interop === "namespace") {
          metadata.interop = "default";
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    exportName: exportName,
    exportNameListName: null,
    hasExports: hasExports,
    local: local,
    source: source
  };
}

function getModuleMetadata(programPath, _ref2) {
  var loose = _ref2.loose,
      lazy = _ref2.lazy;
  var localData = getLocalExportMetadata(programPath, loose);
  var sourceData = new Map();

  var getData = function getData(sourceNode) {
    var source = sourceNode.value;
    var data = sourceData.get(source);

    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
        interop: "none",
        loc: null,
        imports: new Map(),
        importsNamespace: new Set(),
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        lazy: false
      };
      sourceData.set(source, data);
    }

    return data;
  };

  var hasExports = false;
  programPath.get("body").forEach(function (child) {
    if (child.isImportDeclaration()) {
      var data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(function (spec) {
        if (spec.isImportDefaultSpecifier()) {
          var localName = spec.get("local").node.name;
          data.imports.set(localName, "default");
          var reexport = localData.get(localName);

          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(function (name) {
              data.reexports.set(name, "default");
            });
          }
        } else if (spec.isImportNamespaceSpecifier()) {
          var _localName = spec.get("local").node.name;
          data.importsNamespace.add(_localName);

          var _reexport = localData.get(_localName);

          if (_reexport) {
            localData.delete(_localName);

            _reexport.names.forEach(function (name) {
              data.reexportNamespace.add(name);
            });
          }
        } else if (spec.isImportSpecifier()) {
          var importName = spec.get("imported").node.name;
          var _localName2 = spec.get("local").node.name;
          data.imports.set(_localName2, importName);

          var _reexport2 = localData.get(_localName2);

          if (_reexport2) {
            localData.delete(_localName2);

            _reexport2.names.forEach(function (name) {
              data.reexports.set(name, importName);
            });
          }
        }
      });
    } else if (child.isExportAllDeclaration()) {
      hasExports = true;

      var _data = getData(child.node.source);

      if (!_data.loc) _data.loc = child.node.loc;
      _data.reexportAll = {
        loc: child.node.loc
      };
    } else if (child.isExportNamedDeclaration() && child.node.source) {
      hasExports = true;

      var _data2 = getData(child.node.source);

      if (!_data2.loc) _data2.loc = child.node.loc;
      child.get("specifiers").forEach(function (spec) {
        if (!spec.isExportSpecifier()) {
          throw spec.buildCodeFrameError("Unexpected export specifier type");
        }

        var importName = spec.get("local").node.name;
        var exportName = spec.get("exported").node.name;

        _data2.reexports.set(exportName, importName);

        if (exportName === "__esModule") {
          throw exportName.buildCodeFrameError('Illegal export "__esModule".');
        }
      });
    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
      hasExports = true;
    }
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = sourceData.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var metadata = _step2.value;
      var needsDefault = false;
      var needsNamed = false;

      if (metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }

      if (metadata.reexportAll) {
        needsNamed = true;
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = metadata.imports.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var importName = _step4.value;
          if (importName === "default") needsDefault = true;else needsNamed = true;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = metadata.reexports.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _importName = _step5.value;
          if (_importName === "default") needsDefault = true;else needsNamed = true;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (needsDefault && needsNamed) {
        metadata.interop = "namespace";
      } else if (needsDefault) {
        metadata.interop = "default";
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = sourceData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          source = _step3$value[0],
          _metadata = _step3$value[1];

      if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
        if (lazy === true) {
          _metadata.lazy = !/\./.test(source);
        } else if (Array.isArray(lazy)) {
          _metadata.lazy = lazy.indexOf(source) !== -1;
        } else if (typeof lazy === "function") {
          _metadata.lazy = lazy(source);
        } else {
          throw new Error(".lazy must be a boolean, string array, or function");
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return {
    hasExports: hasExports,
    local: localData,
    source: sourceData
  };
}

function getLocalExportMetadata(programPath, loose) {
  var bindingKindLookup = new Map();
  programPath.get("body").forEach(function (child) {
    var kind;

    if (child.isImportDeclaration()) {
      kind = "import";
    } else {
      if (child.isExportDefaultDeclaration()) child = child.get("declaration");

      if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child = child.get("declaration");
        } else if (loose && child.node.source && child.get("source").isStringLiteral()) {
          child.node.specifiers.forEach(function (specifier) {
            bindingKindLookup.set(specifier.local.name, "block");
          });
          return;
        }
      }

      if (child.isFunctionDeclaration()) {
        kind = "hoisted";
      } else if (child.isClassDeclaration()) {
        kind = "block";
      } else if (child.isVariableDeclaration({
        kind: "var"
      })) {
        kind = "var";
      } else if (child.isVariableDeclaration()) {
        kind = "block";
      } else {
        return;
      }
    }

    Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
      bindingKindLookup.set(name, kind);
    });
  });
  var localMetadata = new Map();

  var getLocalMetadata = function getLocalMetadata(idPath) {
    var localName = idPath.node.name;
    var metadata = localMetadata.get(localName);

    if (!metadata) {
      var kind = bindingKindLookup.get(localName);

      if (kind === undefined) {
        throw idPath.buildCodeFrameError("Exporting local \"".concat(localName, "\", which is not declared."));
      }

      metadata = {
        names: [],
        kind: kind
      };
      localMetadata.set(localName, metadata);
    }

    return metadata;
  };

  programPath.get("body").forEach(function (child) {
    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {
      if (child.node.declaration) {
        var declaration = child.get("declaration");
        var ids = declaration.getOuterBindingIdentifierPaths();
        Object.keys(ids).forEach(function (name) {
          if (name === "__esModule") {
            throw declaration.buildCodeFrameError('Illegal export "__esModule".');
          }

          getLocalMetadata(ids[name]).names.push(name);
        });
      } else {
        child.get("specifiers").forEach(function (spec) {
          var local = spec.get("local");
          var exported = spec.get("exported");

          if (exported.node.name === "__esModule") {
            throw exported.buildCodeFrameError('Illegal export "__esModule".');
          }

          getLocalMetadata(local).names.push(exported.node.name);
        });
      }
    } else if (child.isExportDefaultDeclaration()) {
      var _declaration = child.get("declaration");

      if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
        getLocalMetadata(_declaration.get("id")).names.push("default");
      } else {
        throw _declaration.buildCodeFrameError("Unexpected default expression export.");
      }
    }
  });
  return localMetadata;
}

function nameAnonymousExports(programPath) {
  programPath.get("body").forEach(function (child) {
    if (!child.isExportDefaultDeclaration()) return;
    (0, _helperSplitExportDeclaration.default)(child);
  });
}

function removeModuleDeclarations(programPath) {
  programPath.get("body").forEach(function (child) {
    if (child.isImportDeclaration()) {
      child.remove();
    } else if (child.isExportNamedDeclaration()) {
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      } else {
        child.remove();
      }
    } else if (child.isExportDefaultDeclaration()) {
      var declaration = child.get("declaration");

      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(declaration);
      } else {
        throw declaration.buildCodeFrameError("Unexpected default expression export.");
      }
    } else if (child.isExportAllDeclaration()) {
      child.remove();
    }
  });
}

},{"@babel/helper-split-export-declaration":84,"path":1052}],76:[function(require,module,exports){
"use strict";

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rewriteLiveReferences;

var _assert = _interopRequireDefault(require("assert"));

var t = _interopRequireWildcard(require("@babel/types"));

var _template = _interopRequireDefault(require("@babel/template"));

var _helperSimpleAccess = _interopRequireDefault(require("@babel/helper-simple-access"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function rewriteLiveReferences(programPath, metadata) {
  var imported = new Map();
  var exported = new Map();

  var requeueInParent = function requeueInParent(path) {
    programPath.requeue(path);
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = metadata.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          source = _step$value[0],
          data = _step$value[1];

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data.imports[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              localName = _step3$value[0],
              importName = _step3$value[1];

          imported.set(localName, [source, importName, null]);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data.importsNamespace[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _localName = _step4.value;
          imported.set(_localName, [source, null, _localName]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = metadata.local[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _exportMeta;

      var _step2$value = _slicedToArray(_step2.value, 2),
          local = _step2$value[0],
          _data = _step2$value[1];

      var exportMeta = exported.get(local);

      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }

      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  programPath.traverse(rewriteBindingInitVisitor, {
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    exported: exported
  });
  (0, _helperSimpleAccess.default)(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))));
  programPath.traverse(rewriteReferencesVisitor, {
    seen: new WeakSet(),
    metadata: metadata,
    requeueInParent: requeueInParent,
    scope: programPath.scope,
    imported: imported,
    exported: exported,
    buildImportReference: function buildImportReference(_ref, identNode) {
      var _ref2 = _slicedToArray(_ref, 3),
          source = _ref2[0],
          importName = _ref2[1],
          localName = _ref2[2];

      var meta = metadata.source.get(source);

      if (localName) {
        if (meta.lazy) identNode = t.callExpression(identNode, []);
        return identNode;
      }

      var namespace = t.identifier(meta.name);
      if (meta.lazy) namespace = t.callExpression(namespace, []);
      return t.memberExpression(namespace, t.identifier(importName));
    }
  });
}

var rewriteBindingInitVisitor = {
  ClassProperty: function ClassProperty(path) {
    path.skip();
  },
  Function: function Function(path) {
    path.skip();
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var requeueInParent = this.requeueInParent,
        exported = this.exported,
        metadata = this.metadata;
    var id = path.node.id;
    if (!id) throw new Error("Expected class to have a name");
    var localName = id.name;
    var exportNames = exported.get(localName) || [];

    if (exportNames.length > 0) {
      var statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));
      statement._blockHoist = path.node._blockHoist;
      requeueInParent(path.insertAfter(statement)[0]);
    }
  },
  VariableDeclaration: function VariableDeclaration(path) {
    var requeueInParent = this.requeueInParent,
        exported = this.exported,
        metadata = this.metadata;
    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
      var exportNames = exported.get(localName) || [];

      if (exportNames.length > 0) {
        var statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    });
  }
};

var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
  return (exportNames || []).reduce(function (expr, exportName) {
    return t.assignmentExpression("=", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr);
  }, localExpr);
};

var buildImportThrow = function buildImportThrow(localName) {
  return _template.default.expression.ast(_templateObject(), localName);
};

var rewriteReferencesVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path) {
    var seen = this.seen,
        buildImportReference = this.buildImportReference,
        scope = this.scope,
        imported = this.imported,
        requeueInParent = this.requeueInParent;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    var localName = path.node.name;
    var localBinding = path.scope.getBinding(localName);
    var rootBinding = scope.getBinding(localName);
    if (rootBinding !== localBinding) return;
    var importData = imported.get(localName);

    if (importData) {
      var ref = buildImportReference(importData, path.node);
      ref.loc = path.node.loc;

      if (path.parentPath.isCallExpression({
        callee: path.node
      }) && t.isMemberExpression(ref)) {
        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));
      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {
        var object = ref.object,
            property = ref.property;
        path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));
      } else {
        path.replaceWith(ref);
      }

      requeueInParent(path);
      path.skip();
    }
  },
  AssignmentExpression: {
    exit: function exit(path) {
      var _this = this;

      var scope = this.scope,
          seen = this.seen,
          imported = this.imported,
          exported = this.exported,
          requeueInParent = this.requeueInParent,
          buildImportReference = this.buildImportReference;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var left = path.get("left");
      if (left.isMemberExpression()) return;

      if (left.isIdentifier()) {
        var localName = left.node.name;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        var exportedNames = exported.get(localName);
        var importData = imported.get(localName);

        if ((exportedNames === null || exportedNames === void 0 ? void 0 : exportedNames.length) > 0 || importData) {
          (0, _assert.default)(path.node.operator === "=", "Path was not simplified");
          var assignment = path.node;

          if (importData) {
            assignment.left = buildImportReference(importData, assignment.left);
            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);
          }

          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
          requeueInParent(path);
        }
      } else {
        var ids = left.getOuterBindingIdentifiers();
        var programScopeIds = Object.keys(ids).filter(function (localName) {
          return scope.getBinding(localName) === path.scope.getBinding(localName);
        });
        var id = programScopeIds.find(function (localName) {
          return imported.has(localName);
        });

        if (id) {
          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);
        }

        var items = [];
        programScopeIds.forEach(function (localName) {
          var exportedNames = exported.get(localName) || [];

          if (exportedNames.length > 0) {
            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, t.identifier(localName)));
          }
        });

        if (items.length > 0) {
          var node = t.sequenceExpression(items);

          if (path.parentPath.isExpressionStatement()) {
            node = t.expressionStatement(node);
            node._blockHoist = path.parentPath.node._blockHoist;
          }

          var statement = path.insertAfter(node)[0];
          requeueInParent(statement);
        }
      }
    }
  }
};

},{"@babel/helper-simple-access":83,"@babel/template":167,"@babel/types":242,"assert":278}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rewriteThis;

function rewriteThis(programPath) {
  programPath.traverse(rewriteThisVisitor);
}

var rewriteThisVisitor = {
  ThisExpression: function ThisExpression(path) {
    path.replaceWith(path.scope.buildUndefinedNode());
  },
  Function: function Function(path) {
    if (!path.isArrowFunctionExpression()) path.skip();
  },
  ClassProperty: function ClassProperty(path) {
    path.skip();
  },
  ClassPrivateProperty: function ClassPrivateProperty(path) {
    path.skip();
  }
};

},{}],78:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _default(callee, thisNode, args) {
  if (args.length === 1 && t.isSpreadElement(args[0]) && t.isIdentifier(args[0].argument, {
    name: "arguments"
  })) {
    return t.callExpression(t.memberExpression(callee, t.identifier("apply")), [thisNode, args[0].argument]);
  } else {
    return t.callExpression(t.memberExpression(callee, t.identifier("call")), [thisNode].concat(_toConsumableArray(args)));
  }
}

},{"@babel/types":242}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.declare = declare;

function declare(builder) {
  return function (api, options, dirname) {
    if (!api.assertVersion) {
      api = Object.assign(copyApiObject(api), {
        assertVersion: function assertVersion(range) {
          throwVersionError(range, api.version);
        }
      });
    }

    return builder(api, options || {}, dirname);
  };
}

function copyApiObject(api) {
  var proto = null;

  if (typeof api.version === "string" && /^7\./.test(api.version)) {
    proto = Object.getPrototypeOf(api);

    if (proto && (!has(proto, "version") || !has(proto, "transform") || !has(proto, "template") || !has(proto, "types"))) {
      proto = null;
    }
  }

  return Object.assign({}, proto, api);
}

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function throwVersionError(range, version) {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }

    range = "^".concat(range, ".0.0-0");
  }

  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }

  var limit = Error.stackTraceLimit;

  if (typeof limit === "number" && limit < 25) {
    Error.stackTraceLimit = 25;
  }

  var err;

  if (version.slice(0, 2) === "7.") {
    err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"".concat(version, "\". ") + "You'll need to update your @babel/core version.");
  } else {
    err = new Error("Requires Babel \"".concat(range, "\", but was loaded with \"").concat(version, "\". ") + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
  }

  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }

  throw Object.assign(err, {
    code: "BABEL_VERSION_UNSUPPORTED",
    version: version,
    range: range
  });
}

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.is = is;
exports.pullFlag = pullFlag;

function _pull() {
  var data = _interopRequireDefault(require("lodash/pull"));

  _pull = function _pull() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function is(node, flag) {
  return node.type === "RegExpLiteral" && node.flags.indexOf(flag) >= 0;
}

function pullFlag(node, flag) {
  var flags = node.flags.split("");
  if (node.flags.indexOf(flag) < 0) return;
  (0, _pull().default)(flags, flag);
  node.flags = flags.join("");
}

},{"lodash/pull":1037}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _helperWrapFunction = _interopRequireDefault(require("@babel/helper-wrap-function"));

var _helperAnnotateAsPure = _interopRequireDefault(require("@babel/helper-annotate-as-pure"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var awaitVisitor = {
  Function: function Function(path) {
    path.skip();
  },
  AwaitExpression: function AwaitExpression(path, _ref) {
    var wrapAwait = _ref.wrapAwait;
    var argument = path.get("argument");

    if (path.parentPath.isYieldExpression()) {
      path.replaceWith(argument.node);
      return;
    }

    path.replaceWith(t.yieldExpression(wrapAwait ? t.callExpression(t.cloneNode(wrapAwait), [argument.node]) : argument.node));
  }
};

function _default(path, helpers) {
  path.traverse(awaitVisitor, {
    wrapAwait: helpers.wrapAwait
  });
  var isIIFE = checkIsIIFE(path);
  path.node.async = false;
  path.node.generator = true;
  (0, _helperWrapFunction.default)(path, t.cloneNode(helpers.wrapAsync));
  var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

  if (!isProperty && !isIIFE && path.isExpression()) {
    (0, _helperAnnotateAsPure.default)(path);
  }

  function checkIsIIFE(path) {
    if (path.parentPath.isCallExpression({
      callee: path.node
    })) {
      return true;
    }

    var parentPath = path.parentPath;

    if (parentPath.isMemberExpression() && t.isIdentifier(parentPath.node.property, {
      name: "bind"
    })) {
      var bindCall = parentPath.parentPath;
      return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && t.isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
        callee: bindCall.node
      });
    }

    return false;
  }
}

},{"@babel/helper-annotate-as-pure":57,"@babel/helper-wrap-function":85,"@babel/types":242}],82:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.environmentVisitor = void 0;

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _helperMemberExpressionToFunctions = _interopRequireDefault(require("@babel/helper-member-expression-to-functions"));

var _helperOptimiseCallExpression = _interopRequireDefault(require("@babel/helper-optimise-call-expression"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
  objectRef = t.cloneNode(objectRef);
  var targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier("prototype"));
  return t.callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}

function skipAllButComputedKey(path) {
  if (!path.node.computed) {
    path.skip();
    return;
  }

  var keys = t.VISITOR_KEYS[path.type];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var environmentVisitor = {
  TypeAnnotation: function TypeAnnotation(path) {
    path.skip();
  },
  Function: function Function(path) {
    if (path.isMethod()) return;
    if (path.isArrowFunctionExpression()) return;
    path.skip();
  },
  "Method|ClassProperty|ClassPrivateProperty": function MethodClassPropertyClassPrivateProperty(path) {
    skipAllButComputedKey(path);
  }
};
exports.environmentVisitor = environmentVisitor;

var visitor = _traverse.default.visitors.merge([environmentVisitor, {
  Super: function Super(path, state) {
    var node = path.node,
        parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      object: node
    })) return;
    state.handle(parentPath);
  }
}]);

var specHandlers = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
        node = superMember.node;
    var computed = node.computed,
        property = node.property;

    if (!computed) {
      return;
    }

    var memo = scope.maybeGenerateMemoised(property);

    if (!memo) {
      return;
    }

    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node = superMember.node,
        computed = _superMember$node.computed,
        property = _superMember$node.property;

    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }

    if (computed) {
      return t.cloneNode(property);
    }

    return t.stringLiteral(property.name);
  },
  get: function get(superMember) {
    return t.callExpression(this.file.addHelper("get"), [getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod), this.prop(superMember), t.thisExpression()]);
  },
  set: function set(superMember, value) {
    return t.callExpression(this.file.addHelper("set"), [getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod), this.prop(superMember), value, t.thisExpression(), t.booleanLiteral(superMember.isInStrictMode())]);
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args);
  }
};
var looseHandlers = Object.assign({}, specHandlers, {
  prop: function prop(superMember) {
    var property = superMember.node.property;

    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }

    return t.cloneNode(property);
  },
  get: function get(superMember) {
    var isStatic = this.isStatic,
        superRef = this.superRef;
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    var object;

    if (isStatic) {
      object = superRef ? t.cloneNode(superRef) : t.memberExpression(t.identifier("Function"), t.identifier("prototype"));
    } else {
      object = superRef ? t.memberExpression(t.cloneNode(superRef), t.identifier("prototype")) : t.memberExpression(t.identifier("Object"), t.identifier("prototype"));
    }

    return t.memberExpression(object, prop, computed);
  },
  set: function set(superMember, value) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return t.assignmentExpression("=", t.memberExpression(t.thisExpression(), prop, computed), value);
  },
  destructureSet: function destructureSet(superMember) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return t.memberExpression(t.thisExpression(), prop, computed);
  }
});

var ReplaceSupers =
/*#__PURE__*/
function () {
  function ReplaceSupers(opts) {
    _classCallCheck(this, ReplaceSupers);

    var path = opts.methodPath;
    this.methodPath = path;
    this.isStatic = path.isObjectMethod() || path.node.static;
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.superRef = opts.superRef;
    this.isLoose = opts.isLoose;
    this.opts = opts;
  }

  _createClass(ReplaceSupers, [{
    key: "getObjectRef",
    value: function getObjectRef() {
      return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
  }, {
    key: "replace",
    value: function replace() {
      var handler = this.isLoose ? looseHandlers : specHandlers;
      (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({
        file: this.file,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        superRef: this.superRef
      }, handler));
    }
  }]);

  return ReplaceSupers;
}();

exports.default = ReplaceSupers;

},{"@babel/helper-member-expression-to-functions":69,"@babel/helper-optimise-call-expression":78,"@babel/traverse":176,"@babel/types":242}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = simplifyAccess;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function simplifyAccess(path, bindingNames) {
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames: bindingNames,
    seen: new WeakSet()
  });
}

var simpleAssignmentVisitor = {
  UpdateExpression: {
    exit: function exit(path) {
      var scope = this.scope,
          bindingNames = this.bindingNames;
      var arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      var localName = arg.node.name;
      if (!bindingNames.has(localName)) return;

      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }

      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
        var operator = path.node.operator == "++" ? "+=" : "-=";
        path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));
      } else if (path.node.prefix) {
        path.replaceWith(t.assignmentExpression("=", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression("+", arg.node), t.numericLiteral(1))));
      } else {
        var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
        var varName = old.name;
        path.scope.push({
          id: old
        });
        var binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));
        path.replaceWith(t.sequenceExpression([t.assignmentExpression("=", t.identifier(varName), t.unaryExpression("+", arg.node)), t.assignmentExpression("=", t.cloneNode(arg.node), binary), t.identifier(varName)]));
      }
    }
  },
  AssignmentExpression: {
    exit: function exit(path) {
      var scope = this.scope,
          seen = this.seen,
          bindingNames = this.bindingNames;
      if (path.node.operator === "=") return;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var left = path.get("left");
      if (!left.isIdentifier()) return;
      var localName = left.node.name;
      if (!bindingNames.has(localName)) return;

      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }

      path.node.right = t.binaryExpression(path.node.operator.slice(0, -1), t.cloneNode(path.node.left), path.node.right);
      path.node.operator = "=";
    }
  }
};

},{"@babel/types":242}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = splitExportDeclaration;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function splitExportDeclaration(exportDeclaration) {
  if (!exportDeclaration.isExportDeclaration()) {
    throw new Error("Only export declarations can be splitted.");
  }

  var isDefault = exportDeclaration.isExportDefaultDeclaration();
  var declaration = exportDeclaration.get("declaration");
  var isClassDeclaration = declaration.isClassDeclaration();

  if (isDefault) {
    var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
    var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
    var id = declaration.node.id;
    var needBindingRegistration = false;

    if (!id) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier("default");

      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
        declaration.node.id = t.cloneNode(id);
      }
    }

    var updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration("var", [t.variableDeclarator(t.cloneNode(id), declaration.node)]);
    var updatedExportDeclaration = t.exportNamedDeclaration(null, [t.exportSpecifier(t.cloneNode(id), t.identifier("default"))]);
    exportDeclaration.insertAfter(updatedExportDeclaration);
    exportDeclaration.replaceWith(updatedDeclaration);

    if (needBindingRegistration) {
      scope.registerDeclaration(exportDeclaration);
    }

    return exportDeclaration;
  }

  if (exportDeclaration.get("specifiers").length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.");
  }

  var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
  var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
    return t.exportSpecifier(t.identifier(name), t.identifier(name));
  });
  var aliasDeclar = t.exportNamedDeclaration(null, specifiers);
  exportDeclaration.insertAfter(aliasDeclar);
  exportDeclaration.replaceWith(declaration.node);
  return exportDeclaration;
}

},{"@babel/types":242}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrapFunction;

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

var _template = _interopRequireDefault(require("@babel/template"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var buildAnonymousExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");

var buildNamedExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");

var buildDeclarationWrapper = (0, _template.default)("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

function classOrObjectMethod(path, callId) {
  var node = path.node;
  var body = node.body;
  var container = t.functionExpression(null, [], t.blockStatement(body.body), true);
  body.body = [t.returnStatement(t.callExpression(t.callExpression(callId, [container]), []))];
  node.async = false;
  node.generator = false;
  path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
}

function plainFunction(path, callId) {
  var node = path.node;
  var isDeclaration = path.isFunctionDeclaration();
  var functionId = node.id;
  var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

  if (path.isArrowFunctionExpression()) {
    path.arrowFunctionToExpression();
  }

  node.id = null;

  if (isDeclaration) {
    node.type = "FunctionExpression";
  }

  var built = t.callExpression(callId, [node]);
  var container = wrapper({
    NAME: functionId || null,
    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
    FUNCTION: built,
    PARAMS: node.params.reduce(function (acc, param) {
      acc.done = acc.done || t.isAssignmentPattern(param) || t.isRestElement(param);

      if (!acc.done) {
        acc.params.push(path.scope.generateUidIdentifier("x"));
      }

      return acc;
    }, {
      params: [],
      done: false
    }).params
  });

  if (isDeclaration) {
    path.replaceWith(container[0]);
    path.insertAfter(container[1]);
  } else {
    var retFunction = container.callee.body.body[1].argument;

    if (!functionId) {
      (0, _helperFunctionName.default)({
        node: retFunction,
        parent: path.parent,
        scope: path.scope
      });
    }

    if (!retFunction || retFunction.id || node.params.length) {
      path.replaceWith(container);
    } else {
      path.replaceWith(built);
    }
  }
}

function wrapFunction(path, callId) {
  if (path.isClassMethod() || path.isObjectMethod()) {
    classOrObjectMethod(path, callId);
  } else {
    plainFunction(path, callId);
  }
}

},{"@babel/helper-function-name":66,"@babel/template":167,"@babel/types":242}],86:[function(require,module,exports){
"use strict";

function _templateObject73() {
  var data = _taggedTemplateLiteral(["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"], ["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"]);

  _templateObject73 = function _templateObject73() {
    return data;
  };

  return data;
}

function _templateObject72() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateMethodSet() {\n    throw new TypeError(\"attempted to reassign private method\");\n  }\n"]);

  _templateObject72 = function _templateObject72() {
    return data;
  };

  return data;
}

function _templateObject71() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"]);

  _templateObject71 = function _templateObject71() {
    return data;
  };

  return data;
}

function _templateObject70() {
  var data = _taggedTemplateLiteral(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"]);

  _templateObject70 = function _templateObject70() {
    return data;
  };

  return data;
}

function _templateObject69() {
  var data = _taggedTemplateLiteral(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"]);

  _templateObject69 = function _templateObject69() {
    return data;
  };

  return data;
}

function _templateObject68() {
  var data = _taggedTemplateLiteral(["\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    return method;\n  }\n"]);

  _templateObject68 = function _templateObject68() {
    return data;
  };

  return data;
}

function _templateObject67() {
  var data = _taggedTemplateLiteral(["\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

  _templateObject67 = function _templateObject67() {
    return data;
  };

  return data;
}

function _templateObject66() {
  var data = _taggedTemplateLiteral(["\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

  _templateObject66 = function _templateObject66() {
    return data;
  };

  return data;
}

function _templateObject65() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"]);

  _templateObject65 = function _templateObject65() {
    return data;
  };

  return data;
}

function _templateObject64() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

  _templateObject64 = function _templateObject64() {
    return data;
  };

  return data;
}

function _templateObject63() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

  _templateObject63 = function _templateObject63() {
    return data;
  };

  return data;
}

function _templateObject62() {
  var data = _taggedTemplateLiteral(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"]);

  _templateObject62 = function _templateObject62() {
    return data;
  };

  return data;
}

function _templateObject61() {
  var data = _taggedTemplateLiteral(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"]);

  _templateObject61 = function _templateObject61() {
    return data;
  };

  return data;
}

function _templateObject60() {
  var data = _taggedTemplateLiteral(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            // This is a hack to avoid this being processed by 'transform-runtime'.\n            // See issue #9.\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"]);

  _templateObject60 = function _templateObject60() {
    return data;
  };

  return data;
}

function _templateObject59() {
  var data = _taggedTemplateLiteral(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"]);

  _templateObject59 = function _templateObject59() {
    return data;
  };

  return data;
}

function _templateObject58() {
  var data = _taggedTemplateLiteral(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"]);

  _templateObject58 = function _templateObject58() {
    return data;
  };

  return data;
}

function _templateObject57() {
  var data = _taggedTemplateLiteral(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"]);

  _templateObject57 = function _templateObject57() {
    return data;
  };

  return data;
}

function _templateObject56() {
  var data = _taggedTemplateLiteral(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"]);

  _templateObject56 = function _templateObject56() {
    return data;
  };

  return data;
}

function _templateObject55() {
  var data = _taggedTemplateLiteral(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"]);

  _templateObject55 = function _templateObject55() {
    return data;
  };

  return data;
}

function _templateObject54() {
  var data = _taggedTemplateLiteral(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n"]);

  _templateObject54 = function _templateObject54() {
    return data;
  };

  return data;
}

function _templateObject53() {
  var data = _taggedTemplateLiteral(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n"]);

  _templateObject53 = function _templateObject53() {
    return data;
  };

  return data;
}

function _templateObject52() {
  var data = _taggedTemplateLiteral(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    if (!(\n      Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\"\n    )) { return }\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"]);

  _templateObject52 = function _templateObject52() {
    return data;
  };

  return data;
}

function _templateObject51() {
  var data = _taggedTemplateLiteral(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n    if (!(\n      Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\"\n    )) { return }\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n    if (!(\n      Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\"\n    )) { return }\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"]);

  _templateObject51 = function _templateObject51() {
    return data;
  };

  return data;
}

function _templateObject50() {
  var data = _taggedTemplateLiteral(["\n  export default function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === \"[object Arguments]\"\n    ) return Array.from(iter);\n  }\n"]);

  _templateObject50 = function _templateObject50() {
    return data;
  };

  return data;
}

function _templateObject49() {
  var data = _taggedTemplateLiteral(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"]);

  _templateObject49 = function _templateObject49() {
    return data;
  };

  return data;
}

function _templateObject48() {
  var data = _taggedTemplateLiteral(["\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    }\n  }\n"]);

  _templateObject48 = function _templateObject48() {
    return data;
  };

  return data;
}

function _templateObject47() {
  var data = _taggedTemplateLiteral(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n  }\n"]);

  _templateObject47 = function _templateObject47() {
    return data;
  };

  return data;
}

function _templateObject46() {
  var data = _taggedTemplateLiteral(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();\n  }\n"]);

  _templateObject46 = function _templateObject46() {
    return data;
  };

  return data;
}

function _templateObject45() {
  var data = _taggedTemplateLiteral(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return arrayWithHoles(arr) || iterableToArrayLimitLoose(arr, i) || nonIterableRest();\n  }\n"]);

  _templateObject45 = function _templateObject45() {
    return data;
  };

  return data;
}

function _templateObject44() {
  var data = _taggedTemplateLiteral(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n  }\n"]);

  _templateObject44 = function _templateObject44() {
    return data;
  };

  return data;
}

function _templateObject43() {
  var data = _taggedTemplateLiteral(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"]);

  _templateObject43 = function _templateObject43() {
    return data;
  };

  return data;
}

function _templateObject42() {
  var data = _taggedTemplateLiteral(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"]);

  _templateObject42 = function _templateObject42() {
    return data;
  };

  return data;
}

function _templateObject41() {
  var data = _taggedTemplateLiteral(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"]);

  _templateObject41 = function _templateObject41() {
    return data;
  };

  return data;
}

function _templateObject40() {
  var data = _taggedTemplateLiteral(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"]);

  _templateObject40 = function _templateObject40() {
    return data;
  };

  return data;
}

function _templateObject39() {
  var data = _taggedTemplateLiteral(["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"]);

  _templateObject39 = function _templateObject39() {
    return data;
  };

  return data;
}

function _templateObject38() {
  var data = _taggedTemplateLiteral(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"]);

  _templateObject38 = function _templateObject38() {
    return data;
  };

  return data;
}

function _templateObject37() {
  var data = _taggedTemplateLiteral(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"]);

  _templateObject37 = function _templateObject37() {
    return data;
  };

  return data;
}

function _templateObject36() {
  var data = _taggedTemplateLiteral(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"]);

  _templateObject36 = function _templateObject36() {
    return data;
  };

  return data;
}

function _templateObject35() {
  var data = _taggedTemplateLiteral(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n"]);

  _templateObject35 = function _templateObject35() {
    return data;
  };

  return data;
}

function _templateObject34() {
  var data = _taggedTemplateLiteral(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"]);

  _templateObject34 = function _templateObject34() {
    return data;
  };

  return data;
}

function _templateObject33() {
  var data = _taggedTemplateLiteral(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n"]);

  _templateObject33 = function _templateObject33() {
    return data;
  };

  return data;
}

function _templateObject32() {
  var data = _taggedTemplateLiteral(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"]);

  _templateObject32 = function _templateObject32() {
    return data;
  };

  return data;
}

function _templateObject31() {
  var data = _taggedTemplateLiteral(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"]);

  _templateObject31 = function _templateObject31() {
    return data;
  };

  return data;
}

function _templateObject30() {
  var data = _taggedTemplateLiteral(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"]);

  _templateObject30 = function _templateObject30() {
    return data;
  };

  return data;
}

function _templateObject29() {
  var data = _taggedTemplateLiteral(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"]);

  _templateObject29 = function _templateObject29() {
    return data;
  };

  return data;
}

function _templateObject28() {
  var data = _taggedTemplateLiteral(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"]);

  _templateObject28 = function _templateObject28() {
    return data;
  };

  return data;
}

function _templateObject27() {
  var data = _taggedTemplateLiteral(["\n  function _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function () { return cache; };\n    return cache;\n  }\n\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"]);

  _templateObject27 = function _templateObject27() {
    return data;
  };

  return data;
}

function _templateObject26() {
  var data = _taggedTemplateLiteral(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"]);

  _templateObject26 = function _templateObject26() {
    return data;
  };

  return data;
}

function _templateObject25() {
  var data = _taggedTemplateLiteral(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"]);

  _templateObject25 = function _templateObject25() {
    return data;
  };

  return data;
}

function _templateObject24() {
  var data = _taggedTemplateLiteral(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"]);

  _templateObject24 = function _templateObject24() {
    return data;
  };

  return data;
}

function _templateObject23() {
  var data = _taggedTemplateLiteral(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"]);

  _templateObject23 = function _templateObject23() {
    return data;
  };

  return data;
}

function _templateObject22() {
  var data = _taggedTemplateLiteral(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _templateObject21() {
  var data = _taggedTemplateLiteral(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["\n  import defineProperty from \"defineProperty\";\n\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\n  // filters on symbol properties only. Returned string properties are always\n  // enumerable. It is good to use in objectSpread.\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n\n  export default function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n    return target;\n  }\n"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we're going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  export default function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _template = _interopRequireDefault(require("@babel/template"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var helpers = Object.create(null);
var _default = helpers;
exports.default = _default;

var helper = function helper(minVersion) {
  return function (tpl) {
    return {
      minVersion: minVersion,
      ast: function ast() {
        return _template.default.program.ast(tpl);
      }
    };
  };
};

helpers.typeof = helper("7.0.0-beta.0")(_templateObject());
helpers.jsx = helper("7.0.0-beta.0")(_templateObject2());
helpers.asyncIterator = helper("7.0.0-beta.0")(_templateObject3());
helpers.AwaitValue = helper("7.0.0-beta.0")(_templateObject4());
helpers.AsyncGenerator = helper("7.0.0-beta.0")(_templateObject5());
helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")(_templateObject6());
helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")(_templateObject7());
helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")(_templateObject8());
helpers.asyncToGenerator = helper("7.0.0-beta.0")(_templateObject9());
helpers.classCallCheck = helper("7.0.0-beta.0")(_templateObject10());
helpers.createClass = helper("7.0.0-beta.0")(_templateObject11());
helpers.defineEnumerableProperties = helper("7.0.0-beta.0")(_templateObject12());
helpers.defaults = helper("7.0.0-beta.0")(_templateObject13());
helpers.defineProperty = helper("7.0.0-beta.0")(_templateObject14());
helpers.extends = helper("7.0.0-beta.0")(_templateObject15());
helpers.objectSpread = helper("7.0.0-beta.0")(_templateObject16());
helpers.objectSpread2 = helper("7.5.0")(_templateObject17());
helpers.inherits = helper("7.0.0-beta.0")(_templateObject18());
helpers.inheritsLoose = helper("7.0.0-beta.0")(_templateObject19());
helpers.getPrototypeOf = helper("7.0.0-beta.0")(_templateObject20());
helpers.setPrototypeOf = helper("7.0.0-beta.0")(_templateObject21());
helpers.construct = helper("7.0.0-beta.0")(_templateObject22());
helpers.isNativeFunction = helper("7.0.0-beta.0")(_templateObject23());
helpers.wrapNativeSuper = helper("7.0.0-beta.0")(_templateObject24());
helpers.instanceof = helper("7.0.0-beta.0")(_templateObject25());
helpers.interopRequireDefault = helper("7.0.0-beta.0")(_templateObject26());
helpers.interopRequireWildcard = helper("7.0.0-beta.0")(_templateObject27());
helpers.newArrowCheck = helper("7.0.0-beta.0")(_templateObject28());
helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")(_templateObject29());
helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")(_templateObject30());
helpers.objectWithoutProperties = helper("7.0.0-beta.0")(_templateObject31());
helpers.assertThisInitialized = helper("7.0.0-beta.0")(_templateObject32());
helpers.possibleConstructorReturn = helper("7.0.0-beta.0")(_templateObject33());
helpers.superPropBase = helper("7.0.0-beta.0")(_templateObject34());
helpers.get = helper("7.0.0-beta.0")(_templateObject35());
helpers.set = helper("7.0.0-beta.0")(_templateObject36());
helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")(_templateObject37());
helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")(_templateObject38());
helpers.readOnlyError = helper("7.0.0-beta.0")(_templateObject39());
helpers.classNameTDZError = helper("7.0.0-beta.0")(_templateObject40());
helpers.temporalUndefined = helper("7.0.0-beta.0")(_templateObject41());
helpers.tdz = helper("7.5.5")(_templateObject42());
helpers.temporalRef = helper("7.0.0-beta.0")(_templateObject43());
helpers.slicedToArray = helper("7.0.0-beta.0")(_templateObject44());
helpers.slicedToArrayLoose = helper("7.0.0-beta.0")(_templateObject45());
helpers.toArray = helper("7.0.0-beta.0")(_templateObject46());
helpers.toConsumableArray = helper("7.0.0-beta.0")(_templateObject47());
helpers.arrayWithoutHoles = helper("7.0.0-beta.0")(_templateObject48());
helpers.arrayWithHoles = helper("7.0.0-beta.0")(_templateObject49());
helpers.iterableToArray = helper("7.0.0-beta.0")(_templateObject50());
helpers.iterableToArrayLimit = helper("7.0.0-beta.0")(_templateObject51());
helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")(_templateObject52());
helpers.nonIterableSpread = helper("7.0.0-beta.0")(_templateObject53());
helpers.nonIterableRest = helper("7.0.0-beta.0")(_templateObject54());
helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")(_templateObject55());
helpers.toPrimitive = helper("7.1.5")(_templateObject56());
helpers.toPropertyKey = helper("7.1.5")(_templateObject57());
helpers.initializerWarningHelper = helper("7.0.0-beta.0")(_templateObject58());
helpers.initializerDefineProperty = helper("7.0.0-beta.0")(_templateObject59());
helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")(_templateObject60());
helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")(_templateObject61());
helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")(_templateObject62());
helpers.classPrivateFieldGet = helper("7.0.0-beta.0")(_templateObject63());
helpers.classPrivateFieldSet = helper("7.0.0-beta.0")(_templateObject64());
helpers.classPrivateFieldDestructureSet = helper("7.4.4")(_templateObject65());
helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")(_templateObject66());
helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")(_templateObject67());
helpers.classStaticPrivateMethodGet = helper("7.3.2")(_templateObject68());
helpers.classStaticPrivateMethodSet = helper("7.3.2")(_templateObject69());
helpers.decorate = helper("7.1.5")(_templateObject70());
helpers.classPrivateMethodGet = helper("7.1.6")(_templateObject71());
helpers.classPrivateMethodSet = helper("7.1.6")(_templateObject72());
helpers.wrapRegExp = helper("7.2.6")(_templateObject73());

},{"@babel/template":167}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.minVersion = minVersion;
exports.getDependencies = getDependencies;
exports.ensure = ensure;
exports.default = exports.list = void 0;

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var t = _interopRequireWildcard(require("@babel/types"));

var _helpers = _interopRequireDefault(require("./helpers"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function makePath(path) {
  var parts = [];

  for (; path.parentPath; path = path.parentPath) {
    parts.push(path.key);
    if (path.inList) parts.push(path.listKey);
  }

  return parts.reverse().join(".");
}

function getHelperMetadata(file) {
  var globals = new Set();
  var localBindingNames = new Set();
  var dependencies = new Map();
  var exportName;
  var exportPath;
  var exportBindingAssignments = [];
  var importPaths = [];
  var importBindingsReferences = [];
  (0, _traverse.default)(file, {
    ImportDeclaration: function ImportDeclaration(child) {
      var name = child.node.source.value;

      if (!_helpers.default[name]) {
        throw child.buildCodeFrameError("Unknown helper ".concat(name));
      }

      if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
        throw child.buildCodeFrameError("Helpers can only import a default value");
      }

      var bindingIdentifier = child.node.specifiers[0].local;
      dependencies.set(bindingIdentifier, name);
      importPaths.push(makePath(child));
    },
    ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
      var decl = child.get("declaration");

      if (decl.isFunctionDeclaration()) {
        if (!decl.node.id) {
          throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
        }

        exportName = decl.node.id.name;
      }

      exportPath = makePath(child);
    },
    ExportAllDeclaration: function ExportAllDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    Statement: function Statement(child) {
      if (child.isModuleDeclaration()) return;
      child.skip();
    }
  });
  (0, _traverse.default)(file, {
    Program: function Program(path) {
      var bindings = path.scope.getAllBindings();
      Object.keys(bindings).forEach(function (name) {
        if (name === exportName) return;
        if (dependencies.has(bindings[name].identifier)) return;
        localBindingNames.add(name);
      });
    },
    ReferencedIdentifier: function ReferencedIdentifier(child) {
      var name = child.node.name;
      var binding = child.scope.getBinding(name, true);

      if (!binding) {
        globals.add(name);
      } else if (dependencies.has(binding.identifier)) {
        importBindingsReferences.push(makePath(child));
      }
    },
    AssignmentExpression: function AssignmentExpression(child) {
      var left = child.get("left");
      if (!(exportName in left.getBindingIdentifiers())) return;

      if (!left.isIdentifier()) {
        throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
      }

      var binding = child.scope.getBinding(exportName);

      if (binding && binding.scope.path.isProgram()) {
        exportBindingAssignments.push(makePath(child));
      }
    }
  });
  if (!exportPath) throw new Error("Helpers must default-export something.");
  exportBindingAssignments.reverse();
  return {
    globals: Array.from(globals),
    localBindingNames: Array.from(localBindingNames),
    dependencies: dependencies,
    exportBindingAssignments: exportBindingAssignments,
    exportPath: exportPath,
    exportName: exportName,
    importBindingsReferences: importBindingsReferences,
    importPaths: importPaths
  };
}

function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
  if (localBindings && !id) {
    throw new Error("Unexpected local bindings for module-based helpers.");
  }

  if (!id) return;
  var localBindingNames = metadata.localBindingNames,
      dependencies = metadata.dependencies,
      exportBindingAssignments = metadata.exportBindingAssignments,
      exportPath = metadata.exportPath,
      exportName = metadata.exportName,
      importBindingsReferences = metadata.importBindingsReferences,
      importPaths = metadata.importPaths;
  var dependenciesRefs = {};
  dependencies.forEach(function (name, id) {
    dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
  });
  var toRename = {};
  var bindings = new Set(localBindings || []);
  localBindingNames.forEach(function (name) {
    var newName = name;

    while (bindings.has(newName)) {
      newName = "_" + newName;
    }

    if (newName !== name) toRename[name] = newName;
  });

  if (id.type === "Identifier" && exportName !== id.name) {
    toRename[exportName] = id.name;
  }

  (0, _traverse.default)(file, {
    Program: function Program(path) {
      var exp = path.get(exportPath);
      var imps = importPaths.map(function (p) {
        return path.get(p);
      });
      var impsBindingRefs = importBindingsReferences.map(function (p) {
        return path.get(p);
      });
      var decl = exp.get("declaration");

      if (id.type === "Identifier") {
        if (decl.isFunctionDeclaration()) {
          exp.replaceWith(decl);
        } else {
          exp.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(id, decl.node)]));
        }
      } else if (id.type === "MemberExpression") {
        if (decl.isFunctionDeclaration()) {
          exportBindingAssignments.forEach(function (assignPath) {
            var assign = path.get(assignPath);
            assign.replaceWith(t.assignmentExpression("=", id, assign.node));
          });
          exp.replaceWith(decl);
          path.pushContainer("body", t.expressionStatement(t.assignmentExpression("=", id, t.identifier(exportName))));
        } else {
          exp.replaceWith(t.expressionStatement(t.assignmentExpression("=", id, decl.node)));
        }
      } else {
        throw new Error("Unexpected helper format.");
      }

      Object.keys(toRename).forEach(function (name) {
        path.scope.rename(name, toRename[name]);
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = imps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _path = _step.value;

          _path.remove();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = impsBindingRefs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _path2 = _step2.value;
          var node = t.cloneNode(dependenciesRefs[_path2.node.name]);

          _path2.replaceWith(node);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      path.stop();
    }
  });
}

var helperData = Object.create(null);

function loadHelper(name) {
  if (!helperData[name]) {
    var helper = _helpers.default[name];

    if (!helper) {
      throw Object.assign(new ReferenceError("Unknown helper ".concat(name)), {
        code: "BABEL_HELPER_UNKNOWN",
        helper: name
      });
    }

    var fn = function fn() {
      return t.file(helper.ast());
    };

    var metadata = getHelperMetadata(fn());
    helperData[name] = {
      build: function build(getDependency, id, localBindings) {
        var file = fn();
        permuteHelperAST(file, metadata, id, localBindings, getDependency);
        return {
          nodes: file.program.body,
          globals: metadata.globals
        };
      },
      minVersion: function minVersion() {
        return helper.minVersion;
      },
      dependencies: metadata.dependencies
    };
  }

  return helperData[name];
}

function get(name, getDependency, id, localBindings) {
  return loadHelper(name).build(getDependency, id, localBindings);
}

function minVersion(name) {
  return loadHelper(name).minVersion();
}

function getDependencies(name) {
  return Array.from(loadHelper(name).dependencies.values());
}

function ensure(name) {
  loadHelper(name);
}

var list = Object.keys(_helpers.default).map(function (name) {
  return name.replace(/^_/, "");
}).filter(function (name) {
  return name !== "__esModule";
});
exports.list = list;
var _default = get;
exports.default = _default;

},{"./helpers":86,"@babel/traverse":176,"@babel/types":242}],88:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldHighlight = shouldHighlight;
exports.getChalk = getChalk;
exports.default = highlight;

function _jsTokens() {
  var data = _interopRequireWildcard(require("js-tokens"));

  _jsTokens = function _jsTokens() {
    return data;
  };

  return data;
}

function _esutils() {
  var data = _interopRequireDefault(require("esutils"));

  _esutils = function _esutils() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require("chalk"));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,
    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
var JSX_TAG = /^[a-z][\w-]*$/i;
var BRACKET = /^[()[\]{}]$/;

function getTokenType(match) {
  var _match$slice = match.slice(-2),
      _match$slice2 = _slicedToArray(_match$slice, 2),
      offset = _match$slice2[0],
      text = _match$slice2[1];

  var token = (0, _jsTokens().matchToToken)(match);

  if (token.type === "name") {
    if (_esutils().default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
    return "punctuator";
  }

  return token.type;
}

function highlightTokens(defs, text) {
  return text.replace(_jsTokens().default, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = getTokenType(args);
    var colorize = defs[type];

    if (colorize) {
      return args[0].split(NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

function shouldHighlight(options) {
  return _chalk().default.supportsColor || options.forceColor;
}

function getChalk(options) {
  var chalk = _chalk().default;

  if (options.forceColor) {
    chalk = new (_chalk().default.constructor)({
      enabled: true,
      level: 1
    });
  }

  return chalk;
}

function highlight(code) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (shouldHighlight(options)) {
    var chalk = getChalk(options);
    var defs = getDefs(chalk);
    return highlightTokens(defs, code);
  } else {
    return code;
  }
}

},{"chalk":296,"esutils":836,"js-tokens":843}],89:[function(require,module,exports){
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop != null ? conf.binop : null;
  this.updateContext = null;
};

var keywords = new Map();

function createKeyword(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.keyword = name;
  var token = new TokenType(name, options);
  keywords.set(name, token);
  return token;
}

function createBinop(name, binop) {
  return new TokenType(name, {
    beforeExpr: beforeExpr,
    binop: binop
  });
}

var types = {
  num: new TokenType("num", {
    startsExpr: startsExpr
  }),
  bigint: new TokenType("bigint", {
    startsExpr: startsExpr
  }),
  regexp: new TokenType("regexp", {
    startsExpr: startsExpr
  }),
  string: new TokenType("string", {
    startsExpr: startsExpr
  }),
  name: new TokenType("name", {
    startsExpr: startsExpr
  }),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceBarL: new TokenType("{|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", {
    beforeExpr: beforeExpr
  }),
  semi: new TokenType(";", {
    beforeExpr: beforeExpr
  }),
  colon: new TokenType(":", {
    beforeExpr: beforeExpr
  }),
  doubleColon: new TokenType("::", {
    beforeExpr: beforeExpr
  }),
  dot: new TokenType("."),
  question: new TokenType("?", {
    beforeExpr: beforeExpr
  }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", {
    beforeExpr: beforeExpr
  }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", {
    beforeExpr: beforeExpr
  }),
  backQuote: new TokenType("`", {
    startsExpr: startsExpr
  }),
  dollarBraceL: new TokenType("${", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  at: new TokenType("@"),
  hash: new TokenType("#", {
    startsExpr: startsExpr
  }),
  interpreterDirective: new TokenType("#!..."),
  eq: new TokenType("=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  assign: new TokenType("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  incDec: new TokenType("++/--", {
    prefix: prefix,
    postfix: postfix,
    startsExpr: startsExpr
  }),
  bang: new TokenType("!", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  tilde: new TokenType("~", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 2),
  logicalAND: createBinop("&&", 3),
  bitwiseOR: createBinop("|", 4),
  bitwiseXOR: createBinop("^", 5),
  bitwiseAND: createBinop("&", 6),
  equality: createBinop("==/!=/===/!==", 7),
  relational: createBinop("</>/<=/>=", 8),
  bitShift: createBinop("<</>>/>>>", 9),
  plusMin: new TokenType("+/-", {
    beforeExpr: beforeExpr,
    binop: 10,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  modulo: new TokenType("%", {
    beforeExpr: beforeExpr,
    binop: 11,
    startsExpr: startsExpr
  }),
  star: createBinop("*", 11),
  slash: createBinop("/", 11),
  exponent: new TokenType("**", {
    beforeExpr: beforeExpr,
    binop: 12,
    rightAssociative: true
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr: beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr: beforeExpr
  }),
  _do: createKeyword("do", {
    isLoop: isLoop,
    beforeExpr: beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr: beforeExpr
  }),
  _finally: createKeyword("finally"),
  _for: createKeyword("for", {
    isLoop: isLoop
  }),
  _function: createKeyword("function", {
    startsExpr: startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr: beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _while: createKeyword("while", {
    isLoop: isLoop
  }),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr: startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr: startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr: startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr: beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr: startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr: startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr: startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr: startsExpr
  }),
  _in: createKeyword("in", {
    beforeExpr: beforeExpr,
    binop: 8
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr: beforeExpr,
    binop: 8
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  })
};
var SCOPE_OTHER = 0,
    SCOPE_PROGRAM = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS = 256,
    SCOPE_TS_MODULE = 512,
    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;

function functionFlags(isAsync, isGenerator) {
  return SCOPE_FUNCTION | (isAsync ? SCOPE_ASYNC : 0) | (isGenerator ? SCOPE_GENERATOR : 0);
}

var BIND_KIND_VALUE = 1,
    BIND_KIND_TYPE = 2,
    BIND_SCOPE_VAR = 4,
    BIND_SCOPE_LEXICAL = 8,
    BIND_SCOPE_FUNCTION = 16,
    BIND_FLAGS_NONE = 64,
    BIND_FLAGS_CLASS = 128,
    BIND_FLAGS_TS_ENUM = 256,
    BIND_FLAGS_TS_CONST_ENUM = 512,
    BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
    BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;

function isSimpleProperty(node) {
  return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estree = function estree(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
      }

      _createClass(_class, [{
        key: "estreeParseRegExpLiteral",
        value: function estreeParseRegExpLiteral(_ref) {
          var pattern = _ref.pattern,
              flags = _ref.flags;
          var regex = null;

          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {}

          var node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern: pattern,
            flags: flags
          };
          return node;
        }
      }, {
        key: "estreeParseLiteral",
        value: function estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
      }, {
        key: "directiveToStmt",
        value: function directiveToStmt(directive) {
          var directiveLiteral = directive.value;
          var stmt = this.startNodeAt(directive.start, directive.loc.start);
          var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.value;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
        }
      }, {
        key: "initFunction",
        value: function initFunction(node, isAsync) {
          _get(_getPrototypeOf(_class.prototype), "initFunction", this).call(this, node, isAsync);

          node.expression = false;
        }
      }, {
        key: "checkDeclaration",
        value: function checkDeclaration(node) {
          if (isSimpleProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            _get(_getPrototypeOf(_class.prototype), "checkDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "checkGetterSetterParams",
        value: function checkGetterSetterParams(method) {
          var prop = method;
          var paramCount = prop.kind === "get" ? 0 : 1;
          var start = prop.start;

          if (prop.value.params.length !== paramCount) {
            if (prop.kind === "get") {
              this.raise(start, "getter must not have any formal parameters");
            } else {
              this.raise(start, "setter must have exactly one formal parameter");
            }
          } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raise(start, "setter function argument must not be a rest parameter");
          }
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          var _this = this;

          var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
          var checkClashes = arguments.length > 2 ? arguments[2] : undefined;
          var contextDescription = arguments.length > 3 ? arguments[3] : undefined;
          var disallowLetBinding = arguments.length > 4 ? arguments[4] : undefined;

          switch (expr.type) {
            case "ObjectPattern":
              expr.properties.forEach(function (prop) {
                _this.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
              });
              break;

            default:
              _get(_getPrototypeOf(_class.prototype), "checkLVal", this).call(this, expr, bindingType, checkClashes, contextDescription, disallowLetBinding);

          }
        }
      }, {
        key: "checkDuplicatedProto",
        value: function checkDuplicatedProto(prop, protoRef) {
          if (prop.type === "SpreadElement" || prop.computed || prop.method || prop.shorthand) {
            return;
          }

          var key = prop.key;
          var name = key.type === "Identifier" ? key.name : String(key.value);

          if (name === "__proto__" && prop.kind === "init") {
            if (protoRef.used && !protoRef.start) {
              protoRef.start = key.start;
            }

            protoRef.used = true;
          }
        }
      }, {
        key: "isStrictBody",
        value: function isStrictBody(node) {
          var isBlockStatement = node.body.type === "BlockStatement";

          if (isBlockStatement && node.body.body.length > 0) {
            for (var _i = 0, _node$body$body = node.body.body; _i < _node$body$body.length; _i++) {
              var directive = _node$body$body[_i];

              if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
                if (directive.expression.value === "use strict") return true;
              } else {
                break;
              }
            }
          }

          return false;
        }
      }, {
        key: "isValidDirective",
        value: function isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
        }
      }, {
        key: "stmtToDirective",
        value: function stmtToDirective(stmt) {
          var directive = _get(_getPrototypeOf(_class.prototype), "stmtToDirective", this).call(this, stmt);

          var value = stmt.expression.value;
          directive.value.value = value;
          return directive;
        }
      }, {
        key: "parseBlockBody",
        value: function parseBlockBody(node, allowDirectives, topLevel, end) {
          var _this2 = this;

          _get(_getPrototypeOf(_class.prototype), "parseBlockBody", this).call(this, node, allowDirectives, topLevel, end);

          var directiveStatements = node.directives.map(function (d) {
            return _this2.directiveToStmt(d);
          });
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }

          classBody.body.push(method);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refShorthandDefaultPos) {
          switch (this.state.type) {
            case types.regexp:
              return this.estreeParseRegExpLiteral(this.state.value);

            case types.num:
            case types.string:
              return this.estreeParseLiteral(this.state.value);

            case types._null:
              return this.estreeParseLiteral(null);

            case types._true:
              return this.estreeParseLiteral(true);

            case types._false:
              return this.estreeParseLiteral(false);

            default:
              return _get(_getPrototypeOf(_class.prototype), "parseExprAtom", this).call(this, refShorthandDefaultPos);
          }
        }
      }, {
        key: "parseLiteral",
        value: function parseLiteral(value, type, startPos, startLoc) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseLiteral", this).call(this, value, type, startPos, startLoc);

          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpression) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          _get(_getPrototypeOf(_class.prototype), "parseFunctionBody", this).call(this, node, allowExpression, isMethod);

          node.expression = node.body.type !== "BlockStatement";
        }
      }, {
        key: "parseMethod",
        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
          var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
          var funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = _get(_getPrototypeOf(_class.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          type = type === "ClassMethod" ? "MethodDefinition" : type;
          return this.finishNode(node, type);
        }
      }, {
        key: "parseObjectMethod",
        value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern, containsEsc);

          if (node) {
            node.type = "Property";
            if (node.kind === "method") node.kind = "init";
            node.shorthand = false;
          }

          return node;
        }
      }, {
        key: "parseObjectProperty",
        value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseObjectProperty", this).call(this, prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

          if (node) {
            node.kind = "init";
            node.type = "Property";
          }

          return node;
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node, isBinding, contextDescription) {
          if (isSimpleProperty(node)) {
            this.toAssignable(node.value, isBinding, contextDescription);
            return node;
          }

          return _get(_getPrototypeOf(_class.prototype), "toAssignable", this).call(this, node, isBinding, contextDescription);
        }
      }, {
        key: "toAssignableObjectExpressionProp",
        value: function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
          if (prop.kind === "get" || prop.kind === "set") {
            throw this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          } else if (prop.method) {
            throw this.raise(prop.key.start, "Object pattern can't contain methods");
          } else {
            _get(_getPrototypeOf(_class.prototype), "toAssignableObjectExpressionProp", this).call(this, prop, isBinding, isLast);
          }
        }
      }]);

      return _class;
    }(superClass)
  );
};

var lineBreak = /\r\n?|[\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", false),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true),
  functionStatement: new TokContext("function", false)
};

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();

  if (out === types$1.braceStatement && this.curContext().token === "function") {
    out = this.state.context.pop();
  }

  this.state.exprAllowed = !out.isExpr;
};

types.name.updateContext = function (prevType) {
  var allowed = false;

  if (prevType !== types.dot) {
    if (this.state.value === "of" && !this.state.exprAllowed || this.state.value === "yield" && this.scope.inGenerator) {
      allowed = true;
    }
  }

  this.state.exprAllowed = allowed;

  if (this.state.isIterator) {
    this.state.isIterator = false;
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.state.context.push(types$1.functionExpression);
  } else {
    this.state.context.push(types$1.functionStatement);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }

  this.state.exprAllowed = false;
};

var reservedWords = {
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

var isReservedWord = function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
};

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}

var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIteratorStart(current, next) {
  return current === 64 && next === 64;
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

var reservedTypes = ["any", "bool", "boolean", "empty", "false", "mixed", "null", "number", "static", "string", "true", "typeof", "void", "interface", "extends", "_"];

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(state) {
  return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
}

var exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};

function partition(list, test) {
  var list1 = [];
  var list2 = [];

  for (var i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;

var flow = function flow(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass2) {
      _inherits(_class2, _superClass2);

      function _class2(options, input) {
        var _this3;

        _classCallCheck(this, _class2);

        _this3 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this, options, input));
        _this3.flowPragma = undefined;
        return _this3;
      }

      _createClass(_class2, [{
        key: "shouldParseTypes",
        value: function shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
      }, {
        key: "shouldParseEnums",
        value: function shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
      }, {
        key: "finishToken",
        value: function finishToken(type, val) {
          if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
            if (this.flowPragma === undefined) {
              this.flowPragma = null;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "finishToken", this).call(this, type, val);
        }
      }, {
        key: "addComment",
        value: function addComment(comment) {
          if (this.flowPragma === undefined) {
            var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches) ;else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "addComment", this).call(this, comment);
        }
      }, {
        key: "flowParseTypeInitialiser",
        value: function flowParseTypeInitialiser(tok) {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || types.colon);
          var type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
      }, {
        key: "flowParsePredicate",
        value: function flowParsePredicate() {
          var node = this.startNode();
          var moduloLoc = this.state.startLoc;
          var moduloPos = this.state.start;
          this.expect(types.modulo);
          var checksLoc = this.state.startLoc;
          this.expectContextual("checks");

          if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
            this.raise(moduloPos, "Spaces between % and checks are not allowed here.");
          }

          if (this.eat(types.parenL)) {
            node.value = this.parseExpression();
            this.expect(types.parenR);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
      }, {
        key: "flowParseTypeAndPredicateInitialiser",
        value: function flowParseTypeAndPredicateInitialiser() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(types.colon);
          var type = null;
          var predicate = null;

          if (this.match(types.modulo)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;

            if (this.match(types.modulo)) {
              predicate = this.flowParsePredicate();
            }
          }

          return [type, predicate];
        }
      }, {
        key: "flowParseDeclareClass",
        value: function flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
      }, {
        key: "flowParseDeclareFunction",
        value: function flowParseDeclareFunction(node) {
          this.next();
          var id = node.id = this.parseIdentifier();
          var typeNode = this.startNode();
          var typeContainer = this.startNode();

          if (this.isRelational("<")) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }

          this.expect(types.parenL);
          var tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          this.expect(types.parenR);

          var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

          var _this$flowParseTypeAn2 = _slicedToArray(_this$flowParseTypeAn, 2);

          typeNode.returnType = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          return this.finishNode(node, "DeclareFunction");
        }
      }, {
        key: "flowParseDeclare",
        value: function flowParseDeclare(node, insideModule) {
          if (this.match(types._class)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(types._function)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(types._var)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual("module")) {
            if (this.match(types.dot)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(this.state.lastTokStart, "`declare module` cannot be used inside another `declare module`");
              }

              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual("type")) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual("opaque")) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual("interface")) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(types._export)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
      }, {
        key: "flowParseDeclareVariable",
        value: function flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
      }, {
        key: "flowParseDeclareModule",
        value: function flowParseDeclareModule(node) {
          var _this4 = this;

          this.scope.enter(SCOPE_OTHER);

          if (this.match(types.string)) {
            node.id = this.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }

          var bodyNode = node.body = this.startNode();
          var body = bodyNode.body = [];
          this.expect(types.braceL);

          while (!this.match(types.braceR)) {
            var _bodyNode = this.startNode();

            if (this.match(types._import)) {
              this.next();

              if (!this.isContextual("type") && !this.match(types._typeof)) {
                this.raise(this.state.lastTokStart, "Imports within a `declare module` body must always be `import type` or `import typeof`");
              }

              this.parseImport(_bodyNode);
            } else {
              this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
              _bodyNode = this.flowParseDeclare(_bodyNode, true);
            }

            body.push(_bodyNode);
          }

          this.scope.exit();
          this.expect(types.braceR);
          this.finishNode(bodyNode, "BlockStatement");
          var kind = null;
          var hasModuleExport = false;
          var errorMessage = "Found both `declare module.exports` and `declare export` in the same module. " + "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
          body.forEach(function (bodyElement) {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                _this4.raise(bodyElement.start, errorMessage);
              }

              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                _this4.raise(bodyElement.start, "Duplicate `declare module.exports` statement");
              }

              if (kind === "ES") _this4.raise(bodyElement.start, errorMessage);
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
      }, {
        key: "flowParseDeclareExportDeclaration",
        value: function flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(types._export);

          if (this.eat(types._default)) {
            if (this.match(types._function) || this.match(types._class)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }

            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
              var label = this.state.value;
              var suggestion = exportSuggestions[label];
              this.unexpected(this.state.start, "`declare export ".concat(label, "` is not supported. Use `").concat(suggestion, "` instead"));
            }

            if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
          }

          throw this.unexpected();
        }
      }, {
        key: "flowParseDeclareModuleExports",
        value: function flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual("exports");
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
      }, {
        key: "flowParseDeclareTypeAlias",
        value: function flowParseDeclareTypeAlias(node) {
          this.next();
          this.flowParseTypeAlias(node);
          node.type = "DeclareTypeAlias";
          return node;
        }
      }, {
        key: "flowParseDeclareOpaqueType",
        value: function flowParseDeclareOpaqueType(node) {
          this.next();
          this.flowParseOpaqueType(node, true);
          node.type = "DeclareOpaqueType";
          return node;
        }
      }, {
        key: "flowParseDeclareInterface",
        value: function flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
      }, {
        key: "flowParseInterfaceish",
        value: function flowParseInterfaceish(node) {
          var isClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.flowParseRestrictedIdentifier(!isClass);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.extends = [];
          node.implements = [];
          node.mixins = [];

          if (this.eat(types._extends)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(types.comma));
          }

          if (this.isContextual("mixins")) {
            this.next();

            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          if (this.isContextual("implements")) {
            this.next();

            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
      }, {
        key: "flowParseInterfaceExtends",
        value: function flowParseInterfaceExtends() {
          var node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          return this.finishNode(node, "InterfaceExtends");
        }
      }, {
        key: "flowParseInterface",
        value: function flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
      }, {
        key: "checkNotUnderscore",
        value: function checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(this.state.start, "`_` is only allowed as a type argument to call or new");
          }
        }
      }, {
        key: "checkReservedType",
        value: function checkReservedType(word, startLoc) {
          if (reservedTypes.indexOf(word) > -1) {
            this.raise(startLoc, "Cannot overwrite reserved type ".concat(word));
          }
        }
      }, {
        key: "flowParseRestrictedIdentifier",
        value: function flowParseRestrictedIdentifier(liberal) {
          this.checkReservedType(this.state.value, this.state.start);
          return this.parseIdentifier(liberal);
        }
      }, {
        key: "flowParseTypeAlias",
        value: function flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier();
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.right = this.flowParseTypeInitialiser(types.eq);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
      }, {
        key: "flowParseOpaqueType",
        value: function flowParseOpaqueType(node, declare) {
          this.expectContextual("type");
          node.id = this.flowParseRestrictedIdentifier(true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.supertype = null;

          if (this.match(types.colon)) {
            node.supertype = this.flowParseTypeInitialiser(types.colon);
          }

          node.impltype = null;

          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(types.eq);
          }

          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
      }, {
        key: "flowParseTypeParameter",
        value: function flowParseTypeParameter() {
          var requireDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var nodeStart = this.state.start;
          var node = this.startNode();
          var variance = this.flowParseVariance();
          var ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;

          if (this.match(types.eq)) {
            this.eat(types.eq);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(nodeStart, "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.");
            }
          }

          return this.finishNode(node, "TypeParameter");
        }
      }, {
        key: "flowParseTypeParameterDeclaration",
        value: function flowParseTypeParameterDeclaration() {
          var oldInType = this.state.inType;
          var node = this.startNode();
          node.params = [];
          this.state.inType = true;

          if (this.isRelational("<") || this.match(types.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          var defaultRequired = false;

          do {
            var typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);

            if (typeParameter.default) {
              defaultRequired = true;
            }

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          } while (!this.isRelational(">"));

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
      }, {
        key: "flowParseTypeParameterInstantiation",
        value: function flowParseTypeParameterInstantiation() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseType());

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          }

          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseTypeParameterInstantiationCallOrNew",
        value: function flowParseTypeParameterInstantiationCallOrNew() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          }

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseInterfaceType",
        value: function flowParseInterfaceType() {
          var node = this.startNode();
          this.expectContextual("interface");
          node.extends = [];

          if (this.eat(types._extends)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
      }, {
        key: "flowParseObjectPropertyKey",
        value: function flowParseObjectPropertyKey() {
          return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
        }
      }, {
        key: "flowParseObjectTypeIndexer",
        value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;

          if (this.lookahead().type === types.colon) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }

          this.expect(types.bracketR);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
      }, {
        key: "flowParseObjectTypeInternalSlot",
        value: function flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(types.bracketR);
          this.expect(types.bracketR);

          if (this.isRelational("<") || this.match(types.parenL)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;

            if (this.eat(types.question)) {
              node.optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
          }

          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
      }, {
        key: "flowParseObjectTypeMethodish",
        value: function flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          this.expect(types.parenL);

          while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            node.params.push(this.flowParseFunctionTypeParam());

            if (!this.match(types.parenR)) {
              this.expect(types.comma);
            }
          }

          if (this.eat(types.ellipsis)) {
            node.rest = this.flowParseFunctionTypeParam();
          }

          this.expect(types.parenR);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
      }, {
        key: "flowParseObjectTypeCallProperty",
        value: function flowParseObjectTypeCallProperty(node, isStatic) {
          var valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
      }, {
        key: "flowParseObjectType",
        value: function flowParseObjectType(_ref2) {
          var allowStatic = _ref2.allowStatic,
              allowExact = _ref2.allowExact,
              allowSpread = _ref2.allowSpread,
              allowProto = _ref2.allowProto,
              allowInexact = _ref2.allowInexact;
          var oldInType = this.state.inType;
          this.state.inType = true;
          var nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          var endDelim;
          var exact;
          var inexact = false;

          if (allowExact && this.match(types.braceBarL)) {
            this.expect(types.braceBarL);
            endDelim = types.braceBarR;
            exact = true;
          } else {
            this.expect(types.braceL);
            endDelim = types.braceR;
            exact = false;
          }

          nodeStart.exact = exact;

          while (!this.match(endDelim)) {
            var isStatic = false;
            var protoStart = null;
            var inexactStart = null;
            var node = this.startNode();

            if (allowProto && this.isContextual("proto")) {
              var lookahead = this.lookahead();

              if (lookahead.type !== types.colon && lookahead.type !== types.question) {
                this.next();
                protoStart = this.state.start;
                allowStatic = false;
              }
            }

            if (allowStatic && this.isContextual("static")) {
              var _lookahead = this.lookahead();

              if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
                this.next();
                isStatic = true;
              }
            }

            var variance = this.flowParseVariance();

            if (this.eat(types.bracketL)) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (this.eat(types.bracketL)) {
                if (variance) {
                  this.unexpected(variance.start);
                }

                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(types.parenL) || this.isRelational("<")) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              var _allowInexact;

              var kind = "init";

              if (this.isContextual("get") || this.isContextual("set")) {
                var _lookahead2 = this.lookahead();

                if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
                  kind = this.state.value;
                  this.next();
                }
              }

              var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, (_allowInexact = allowInexact) !== null && _allowInexact !== void 0 ? _allowInexact : !exact);

              if (propOrInexact === null) {
                inexact = true;
                inexactStart = this.state.lastTokStart;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }

            this.flowObjectTypeSemicolon();

            if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
              this.raise(inexactStart, "Explicit inexact syntax must appear at the end of an inexact object");
            }
          }

          this.expect(endDelim);

          if (allowSpread) {
            nodeStart.inexact = inexact;
          }

          var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
      }, {
        key: "flowParseObjectTypeProperty",
        value: function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
          if (this.eat(types.ellipsis)) {
            var isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(this.state.lastTokStart, "Explicit inexact syntax cannot appear in class or interface definitions");
              } else if (!allowInexact) {
                this.raise(this.state.lastTokStart, "Explicit inexact syntax cannot appear inside an explicit exact object type");
              }

              if (variance) {
                this.raise(variance.start, "Explicit inexact syntax cannot have variance");
              }

              return null;
            }

            if (!allowSpread) {
              this.raise(this.state.lastTokStart, "Spread operator cannot appear in class or interface definitions");
            }

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.raise(variance.start, "Spread properties cannot have variance");
            }

            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStart != null;
            node.kind = kind;
            var optional = false;

            if (this.isRelational("<") || this.match(types.parenL)) {
              node.method = true;

              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
            } else {
              if (kind !== "init") this.unexpected();
              node.method = false;

              if (this.eat(types.question)) {
                optional = true;
              }

              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }

            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
      }, {
        key: "flowCheckGetterSetterParams",
        value: function flowCheckGetterSetterParams(property) {
          var paramCount = property.kind === "get" ? 0 : 1;
          var start = property.start;
          var length = property.value.params.length + (property.value.rest ? 1 : 0);

          if (length !== paramCount) {
            if (property.kind === "get") {
              this.raise(start, "getter must not have any formal parameters");
            } else {
              this.raise(start, "setter must have exactly one formal parameter");
            }
          }

          if (property.kind === "set" && property.value.rest) {
            this.raise(start, "setter function argument must not be a rest parameter");
          }
        }
      }, {
        key: "flowObjectTypeSemicolon",
        value: function flowObjectTypeSemicolon() {
          if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
            this.unexpected();
          }
        }
      }, {
        key: "flowParseQualifiedTypeIdentifier",
        value: function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          var node = id || this.parseIdentifier();

          while (this.eat(types.dot)) {
            var node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.parseIdentifier();
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }

          return node;
        }
      }, {
        key: "flowParseGenericType",
        value: function flowParseGenericType(startPos, startLoc, id) {
          var node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }

          return this.finishNode(node, "GenericTypeAnnotation");
        }
      }, {
        key: "flowParseTypeofType",
        value: function flowParseTypeofType() {
          var node = this.startNode();
          this.expect(types._typeof);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
      }, {
        key: "flowParseTupleType",
        value: function flowParseTupleType() {
          var node = this.startNode();
          node.types = [];
          this.expect(types.bracketL);

          while (this.state.pos < this.length && !this.match(types.bracketR)) {
            node.types.push(this.flowParseType());
            if (this.match(types.bracketR)) break;
            this.expect(types.comma);
          }

          this.expect(types.bracketR);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
      }, {
        key: "flowParseFunctionTypeParam",
        value: function flowParseFunctionTypeParam() {
          var name = null;
          var optional = false;
          var typeAnnotation = null;
          var node = this.startNode();
          var lh = this.lookahead();

          if (lh.type === types.colon || lh.type === types.question) {
            name = this.parseIdentifier();

            if (this.eat(types.question)) {
              optional = true;
            }

            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }

          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "reinterpretTypeAsFunctionTypeParam",
        value: function reinterpretTypeAsFunctionTypeParam(type) {
          var node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "flowParseFunctionTypeParams",
        value: function flowParseFunctionTypeParams() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var rest = null;

          while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            params.push(this.flowParseFunctionTypeParam());

            if (!this.match(types.parenR)) {
              this.expect(types.comma);
            }
          }

          if (this.eat(types.ellipsis)) {
            rest = this.flowParseFunctionTypeParam();
          }

          return {
            params: params,
            rest: rest
          };
        }
      }, {
        key: "flowIdentToTypeAnnotation",
        value: function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");

            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");

            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");

            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");

            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");

            case "string":
              return this.finishNode(node, "StringTypeAnnotation");

            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
      }, {
        key: "flowParsePrimaryType",
        value: function flowParsePrimaryType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.startNode();
          var tmp;
          var type;
          var isGroupedType = false;
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;

          switch (this.state.type) {
            case types.name:
              if (this.isContextual("interface")) {
                return this.flowParseInterfaceType();
              }

              return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

            case types.braceL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });

            case types.braceBarL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });

            case types.bracketL:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;

            case types.relational:
              if (this.state.value === "<") {
                node.typeParameters = this.flowParseTypeParameterDeclaration();
                this.expect(types.parenL);
                tmp = this.flowParseFunctionTypeParams();
                node.params = tmp.params;
                node.rest = tmp.rest;
                this.expect(types.parenR);
                this.expect(types.arrow);
                node.returnType = this.flowParseType();
                return this.finishNode(node, "FunctionTypeAnnotation");
              }

              break;

            case types.parenL:
              this.next();

              if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
                if (this.match(types.name)) {
                  var token = this.lookahead().type;
                  isGroupedType = token !== types.question && token !== types.colon;
                } else {
                  isGroupedType = true;
                }
              }

              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;

                if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
                  this.expect(types.parenR);
                  return type;
                } else {
                  this.eat(types.comma);
                }
              }

              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }

              node.params = tmp.params;
              node.rest = tmp.rest;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");

            case types.string:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

            case types._true:
            case types._false:
              node.value = this.match(types._true);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");

            case types.plusMin:
              if (this.state.value === "-") {
                this.next();

                if (this.match(types.num)) {
                  return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
                }

                if (this.match(types.bigint)) {
                  return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
                }

                throw this.raise(this.state.start, "Unexpected token, expected \"number\" or \"bigint\"");
              }

              this.unexpected();

            case types.num:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

            case types.bigint:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

            case types._void:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");

            case types._null:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");

            case types._this:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");

            case types.star:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");

            default:
              if (this.state.type.keyword === "typeof") {
                return this.flowParseTypeofType();
              } else if (this.state.type.keyword) {
                var label = this.state.type.label;
                this.next();
                return _get(_getPrototypeOf(_class2.prototype), "createIdentifier", this).call(this, node, label);
              }

          }

          throw this.unexpected();
        }
      }, {
        key: "flowParsePostfixType",
        value: function flowParsePostfixType() {
          var startPos = this.state.start,
              startLoc = this.state.startLoc;
          var type = this.flowParsePrimaryType();

          while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
            var node = this.startNodeAt(startPos, startLoc);
            node.elementType = type;
            this.expect(types.bracketL);
            this.expect(types.bracketR);
            type = this.finishNode(node, "ArrayTypeAnnotation");
          }

          return type;
        }
      }, {
        key: "flowParsePrefixType",
        value: function flowParsePrefixType() {
          var node = this.startNode();

          if (this.eat(types.question)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
      }, {
        key: "flowParseAnonFunctionWithoutParens",
        value: function flowParseAnonFunctionWithoutParens() {
          var param = this.flowParsePrefixType();

          if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
            var node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          return param;
        }
      }, {
        key: "flowParseIntersectionType",
        value: function flowParseIntersectionType() {
          var node = this.startNode();
          this.eat(types.bitwiseAND);
          var type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];

          while (this.eat(types.bitwiseAND)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
      }, {
        key: "flowParseUnionType",
        value: function flowParseUnionType() {
          var node = this.startNode();
          this.eat(types.bitwiseOR);
          var type = this.flowParseIntersectionType();
          node.types = [type];

          while (this.eat(types.bitwiseOR)) {
            node.types.push(this.flowParseIntersectionType());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
      }, {
        key: "flowParseType",
        value: function flowParseType() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          var type = this.flowParseUnionType();
          this.state.inType = oldInType;
          this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
          return type;
        }
      }, {
        key: "flowParseTypeOrImplicitInstantiation",
        value: function flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === types.name && this.state.value === "_") {
            var startPos = this.state.start;
            var startLoc = this.state.startLoc;
            var node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
      }, {
        key: "flowParseTypeAnnotation",
        value: function flowParseTypeAnnotation() {
          var node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
      }, {
        key: "flowParseTypeAnnotatableIdentifier",
        value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

          if (this.match(types.colon)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }

          return ident;
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "flowParseVariance",
        value: function flowParseVariance() {
          var variance = null;

          if (this.match(types.plusMin)) {
            variance = this.startNode();

            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }

            this.next();
            this.finishNode(variance, "Variance");
          }

          return variance;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpressionBody) {
          var _this5 = this;

          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseFunctionBody", _this5).call(_this5, node, true, isMethod);
            });
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseFunctionBody", this).call(this, node, false, isMethod);
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(types.colon)) {
            var typeNode = this.startNode();

            var _this$flowParseTypeAn3 = this.flowParseTypeAndPredicateInitialiser();

            var _this$flowParseTypeAn4 = _slicedToArray(_this$flowParseTypeAn3, 2);

            typeNode.typeAnnotation = _this$flowParseTypeAn4[0];
            node.predicate = _this$flowParseTypeAn4[1];
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }

          _get(_getPrototypeOf(_class2.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "parseStatement",
        value: function parseStatement(context, topLevel) {
          if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            var _node = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_node);
          } else {
            var stmt = _get(_getPrototypeOf(_class2.prototype), "parseStatement", this).call(this, context, topLevel);

            if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
              this.flowPragma = null;
            }

            return stmt;
          }
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
                return this.flowParseDeclare(node);
              }
            } else if (this.match(types.name)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _get(_getPrototypeOf(_class2.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
            return false;
          }

          return _get(_getPrototypeOf(_class2.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual("enum")) {
            var node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
          var _this6 = this;

          if (!this.match(types.question)) return expr;

          if (refNeedsArrowPos) {
            var result = this.tryParse(function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseConditional", _this6).call(_this6, expr, noIn, startPos, startLoc);
            });

            if (!result.node) {
              refNeedsArrowPos.start = result.error.pos || this.state.start;
              return expr;
            }

            if (result.error) this.state = result.failState;
            return result.node;
          }

          this.expect(types.question);
          var state = this.state.clone();
          var originalNoArrowAt = this.state.noArrowAt;
          var node = this.startNodeAt(startPos, startLoc);

          var _this$tryParseConditi = this.tryParseConditionalConsequent(),
              consequent = _this$tryParseConditi.consequent,
              failed = _this$tryParseConditi.failed;

          var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
              _this$getArrowLikeExp2 = _slicedToArray(_this$getArrowLikeExp, 2),
              valid = _this$getArrowLikeExp2[0],
              invalid = _this$getArrowLikeExp2[1];

          if (failed || invalid.length > 0) {
            var noArrowAt = _toConsumableArray(originalNoArrowAt);

            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;

              for (var i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }

              var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi2.consequent;
              failed = _this$tryParseConditi2.failed;

              var _this$getArrowLikeExp3 = this.getArrowLikeExpressions(consequent);

              var _this$getArrowLikeExp4 = _slicedToArray(_this$getArrowLikeExp3, 2);

              valid = _this$getArrowLikeExp4[0];
              invalid = _this$getArrowLikeExp4[1];
            }

            if (failed && valid.length > 1) {
              this.raise(state.start, "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.");
            }

            if (failed && valid.length === 1) {
              this.state = state;
              this.state.noArrowAt = noArrowAt.concat(valid[0].start);

              var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi3.consequent;
              failed = _this$tryParseConditi3.failed;
            }
          }

          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(types.colon);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
            return _this6.parseMaybeAssign(noIn, undefined, undefined, undefined);
          });
          return this.finishNode(node, "ConditionalExpression");
        }
      }, {
        key: "tryParseConditionalConsequent",
        value: function tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          var consequent = this.parseMaybeAssign();
          var failed = !this.match(types.colon);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent: consequent,
            failed: failed
          };
        }
      }, {
        key: "getArrowLikeExpressions",
        value: function getArrowLikeExpressions(node, disallowInvalid) {
          var _this7 = this;

          var stack = [node];
          var arrows = [];

          while (stack.length !== 0) {
            var _node2 = stack.pop();

            if (_node2.type === "ArrowFunctionExpression") {
              if (_node2.typeParameters || !_node2.returnType) {
                this.finishArrowValidation(_node2);
              } else {
                arrows.push(_node2);
              }

              stack.push(_node2.body);
            } else if (_node2.type === "ConditionalExpression") {
              stack.push(_node2.consequent);
              stack.push(_node2.alternate);
            }
          }

          if (disallowInvalid) {
            arrows.forEach(function (node) {
              return _this7.finishArrowValidation(node);
            });
            return [arrows, []];
          }

          return partition(arrows, function (node) {
            return node.params.every(function (param) {
              return _this7.isAssignable(param, true);
            });
          });
        }
      }, {
        key: "finishArrowValidation",
        value: function finishArrowValidation(node) {
          var _node$extra;

          this.toAssignableList(node.params, true, "arrow function parameters", (_node$extra = node.extra) === null || _node$extra === void 0 ? void 0 : _node$extra.trailingComma);
          this.scope.enter(functionFlags(false, false) | SCOPE_ARROW);

          _get(_getPrototypeOf(_class2.prototype), "checkParams", this).call(this, node, false, true);

          this.scope.exit();
        }
      }, {
        key: "forwardNoArrowParamsConversionAt",
        value: function forwardNoArrowParamsConversionAt(node, parse) {
          var result;

          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse();
          }

          return result;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(_class2.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(types.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }

          return node;
        }
      }, {
        key: "assertModuleNodeAllowed",
        value: function assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "assertModuleNodeAllowed", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var decl = _get(_getPrototypeOf(_class2.prototype), "parseExport", this).call(this, node);

          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }

          return decl;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          if (this.isContextual("type")) {
            node.exportKind = "type";
            var declarationNode = this.startNode();
            this.next();

            if (this.match(types.braceL)) {
              node.specifiers = this.parseExportSpecifiers();
              this.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual("opaque")) {
            node.exportKind = "type";

            var _declarationNode = this.startNode();

            this.next();
            return this.flowParseOpaqueType(_declarationNode, false);
          } else if (this.isContextual("interface")) {
            node.exportKind = "type";

            var _declarationNode2 = this.startNode();

            this.next();
            return this.flowParseInterface(_declarationNode2);
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            node.exportKind = "value";

            var _declarationNode3 = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_declarationNode3);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "parseExportDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "eatExportStar",
        value: function eatExportStar(node) {
          if (_get(_getPrototypeOf(_class2.prototype), "eatExportStar", this).apply(this, arguments)) return true;

          if (this.isContextual("type") && this.lookahead().type === types.star) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }

          return false;
        }
      }, {
        key: "maybeParseExportNamespaceSpecifier",
        value: function maybeParseExportNamespaceSpecifier(node) {
          var pos = this.state.start;

          var hasNamespace = _get(_getPrototypeOf(_class2.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node);

          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(pos);
          }

          return hasNamespace;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId) {
          _get(_getPrototypeOf(_class2.prototype), "parseClassId", this).call(this, node, isStatement, optionalId);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 123 && next === 124) {
            return this.finishOp(types.braceBarL, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types.relational, 1);
          } else if (isIteratorStart(code, next)) {
            this.state.isIterator = true;
            return _get(_getPrototypeOf(_class2.prototype), "readWord", this).call(this);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "getTokenFromCode", this).call(this, code);
          }
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          var _this8 = this;

          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
              return true;

            case "ObjectExpression":
              {
                var _last = node.properties.length - 1;

                return node.properties.every(function (prop, i) {
                  return prop.type !== "ObjectMethod" && (i === _last || prop.type === "SpreadElement") && _this8.isAssignable(prop);
                });
              }

            case "ObjectProperty":
              return this.isAssignable(node.value);

            case "SpreadElement":
              return this.isAssignable(node.argument);

            case "ArrayExpression":
              return node.elements.every(function (element) {
                return _this8.isAssignable(element);
              });

            case "AssignmentExpression":
              return node.operator === "=";

            case "ParenthesizedExpression":
            case "TypeCastExpression":
              return this.isAssignable(node.expression);

            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;

            default:
              return false;
          }
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node, isBinding, contextDescription) {
          if (node.type === "TypeCastExpression") {
            return _get(_getPrototypeOf(_class2.prototype), "toAssignable", this).call(this, this.typeCastToParameter(node), isBinding, contextDescription);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "toAssignable", this).call(this, node, isBinding, contextDescription);
          }
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "toAssignableList", this).call(this, exprList, isBinding, contextDescription, trailingCommaPos);
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isParenthesizedExpr) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(expr.typeAnnotation.start, "The type cast expression is expected to be wrapped with parenthesis");
            }
          }

          return exprList;
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
          var checkClashes = arguments.length > 2 ? arguments[2] : undefined;
          var contextDescription = arguments.length > 3 ? arguments[3] : undefined;

          if (expr.type !== "TypeCastExpression") {
            return _get(_getPrototypeOf(_class2.prototype), "checkLVal", this).call(this, expr, bindingType, checkClashes, contextDescription);
          }
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          if (this.match(types.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (this.match(types.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.isRelational("<") || _get(_getPrototypeOf(_class2.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(types.colon) || _get(_getPrototypeOf(_class2.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "isNonstaticConstructor",
        value: function isNonstaticConstructor(method) {
          return !this.match(types.colon) && _get(_getPrototypeOf(_class2.prototype), "isNonstaticConstructor", this).call(this, method);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(_class2.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }

          if (this.isContextual("implements")) {
            this.next();
            var implemented = node.implements = [];

            do {
              var _node3 = this.startNode();

              _node3.id = this.flowParseRestrictedIdentifier(true);

              if (this.isRelational("<")) {
                _node3.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                _node3.typeParameters = null;
              }

              implemented.push(this.finishNode(_node3, "ClassImplements"));
            } while (this.eat(types.comma));
          }
        }
      }, {
        key: "parsePropertyName",
        value: function parsePropertyName(node) {
          var variance = this.flowParseVariance();

          var key = _get(_getPrototypeOf(_class2.prototype), "parsePropertyName", this).call(this, node);

          node.variance = variance;
          return key;
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
          if (prop.variance) {
            this.unexpected(prop.variance.start);
          }

          delete prop.variance;
          var typeParameters;

          if (this.isRelational("<")) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(types.parenL)) this.unexpected();
          }

          _get(_getPrototypeOf(_class2.prototype), "parseObjPropValue", this).call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);

          if (typeParameters) {
            (prop.value || prop).typeParameters = typeParameters;
          }
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(types.question)) {
            if (param.type !== "Identifier") {
              this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
            }

            param.optional = true;
          }

          if (this.match(types.colon)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          }

          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault(startPos, startLoc, left) {
          var node = _get(_getPrototypeOf(_class2.prototype), "parseMaybeDefault", this).call(this, startPos, startLoc, left);

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
          }

          return node;
        }
      }, {
        key: "shouldParseDefaultImport",
        value: function shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return _get(_getPrototypeOf(_class2.prototype), "shouldParseDefaultImport", this).call(this, node);
          }

          return isMaybeDefaultImport(this.state);
        }
      }, {
        key: "parseImportSpecifierLocal",
        value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();
          this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
          node.specifiers.push(this.finishNode(specifier, type));
        }
      }, {
        key: "maybeParseDefaultImportSpecifier",
        value: function maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          var kind = null;

          if (this.match(types._typeof)) {
            kind = "typeof";
          } else if (this.isContextual("type")) {
            kind = "type";
          }

          if (kind) {
            var lh = this.lookahead();

            if (kind === "type" && lh.type === types.star) {
              this.unexpected(lh.start);
            }

            if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
              this.next();
              node.importKind = kind;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "maybeParseDefaultImportSpecifier", this).call(this, node);
        }
      }, {
        key: "parseImportSpecifier",
        value: function parseImportSpecifier(node) {
          var specifier = this.startNode();
          var firstIdentLoc = this.state.start;
          var firstIdent = this.parseIdentifier(true);
          var specifierTypeKind = null;

          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }

          var isBinding = false;

          if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
            var as_ident = this.parseIdentifier(true);

            if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = as_ident.__clone();
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;

            if (this.eatContextual("as")) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = specifier.imported.__clone();
            }
          } else {
            isBinding = true;
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = specifier.imported.__clone();
          }

          var nodeIsTypeImport = hasTypeImportKind(node);
          var specifierIsTypeImport = hasTypeImportKind(specifier);

          if (nodeIsTypeImport && specifierIsTypeImport) {
            this.raise(firstIdentLoc, "The `type` and `typeof` keywords on named imports can only be used on regular " + "`import` statements. It cannot be used with `import type` or `import typeof` statements");
          }

          if (nodeIsTypeImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.start);
          }

          if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.start, true, true);
          }

          this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
          node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var kind = node.kind;

          if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(_class2.prototype), "parseVarId", this).call(this, decl, kind);

          if (this.match(types.colon)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types.colon)) {
            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(types.colon) || _get(_getPrototypeOf(_class2.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
          var _this9 = this;

          var state = null;
          var jsx;

          if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", _this9).call(_this9, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;

            if (context[context.length - 1] === types$1.j_oTag) {
              context.length -= 2;
            } else if (context[context.length - 1] === types$1.j_expr) {
              context.length -= 1;
            }
          }

          if (jsx && jsx.error || this.isRelational("<")) {
            state = state || this.state.clone();
            var typeParameters;
            var arrow = this.tryParse(function () {
              typeParameters = _this9.flowParseTypeParameterDeclaration();

              var arrowExpression = _this9.forwardNoArrowParamsConversionAt(typeParameters, function () {
                return _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", _this9).call(_this9, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
              });

              arrowExpression.typeParameters = typeParameters;

              _this9.resetStartLocationFromNode(arrowExpression, typeParameters);

              return arrowExpression;
            }, state);
            var arrowExpression = arrow.node && arrow.node.type === "ArrowFunctionExpression" ? arrow.node : null;
            if (!arrow.error && arrowExpression) return arrowExpression;

            if (jsx && jsx.node) {
              this.state = jsx.failState;
              return jsx.node;
            }

            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }

            if (jsx && jsx.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            throw this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", this).call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this10 = this;

          if (this.match(types.colon)) {
            var result = this.tryParse(function () {
              var oldNoAnonFunctionType = _this10.state.noAnonFunctionType;
              _this10.state.noAnonFunctionType = true;

              var typeNode = _this10.startNode();

              var _this10$flowParseType = _this10.flowParseTypeAndPredicateInitialiser();

              var _this10$flowParseType2 = _slicedToArray(_this10$flowParseType, 2);

              typeNode.typeAnnotation = _this10$flowParseType2[0];
              node.predicate = _this10$flowParseType2[1];
              _this10.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (_this10.canInsertSemicolon()) _this10.unexpected();
              if (!_this10.match(types.arrow)) _this10.unexpected();
              return typeNode;
            });
            if (result.thrown) return null;
            if (result.error) this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow() {
          return this.match(types.colon) || _get(_getPrototypeOf(_class2.prototype), "shouldParseArrow", this).call(this);
        }
      }, {
        key: "setArrowFunctionParameters",
        value: function setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            _get(_getPrototypeOf(_class2.prototype), "setArrowFunctionParameters", this).call(this, node, params);
          }
        }
      }, {
        key: "checkParams",
        value: function checkParams(node, allowDuplicates, isArrowFunction) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }

          return _get(_getPrototypeOf(_class2.prototype), "checkParams", this).apply(this, arguments);
        }
      }, {
        key: "parseParenAndDistinguishExpression",
        value: function parseParenAndDistinguishExpression(canBeArrow) {
          return _get(_getPrototypeOf(_class2.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
      }, {
        key: "parseSubscripts",
        value: function parseSubscripts(base, startPos, startLoc, noCalls) {
          var _this11 = this;

          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
            var state = this.state.clone();
            var arrow = this.tryParse(function (abort) {
              return _this11.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
            }, state);
            if (!arrow.error && !arrow.aborted) return arrow.node;
            var result = this.tryParse(function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseSubscripts", _this11).call(_this11, base, startPos, startLoc, noCalls);
            }, state);
            if (result.node && !result.error) return result.node;

            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }

            if (result.node) {
              this.state = result.failState;
              return result.node;
            }

            throw arrow.error || result.error;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseSubscripts", this).call(this, base, startPos, startLoc, noCalls);
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          var _this12 = this;

          if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
            this.expectPlugin("optionalChaining");
            subscriptState.optionalChainMember = true;

            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }

            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(types.parenL);
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
            var _node4 = this.startNodeAt(startPos, startLoc);

            _node4.callee = base;
            var result = this.tryParse(function () {
              _node4.typeArguments = _this12.flowParseTypeParameterInstantiationCallOrNew();

              _this12.expect(types.parenL);

              _node4.arguments = _this12.parseCallExpressionArguments(types.parenR, false);
              if (subscriptState.optionalChainMember) _node4.optional = false;
              return _this12.finishCallExpression(_node4, subscriptState.optionalChainMember);
            });

            if (result.node) {
              if (result.error) this.state = result.failState;
              return result.node;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, subscriptState);
        }
      }, {
        key: "parseNewArguments",
        value: function parseNewArguments(node) {
          var _this13 = this;

          var targs = null;

          if (this.shouldParseTypes() && this.isRelational("<")) {
            targs = this.tryParse(function () {
              return _this13.flowParseTypeParameterInstantiationCallOrNew();
            }).node;
          }

          node.typeArguments = targs;

          _get(_getPrototypeOf(_class2.prototype), "parseNewArguments", this).call(this, node);
        }
      }, {
        key: "parseAsyncArrowWithTypeParameters",
        value: function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node)) return;
          return this.parseArrowExpression(node, undefined, true);
        }
      }, {
        key: "readToken_mult_modulo",
        value: function readToken_mult_modulo(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "readToken_mult_modulo", this).call(this, code);
        }
      }, {
        key: "readToken_pipe_amp",
        value: function readToken_pipe_amp(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 124 && next === 125) {
            this.finishOp(types.braceBarR, 2);
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "readToken_pipe_amp", this).call(this, code);
        }
      }, {
        key: "parseTopLevel",
        value: function parseTopLevel(file, program) {
          var fileNode = _get(_getPrototypeOf(_class2.prototype), "parseTopLevel", this).call(this, file, program);

          if (this.state.hasFlowComment) {
            this.raise(this.state.pos, "Unterminated flow-comment");
          }

          return fileNode;
        }
      }, {
        key: "skipBlockComment",
        value: function skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              this.unexpected(null, "Cannot have a flow comment inside another flow comment");
            }

            this.hasFlowCommentCompletion();
            this.state.pos += this.skipFlowComment();
            this.state.hasFlowComment = true;
            return;
          }

          if (this.state.hasFlowComment) {
            var end = this.input.indexOf("*-/", this.state.pos += 2);

            if (end === -1) {
              throw this.raise(this.state.pos - 2, "Unterminated comment");
            }

            this.state.pos = end + 3;
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "skipBlockComment", this).call(this);
        }
      }, {
        key: "skipFlowComment",
        value: function skipFlowComment() {
          var pos = this.state.pos;
          var shiftToFirstNonWhiteSpace = 2;

          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }

          var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }

          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }

          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }

          return false;
        }
      }, {
        key: "hasFlowCommentCompletion",
        value: function hasFlowCommentCompletion() {
          var end = this.input.indexOf("*/", this.state.pos);

          if (end === -1) {
            throw this.raise(this.state.pos, "Unterminated comment");
          }
        }
      }, {
        key: "flowEnumErrorBooleanMemberNotInitialized",
        value: function flowEnumErrorBooleanMemberNotInitialized(pos, _ref3) {
          var enumName = _ref3.enumName,
              memberName = _ref3.memberName;
          this.raise(pos, "Boolean enum members need to be initialized. Use either `".concat(memberName, " = true,` ") + "or `".concat(memberName, " = false,` in enum `").concat(enumName, "`."));
        }
      }, {
        key: "flowEnumErrorInvalidMemberName",
        value: function flowEnumErrorInvalidMemberName(pos, _ref4) {
          var enumName = _ref4.enumName,
              memberName = _ref4.memberName;
          var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
          this.raise(pos, "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using " + "`".concat(memberName, "`, consider using `").concat(suggestion, "`, in enum `").concat(enumName, "`."));
        }
      }, {
        key: "flowEnumErrorDuplicateMemberName",
        value: function flowEnumErrorDuplicateMemberName(pos, _ref5) {
          var enumName = _ref5.enumName,
              memberName = _ref5.memberName;
          this.raise(pos, "Enum member names need to be unique, but the name `".concat(memberName, "` has already been used ") + "before in enum `".concat(enumName, "`."));
        }
      }, {
        key: "flowEnumErrorInconsistentMemberValues",
        value: function flowEnumErrorInconsistentMemberValues(pos, _ref6) {
          var enumName = _ref6.enumName;
          this.raise(pos, "Enum `".concat(enumName, "` has inconsistent member initializers. Either use no initializers, or ") + "consistently use literals (either booleans, numbers, or strings) for all member initializers.");
        }
      }, {
        key: "flowEnumErrorInvalidExplicitType",
        value: function flowEnumErrorInvalidExplicitType(pos, _ref7) {
          var enumName = _ref7.enumName,
              suppliedType = _ref7.suppliedType;
          var suggestion = "Use one of `boolean`, `number`, `string`, or `symbol` in " + "enum `".concat(enumName, "`.");
          var message = suppliedType === null ? "Supplied enum type is not valid. ".concat(suggestion) : "Enum type `".concat(suppliedType, "` is not valid. ").concat(suggestion);
          return this.raise(pos, message);
        }
      }, {
        key: "flowEnumErrorInvalidMemberInitializer",
        value: function flowEnumErrorInvalidMemberInitializer(pos, _ref8) {
          var enumName = _ref8.enumName,
              explicitType = _ref8.explicitType,
              memberName = _ref8.memberName;
          var message = null;

          switch (explicitType) {
            case "boolean":
            case "number":
            case "string":
              message = "Enum `".concat(enumName, "` has type `").concat(explicitType, "`, so the initializer of ") + "`".concat(memberName, "` needs to be a ").concat(explicitType, " literal.");
              break;

            case "symbol":
              message = "Symbol enum members cannot be initialized. Use `".concat(memberName, ",` in ") + "enum `".concat(enumName, "`.");
              break;

            default:
              message = "The enum member initializer for `".concat(memberName, "` needs to be a literal (either ") + "a boolean, number, or string) in enum `".concat(enumName, "`.");
          }

          return this.raise(pos, message);
        }
      }, {
        key: "flowEnumErrorNumberMemberNotInitialized",
        value: function flowEnumErrorNumberMemberNotInitialized(pos, _ref9) {
          var enumName = _ref9.enumName,
              memberName = _ref9.memberName;
          this.raise(pos, "Number enum members need to be initialized, e.g. `".concat(memberName, " = 1` in enum `").concat(enumName, "`."));
        }
      }, {
        key: "flowEnumErrorStringMemberInconsistentlyInitailized",
        value: function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref10) {
          var enumName = _ref10.enumName;
          this.raise(pos, "String enum members need to consistently either all use initializers, or use no initializers, " + "in enum `".concat(enumName, "`."));
        }
      }, {
        key: "flowEnumMemberInit",
        value: function flowEnumMemberInit() {
          var _this14 = this;

          var startPos = this.state.start;

          var endOfInit = function endOfInit() {
            return _this14.match(types.comma) || _this14.match(types.braceR);
          };

          switch (this.state.type) {
            case types.num:
              {
                var _literal = this.parseLiteral(this.state.value, "NumericLiteral");

                if (endOfInit()) {
                  return {
                    type: "number",
                    pos: _literal.start,
                    value: _literal
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types.string:
              {
                var _literal2 = this.parseLiteral(this.state.value, "StringLiteral");

                if (endOfInit()) {
                  return {
                    type: "string",
                    pos: _literal2.start,
                    value: _literal2
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types._true:
            case types._false:
              {
                var _literal3 = this.parseBooleanLiteral();

                if (endOfInit()) {
                  return {
                    type: "boolean",
                    pos: _literal3.start,
                    value: _literal3
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            default:
              return {
                type: "invalid",
                pos: startPos
              };
          }
        }
      }, {
        key: "flowEnumMemberRaw",
        value: function flowEnumMemberRaw() {
          var pos = this.state.start;
          var id = this.parseIdentifier(true);
          var init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
            type: "none",
            pos: pos
          };
          return {
            id: id,
            init: init
          };
        }
      }, {
        key: "flowEnumCheckExplicitTypeMismatch",
        value: function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
          var explicitType = context.explicitType;

          if (explicitType === null) {
            return;
          }

          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(pos, context);
          }
        }
      }, {
        key: "flowEnumMembers",
        value: function flowEnumMembers(_ref11) {
          var enumName = _ref11.enumName,
              explicitType = _ref11.explicitType;
          var seenNames = new Set();
          var members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };

          while (!this.match(types.braceR)) {
            var memberNode = this.startNode();

            var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
                id = _this$flowEnumMemberR.id,
                init = _this$flowEnumMemberR.init;

            var memberName = id.name;

            if (memberName === "") {
              continue;
            }

            if (/^[a-z]/.test(memberName)) {
              this.flowEnumErrorInvalidMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            if (seenNames.has(memberName)) {
              this.flowEnumErrorDuplicateMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            seenNames.add(memberName);
            var context = {
              enumName: enumName,
              explicitType: explicitType,
              memberName: memberName
            };
            memberNode.id = id;

            switch (init.type) {
              case "boolean":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                  memberNode.init = init.value;
                  members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                }

              case "number":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                  memberNode.init = init.value;
                  members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                }

              case "string":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                  memberNode.init = init.value;
                  members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                }

              case "invalid":
                {
                  throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
                }

              case "none":
                {
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                      break;

                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                      break;

                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
                }
            }

            if (!this.match(types.braceR)) {
              this.expect(types.comma);
            }
          }

          return members;
        }
      }, {
        key: "flowEnumStringBody",
        value: function flowEnumStringBody(bodyNode, initializedMembers, defaultedMembers, _ref12) {
          var enumName = _ref12.enumName;

          if (initializedMembers.length === 0) {
            bodyNode.members = defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            bodyNode.members = initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            bodyNode.members = defaultedMembers;

            for (var _i = 0; _i < initializedMembers.length; _i++) {
              var member = initializedMembers[_i];
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
                enumName: enumName
              });
            }
          } else {
            bodyNode.members = initializedMembers;

            for (var _i2 = 0; _i2 < defaultedMembers.length; _i2++) {
              var _member = defaultedMembers[_i2];
              this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
                enumName: enumName
              });
            }
          }

          return this.finishNode(bodyNode, "EnumStringBody");
        }
      }, {
        key: "flowEnumParseExplicitType",
        value: function flowEnumParseExplicitType(_ref13) {
          var enumName = _ref13.enumName;

          if (this.eatContextual("of")) {
            if (!this.match(types.name)) {
              throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: null
              });
            }

            var value = this.state.value;
            this.next();

            if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
              this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: value
              });
            }

            return value;
          }

          return null;
        }
      }, {
        key: "flowParseEnumDeclaration",
        value: function flowParseEnumDeclaration(node) {
          var _this15 = this;

          var id = this.parseIdentifier();
          node.id = id;
          var enumName = id.name;
          var explicitType = this.flowEnumParseExplicitType({
            enumName: enumName
          });
          this.expect(types.braceL);
          var bodyNode = this.startNode();
          var members = this.flowEnumMembers({
            enumName: enumName,
            explicitType: explicitType
          });

          switch (explicitType) {
            case "boolean":
              bodyNode.explicitType = true;
              bodyNode.members = members.booleanMembers;
              node.body = this.finishNode(bodyNode, "EnumBooleanBody");
              break;

            case "number":
              bodyNode.explicitType = true;
              bodyNode.members = members.numberMembers;
              node.body = this.finishNode(bodyNode, "EnumNumberBody");
              break;

            case "string":
              bodyNode.explicitType = true;
              node.body = this.flowEnumStringBody(bodyNode, members.stringMembers, members.defaultedMembers, {
                enumName: enumName
              });
              break;

            case "symbol":
              bodyNode.members = members.defaultedMembers;
              node.body = this.finishNode(bodyNode, "EnumSymbolBody");
              break;

            default:
              {
                var empty = function empty() {
                  bodyNode.members = [];
                  return _this15.finishNode(bodyNode, "EnumStringBody");
                };

                bodyNode.explicitType = false;
                var boolsLen = members.booleanMembers.length;
                var numsLen = members.numberMembers.length;
                var strsLen = members.stringMembers.length;
                var defaultedLen = members.defaultedMembers.length;

                if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                  node.body = empty();
                } else if (!boolsLen && !numsLen) {
                  node.body = this.flowEnumStringBody(bodyNode, members.stringMembers, members.defaultedMembers, {
                    enumName: enumName
                  });
                } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  bodyNode.members = members.booleanMembers;
                  node.body = this.finishNode(bodyNode, "EnumBooleanBody");

                  for (var _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {
                    var member = _members$defaultedMem[_i3];
                    this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                      enumName: enumName,
                      memberName: member.id.name
                    });
                  }
                } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  bodyNode.members = members.numberMembers;
                  node.body = this.finishNode(bodyNode, "EnumNumberBody");

                  for (var _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {
                    var _member2 = _members$defaultedMem2[_i4];
                    this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                      enumName: enumName,
                      memberName: _member2.id.name
                    });
                  }
                } else {
                  node.body = empty();
                  this.flowEnumErrorInconsistentMemberValues(id.start, {
                    enumName: enumName
                  });
                }
              }
          }

          this.expect(types.braceR);
          return this.finishNode(node, "EnumDeclaration");
        }
      }]);

      return _class2;
    }(superClass)
  );
};

var entities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};
var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;
types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", {
  beforeExpr: true
});
types.jsxTagStart = new TokenType("jsxTagStart", {
  startsExpr: true
});
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr);
  this.state.context.push(types$1.j_oTag);
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();

  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = function jsx(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass3) {
      _inherits(_class3, _superClass3);

      function _class3() {
        _classCallCheck(this, _class3);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class3).apply(this, arguments));
      }

      _createClass(_class3, [{
        key: "jsxReadToken",
        value: function jsxReadToken() {
          var out = "";
          var chunkStart = this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, "Unterminated JSX contents");
            }

            var ch = this.input.charCodeAt(this.state.pos);

            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.exprAllowed) {
                    ++this.state.pos;
                    return this.finishToken(types.jsxTagStart);
                  }

                  return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, ch);
                }

                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(types.jsxText, out);

              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;

              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }

            }
          }
        }
      }, {
        key: "jsxReadNewLine",
        value: function jsxReadNewLine(normalizeCRLF) {
          var ch = this.input.charCodeAt(this.state.pos);
          var out;
          ++this.state.pos;

          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
      }, {
        key: "jsxReadString",
        value: function jsxReadString(quote) {
          var out = "";
          var chunkStart = ++this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, "Unterminated string constant");
            }

            var ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;

            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(types.string, out);
        }
      }, {
        key: "jsxReadEntity",
        value: function jsxReadEntity() {
          var str = "";
          var count = 0;
          var entity;
          var ch = this.input[this.state.pos];
          var startPos = ++this.state.pos;

          while (this.state.pos < this.length && count++ < 10) {
            ch = this.input[this.state.pos++];

            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);

                  if (HEX_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 16));
                  }
                } else {
                  str = str.substr(1);

                  if (DECIMAL_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 10));
                  }
                }
              } else {
                entity = entities[str];
              }

              break;
            }

            str += ch;
          }

          if (!entity) {
            this.state.pos = startPos;
            return "&";
          }

          return entity;
        }
      }, {
        key: "jsxReadWord",
        value: function jsxReadWord() {
          var ch;
          var start = this.state.pos;

          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);

          return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
        }
      }, {
        key: "jsxParseIdentifier",
        value: function jsxParseIdentifier() {
          var node = this.startNode();

          if (this.match(types.jsxName)) {
            node.name = this.state.value;
          } else if (this.state.type.keyword) {
            node.name = this.state.type.keyword;
          } else {
            this.unexpected();
          }

          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
      }, {
        key: "jsxParseNamespacedName",
        value: function jsxParseNamespacedName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var name = this.jsxParseIdentifier();
          if (!this.eat(types.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
      }, {
        key: "jsxParseElementName",
        value: function jsxParseElementName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.jsxParseNamespacedName();

          if (node.type === "JSXNamespacedName") {
            return node;
          }

          while (this.eat(types.dot)) {
            var newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }

          return node;
        }
      }, {
        key: "jsxParseAttributeValue",
        value: function jsxParseAttributeValue() {
          var node;

          switch (this.state.type) {
            case types.braceL:
              node = this.startNode();
              this.next();
              node = this.jsxParseExpressionContainer(node);

              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
              }

              return node;

            case types.jsxTagStart:
            case types.string:
              return this.parseExprAtom();

            default:
              throw this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
      }, {
        key: "jsxParseEmptyExpression",
        value: function jsxParseEmptyExpression() {
          var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
        }
      }, {
        key: "jsxParseSpreadChild",
        value: function jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.expect(types.braceR);
          return this.finishNode(node, "JSXSpreadChild");
        }
      }, {
        key: "jsxParseExpressionContainer",
        value: function jsxParseExpressionContainer(node) {
          if (this.match(types.braceR)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            node.expression = this.parseExpression();
          }

          this.expect(types.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        }
      }, {
        key: "jsxParseAttribute",
        value: function jsxParseAttribute() {
          var node = this.startNode();

          if (this.eat(types.braceL)) {
            this.expect(types.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(types.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }

          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
      }, {
        key: "jsxParseOpeningElementAt",
        value: function jsxParseOpeningElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types.jsxTagEnd)) {
            this.expect(types.jsxTagEnd);
            return this.finishNode(node, "JSXOpeningFragment");
          }

          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var attributes = [];

          while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
            attributes.push(this.jsxParseAttribute());
          }

          node.attributes = attributes;
          node.selfClosing = this.eat(types.slash);
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningElement");
        }
      }, {
        key: "jsxParseClosingElementAt",
        value: function jsxParseClosingElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types.jsxTagEnd)) {
            this.expect(types.jsxTagEnd);
            return this.finishNode(node, "JSXClosingFragment");
          }

          node.name = this.jsxParseElementName();
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXClosingElement");
        }
      }, {
        key: "jsxParseElementAt",
        value: function jsxParseElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          var children = [];
          var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          var closingElement = null;

          if (!openingElement.selfClosing) {
            contents: for (;;) {
              switch (this.state.type) {
                case types.jsxTagStart:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();

                  if (this.eat(types.slash)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }

                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;

                case types.jsxText:
                  children.push(this.parseExprAtom());
                  break;

                case types.braceL:
                  {
                    var _node5 = this.startNode();

                    this.next();

                    if (this.match(types.ellipsis)) {
                      children.push(this.jsxParseSpreadChild(_node5));
                    } else {
                      children.push(this.jsxParseExpressionContainer(_node5));
                    }

                    break;
                  }

                default:
                  throw this.unexpected();
              }
            }

            if (isFragment(openingElement) && !isFragment(closingElement)) {
              this.raise(closingElement.start, "Expected corresponding JSX closing tag for <>");
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
              }
            }
          }

          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }

          node.children = children;

          if (this.isRelational("<")) {
            throw this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag. " + "Did you want a JSX fragment <>...</>?");
          }

          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
      }, {
        key: "jsxParseElement",
        value: function jsxParseElement() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refShortHandDefaultPos) {
          if (this.match(types.jsxText)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(types.jsxTagStart)) {
            return this.jsxParseElement();
          } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
            this.finishToken(types.jsxTagStart);
            return this.jsxParseElement();
          } else {
            return _get(_getPrototypeOf(_class3.prototype), "parseExprAtom", this).call(this, refShortHandDefaultPos);
          }
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (this.state.inPropertyName) return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, code);
          var context = this.curContext();

          if (context === types$1.j_expr) {
            return this.jsxReadToken();
          }

          if (context === types$1.j_oTag || context === types$1.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }

            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(types.jsxTagEnd);
            }

            if ((code === 34 || code === 39) && context === types$1.j_oTag) {
              return this.jsxReadString(code);
            }
          }

          if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }

          return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, code);
        }
      }, {
        key: "updateContext",
        value: function updateContext(prevType) {
          if (this.match(types.braceL)) {
            var curContext = this.curContext();

            if (curContext === types$1.j_oTag) {
              this.state.context.push(types$1.braceExpression);
            } else if (curContext === types$1.j_expr) {
              this.state.context.push(types$1.templateQuasi);
            } else {
              _get(_getPrototypeOf(_class3.prototype), "updateContext", this).call(this, prevType);
            }

            this.state.exprAllowed = true;
          } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
            this.state.context.length -= 2;
            this.state.context.push(types$1.j_cTag);
            this.state.exprAllowed = false;
          } else {
            return _get(_getPrototypeOf(_class3.prototype), "updateContext", this).call(this, prevType);
          }
        }
      }]);

      return _class3;
    }(superClass)
  );
};

var Scope = function Scope(flags) {
  _classCallCheck(this, Scope);

  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.flags = flags;
};

var ScopeHandler =
/*#__PURE__*/
function () {
  function ScopeHandler(raise, inModule) {
    _classCallCheck(this, ScopeHandler);

    this.scopeStack = [];
    this.undefinedExports = new Map();
    this.raise = raise;
    this.inModule = inModule;
  }

  _createClass(ScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new Scope(flags);
    }
  }, {
    key: "enter",
    value: function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
  }, {
    key: "exit",
    value: function exit() {
      this.scopeStack.pop();
    }
  }, {
    key: "treatFunctionsAsVarInScope",
    value: function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
  }, {
    key: "maybeExportDefined",
    value: function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
  }, {
    key: "checkRedeclarationInScope",
    value: function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, "Identifier '".concat(name, "' has already been declared"));
      }
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;
      }

      return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
        this.undefinedExports.set(id.name, id.start);
      }
    }
  }, {
    key: "currentScope",
    value: function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
  }, {
    key: "currentVarScope",
    value: function currentVarScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    }
  }, {
    key: "currentThisScope",
    value: function currentThisScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    }
  }, {
    key: "inFunction",
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "inGenerator",
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    }
  }, {
    key: "inAsync",
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    }
  }, {
    key: "allowSuper",
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    }
  }, {
    key: "allowDirectSuper",
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    }
  }, {
    key: "inNonArrowFunction",
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "treatFunctionsAsVar",
    get: function get() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
  }]);

  return ScopeHandler;
}();

var TypeScriptScope =
/*#__PURE__*/
function (_Scope) {
  _inherits(TypeScriptScope, _Scope);

  function TypeScriptScope() {
    var _getPrototypeOf2;

    var _this16;

    _classCallCheck(this, TypeScriptScope);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this16 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TypeScriptScope)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this16.types = [];
    _this16.enums = [];
    _this16.constEnums = [];
    _this16.classes = [];
    _this16.exportOnlyBindings = [];
    return _this16;
  }

  return TypeScriptScope;
}(Scope);

var TypeScriptScopeHandler =
/*#__PURE__*/
function (_ScopeHandler) {
  _inherits(TypeScriptScopeHandler, _ScopeHandler);

  function TypeScriptScopeHandler() {
    _classCallCheck(this, TypeScriptScopeHandler);

    return _possibleConstructorReturn(this, _getPrototypeOf(TypeScriptScopeHandler).apply(this, arguments));
  }

  _createClass(TypeScriptScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new TypeScriptScope(flags);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "declareName", this).apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "isRedeclaredInScope", this).apply(this, arguments);
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
        _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "checkLocalExport", this).call(this, id);
      }
    }
  }]);

  return TypeScriptScopeHandler;
}(ScopeHandler);

function nonNull(x) {
  if (x == null) {
    throw new Error("Unexpected ".concat(x, " value."));
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

var typescript = function typescript(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass4) {
      _inherits(_class4, _superClass4);

      function _class4() {
        _classCallCheck(this, _class4);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class4).apply(this, arguments));
      }

      _createClass(_class4, [{
        key: "getScopeHandler",
        value: function getScopeHandler() {
          return TypeScriptScopeHandler;
        }
      }, {
        key: "tsIsIdentifier",
        value: function tsIsIdentifier() {
          return this.match(types.name);
        }
      }, {
        key: "tsNextTokenCanFollowModifier",
        value: function tsNextTokenCanFollowModifier() {
          this.next();
          return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
        }
      }, {
        key: "tsParseModifier",
        value: function tsParseModifier(allowedModifiers) {
          if (!this.match(types.name)) {
            return undefined;
          }

          var modifier = this.state.value;

          if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }

          return undefined;
        }
      }, {
        key: "tsParseModifiers",
        value: function tsParseModifiers(allowedModifiers) {
          var modifiers = Object.create(null);

          while (true) {
            var startPos = this.state.start;
            var modifier = this.tsParseModifier(allowedModifiers);
            if (!modifier) break;

            if (Object.hasOwnProperty.call(modifiers, modifier)) {
              this.raise(startPos, "Duplicate modifier: '".concat(modifier, "'"));
            }

            modifiers[modifier] = true;
          }

          return modifiers;
        }
      }, {
        key: "tsIsListTerminator",
        value: function tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(types.braceR);

            case "HeritageClauseElement":
              return this.match(types.braceL);

            case "TupleElementTypes":
              return this.match(types.bracketR);

            case "TypeParametersOrArguments":
              return this.isRelational(">");
          }

          throw new Error("Unreachable");
        }
      }, {
        key: "tsParseList",
        value: function tsParseList(kind, parseElement) {
          var result = [];

          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }

          return result;
        }
      }, {
        key: "tsParseDelimitedList",
        value: function tsParseDelimitedList(kind, parseElement) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
        }
      }, {
        key: "tsParseDelimitedListWorker",
        value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
          var result = [];

          while (true) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }

            var element = parseElement();

            if (element == null) {
              return undefined;
            }

            result.push(element);

            if (this.eat(types.comma)) {
              continue;
            }

            if (this.tsIsListTerminator(kind)) {
              break;
            }

            if (expectSuccess) {
              this.expect(types.comma);
            }

            return undefined;
          }

          return result;
        }
      }, {
        key: "tsParseBracketedList",
        value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(types.bracketL);
            } else {
              this.expectRelational("<");
            }
          }

          var result = this.tsParseDelimitedList(kind, parseElement);

          if (bracket) {
            this.expect(types.bracketR);
          } else {
            this.expectRelational(">");
          }

          return result;
        }
      }, {
        key: "tsParseImportType",
        value: function tsParseImportType() {
          var node = this.startNode();
          this.expect(types._import);
          this.expect(types.parenL);

          if (!this.match(types.string)) {
            this.raise(this.state.start, "Argument in a type import must be a string literal");
          }

          node.argument = this.parseExprAtom();
          this.expect(types.parenR);

          if (this.eat(types.dot)) {
            node.qualifier = this.tsParseEntityName(true);
          }

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSImportType");
        }
      }, {
        key: "tsParseEntityName",
        value: function tsParseEntityName(allowReservedWords) {
          var entity = this.parseIdentifier();

          while (this.eat(types.dot)) {
            var node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }

          return entity;
        }
      }, {
        key: "tsParseTypeReference",
        value: function tsParseTypeReference() {
          var node = this.startNode();
          node.typeName = this.tsParseEntityName(false);

          if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSTypeReference");
        }
      }, {
        key: "tsParseThisTypePredicate",
        value: function tsParseThisTypePredicate(lhs) {
          this.next();
          var node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          return this.finishNode(node, "TSTypePredicate");
        }
      }, {
        key: "tsParseThisTypeNode",
        value: function tsParseThisTypeNode() {
          var node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
      }, {
        key: "tsParseTypeQuery",
        value: function tsParseTypeQuery() {
          var node = this.startNode();
          this.expect(types._typeof);

          if (this.match(types._import)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName(true);
          }

          return this.finishNode(node, "TSTypeQuery");
        }
      }, {
        key: "tsParseTypeParameter",
        value: function tsParseTypeParameter() {
          var node = this.startNode();
          node.name = this.parseIdentifierName(node.start);
          node.constraint = this.tsEatThenParseType(types._extends);
          node.default = this.tsEatThenParseType(types.eq);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsTryParseTypeParameters",
        value: function tsTryParseTypeParameters() {
          if (this.isRelational("<")) {
            return this.tsParseTypeParameters();
          }
        }
      }, {
        key: "tsParseTypeParameters",
        value: function tsParseTypeParameters() {
          var node = this.startNode();

          if (this.isRelational("<") || this.match(types.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
      }, {
        key: "tsTryNextParseConstantContext",
        value: function tsTryNextParseConstantContext() {
          if (this.lookahead().type === types._const) {
            this.next();
            return this.tsParseTypeReference();
          }

          return null;
        }
      }, {
        key: "tsFillSignature",
        value: function tsFillSignature(returnToken, signature) {
          var returnTokenRequired = returnToken === types.arrow;
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(types.parenL);
          signature.parameters = this.tsParseBindingListForSignature();

          if (returnTokenRequired) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
      }, {
        key: "tsParseBindingListForSignature",
        value: function tsParseBindingListForSignature() {
          var _this17 = this;

          return this.parseBindingList(types.parenR, 41).map(function (pattern) {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              _this17.raise(pattern.start, "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern," + "instead got ".concat(pattern.type));
            }

            return pattern;
          });
        }
      }, {
        key: "tsParseTypeMemberSemicolon",
        value: function tsParseTypeMemberSemicolon() {
          if (!this.eat(types.comma)) {
            this.semicolon();
          }
        }
      }, {
        key: "tsParseSignatureMember",
        value: function tsParseSignatureMember(kind, node) {
          this.tsFillSignature(types.colon, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
      }, {
        key: "tsIsUnambiguouslyIndexSignature",
        value: function tsIsUnambiguouslyIndexSignature() {
          this.next();
          return this.eat(types.name) && this.match(types.colon);
        }
      }, {
        key: "tsTryParseIndexSignature",
        value: function tsTryParseIndexSignature(node) {
          if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return undefined;
          }

          this.expect(types.bracketL);
          var id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(types.bracketR);
          node.parameters = [id];
          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
      }, {
        key: "tsParsePropertyOrMethodSignature",
        value: function tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(types.question)) node.optional = true;
          var nodeAny = node;

          if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
            var method = nodeAny;
            this.tsFillSignature(types.colon, method);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(method, "TSMethodSignature");
          } else {
            var property = nodeAny;
            if (readonly) property.readonly = true;
            var type = this.tsTryParseTypeAnnotation();
            if (type) property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
      }, {
        key: "tsParseTypeMember",
        value: function tsParseTypeMember() {
          var node = this.startNode();

          if (this.match(types.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }

          if (this.match(types._new)) {
            var id = this.startNode();
            this.next();

            if (this.match(types.parenL) || this.isRelational("<")) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }

          var readonly = !!this.tsParseModifier(["readonly"]);
          var idx = this.tsTryParseIndexSignature(node);

          if (idx) {
            if (readonly) node.readonly = true;
            return idx;
          }

          this.parsePropertyName(node);
          return this.tsParsePropertyOrMethodSignature(node, readonly);
        }
      }, {
        key: "tsParseTypeLiteral",
        value: function tsParseTypeLiteral() {
          var node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
      }, {
        key: "tsParseObjectTypeMembers",
        value: function tsParseObjectTypeMembers() {
          this.expect(types.braceL);
          var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(types.braceR);
          return members;
        }
      }, {
        key: "tsIsStartOfMappedType",
        value: function tsIsStartOfMappedType() {
          this.next();

          if (this.eat(types.plusMin)) {
            return this.isContextual("readonly");
          }

          if (this.isContextual("readonly")) {
            this.next();
          }

          if (!this.match(types.bracketL)) {
            return false;
          }

          this.next();

          if (!this.tsIsIdentifier()) {
            return false;
          }

          this.next();
          return this.match(types._in);
        }
      }, {
        key: "tsParseMappedTypeParameter",
        value: function tsParseMappedTypeParameter() {
          var node = this.startNode();
          node.name = this.parseIdentifierName(node.start);
          node.constraint = this.tsExpectThenParseType(types._in);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsParseMappedType",
        value: function tsParseMappedType() {
          var node = this.startNode();
          this.expect(types.braceL);

          if (this.match(types.plusMin)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual("readonly");
          } else if (this.eatContextual("readonly")) {
            node.readonly = true;
          }

          this.expect(types.bracketL);
          node.typeParameter = this.tsParseMappedTypeParameter();
          this.expect(types.bracketR);

          if (this.match(types.plusMin)) {
            node.optional = this.state.value;
            this.next();
            this.expect(types.question);
          } else if (this.eat(types.question)) {
            node.optional = true;
          }

          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(types.braceR);
          return this.finishNode(node, "TSMappedType");
        }
      }, {
        key: "tsParseTupleType",
        value: function tsParseTupleType() {
          var _this18 = this;

          var node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          var seenOptionalElement = false;
          node.elementTypes.forEach(function (elementNode) {
            if (elementNode.type === "TSOptionalType") {
              seenOptionalElement = true;
            } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
              _this18.raise(elementNode.start, "A required element cannot follow an optional element.");
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
      }, {
        key: "tsParseTupleElementType",
        value: function tsParseTupleElementType() {
          if (this.match(types.ellipsis)) {
            var restNode = this.startNode();
            this.next();
            restNode.typeAnnotation = this.tsParseType();
            this.checkCommaAfterRest(93);
            return this.finishNode(restNode, "TSRestType");
          }

          var type = this.tsParseType();

          if (this.eat(types.question)) {
            var optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            return this.finishNode(optionalTypeNode, "TSOptionalType");
          }

          return type;
        }
      }, {
        key: "tsParseParenthesizedType",
        value: function tsParseParenthesizedType() {
          var node = this.startNode();
          this.expect(types.parenL);
          node.typeAnnotation = this.tsParseType();
          this.expect(types.parenR);
          return this.finishNode(node, "TSParenthesizedType");
        }
      }, {
        key: "tsParseFunctionOrConstructorType",
        value: function tsParseFunctionOrConstructorType(type) {
          var node = this.startNode();

          if (type === "TSConstructorType") {
            this.expect(types._new);
          }

          this.tsFillSignature(types.arrow, node);
          return this.finishNode(node, type);
        }
      }, {
        key: "tsParseLiteralTypeNode",
        value: function tsParseLiteralTypeNode() {
          var _this19 = this;

          var node = this.startNode();

          node.literal = function () {
            switch (_this19.state.type) {
              case types.num:
              case types.string:
              case types._true:
              case types._false:
                return _this19.parseExprAtom();

              default:
                throw _this19.unexpected();
            }
          }();

          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "tsParseTemplateLiteralType",
        value: function tsParseTemplateLiteralType() {
          var node = this.startNode();
          var templateNode = this.parseTemplate(false);

          if (templateNode.expressions.length > 0) {
            this.raise(templateNode.expressions[0].start, "Template literal types cannot have any substitution");
          }

          node.literal = templateNode;
          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "tsParseNonArrayType",
        value: function tsParseNonArrayType() {
          switch (this.state.type) {
            case types.name:
            case types._void:
            case types._null:
              {
                var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

                if (type !== undefined && this.lookaheadCharCode() !== 46) {
                  var node = this.startNode();
                  this.next();
                  return this.finishNode(node, type);
                }

                return this.tsParseTypeReference();
              }

            case types.string:
            case types.num:
            case types._true:
            case types._false:
              return this.tsParseLiteralTypeNode();

            case types.plusMin:
              if (this.state.value === "-") {
                var _node6 = this.startNode();

                if (this.lookahead().type !== types.num) {
                  throw this.unexpected();
                }

                _node6.literal = this.parseMaybeUnary();
                return this.finishNode(_node6, "TSLiteralType");
              }

              break;

            case types._this:
              {
                var thisKeyword = this.tsParseThisTypeNode();

                if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                  return this.tsParseThisTypePredicate(thisKeyword);
                } else {
                  return thisKeyword;
                }
              }

            case types._typeof:
              return this.tsParseTypeQuery();

            case types._import:
              return this.tsParseImportType();

            case types.braceL:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

            case types.bracketL:
              return this.tsParseTupleType();

            case types.parenL:
              return this.tsParseParenthesizedType();

            case types.backQuote:
              return this.tsParseTemplateLiteralType();
          }

          throw this.unexpected();
        }
      }, {
        key: "tsParseArrayTypeOrHigher",
        value: function tsParseArrayTypeOrHigher() {
          var type = this.tsParseNonArrayType();

          while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
            if (this.match(types.bracketR)) {
              var node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(types.bracketR);
              type = this.finishNode(node, "TSArrayType");
            } else {
              var _node7 = this.startNodeAtNode(type);

              _node7.objectType = type;
              _node7.indexType = this.tsParseType();
              this.expect(types.bracketR);
              type = this.finishNode(_node7, "TSIndexedAccessType");
            }
          }

          return type;
        }
      }, {
        key: "tsParseTypeOperator",
        value: function tsParseTypeOperator(operator) {
          var node = this.startNode();
          this.expectContextual(operator);
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }

          return this.finishNode(node, "TSTypeOperator");
        }
      }, {
        key: "tsCheckTypeAnnotationForReadOnly",
        value: function tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;

            default:
              this.raise(node.start, "'readonly' type modifier is only permitted on array and tuple literal types.");
          }
        }
      }, {
        key: "tsParseInferType",
        value: function tsParseInferType() {
          var node = this.startNode();
          this.expectContextual("infer");
          var typeParameter = this.startNode();
          typeParameter.name = this.parseIdentifierName(typeParameter.start);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
      }, {
        key: "tsParseTypeOperatorOrHigher",
        value: function tsParseTypeOperatorOrHigher() {
          var _this20 = this;

          var operator = ["keyof", "unique", "readonly"].find(function (kw) {
            return _this20.isContextual(kw);
          });
          return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
        }
      }, {
        key: "tsParseUnionOrIntersectionType",
        value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          this.eat(operator);
          var type = parseConstituentType();

          if (this.match(operator)) {
            var _types = [type];

            while (this.eat(operator)) {
              _types.push(parseConstituentType());
            }

            var node = this.startNodeAtNode(type);
            node.types = _types;
            type = this.finishNode(node, kind);
          }

          return type;
        }
      }, {
        key: "tsParseIntersectionTypeOrHigher",
        value: function tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
        }
      }, {
        key: "tsParseUnionTypeOrHigher",
        value: function tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
        }
      }, {
        key: "tsIsStartOfFunctionType",
        value: function tsIsStartOfFunctionType() {
          if (this.isRelational("<")) {
            return true;
          }

          return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
      }, {
        key: "tsSkipParameterStart",
        value: function tsSkipParameterStart() {
          if (this.match(types.name) || this.match(types._this)) {
            this.next();
            return true;
          }

          if (this.match(types.braceL)) {
            var braceStackCounter = 1;
            this.next();

            while (braceStackCounter > 0) {
              if (this.match(types.braceL)) {
                ++braceStackCounter;
              } else if (this.match(types.braceR)) {
                --braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          if (this.match(types.bracketL)) {
            var _braceStackCounter = 1;
            this.next();

            while (_braceStackCounter > 0) {
              if (this.match(types.bracketL)) {
                ++_braceStackCounter;
              } else if (this.match(types.bracketR)) {
                --_braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          return false;
        }
      }, {
        key: "tsIsUnambiguouslyStartOfFunctionType",
        value: function tsIsUnambiguouslyStartOfFunctionType() {
          this.next();

          if (this.match(types.parenR) || this.match(types.ellipsis)) {
            return true;
          }

          if (this.tsSkipParameterStart()) {
            if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
              return true;
            }

            if (this.match(types.parenR)) {
              this.next();

              if (this.match(types.arrow)) {
                return true;
              }
            }
          }

          return false;
        }
      }, {
        key: "tsParseTypeOrTypePredicateAnnotation",
        value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
          var _this21 = this;

          return this.tsInType(function () {
            var t = _this21.startNode();

            _this21.expect(returnToken);

            var asserts = _this21.tsTryParse(_this21.tsParseTypePredicateAsserts.bind(_this21));

            var typePredicateVariable = _this21.tsIsIdentifier() && _this21.tsTryParse(_this21.tsParseTypePredicatePrefix.bind(_this21));

            if (!typePredicateVariable) {
              if (!asserts) {
                return _this21.tsParseTypeAnnotation(false, t);
              }

              var _node8 = _this21.startNodeAtNode(t);

              _node8.parameterName = _this21.parseIdentifier();
              _node8.asserts = asserts;
              t.typeAnnotation = _this21.finishNode(_node8, "TSTypePredicate");
              return _this21.finishNode(t, "TSTypeAnnotation");
            }

            var type = _this21.tsParseTypeAnnotation(false);

            var node = _this21.startNodeAtNode(t);

            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = _this21.finishNode(node, "TSTypePredicate");
            return _this21.finishNode(t, "TSTypeAnnotation");
          });
        }
      }, {
        key: "tsTryParseTypeOrTypePredicateAnnotation",
        value: function tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
        }
      }, {
        key: "tsTryParseTypeAnnotation",
        value: function tsTryParseTypeAnnotation() {
          return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
        }
      }, {
        key: "tsTryParseType",
        value: function tsTryParseType() {
          return this.tsEatThenParseType(types.colon);
        }
      }, {
        key: "tsParseTypePredicatePrefix",
        value: function tsParseTypePredicatePrefix() {
          var id = this.parseIdentifier();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
      }, {
        key: "tsParseTypePredicateAsserts",
        value: function tsParseTypePredicateAsserts() {
          if (!this.tsIsIdentifier()) {
            return false;
          }

          var id = this.parseIdentifier();

          if (id.name !== "asserts" || this.hasPrecedingLineBreak() || !this.tsIsIdentifier()) {
            return false;
          }

          return true;
        }
      }, {
        key: "tsParseTypeAnnotation",
        value: function tsParseTypeAnnotation() {
          var _this22 = this;

          var eatColon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();
          this.tsInType(function () {
            if (eatColon) _this22.expect(types.colon);
            t.typeAnnotation = _this22.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        }
      }, {
        key: "tsParseType",
        value: function tsParseType() {
          assert(this.state.inType);
          var type = this.tsParseNonConditionalType();

          if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
            return type;
          }

          var node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsParseNonConditionalType();
          this.expect(types.question);
          node.trueType = this.tsParseType();
          this.expect(types.colon);
          node.falseType = this.tsParseType();
          return this.finishNode(node, "TSConditionalType");
        }
      }, {
        key: "tsParseNonConditionalType",
        value: function tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }

          if (this.match(types._new)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          }

          return this.tsParseUnionTypeOrHigher();
        }
      }, {
        key: "tsParseTypeAssertion",
        value: function tsParseTypeAssertion() {
          var node = this.startNode();

          var _const = this.tsTryNextParseConstantContext();

          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expectRelational(">");
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
      }, {
        key: "tsParseHeritageClause",
        value: function tsParseHeritageClause(descriptor) {
          var originalStart = this.state.start;
          var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

          if (!delimitedList.length) {
            this.raise(originalStart, "'".concat(descriptor, "' list cannot be empty."));
          }

          return delimitedList;
        }
      }, {
        key: "tsParseExpressionWithTypeArguments",
        value: function tsParseExpressionWithTypeArguments() {
          var node = this.startNode();
          node.expression = this.tsParseEntityName(false);

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSExpressionWithTypeArguments");
        }
      }, {
        key: "tsParseInterfaceDeclaration",
        value: function tsParseInterfaceDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
          node.typeParameters = this.tsTryParseTypeParameters();

          if (this.eat(types._extends)) {
            node.extends = this.tsParseHeritageClause("extends");
          }

          var body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
      }, {
        key: "tsParseTypeAliasDeclaration",
        value: function tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
          node.typeParameters = this.tsTryParseTypeParameters();
          node.typeAnnotation = this.tsExpectThenParseType(types.eq);
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
      }, {
        key: "tsInNoContext",
        value: function tsInNoContext(cb) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];

          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
      }, {
        key: "tsInType",
        value: function tsInType(cb) {
          var oldInType = this.state.inType;
          this.state.inType = true;

          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
      }, {
        key: "tsEatThenParseType",
        value: function tsEatThenParseType(token) {
          return !this.match(token) ? undefined : this.tsNextThenParseType();
        }
      }, {
        key: "tsExpectThenParseType",
        value: function tsExpectThenParseType(token) {
          var _this23 = this;

          return this.tsDoThenParseType(function () {
            return _this23.expect(token);
          });
        }
      }, {
        key: "tsNextThenParseType",
        value: function tsNextThenParseType() {
          var _this24 = this;

          return this.tsDoThenParseType(function () {
            return _this24.next();
          });
        }
      }, {
        key: "tsDoThenParseType",
        value: function tsDoThenParseType(cb) {
          var _this25 = this;

          return this.tsInType(function () {
            cb();
            return _this25.tsParseType();
          });
        }
      }, {
        key: "tsParseEnumMember",
        value: function tsParseEnumMember() {
          var node = this.startNode();
          node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

          if (this.eat(types.eq)) {
            node.initializer = this.parseMaybeAssign();
          }

          return this.finishNode(node, "TSEnumMember");
        }
      }, {
        key: "tsParseEnumDeclaration",
        value: function tsParseEnumDeclaration(node, isConst) {
          if (isConst) node.const = true;
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
          this.expect(types.braceL);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(types.braceR);
          return this.finishNode(node, "TSEnumDeclaration");
        }
      }, {
        key: "tsParseModuleBlock",
        value: function tsParseModuleBlock() {
          var node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(types.braceL);
          this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
      }, {
        key: "tsParseModuleOrNamespaceDeclaration",
        value: function tsParseModuleOrNamespaceDeclaration(node) {
          var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.parseIdentifier();

          if (!nested) {
            this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
          }

          if (this.eat(types.dot)) {
            var inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            node.body = this.tsParseModuleBlock();
            this.scope.exit();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseAmbientExternalModuleDeclaration",
        value: function tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual("global")) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(types.string)) {
            node.id = this.parseExprAtom();
          } else {
            this.unexpected();
          }

          if (this.match(types.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            node.body = this.tsParseModuleBlock();
            this.scope.exit();
          } else {
            this.semicolon();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseImportEqualsDeclaration",
        value: function tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.expect(types.eq);
          node.moduleReference = this.tsParseModuleReference();
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
      }, {
        key: "tsIsExternalModuleReference",
        value: function tsIsExternalModuleReference() {
          return this.isContextual("require") && this.lookaheadCharCode() === 40;
        }
      }, {
        key: "tsParseModuleReference",
        value: function tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
      }, {
        key: "tsParseExternalModuleReference",
        value: function tsParseExternalModuleReference() {
          var node = this.startNode();
          this.expectContextual("require");
          this.expect(types.parenL);

          if (!this.match(types.string)) {
            throw this.unexpected();
          }

          node.expression = this.parseExprAtom();
          this.expect(types.parenR);
          return this.finishNode(node, "TSExternalModuleReference");
        }
      }, {
        key: "tsLookAhead",
        value: function tsLookAhead(f) {
          var state = this.state.clone();
          var res = f();
          this.state = state;
          return res;
        }
      }, {
        key: "tsTryParseAndCatch",
        value: function tsTryParseAndCatch(f) {
          var result = this.tryParse(function (abort) {
            return f() || abort();
          });
          if (result.aborted || !result.node) return undefined;
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "tsTryParse",
        value: function tsTryParse(f) {
          var state = this.state.clone();
          var result = f();

          if (result !== undefined && result !== false) {
            return result;
          } else {
            this.state = state;
            return undefined;
          }
        }
      }, {
        key: "tsTryParseDeclare",
        value: function tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }

          var starttype = this.state.type;
          var kind;

          if (this.isContextual("let")) {
            starttype = types._var;
            kind = "let";
          }

          switch (starttype) {
            case types._function:
              return this.parseFunctionStatement(nany, false, true);

            case types._class:
              nany.declare = true;
              return this.parseClass(nany, true, false);

            case types._const:
              if (this.match(types._const) && this.isLookaheadContextual("enum")) {
                this.expect(types._const);
                this.expectContextual("enum");
                return this.tsParseEnumDeclaration(nany, true);
              }

            case types._var:
              kind = kind || this.state.value;
              return this.parseVarStatement(nany, kind);

            case types.name:
              {
                var value = this.state.value;

                if (value === "global") {
                  return this.tsParseAmbientExternalModuleDeclaration(nany);
                } else {
                  return this.tsParseDeclaration(nany, value, true);
                }
              }
          }
        }
      }, {
        key: "tsTryParseExportDeclaration",
        value: function tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
      }, {
        key: "tsParseExpressionStatement",
        value: function tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare":
              {
                var declaration = this.tsTryParseDeclare(node);

                if (declaration) {
                  declaration.declare = true;
                  return declaration;
                }

                break;
              }

            case "global":
              if (this.match(types.braceL)) {
                this.scope.enter(SCOPE_TS_MODULE);
                var mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }

              break;

            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
      }, {
        key: "tsParseDeclaration",
        value: function tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
                var cls = node;
                cls.abstract = true;

                if (next) {
                  this.next();

                  if (!this.match(types._class)) {
                    this.unexpected(null, types._class);
                  }
                }

                return this.parseClass(cls, true, false);
              }

              break;

            case "enum":
              if (next || this.match(types.name)) {
                if (next) this.next();
                return this.tsParseEnumDeclaration(node, false);
              }

              break;

            case "interface":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseInterfaceDeclaration(node);
              }

              break;

            case "module":
              if (next) this.next();

              if (this.match(types.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "namespace":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "type":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseTypeAliasDeclaration(node);
              }

              break;
          }
        }
      }, {
        key: "tsCheckLineTerminatorAndMatch",
        value: function tsCheckLineTerminatorAndMatch(tokenType, next) {
          return (next || this.match(tokenType)) && !this.isLineTerminator();
        }
      }, {
        key: "tsTryParseGenericAsyncArrowFunction",
        value: function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          var _this26 = this;

          if (!this.isRelational("<")) {
            return undefined;
          }

          var res = this.tsTryParseAndCatch(function () {
            var node = _this26.startNodeAt(startPos, startLoc);

            node.typeParameters = _this26.tsParseTypeParameters();

            _get(_getPrototypeOf(_class4.prototype), "parseFunctionParams", _this26).call(_this26, node);

            node.returnType = _this26.tsTryParseTypeOrTypePredicateAnnotation();

            _this26.expect(types.arrow);

            return node;
          });

          if (!res) {
            return undefined;
          }

          return this.parseArrowExpression(res, null, true);
        }
      }, {
        key: "tsParseTypeArguments",
        value: function tsParseTypeArguments() {
          var _this27 = this;

          var node = this.startNode();
          node.params = this.tsInType(function () {
            return _this27.tsInNoContext(function () {
              _this27.expectRelational("<");

              return _this27.tsParseDelimitedList("TypeParametersOrArguments", _this27.tsParseType.bind(_this27));
            });
          });
          this.state.exprAllowed = false;
          this.expectRelational(">");
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
      }, {
        key: "tsIsDeclarationStart",
        value: function tsIsDeclarationStart() {
          if (this.match(types.name)) {
            switch (this.state.value) {
              case "abstract":
              case "declare":
              case "enum":
              case "interface":
              case "module":
              case "namespace":
              case "type":
                return true;
            }
          }

          return false;
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart()) return false;
          return _get(_getPrototypeOf(_class4.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseAssignableListItem",
        value: function parseAssignableListItem(allowModifiers, decorators) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var accessibility;
          var readonly = false;

          if (allowModifiers) {
            accessibility = this.parseAccessModifier();
            readonly = !!this.tsParseModifier(["readonly"]);
          }

          var left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

          if (accessibility || readonly) {
            var pp = this.startNodeAt(startPos, startLoc);

            if (decorators.length) {
              pp.decorators = decorators;
            }

            if (accessibility) pp.accessibility = accessibility;
            if (readonly) pp.readonly = readonly;

            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(pp.start, "A parameter property may not be declared using a binding pattern.");
            }

            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }

          if (decorators.length) {
            left.decorators = decorators;
          }

          return elt;
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(types.colon)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
          }

          var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

          if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
            this.finishNode(node, bodilessType);
            return;
          }

          _get(_getPrototypeOf(_class4.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "registerFunctionStatementId",
        value: function registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
          } else {
            _get(_getPrototypeOf(_class4.prototype), "registerFunctionStatementId", this).apply(this, arguments);
          }
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var _this28 = this;

          if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
            this.state.exprAllowed = false;
            this.next();
            var nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }

          if (this.isRelational("<")) {
            var result = this.tsTryParseAndCatch(function () {
              if (!noCalls && _this28.atPossibleAsync(base)) {
                var asyncArrowFn = _this28.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }

              var node = _this28.startNodeAt(startPos, startLoc);

              node.callee = base;

              var typeArguments = _this28.tsParseTypeArguments();

              if (typeArguments) {
                if (!noCalls && _this28.eat(types.parenL)) {
                  node.arguments = _this28.parseCallExpressionArguments(types.parenR, false);
                  node.typeParameters = typeArguments;
                  return _this28.finishCallExpression(node, state.optionalChainMember);
                } else if (_this28.match(types.backQuote)) {
                  return _this28.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
                }
              }

              _this28.unexpected();
            });
            if (result) return result;
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, state);
        }
      }, {
        key: "parseNewArguments",
        value: function parseNewArguments(node) {
          var _this29 = this;

          if (this.isRelational("<")) {
            var typeParameters = this.tsTryParseAndCatch(function () {
              var args = _this29.tsParseTypeArguments();

              if (!_this29.match(types.parenL)) _this29.unexpected();
              return args;
            });

            if (typeParameters) {
              node.typeParameters = typeParameters;
            }
          }

          _get(_getPrototypeOf(_class4.prototype), "parseNewArguments", this).call(this, node);
        }
      }, {
        key: "parseExprOp",
        value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
          if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
            var node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;

            var _const = this.tsTryNextParseConstantContext();

            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }

            this.finishNode(node, "TSAsExpression");
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseExprOp", this).call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {}
      }, {
        key: "checkDuplicateExports",
        value: function checkDuplicateExports() {}
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          if (this.match(types.name) && this.lookahead().type === types.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseImport", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          if (this.match(types._import)) {
            this.expect(types._import);
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(types.eq)) {
            var assign = node;
            assign.expression = this.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual("as")) {
            var decl = node;
            this.expectContextual("namespace");
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            return _get(_getPrototypeOf(_class4.prototype), "parseExport", this).call(this, node);
          }
        }
      }, {
        key: "isAbstractClass",
        value: function isAbstractClass() {
          return this.isContextual("abstract") && this.lookahead().type === types._class;
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            var cls = this.startNode();
            this.next();
            this.parseClass(cls, true, true);
            cls.abstract = true;
            return cls;
          }

          if (this.state.value === "interface") {
            var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
            if (result) return result;
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseStatementContent",
        value: function parseStatementContent(context, topLevel) {
          if (this.state.type === types._const) {
            var ahead = this.lookahead();

            if (ahead.type === types.name && ahead.value === "enum") {
              var node = this.startNode();
              this.expect(types._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(node, true);
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseStatementContent", this).call(this, context, topLevel);
        }
      }, {
        key: "parseAccessModifier",
        value: function parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
      }, {
        key: "parseClassMember",
        value: function parseClassMember(classBody, member, state, constructorAllowsSuper) {
          var accessibility = this.parseAccessModifier();
          if (accessibility) member.accessibility = accessibility;

          _get(_getPrototypeOf(_class4.prototype), "parseClassMember", this).call(this, classBody, member, state, constructorAllowsSuper);
        }
      }, {
        key: "parseClassMemberWithIsStatic",
        value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
          var modifiers = this.tsParseModifiers(["abstract", "readonly", "declare"]);
          Object.assign(member, modifiers);
          var idx = this.tsTryParseIndexSignature(member);

          if (idx) {
            classBody.body.push(idx);

            if (modifiers.abstract) {
              this.raise(member.start, "Index signatures cannot have the 'abstract' modifier");
            }

            if (isStatic) {
              this.raise(member.start, "Index signatures cannot have the 'static' modifier");
            }

            if (member.accessibility) {
              this.raise(member.start, "Index signatures cannot have an accessibility modifier ('".concat(member.accessibility, "')"));
            }

            return;
          }

          _get(_getPrototypeOf(_class4.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody, member, state, isStatic, constructorAllowsSuper);
        }
      }, {
        key: "parsePostMemberNameModifiers",
        value: function parsePostMemberNameModifiers(methodOrProp) {
          var optional = this.eat(types.question);
          if (optional) methodOrProp.optional = true;

          if (methodOrProp.readonly && this.match(types.parenL)) {
            this.raise(methodOrProp.start, "Class methods cannot have the 'readonly' modifier");
          }

          if (methodOrProp.declare && this.match(types.parenL)) {
            this.raise(methodOrProp.start, "Class methods cannot have the 'declare' modifier");
          }
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
          return decl || _get(_getPrototypeOf(_class4.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart()) return true;
          return _get(_getPrototypeOf(_class4.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
          var _this30 = this;

          if (!refNeedsArrowPos || !this.match(types.question)) {
            return _get(_getPrototypeOf(_class4.prototype), "parseConditional", this).call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);
          }

          var result = this.tryParse(function () {
            return _get(_getPrototypeOf(_class4.prototype), "parseConditional", _this30).call(_this30, expr, noIn, startPos, startLoc);
          });

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(_class4.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(types.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }

          return node;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var isDeclare = this.eatContextual("declare");
          var declaration;

          if (this.match(types.name)) {
            declaration = this.tsTryParseExportDeclaration();
          }

          if (!declaration) {
            declaration = _get(_getPrototypeOf(_class4.prototype), "parseExportDeclaration", this).call(this, node);
          }

          if (declaration && isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }

          return declaration;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId) {
          if ((!isStatement || optionalId) && this.isContextual("implements")) {
            return;
          }

          _get(_getPrototypeOf(_class4.prototype), "parseClassId", this).call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;
        }
      }, {
        key: "parseClassPropertyAnnotation",
        value: function parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(types.bang)) {
            node.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);

          if (node.declare && this.match(types.equal)) {
            this.raise(this.state.start, "'declare' class fields cannot have an initializer");
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(node.start, "Private elements cannot have the 'abstract' modifier.");
          }

          if (node.accessibility) {
            this.raise(node.start, "Private elements cannot have an accessibility modifier ('".concat(node.accessibility, "')"));
          }

          this.parseClassPropertyAnnotation(node);
          return _get(_getPrototypeOf(_class4.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(_class4.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.tsParseTypeArguments();
          }

          if (this.eatContextual("implements")) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop) {
          var _get2;

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) prop.typeParameters = typeParameters;

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (_get2 = _get(_getPrototypeOf(_class4.prototype), "parseObjPropValue", this)).call.apply(_get2, [this, prop].concat(args));
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(_class4.prototype), "parseVarId", this).call(this, decl, kind);

          if (decl.id.type === "Identifier" && this.eat(types.bang)) {
            decl.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types.colon)) {
            node.returnType = this.tsParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign() {
          var _this31 = this;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var state;
          var jsx;
          var typeCast;

          if (this.match(types.jsxTagStart)) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              var _get3;

              return (_get3 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this31)).call.apply(_get3, [_this31].concat(args));
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;

            if (context[context.length - 1] === types$1.j_oTag) {
              context.length -= 2;
            } else if (context[context.length - 1] === types$1.j_expr) {
              context.length -= 1;
            }
          }

          if (!(jsx && jsx.error) && !this.isRelational("<")) {
            var _get4;

            return (_get4 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", this)).call.apply(_get4, [this].concat(args));
          }

          var typeParameters;
          state = state || this.state.clone();
          var arrow = this.tryParse(function (abort) {
            var _get5;

            typeParameters = _this31.tsParseTypeParameters();

            var expr = (_get5 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this31)).call.apply(_get5, [_this31].concat(args));

            if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
              abort();
            }

            if (typeParameters && typeParameters.params.length !== 0) {
              _this31.resetStartLocationFromNode(expr, typeParameters);
            }

            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;

          if (!jsx) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(function () {
              var _get6;

              return (_get6 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this31)).call.apply(_get6, [_this31].concat(args));
            }, state);
            if (!typeCast.error) return typeCast.node;
          }

          if (jsx && jsx.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (typeCast && typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }

          if (jsx && jsx.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          if (typeCast && typeCast.thrown) throw typeCast.error;
          throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;
        }
      }, {
        key: "parseMaybeUnary",
        value: function parseMaybeUnary(refShorthandDefaultPos) {
          if (!this.hasPlugin("jsx") && this.isRelational("<")) {
            return this.tsParseTypeAssertion();
          } else {
            return _get(_getPrototypeOf(_class4.prototype), "parseMaybeUnary", this).call(this, refShorthandDefaultPos);
          }
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this32 = this;

          if (this.match(types.colon)) {
            var result = this.tryParse(function (abort) {
              var returnType = _this32.tsParseTypeOrTypePredicateAnnotation(types.colon);

              if (_this32.canInsertSemicolon() || !_this32.match(types.arrow)) abort();
              return returnType;
            });
            if (result.aborted) return;

            if (!result.thrown) {
              if (result.error) this.state = result.failState;
              node.returnType = result.node;
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(types.question)) {
            if (param.type !== "Identifier") {
              this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
            }

            param.optional = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node, isBinding, contextDescription) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, this.typeCastToParameter(node), isBinding, contextDescription);

            case "TSParameterProperty":
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, node, isBinding, contextDescription);

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
              return node;

            default:
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, node, isBinding, contextDescription);
          }
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
          var checkClashes = arguments.length > 2 ? arguments[2] : undefined;
          var contextDescription = arguments.length > 3 ? arguments[3] : undefined;

          switch (expr.type) {
            case "TSTypeCastExpression":
              return;

            case "TSParameterProperty":
              this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
              return;

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
              return;

            default:
              _get(_getPrototypeOf(_class4.prototype), "checkLVal", this).call(this, expr, bindingType, checkClashes, contextDescription);

              return;
          }
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          switch (this.state.type) {
            case types._this:
              return this.parseIdentifier(true);

            default:
              return _get(_getPrototypeOf(_class4.prototype), "parseBindingAtom", this).call(this);
          }
        }
      }, {
        key: "parseMaybeDecoratorArguments",
        value: function parseMaybeDecoratorArguments(expr) {
          if (this.isRelational("<")) {
            var typeArguments = this.tsParseTypeArguments();

            if (this.match(types.parenL)) {
              var call = _get(_getPrototypeOf(_class4.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);

              call.typeParameters = typeArguments;
              return call;
            }

            this.unexpected(this.state.start, types.parenL);
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.isRelational("<") || _get(_getPrototypeOf(_class4.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(types.bang) || this.match(types.colon) || _get(_getPrototypeOf(_class4.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault() {
          var _get7;

          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          var node = (_get7 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeDefault", this)).call.apply(_get7, [this].concat(args));

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
          }

          return node;
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types.relational, 1);
          } else {
            return _get(_getPrototypeOf(_class4.prototype), "getTokenFromCode", this).call(this, code);
          }
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];
            if (!expr) continue;

            switch (expr.type) {
              case "TSTypeCastExpression":
                exprList[i] = this.typeCastToParameter(expr);
                break;

              case "TSAsExpression":
              case "TSTypeAssertion":
                this.raise(expr.start, "Unexpected type cast in parameter position.");
                break;
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "toAssignableList", this).apply(this, arguments);
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isInParens) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr._exprListItem && expr.type === "TsTypeCastExpression") {
              this.raise(expr.start, "Did not expect a type annotation here.");
            }
          }

          return exprList;
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow() {
          return this.match(types.colon) || _get(_getPrototypeOf(_class4.prototype), "shouldParseArrow", this).call(this);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(types.colon) || _get(_getPrototypeOf(_class4.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "canHaveLeadingDecorator",
        value: function canHaveLeadingDecorator() {
          return _get(_getPrototypeOf(_class4.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var _this33 = this;

          if (this.isRelational("<")) {
            var typeArguments = this.tsTryParseAndCatch(function () {
              return _this33.tsParseTypeArguments();
            });
            if (typeArguments) node.typeParameters = typeArguments;
          }

          return _get(_getPrototypeOf(_class4.prototype), "jsxParseOpeningElementAfterName", this).call(this, node);
        }
      }, {
        key: "getGetterSetterExpectedParamCount",
        value: function getGetterSetterExpectedParamCount(method) {
          var baseCount = _get(_getPrototypeOf(_class4.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);

          var firstParam = method.params[0];
          var hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
          return hasContextParam ? baseCount + 1 : baseCount;
        }
      }]);

      return _class4;
    }(superClass)
  );
};

types.placeholder = new TokenType("%%", {
  startsExpr: true
});

var placeholders = function placeholders(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass5) {
      _inherits(_class5, _superClass5);

      function _class5() {
        _classCallCheck(this, _class5);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class5).apply(this, arguments));
      }

      _createClass(_class5, [{
        key: "parsePlaceholder",
        value: function parsePlaceholder(expectedNode) {
          if (this.match(types.placeholder)) {
            var node = this.startNode();
            this.next();
            this.assertNoSpace("Unexpected space in placeholder.");
            node.name = _get(_getPrototypeOf(_class5.prototype), "parseIdentifier", this).call(this, true);
            this.assertNoSpace("Unexpected space in placeholder.");
            this.expect(types.placeholder);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
      }, {
        key: "finishPlaceholder",
        value: function finishPlaceholder(node, expectedNode) {
          var isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(types.placeholder, 2);
          }

          return _get(_getPrototypeOf(_class5.prototype), "getTokenFromCode", this).apply(this, arguments);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom() {
          return this.parsePlaceholder("Expression") || _get(_getPrototypeOf(_class5.prototype), "parseExprAtom", this).apply(this, arguments);
        }
      }, {
        key: "parseIdentifier",
        value: function parseIdentifier() {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(_class5.prototype), "parseIdentifier", this).apply(this, arguments);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word) {
          if (word !== undefined) _get(_getPrototypeOf(_class5.prototype), "checkReservedWord", this).apply(this, arguments);
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || _get(_getPrototypeOf(_class5.prototype), "parseBindingAtom", this).apply(this, arguments);
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          if (expr.type !== "Placeholder") _get(_getPrototypeOf(_class5.prototype), "checkLVal", this).apply(this, arguments);
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
            return node;
          }

          return _get(_getPrototypeOf(_class5.prototype), "toAssignable", this).apply(this, arguments);
        }
      }, {
        key: "verifyBreakContinue",
        value: function verifyBreakContinue(node) {
          if (node.label && node.label.type === "Placeholder") return;

          _get(_getPrototypeOf(_class5.prototype), "verifyBreakContinue", this).apply(this, arguments);
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return _get(_getPrototypeOf(_class5.prototype), "parseExpressionStatement", this).apply(this, arguments);
          }

          if (this.match(types.colon)) {
            var stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = this.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }

          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
      }, {
        key: "parseBlock",
        value: function parseBlock() {
          return this.parsePlaceholder("BlockStatement") || _get(_getPrototypeOf(_class5.prototype), "parseBlock", this).apply(this, arguments);
        }
      }, {
        key: "parseFunctionId",
        value: function parseFunctionId() {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(_class5.prototype), "parseFunctionId", this).apply(this, arguments);
        }
      }, {
        key: "parseClass",
        value: function parseClass(node, isStatement, optionalId) {
          var type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          var placeholder = this.parsePlaceholder("Identifier");

          if (placeholder) {
            if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              this.unexpected(null, "A class name is required");
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }

          this.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass);
          return this.finishNode(node, type);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(_class5.prototype), "parseExport", this).apply(this, arguments);

          if (!this.isContextual("from") && !this.match(types.comma)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }

          this.expectPlugin("exportDefaultFrom");
          var specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return _get(_getPrototypeOf(_class5.prototype), "parseExport", this).call(this, node);
        }
      }, {
        key: "maybeParseExportDefaultSpecifier",
        value: function maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }

          return _get(_getPrototypeOf(_class5.prototype), "maybeParseExportDefaultSpecifier", this).apply(this, arguments);
        }
      }, {
        key: "checkExport",
        value: function checkExport(node) {
          var specifiers = node.specifiers;

          if (specifiers && specifiers.length) {
            node.specifiers = specifiers.filter(function (node) {
              return node.exported.type === "Placeholder";
            });
          }

          _get(_getPrototypeOf(_class5.prototype), "checkExport", this).call(this, node);

          node.specifiers = specifiers;
        }
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(_class5.prototype), "parseImport", this).apply(this, arguments);
          node.specifiers = [];

          if (!this.isContextual("from") && !this.match(types.comma)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }

          var specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          this.finishNode(specifier, "ImportDefaultSpecifier");
          node.specifiers.push(specifier);

          if (this.eat(types.comma)) {
            var hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport) this.parseNamedImportSpecifiers(node);
          }

          this.expectContextual("from");
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
      }, {
        key: "parseImportSource",
        value: function parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || _get(_getPrototypeOf(_class5.prototype), "parseImportSource", this).apply(this, arguments);
        }
      }]);

      return _class5;
    }(superClass)
  );
};

var v8intrinsic = function v8intrinsic(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass6) {
      _inherits(_class6, _superClass6);

      function _class6() {
        _classCallCheck(this, _class6);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class6).apply(this, arguments));
      }

      _createClass(_class6, [{
        key: "parseV8Intrinsic",
        value: function parseV8Intrinsic() {
          if (this.match(types.modulo)) {
            var v8IntrinsicStart = this.state.start;
            var node = this.startNode();
            this.eat(types.modulo);

            if (this.match(types.name)) {
              var name = this.parseIdentifierName(this.state.start);
              var identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";

              if (this.match(types.parenL)) {
                return identifier;
              }
            }

            this.unexpected(v8IntrinsicStart);
          }
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom() {
          return this.parseV8Intrinsic() || _get(_getPrototypeOf(_class6.prototype), "parseExprAtom", this).apply(this, arguments);
        }
      }]);

      return _class6;
    }(superClass)
  );
};

function hasPlugin(plugins, name) {
  return plugins.some(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}

function getPluginOption(plugins, name, option) {
  var plugin = plugins.find(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }

  return null;
}

var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];

function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport == null) {
      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
    throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
      return "'".concat(p, "'");
    }).join(", "));
  }
}

var mixinPlugins = {
  estree: estree,
  jsx: jsx,
  flow: flow,
  typescript: typescript,
  v8intrinsic: v8intrinsic,
  placeholders: placeholders
};
var mixinPluginNames = Object.keys(mixinPlugins);
var defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false
};

function getOptions(opts) {
  var options = {};

  for (var _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

var Position = function Position(line, col) {
  _classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

function getLineInfo(input, offset) {
  var line = 1;
  var lineStart = 0;
  var match;
  lineBreakG.lastIndex = 0;

  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }

  return new Position(line, offset - lineStart);
}

var BaseParser =
/*#__PURE__*/
function () {
  function BaseParser() {
    _classCallCheck(this, BaseParser);

    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  _createClass(BaseParser, [{
    key: "hasPlugin",
    value: function hasPlugin(name) {
      return this.plugins.has(name);
    }
  }, {
    key: "getPluginOption",
    value: function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }
  }]);

  return BaseParser;
}();

function last(stack) {
  return stack[stack.length - 1];
}

var CommentsParser =
/*#__PURE__*/
function (_BaseParser) {
  _inherits(CommentsParser, _BaseParser);

  function CommentsParser() {
    _classCallCheck(this, CommentsParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(CommentsParser).apply(this, arguments));
  }

  _createClass(CommentsParser, [{
    key: "addComment",
    value: function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    }
  }, {
    key: "adjustCommentsAfterTrailingComma",
    value: function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      var lastElement = null;
      var i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (var j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      var newTrailingComments = [];

      for (var _i7 = 0; _i7 < this.state.leadingComments.length; _i7++) {
        var leadingComment = this.state.leadingComments[_i7];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(_i7, 1);
            _i7--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    }
  }, {
    key: "processComment",
    value: function processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      var stack = this.state.commentStack;
      var firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        var lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode], true);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          var leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          node.trailingComments = trailingComments;
        }
      }

      stack.push(node);
    }
  }]);

  return CommentsParser;
}(BaseParser);

var LocationParser =
/*#__PURE__*/
function (_CommentsParser) {
  _inherits(LocationParser, _CommentsParser);

  function LocationParser() {
    _classCallCheck(this, LocationParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(LocationParser).apply(this, arguments));
  }

  _createClass(LocationParser, [{
    key: "getLocationForPosition",
    value: function getLocationForPosition(pos) {
      var loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    }
  }, {
    key: "raise",
    value: function raise(pos, message) {
      var _ref14 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          missingPluginNames = _ref14.missingPluginNames,
          code = _ref14.code;

      var loc = this.getLocationForPosition(pos);
      message += " (".concat(loc.line, ":").concat(loc.column, ")");
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;

      if (missingPluginNames) {
        err.missingPlugin = missingPluginNames;
      }

      if (code !== undefined) {
        err.code = code;
      }

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }
  }]);

  return LocationParser;
}(CommentsParser);

var State =
/*#__PURE__*/
function () {
  function State() {
    _classCallCheck(this, State);

    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.inParameters = false;
    this.maybeInArrowParameters = false;
    this.inPipeline = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.inPropertyName = false;
    this.inClassProperty = false;
    this.hasFlowComment = false;
    this.isIterator = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.classLevel = 0;
    this.labels = [];
    this.decoratorStack = [[]];
    this.yieldPos = -1;
    this.awaitPos = -1;
    this.tokens = [];
    this.comments = [];
    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];
    this.commentPreviousNode = null;
    this.pos = 0;
    this.lineStart = 0;
    this.type = types.eof;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.lastTokEnd = 0;
    this.context = [types$1.braceStatement];
    this.exprAllowed = true;
    this.containsEsc = false;
    this.containsOctal = false;
    this.octalPosition = null;
    this.exportedIdentifiers = [];
    this.invalidTemplateEscapePosition = null;
  }

  _createClass(State, [{
    key: "init",
    value: function init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }
  }, {
    key: "curPosition",
    value: function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  }, {
    key: "clone",
    value: function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }
  }]);

  return State;
}();

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};

var VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
var forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
var allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.bin), [50, 51, 52, 53, 54, 55]);
allowedNumericSeparatorSiblings.dec = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.oct), [56, 57]);
allowedNumericSeparatorSiblings.hex = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.dec), [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);

var Token = function Token(state) {
  _classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

var Tokenizer =
/*#__PURE__*/
function (_LocationParser) {
  _inherits(Tokenizer, _LocationParser);

  function Tokenizer(options, input) {
    var _this34;

    _classCallCheck(this, Tokenizer);

    _this34 = _possibleConstructorReturn(this, _getPrototypeOf(Tokenizer).call(this));
    _this34.state = new State();

    _this34.state.init(options);

    _this34.input = input;
    _this34.length = input.length;
    _this34.isLookahead = false;
    return _this34;
  }

  _createClass(Tokenizer, [{
    key: "next",
    value: function next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.state.tokens.push(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
  }, {
    key: "eat",
    value: function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "match",
    value: function match(type) {
      return this.state.type === type;
    }
  }, {
    key: "lookahead",
    value: function lookahead() {
      var old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    }
  }, {
    key: "nextTokenStart",
    value: function nextTokenStart() {
      var thisTokEnd = this.state.pos;
      skipWhiteSpace.lastIndex = thisTokEnd;
      var skip = skipWhiteSpace.exec(this.input);
      return thisTokEnd + skip[0].length;
    }
  }, {
    key: "lookaheadCharCode",
    value: function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
  }, {
    key: "setStrict",
    value: function setStrict(strict) {
      this.state.strict = strict;
      if (!this.match(types.num) && !this.match(types.string)) return;
      this.state.pos = this.state.start;

      while (this.state.pos < this.state.lineStart) {
        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
        --this.state.curLine;
      }

      this.nextToken();
    }
  }, {
    key: "curContext",
    value: function curContext() {
      return this.state.context[this.state.context.length - 1];
    }
  }, {
    key: "nextToken",
    value: function nextToken() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) this.skipSpace();
      this.state.containsOctal = false;
      this.state.octalPosition = null;
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      if (curContext.override) {
        curContext.override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    }
  }, {
    key: "pushComment",
    value: function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  }, {
    key: "skipBlockComment",
    value: function skipBlockComment() {
      var startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, "Unterminated comment");
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      var match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    }
  }, {
    key: "skipLineComment",
    value: function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    }
  }, {
    key: "skipSpace",
    value: function skipSpace() {
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    }
  }, {
    key: "finishToken",
    value: function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    }
  }, {
    key: "readToken_numberSign",
    value: function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, "Unexpected digit after hash token");
      }

      if ((this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods")) && this.state.classLevel > 0) {
        ++this.state.pos;
        this.finishToken(types.hash);
        return;
      } else if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        this.finishOp(types.hash, 1);
      } else {
        throw this.raise(this.state.pos, "Unexpected character '#'");
      }
    }
  }, {
    key: "readToken_dot",
    value: function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    }
  }, {
    key: "readToken_slash",
    value: function readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    }
  }, {
    key: "readToken_interpreter",
    value: function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var start = this.state.pos;
      this.state.pos += 1;
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch !== 33) return false;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    }
  }, {
    key: "readToken_mult_modulo",
    value: function readToken_mult_modulo(code) {
      var type = code === 42 ? types.star : types.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      var exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    }
  }, {
    key: "readToken_pipe_amp",
    value: function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    }
  }, {
    key: "readToken_caret",
    value: function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    }
  }, {
    key: "readToken_plus_min",
    value: function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    }
  }, {
    key: "readToken_lt_gt",
    value: function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    }
  }, {
    key: "readToken_eq_excl",
    value: function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    }
  }, {
    key: "readToken_question",
    value: function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63 && !this.state.inType) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    }
  }, {
    key: "getTokenFromCode",
    value: function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          ++this.state.pos;
          this.finishToken(types.bracketL);
          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          ++this.state.pos;
          this.finishToken(types.braceL);
          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }

      }

      throw this.raise(this.state.pos, "Unexpected character '".concat(String.fromCodePoint(code), "'"));
    }
  }, {
    key: "finishOp",
    value: function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
  }, {
    key: "readRegexp",
    value: function readRegexp() {
      var start = this.state.pos;
      var escaped, inClass;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, "Unterminated regular expression");
        }

        var ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, "Unterminated regular expression");
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }

          escaped = ch === "\\";
        }

        ++this.state.pos;
      }

      var content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      var mods = "";

      while (this.state.pos < this.length) {
        var char = this.input[this.state.pos];
        var charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(char)) {
          if (mods.indexOf(char) > -1) {
            this.raise(this.state.pos + 1, "Duplicate regular expression flag");
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, "Invalid regular expression flag");
        } else {
          break;
        }

        ++this.state.pos;
        mods += char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    }
  }, {
    key: "readInt",
    value: function readInt(radix, len, forceLen) {
      var allowNumSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (this.hasPlugin("numericSeparator")) {
          if (code === 95) {
            var prev = this.input.charCodeAt(this.state.pos - 1);
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (allowedSiblings.indexOf(next) === -1) {
              this.raise(this.state.pos, "A numeric separator is only allowed between two digits");
            } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
              this.raise(this.state.pos, "A numeric separator is only allowed between two digits");
            }

            if (!allowNumSeparator) {
              this.raise(this.state.pos, "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences");
            }

            ++this.state.pos;
            continue;
          }
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, "Expected number in radix " + radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    }
  }, {
    key: "readRadixNumber",
    value: function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, "Expected number in radix " + radix);
      }

      if (this.hasPlugin("bigInt")) {
        if (this.input.charCodeAt(this.state.pos) === 110) {
          ++this.state.pos;
          isBigInt = true;
        }
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, "Identifier directly after number");
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    }
  }, {
    key: "readNumber",
    value: function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isNonOctalDecimalInt = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, "Invalid number");
      }

      var octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (octal) {
        if (this.state.strict) {
          this.raise(start, "Legacy octal literals are not allowed in strict mode");
        }

        if (/[89]/.test(this.input.slice(start, this.state.pos))) {
          octal = false;
          isNonOctalDecimalInt = true;
        }
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !octal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) this.raise(start, "Invalid number");
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
        var underscorePos = this.input.slice(start, this.state.pos).indexOf("_");

        if (underscorePos > 0) {
          this.raise(underscorePos + start, "Numeric separator can not be used after leading 0");
        }
      }

      if (this.hasPlugin("bigInt")) {
        if (next === 110) {
          if (isFloat || octal || isNonOctalDecimalInt) {
            this.raise(start, "Invalid BigIntLiteral");
          }

          ++this.state.pos;
          isBigInt = true;
        }
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, "Identifier directly after number");
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      var val = octal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    }
  }, {
    key: "readCodePoint",
    value: function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code === null) {
          --this.state.invalidTemplateEscapePosition;
        } else if (code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, "Code point out of bounds");
          } else {
            this.state.invalidTemplateEscapePosition = codePos - 2;
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }
  }, {
    key: "readString",
    value: function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, "Unterminated string constant");
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, "Unterminated string constant");
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    }
  }, {
    key: "readTmplToken",
    value: function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, "Unterminated template");
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }
  }, {
    key: "readEscapedChar",
    value: function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);

            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\x0B";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            var codePos = this.state.pos - 1;
            this.state.invalidTemplateEscapePosition = codePos;
            return null;
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var _codePos = this.state.pos - 1;

            var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                this.state.invalidTemplateEscapePosition = _codePos;
                return null;
              } else if (this.state.strict) {
                this.raise(_codePos, "Octal literal in strict mode");
              } else if (!this.state.containsOctal) {
                this.state.containsOctal = true;
                this.state.octalPosition = _codePos;
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }
  }, {
    key: "readHexChar",
    value: function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, "Bad character escape sequence");
        } else {
          this.state.pos = codePos - 1;
          this.state.invalidTemplateEscapePosition = codePos - 1;
        }
      }

      return n;
    }
  }, {
    key: "readWord1",
    value: function readWord1() {
      var word = "";
      this.state.containsEsc = false;
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        var ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, "Invalid Unicode escape");
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }
  }, {
    key: "isIterator",
    value: function isIterator(word) {
      return word === "@@iterator" || word === "@@asyncIterator";
    }
  }, {
    key: "readWord",
    value: function readWord() {
      var word = this.readWord1();
      var type = keywords.get(word) || types.name;

      if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
        this.raise(this.state.pos, "Invalid identifier ".concat(word));
      }

      this.finishToken(type, word);
    }
  }, {
    key: "checkKeywordEscapes",
    value: function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, "Escape sequence in keyword ".concat(kw));
      }
    }
  }, {
    key: "braceIsBlock",
    value: function braceIsBlock(prevType) {
      var parent = this.curContext();

      if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
        return true;
      }

      if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
        return !parent.isExpr;
      }

      if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      }

      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    }
  }, {
    key: "updateContext",
    value: function updateContext(prevType) {
      var type = this.state.type;
      var update;

      if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }
  }]);

  return Tokenizer;
}(LocationParser);

var literal = /^('|")((?:\\?.)*?)\1/;

var UtilParser =
/*#__PURE__*/
function (_Tokenizer) {
  _inherits(UtilParser, _Tokenizer);

  function UtilParser() {
    _classCallCheck(this, UtilParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(UtilParser).apply(this, arguments));
  }

  _createClass(UtilParser, [{
    key: "addExtra",
    value: function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    }
  }, {
    key: "isRelational",
    value: function isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    }
  }, {
    key: "isLookaheadRelational",
    value: function isLookaheadRelational(op) {
      var next = this.nextTokenStart();

      if (this.input.charAt(next) === op) {
        if (next + 1 === this.input.length) {
          return true;
        }

        var afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== op.charCodeAt(0) && afterNext !== 61;
      }

      return false;
    }
  }, {
    key: "expectRelational",
    value: function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    }
  }, {
    key: "eatRelational",
    value: function eatRelational(op) {
      if (this.isRelational(op)) {
        this.next();
        return true;
      }

      return false;
    }
  }, {
    key: "isContextual",
    value: function isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    }
  }, {
    key: "isUnparsedContextual",
    value: function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    }
  }, {
    key: "isLookaheadContextual",
    value: function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
  }, {
    key: "eatContextual",
    value: function eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    }
  }, {
    key: "expectContextual",
    value: function expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    }
  }, {
    key: "canInsertSemicolon",
    value: function canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    }
  }, {
    key: "hasPrecedingLineBreak",
    value: function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
  }, {
    key: "isLineTerminator",
    value: function isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, types.semi);
    }
  }, {
    key: "expect",
    value: function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
  }, {
    key: "assertNoSpace",
    value: function assertNoSpace() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected space.";

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    }
  }, {
    key: "unexpected",
    value: function unexpected(pos) {
      var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

      if (typeof messageOrType !== "string") {
        messageOrType = "Unexpected token, expected \"".concat(messageOrType.label, "\"");
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }
  }, {
    key: "expectPlugin",
    value: function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raise(pos != null ? pos : this.state.start, "This experimental syntax requires enabling the parser plugin: '".concat(name, "'"), {
          missingPluginNames: [name]
        });
      }

      return true;
    }
  }, {
    key: "expectOnePlugin",
    value: function expectOnePlugin(names, pos) {
      var _this35 = this;

      if (!names.some(function (n) {
        return _this35.hasPlugin(n);
      })) {
        throw this.raise(pos != null ? pos : this.state.start, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(names.join(", "), "'"), {
          missingPluginNames: names
        });
      }
    }
  }, {
    key: "checkYieldAwaitInDefaultParams",
    value: function checkYieldAwaitInDefaultParams() {
      if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
        this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
      }

      if (this.state.awaitPos !== -1) {
        this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
      }
    }
  }, {
    key: "strictDirective",
    value: function strictDirective(start) {
      for (;;) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) break;
        if (match[2] === "use strict") return true;
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;

        if (this.input[start] === ";") {
          start++;
        }
      }

      return false;
    }
  }, {
    key: "tryParse",
    value: function tryParse(fn) {
      var oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();
      var abortSignal = {
        node: null
      };

      try {
        var node = fn(function () {
          var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    }
  }]);

  return UtilParser;
}(Tokenizer);

var Node =
/*#__PURE__*/
function () {
  function Node(parser, pos, loc) {
    _classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser && parser.options.ranges) this.range = [pos, 0];
    if (parser && parser.filename) this.loc.filename = parser.filename;
  }

  _createClass(Node, [{
    key: "__clone",
    value: function __clone() {
      var newNode = new Node();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];

        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }

      return newNode;
    }
  }]);

  return Node;
}();

var NodeUtils =
/*#__PURE__*/
function (_UtilParser) {
  _inherits(NodeUtils, _UtilParser);

  function NodeUtils() {
    _classCallCheck(this, NodeUtils);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeUtils).apply(this, arguments));
  }

  _createClass(NodeUtils, [{
    key: "startNode",
    value: function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
  }, {
    key: "startNodeAt",
    value: function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
  }, {
    key: "startNodeAtNode",
    value: function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
  }, {
    key: "finishNode",
    value: function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
  }, {
    key: "finishNodeAt",
    value: function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    }
  }, {
    key: "resetStartLocation",
    value: function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }
  }, {
    key: "resetEndLocation",
    value: function resetEndLocation(node) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEnd;
      var endLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.lastTokEndLoc;
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }
  }, {
    key: "resetStartLocationFromNode",
    value: function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  }]);

  return NodeUtils;
}(UtilParser);

var LValParser =
/*#__PURE__*/
function (_NodeUtils) {
  _inherits(LValParser, _NodeUtils);

  function LValParser() {
    _classCallCheck(this, LValParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(LValParser).apply(this, arguments));
  }

  _createClass(LValParser, [{
    key: "toAssignable",
    value: function toAssignable(node, isBinding, contextDescription) {
      var _node$extra2;

      if (node) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;

          case "ObjectExpression":
            node.type = "ObjectPattern";

            for (var i = 0, length = node.properties.length, _last2 = length - 1; i < length; i++) {
              var _node$extra;

              var prop = node.properties[i];
              var isLast = i === _last2;
              this.toAssignableObjectExpressionProp(prop, isBinding, isLast);

              if (isLast && prop.type === "RestElement" && ((_node$extra = node.extra) === null || _node$extra === void 0 ? void 0 : _node$extra.trailingComma)) {
                this.raiseRestNotLast(node.extra.trailingComma);
              }
            }

            break;

          case "ObjectProperty":
            this.toAssignable(node.value, isBinding, contextDescription);
            break;

          case "SpreadElement":
            {
              this.checkToRestConversion(node);
              node.type = "RestElement";
              var arg = node.argument;
              this.toAssignable(arg, isBinding, contextDescription);
              break;
            }

          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, isBinding, contextDescription, (_node$extra2 = node.extra) === null || _node$extra2 === void 0 ? void 0 : _node$extra2.trailingComma);
            break;

          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }

            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding, contextDescription);
            break;

          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
            break;

          case "MemberExpression":
            if (!isBinding) break;

          default:
        }
      }

      return node;
    }
  }, {
    key: "toAssignableObjectExpressionProp",
    value: function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? "Object pattern can't contain getter or setter" : "Object pattern can't contain methods";
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isBinding, "object destructuring pattern");
      }
    }
  }, {
    key: "toAssignableList",
    value: function toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {
      var end = exprList.length;

      if (end) {
        var _last3 = exprList[end - 1];

        if (_last3 && _last3.type === "RestElement") {
          --end;
        } else if (_last3 && _last3.type === "SpreadElement") {
          _last3.type = "RestElement";
          var arg = _last3.argument;
          this.toAssignable(arg, isBinding, contextDescription);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isBinding, contextDescription);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }
  }, {
    key: "toReferencedList",
    value: function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
  }, {
    key: "toReferencedListDeep",
    value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (var _i = 0; _i < exprList.length; _i++) {
        var expr = exprList[_i];

        if (expr && expr.type === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }

      return exprList;
    }
  }, {
    key: "parseSpread",
    value: function parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }
  }, {
    key: "parseRestBinding",
    value: function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
  }, {
    key: "parseBindingAtom",
    value: function parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types.braceL:
          return this.parseObj(true);
      }

      return this.parseIdentifier();
    }
  }, {
    key: "parseBindingList",
    value: function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, "Stage 2 decorators cannot be used to decorate parameters");
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }
  }, {
    key: "parseAssignableListItem",
    value: function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }
  }, {
    key: "parseAssignableListItemTypes",
    value: function parseAssignableListItemTypes(param) {
      return param;
    }
  }, {
    key: "parseMaybeDefault",
    value: function parseMaybeDefault(startPos, startLoc, left) {
      startLoc = startLoc || this.state.startLoc;
      startPos = startPos || this.state.start;
      left = left || this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    }
  }, {
    key: "checkLVal",
    value: function checkLVal(expr) {
      var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
      var checkClashes = arguments.length > 2 ? arguments[2] : undefined;
      var contextDescription = arguments.length > 3 ? arguments[3] : undefined;
      var disallowLetBinding = arguments.length > 4 ? arguments[4] : undefined;
      var strictModeChanged = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      switch (expr.type) {
        case "Identifier":
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
            this.raise(expr.start, "".concat(bindingType === BIND_NONE ? "Assigning to" : "Binding", " '").concat(expr.name, "' in strict mode"));
          }

          if (checkClashes) {
            var key = "_".concat(expr.name);

            if (checkClashes[key]) {
              this.raise(expr.start, "Argument name clash");
            } else {
              checkClashes[key] = true;
            }
          }

          if (disallowLetBinding && expr.name === "let") {
            this.raise(expr.start, "'let' is not allowed to be used as a name in 'let' or 'const' declarations.");
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(expr.name, bindingType, expr.start);
          }

          break;

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, "Binding member expression");
          }

          break;

        case "ObjectPattern":
          for (var _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
            var prop = _expr$properties[_i2];
            if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
            this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (var _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
            var elem = _expr$elements[_i3];

            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
          break;

        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
          break;

        default:
          {
            var message = (bindingType === BIND_NONE ? "Invalid" : "Binding invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
            this.raise(expr.start, message);
          }
      }
    }
  }, {
    key: "checkToRestConversion",
    value: function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, "Invalid rest operator's argument");
      }
    }
  }, {
    key: "checkCommaAfterRest",
    value: function checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }
  }, {
    key: "raiseRestNotLast",
    value: function raiseRestNotLast(pos) {
      throw this.raise(pos, "Rest element must be last element");
    }
  }, {
    key: "raiseTrailingCommaAfterRest",
    value: function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, "Unexpected trailing comma after rest element");
    }
  }]);

  return LValParser;
}(NodeUtils);

var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

var ExpressionParser =
/*#__PURE__*/
function (_LValParser) {
  _inherits(ExpressionParser, _LValParser);

  function ExpressionParser() {
    _classCallCheck(this, ExpressionParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(ExpressionParser).apply(this, arguments));
  }

  _createClass(ExpressionParser, [{
    key: "checkDuplicatedProto",
    value: function checkDuplicatedProto(prop, protoRef) {
      if (prop.type === "SpreadElement" || prop.computed || prop.kind || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (protoRef.used && !protoRef.start) {
          protoRef.start = key.start;
        }

        protoRef.used = true;
      }
    }
  }, {
    key: "getExpression",
    value: function getExpression() {
      this.scope.enter(SCOPE_PROGRAM);
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      return expr;
    }
  }, {
    key: "parseExpression",
    value: function parseExpression(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);

      if (this.match(types.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }
  }, {
    key: "parseMaybeAssign",
    value: function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.scope.inGenerator) {
          var _left = this.parseYield(noIn);

          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startPos, startLoc);
          }

          return _left;
        } else {
          this.state.exprAllowed = false;
        }
      }

      var failOnShorthandAssign;

      if (refShorthandDefaultPos) {
        failOnShorthandAssign = false;
      } else {
        refShorthandDefaultPos = {
          start: 0
        };
        failOnShorthandAssign = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (operator === "??=") {
          this.expectPlugin("nullishCoalescingOperator");
          this.expectPlugin("logicalAssignment");
        }

        if (operator === "||=" || operator === "&&=") {
          this.expectPlugin("logicalAssignment");
        }

        node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;

        if (refShorthandDefaultPos.start >= node.left.start) {
          refShorthandDefaultPos.start = 0;
        }

        this.checkLVal(left, undefined, undefined, "assignment expression");
        var maybePattern = unwrapParenthesizedExpression(left);
        var patternErrorMsg;

        if (maybePattern.type === "ObjectPattern") {
          patternErrorMsg = "`({a}) = 0` use `({a} = 0)`";
        } else if (maybePattern.type === "ArrayPattern") {
          patternErrorMsg = "`([a]) = 0` use `([a] = 0)`";
        }

        if (patternErrorMsg && (left.extra && left.extra.parenthesized || left.type === "ParenthesizedExpression")) {
          this.raise(maybePattern.start, "You're trying to assign to a parenthesized expression, eg. instead of ".concat(patternErrorMsg));
        }

        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      return left;
    }
  }, {
    key: "parseMaybeConditional",
    value: function parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(noIn, refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    }
  }, {
    key: "parseConditional",
    value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }
  }, {
    key: "parseExprOps",
    value: function parseExprOps(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    }
  }, {
    key: "parseExprOp",
    value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.state.type.binop;

      if (prec != null && (!noIn || !this.match(types._in))) {
        if (prec > minPrec) {
          var operator = this.state.value;

          if (operator === "|>" && this.state.inFSharpPipelineDirectBody) {
            return left;
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = operator;

          if (operator === "**" && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
            this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
          }

          var op = this.state.type;

          if (op === types.pipeline) {
            this.expectPlugin("pipelineOperator");
            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          } else if (op === types.nullishCoalescing) {
            this.expectPlugin("nullishCoalescingOperator");
          }

          this.next();

          if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types.name) && this.state.value === "await" && this.scope.inAsync) {
              throw this.raise(this.state.start, "Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal");
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec, noIn);

          if (op === types.nullishCoalescing) {
            if (left.type === "LogicalExpression" && left.operator !== "??" && !(left.extra && left.extra.parenthesized)) {
              throw this.raise(left.start, "Nullish coalescing operator(??) requires parens when mixing with logical operators");
            } else if (node.right.type === "LogicalExpression" && node.right.operator !== "??" && !(node.right.extra && node.right.extra.parenthesized)) {
              throw this.raise(node.right.start, "Nullish coalescing operator(??) requires parens when mixing with logical operators");
            }
          }

          this.finishNode(node, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }

      return left;
    }
  }, {
    key: "parseExprOpRightExpr",
    value: function parseExprOpRightExpr(op, prec, noIn) {
      var _this36 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(function () {
                return _this36.parseSmartPipelineBody(_this36.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this36.parseFSharpPipelineBody(prec, noIn);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec, noIn);
      }
    }
  }, {
    key: "parseExprOpBaseRightExpr",
    value: function parseExprOpBaseRightExpr(op, prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
    }
  }, {
    key: "parseMaybeUnary",
    value: function parseMaybeUnary(refShorthandDefaultPos) {
      if (this.isContextual("await") && this.isAwaitAllowed()) {
        return this.parseAwait();
      } else if (this.state.type.prefix) {
        var node = this.startNode();
        var update = this.match(types.incDec);
        node.operator = this.state.value;
        node.prefix = true;

        if (node.operator === "throw") {
          this.expectPlugin("throwExpressions");
        }

        this.next();
        node.argument = this.parseMaybeUnary();

        if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
          this.unexpected(refShorthandDefaultPos.start);
        }

        if (update) {
          this.checkLVal(node.argument, undefined, undefined, "prefix operation");
        } else if (this.state.strict && node.operator === "delete") {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, "Deleting local variable in strict mode");
          } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
            this.raise(node.start, "Deleting a private field is not allowed");
          }
        }

        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node9 = this.startNodeAt(startPos, startLoc);

        _node9.operator = this.state.value;
        _node9.prefix = false;
        _node9.argument = expr;
        this.checkLVal(expr, undefined, undefined, "postfix operation");
        this.next();
        expr = this.finishNode(_node9, "UpdateExpression");
      }

      return expr;
    }
  }, {
    key: "parseExprSubscripts",
    value: function parseExprSubscripts(refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }
  }, {
    key: "parseSubscripts",
    value: function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsync(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }
  }, {
    key: "parseSubscript",
    value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      } else if (this.match(types.questionDot)) {
        this.expectPlugin("optionalChaining");
        state.optionalChainMember = true;

        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        this.next();

        var _node10 = this.startNodeAt(startPos, startLoc);

        if (this.eat(types.bracketL)) {
          _node10.object = base;
          _node10.property = this.parseExpression();
          _node10.computed = true;
          _node10.optional = true;
          this.expect(types.bracketR);
          return this.finishNode(_node10, "OptionalMemberExpression");
        } else if (this.eat(types.parenL)) {
          _node10.callee = base;
          _node10.arguments = this.parseCallExpressionArguments(types.parenR, false);
          _node10.optional = true;
          return this.finishCallExpression(_node10, true);
        } else {
          _node10.object = base;
          _node10.property = this.parseIdentifier(true);
          _node10.computed = false;
          _node10.optional = true;
          return this.finishNode(_node10, "OptionalMemberExpression");
        }
      } else if (this.eat(types.dot)) {
        var _node11 = this.startNodeAt(startPos, startLoc);

        _node11.object = base;
        _node11.property = this.parseMaybePrivateName();
        _node11.computed = false;

        if (_node11.property.type === "PrivateName" && _node11.object.type === "Super") {
          this.raise(startPos, "Private fields can't be accessed on super");
        }

        if (state.optionalChainMember) {
          _node11.optional = false;
          return this.finishNode(_node11, "OptionalMemberExpression");
        }

        return this.finishNode(_node11, "MemberExpression");
      } else if (this.eat(types.bracketL)) {
        var _node12 = this.startNodeAt(startPos, startLoc);

        _node12.object = base;
        _node12.property = this.parseExpression();
        _node12.computed = true;
        this.expect(types.bracketR);

        if (state.optionalChainMember) {
          _node12.optional = false;
          return this.finishNode(_node12, "OptionalMemberExpression");
        }

        return this.finishNode(_node12, "MemberExpression");
      } else if (!noCalls && this.match(types.parenL)) {
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = true;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.next();

        var _node13 = this.startNodeAt(startPos, startLoc);

        _node13.callee = base;
        _node13.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", _node13);
        this.finishCallExpression(_node13, state.optionalChainMember);

        if (state.maybeAsyncArrow && this.shouldParseAsyncArrow()) {
          state.stop = true;
          _node13 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node13);
          this.checkYieldAwaitInDefaultParams();
          this.state.yieldPos = oldYieldPos;
          this.state.awaitPos = oldAwaitPos;
        } else {
          this.toReferencedListDeep(_node13.arguments);
          if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

          if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
            this.state.awaitPos = oldAwaitPos;
          }
        }

        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return _node13;
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
      } else {
        state.stop = true;
        return base;
      }
    }
  }, {
    key: "parseTaggedTemplateExpression",
    value: function parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (typeArguments) node.typeParameters = typeArguments;

      if (state.optionalChainMember) {
        this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain");
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }
  }, {
    key: "atPossibleAsync",
    value: function atPossibleAsync(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    }
  }, {
    key: "finishCallExpression",
    value: function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length !== 1) {
          this.raise(node.start, "import() requires exactly one argument");
        } else {
          var importArg = node.arguments[0];

          if (importArg && importArg.type === "SpreadElement") {
            this.raise(importArg.start, "... is not allowed in import()");
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
  }, {
    key: "parseCallExpressionArguments",
    value: function parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      var elts = [];
      var innerParenStart;
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (dynamicImport) {
              this.raise(this.state.lastTokStart, "Trailing comma is disallowed inside import(...) arguments");
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        if (this.match(types.parenL) && !innerParenStart) {
          innerParenStart = this.state.start;
        }

        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {
          start: 0
        } : undefined, possibleAsyncArrow ? {
          start: 0
        } : undefined, allowPlaceholder));
      }

      if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
        this.unexpected();
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
  }, {
    key: "shouldParseAsyncArrow",
    value: function shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    }
  }, {
    key: "parseAsyncArrowFromCallExpression",
    value: function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) === null || _call$extra === void 0 ? void 0 : _call$extra.trailingComma);
      return node;
    }
  }, {
    key: "parseNoCallExpr",
    value: function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
  }, {
    key: "parseExprAtom",
    value: function parseExprAtom(refShorthandDefaultPos) {
      if (this.state.type === types.slash) this.readRegexp();
      var canBeArrow = this.state.potentialArrowAt === this.state.start;
      var node;

      switch (this.state.type) {
        case types._super:
          node = this.startNode();
          this.next();

          if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, "super() is only valid inside a class constructor of a subclass. " + "Maybe a typo in the method name ('constructor') or not extending another class?");
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, "super is only allowed in object methods and classes");
          }

          if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
            this.raise(node.start, "super can only be used with function calls (i.e. super()) or " + "in property accesses (i.e. super.prop or super[prop])");
          }

          return this.finishNode(node, "Super");

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          this.expectPlugin("dynamicImport", node.start);

          if (!this.match(types.parenL)) {
            this.unexpected(null, types.parenL);
          }

          return this.finishNode(node, "Import");

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types.name:
          {
            node = this.startNode();
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseFunction(node, undefined, true);
            } else if (canBeArrow && !containsEsc && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
              var params = [this.parseIdentifier()];
              this.expect(types.arrow);
              this.parseArrowExpression(node, params, true);
              return node;
            }

            if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
              this.next();
              this.parseArrowExpression(node, [id], false);
              return node;
            }

            return id;
          }

        case types._do:
          {
            this.expectPlugin("doExpressions");

            var _node14 = this.startNode();

            this.next();
            var oldLabels = this.state.labels;
            this.state.labels = [];
            _node14.body = this.parseBlock();
            this.state.labels = oldLabels;
            return this.finishNode(_node14, "DoExpression");
          }

        case types.regexp:
          {
            var value = this.state.value;
            node = this.parseLiteral(value.value, "RegExpLiteral");
            node.pattern = value.pattern;
            node.flags = value.flags;
            return node;
          }

        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketL:
          {
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos, node);

            if (!this.state.maybeInArrowParameters) {
              this.toReferencedList(node.elements);
            }

            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return this.finishNode(node, "ArrayExpression");
          }

        case types.braceL:
          {
            var _oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            var ret = this.parseObj(false, refShorthandDefaultPos);
            this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody;
            return ret;
          }

        case types._function:
          return this.parseFunctionExpression();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNew();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, "Binding should be performed on object property.");
            }
          }

        case types.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.");
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, "Topic reference was used in a lexical context without topic binding");
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }
          }

        default:
          throw this.unexpected();
      }
    }
  }, {
    key: "parseBooleanLiteral",
    value: function parseBooleanLiteral() {
      var node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
  }, {
    key: "parseMaybePrivateName",
    value: function parseMaybePrivateName() {
      var isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);
        var node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space between # and identifier");
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, "PrivateName");
      } else {
        return this.parseIdentifier(true);
      }
    }
  }, {
    key: "parseFunctionExpression",
    value: function parseFunctionExpression() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "function");

      if (this.scope.inGenerator && this.eat(types.dot)) {
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }
  }, {
    key: "parseMetaProperty",
    value: function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, "The only valid meta property for ".concat(meta.name, " is ").concat(meta.name, ".").concat(propertyName));
      }

      return this.finishNode(node, "MetaProperty");
    }
  }, {
    key: "parseImportMetaProperty",
    value: function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.expect(types.dot);

      if (this.isContextual("meta")) {
        this.expectPlugin("importMeta");

        if (!this.inModule) {
          this.raise(id.start, "import.meta may appear only with 'sourceType: \"module\"'", {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          });
        }

        this.sawUnambiguousESM = true;
      } else if (!this.hasPlugin("importMeta")) {
        this.raise(id.start, "Dynamic imports require a parameter: import('a.js')");
      }

      return this.parseMetaProperty(node, id, "meta");
    }
  }, {
    key: "parseLiteral",
    value: function parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
  }, {
    key: "parseParenAndDistinguishExpression",
    value: function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.expect(types.parenL);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refShorthandDefaultPos = {
        start: 0
      };
      var refNeedsArrowPos = {
        start: 0
      };
      var first = true;
      var spreadStart;
      var optionalCommaStart;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
        }
      }

      var innerEndPos = this.state.start;
      var innerEndLoc = this.state.startLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;

        for (var _i = 0; _i < exprList.length; _i++) {
          var param = exprList[_i];

          if (param.extra && param.extra.parenthesized) {
            this.unexpected(param.extra.parenStart);
          }
        }

        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
      if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);

      if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }
  }, {
    key: "shouldParseArrow",
    value: function shouldParseArrow() {
      return !this.canInsertSemicolon();
    }
  }, {
    key: "parseArrow",
    value: function parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    }
  }, {
    key: "parseParenItem",
    value: function parseParenItem(node, startPos, startLoc) {
      return node;
    }
  }, {
    key: "parseNew",
    value: function parseNew() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "new");

      if (this.eat(types.dot)) {
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.state.inClassProperty) {
          var error = "new.target can only be used in functions";

          if (this.hasPlugin("classProperties")) {
            error += " or class properties";
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, "Cannot use new with import(...)");
      } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
        this.raise(this.state.lastTokEnd, "constructors in/after an Optional Chain are not allowed");
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, "constructors in/after an Optional Chain are not allowed");
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }
  }, {
    key: "parseNewArguments",
    value: function parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        var args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }
  }, {
    key: "parseTemplateElement",
    value: function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.invalidTemplateEscapePosition || 0, "Invalid escape sequence in template");
        } else {
          this.state.invalidTemplateEscapePosition = null;
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }
  }, {
    key: "parseTemplate",
    value: function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }
  }, {
    key: "parseObj",
    value: function parseObj(isPattern, refShorthandDefaultPos) {
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(types.braceR)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            this.next();
            break;
          }
        }

        var prop = this.parseObjectMember(isPattern, refShorthandDefaultPos);
        if (!isPattern) this.checkDuplicatedProto(prop, propHash);

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      if (!this.match(types.eq) && propHash.start !== undefined) {
        this.raise(propHash.start, "Redefinition of __proto__ property");
      }

      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    }
  }, {
    key: "isAsyncProp",
    value: function isAsyncProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();
    }
  }, {
    key: "parseObjectMember",
    value: function parseObjectMember(isPattern, refShorthandDefaultPos) {
      var decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, "Stage 2 decorators disallow object literal property decorators");
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var startPos;
      var startLoc;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refShorthandDefaultPos) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      var containsEsc = this.state.containsEsc;
      this.parsePropertyName(prop);

      if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);
      return prop;
    }
  }, {
    key: "isGetterOrSetterMethod",
    value: function isGetterOrSetterMethod(prop, isPattern) {
      return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
    }
  }, {
    key: "getGetterSetterExpectedParamCount",
    value: function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
  }, {
    key: "checkGetterSetterParams",
    value: function checkGetterSetterParams(method) {
      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var start = method.start;

      if (method.params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, "getter must not have any formal parameters");
        } else {
          this.raise(start, "setter must have exactly one formal parameter");
        }
      }

      if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
        this.raise(start, "setter function argument must not be a rest parameter");
      }
    }
  }, {
    key: "parseObjectMethod",
    value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }

      if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
        if (isGenerator || isAsync) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        this.parseMethod(prop, false, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }
    }
  }, {
    key: "parseObjectProperty",
    value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, true);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start) {
            refShorthandDefaultPos.start = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
  }, {
    key: "parseObjPropValue",
    value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);
      if (!node) this.unexpected();
      return node;
    }
  }, {
    key: "parsePropertyName",
    value: function parsePropertyName(prop) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();

        if (prop.key.type !== "PrivateName") {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }
  }, {
    key: "initFunction",
    value: function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }
  }, {
    key: "parseMethod",
    value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
      var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.parseFunctionParams(node, allowModifiers);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBodyAndFinish(node, type, true);
      this.scope.exit();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }
  }, {
    key: "parseArrowExpression",
    value: function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      if (params) this.setArrowFunctionParameters(node, params, trailingCommaPos);
      this.parseFunctionBody(node, true);
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
  }, {
    key: "setArrowFunctionParameters",
    value: function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, true, "arrow function parameters", trailingCommaPos);
    }
  }, {
    key: "isStrictBody",
    value: function isStrictBody(node) {
      var isBlockStatement = node.body.type === "BlockStatement";

      if (isBlockStatement && node.body.directives.length) {
        for (var _i2 = 0, _node$body$directives = node.body.directives; _i2 < _node$body$directives.length; _i2++) {
          var directive = _node$body$directives[_i2];

          if (directive.value.value === "use strict") {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "parseFunctionBodyAndFinish",
    value: function parseFunctionBodyAndFinish(node, type) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }
  }, {
    key: "parseFunctionBody",
    value: function parseFunctionBody(node, allowExpression) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isExpression = allowExpression && !this.match(types.braceL);
      var oldStrict = this.state.strict;
      var useStrict = false;
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var nonSimple = !this.isSimpleParamList(node.params);

        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.state.end);

          if (useStrict && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
            this.raise(errorPos, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }

        var oldLabels = this.state.labels;
        this.state.labels = [];
        if (useStrict) this.state.strict = true;
        this.checkParams(node, !oldStrict && !useStrict && !allowExpression && !isMethod && !nonSimple, allowExpression, !oldStrict && useStrict);
        node.body = this.parseBlock(true, false);
        this.state.labels = oldLabels;
      }

      this.state.inParameters = oldInParameters;

      if (this.state.strict && node.id) {
        this.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, !oldStrict && useStrict);
      }

      this.state.strict = oldStrict;
    }
  }, {
    key: "isSimpleParamList",
    value: function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    }
  }, {
    key: "checkParams",
    value: function checkParams(node, allowDuplicates, isArrowFunction) {
      var strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var nameHash = Object.create(null);

      for (var i = 0; i < node.params.length; i++) {
        this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
      }
    }
  }, {
    key: "parseExprList",
    value: function parseExprList(close, allowEmpty, refShorthandDefaultPos, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
      }

      return elts;
    }
  }, {
    key: "parseExprListItem",
    value: function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, allowPlaceholder) {
      var elt;

      if (allowEmpty && this.match(types.comma)) {
        elt = null;
      } else if (this.match(types.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, "Unexpected argument placeholder");
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
      }

      return elt;
    }
  }, {
    key: "parseIdentifier",
    value: function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
  }, {
    key: "createIdentifier",
    value: function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
  }, {
    key: "parseIdentifierName",
    value: function parseIdentifierName(pos, liberal) {
      var name;

      if (this.match(types.name)) {
        name = this.state.value;
      } else if (this.state.type.keyword) {
        name = this.state.type.keyword;

        if ((name === "class" || name === "function") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.input.charCodeAt(this.state.lastTokStart) !== 46)) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
      }

      this.next();
      return name;
    }
  }, {
    key: "checkReservedWord",
    value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.scope.inGenerator && word === "yield") {
        this.raise(startLoc, "Can not use 'yield' as identifier inside a generator");
        return;
      }

      if (word === "await") {
        if (this.scope.inAsync) {
          this.raise(startLoc, "Can not use 'await' as identifier inside an async function");
          return;
        }

        if (this.state.awaitPos === -1 && (this.state.maybeInArrowParameters || this.isAwaitAllowed())) {
          this.state.awaitPos = this.state.start;
        }
      }

      if (this.state.inClassProperty && word === "arguments") {
        this.raise(startLoc, "'arguments' is not allowed in class field initializer");
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, "Unexpected keyword '".concat(word, "'"));
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        if (!this.scope.inAsync && word === "await") {
          this.raise(startLoc, "Can not use keyword 'await' outside an async function");
        } else {
          this.raise(startLoc, "Unexpected reserved word '".concat(word, "'"));
        }
      }
    }
  }, {
    key: "isAwaitAllowed",
    value: function isAwaitAllowed() {
      if (this.scope.inFunction) return this.scope.inAsync;
      if (this.options.allowAwaitOutsideFunction) return true;
      if (this.hasPlugin("topLevelAwait")) return this.inModule;
      return false;
    }
  }, {
    key: "parseAwait",
    value: function parseAwait() {
      var node = this.startNode();
      this.next();

      if (this.state.inParameters) {
        this.raise(node.start, "await is not allowed in async function parameters");
      } else if (this.state.awaitPos === -1) {
        this.state.awaitPos = node.start;
      }

      if (this.eat(types.star)) {
        this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary();
      }

      return this.finishNode(node, "AwaitExpression");
    }
  }, {
    key: "parseYield",
    value: function parseYield(noIn) {
      var node = this.startNode();

      if (this.state.inParameters) {
        this.raise(node.start, "yield is not allowed in generator parameters");
      } else if (this.state.yieldPos === -1) {
        this.state.yieldPos = node.start;
      }

      this.next();

      if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }

      return this.finishNode(node, "YieldExpression");
    }
  }, {
    key: "checkPipelineAtInfixOperator",
    value: function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, "Pipeline head should not be a comma-separated sequence expression");
        }
      }
    }
  }, {
    key: "parseSmartPipelineBody",
    value: function parseSmartPipelineBody(childExpression, startPos, startLoc) {
      var pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
      this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
    }
  }, {
    key: "checkSmartPipelineBodyEarlyErrors",
    value: function checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, "Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized");
      } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
        this.raise(startPos, "Pipeline body may not be a comma-separated sequence expression");
      }
    }
  }, {
    key: "parseSmartPipelineBodyInStyle",
    value: function parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);

      switch (pipelineStyle) {
        case "PipelineBareFunction":
          bodyNode.callee = childExpression;
          break;

        case "PipelineBareConstructor":
          bodyNode.callee = childExpression.callee;
          break;

        case "PipelineBareAwaitedFunction":
          bodyNode.callee = childExpression.argument;
          break;

        case "PipelineTopicExpression":
          if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
            this.raise(startPos, "Pipeline is in topic style but does not use topic reference");
          }

          bodyNode.expression = childExpression;
          break;

        default:
          throw new Error("Internal @babel/parser error: Unknown pipeline style (".concat(pipelineStyle, ")"));
      }

      return this.finishNode(bodyNode, pipelineStyle);
    }
  }, {
    key: "checkSmartPipelineBodyStyle",
    value: function checkSmartPipelineBodyStyle(expression) {
      switch (expression.type) {
        default:
          return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
      }
    }
  }, {
    key: "isSimpleReference",
    value: function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }
  }, {
    key: "withTopicPermittingContext",
    value: function withTopicPermittingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: "withTopicForbiddingContext",
    value: function withTopicForbiddingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: "withSoloAwaitPermittingContext",
    value: function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
  }, {
    key: "registerTopicReference",
    value: function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
  }, {
    key: "primaryTopicReferenceIsAllowedInCurrentTopicContext",
    value: function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
  }, {
    key: "topicReferenceWasUsedInCurrentTopicContext",
    value: function topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
  }, {
    key: "parseFSharpPipelineBody",
    value: function parseFSharpPipelineBody(prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
  }]);

  return ExpressionParser;
}(LValParser);

var loopLabel = {
  kind: "loop"
},
    switchLabel = {
  kind: "switch"
};
var FUNC_NO_FLAGS = 0,
    FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;

var StatementParser =
/*#__PURE__*/
function (_ExpressionParser) {
  _inherits(StatementParser, _ExpressionParser);

  function StatementParser() {
    _classCallCheck(this, StatementParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(StatementParser).apply(this, arguments));
  }

  _createClass(StatementParser, [{
    key: "parseTopLevel",
    value: function parseTopLevel(file, program) {
      program.sourceType = this.options.sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, types.eof);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i], 1),
              name = _Array$from$_i[0];

          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, "Export '".concat(name, "' is not defined"));
        }
      }

      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.state.tokens;
      return this.finishNode(file, "File");
    }
  }, {
    key: "stmtToDirective",
    value: function stmtToDirective(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    }
  }, {
    key: "parseInterpreterDirective",
    value: function parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
  }, {
    key: "isLet",
    value: function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      var next = this.nextTokenStart();
      var nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        var pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    }
  }, {
    key: "parseStatement",
    value: function parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }
  }, {
    key: "parseStatementContent",
    value: function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, "In strict mode code, functions can only be declared at top level or inside a block");
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, "In non-strict mode code, functions can only be declared at top level, " + "inside a block, or as the body of an if statement");
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, "Lexical declaration cannot appear in a single-statement context");
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._export:
        case types._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }

            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
            }

            this.next();
            var result;

            if (starttype === types._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, "Async functions can only be declared at the top level or inside a block");
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }
  }, {
    key: "assertModuleNodeAllowed",
    value: function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, "'import' and 'export' may appear only with 'sourceType: \"module\"'", {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        });
      }
    }
  }, {
    key: "takeDecorators",
    value: function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }
  }, {
    key: "canHaveLeadingDecorator",
    value: function canHaveLeadingDecorator() {
      return this.match(types._class);
    }
  }, {
    key: "parseDecorators",
    value: function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, "Using the export keyword between a decorator and a class is not allowed. " + "Please use `export @dec class` instead.");
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
      }
    }
  }, {
    key: "parseDecorator",
    value: function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            var _node15 = this.startNodeAt(startPos, startLoc);

            _node15.object = expr;
            _node15.property = this.parseIdentifier(true);
            _node15.computed = false;
            expr = this.finishNode(_node15, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }
  }, {
    key: "parseMaybeDecoratorArguments",
    value: function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }
  }, {
    key: "parseBreakContinueStatement",
    value: function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
  }, {
    key: "verifyBreakContinue",
    value: function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
    }
  }, {
    key: "parseDebuggerStatement",
    value: function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
  }, {
    key: "parseHeaderExpression",
    value: function parseHeaderExpression() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    }
  }, {
    key: "parseDoStatement",
    value: function parseDoStatement(node) {
      var _this37 = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this37.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    }
  }, {
    key: "parseForStatement",
    value: function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var isLet = this.isLet();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        var _init = this.startNode();

        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var refShorthandDefaultPos = {
        start: 0
      };
      var init = this.parseExpression(true, refShorthandDefaultPos);

      if (this.match(types._in) || this.isContextual("of")) {
        var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.toAssignable(init, undefined, description);
        this.checkLVal(init, undefined, undefined, description);
        return this.parseForIn(node, init, awaitAt);
      } else if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }
  }, {
    key: "parseFunctionStatement",
    value: function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }
  }, {
    key: "parseIfStatement",
    value: function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }
  }, {
    key: "parseReturnStatement",
    value: function parseReturnStatement(node) {
      if (!this.scope.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, "'return' outside of function");
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }
  }, {
    key: "parseSwitchStatement",
    value: function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(types.braceR);) {
        if (this.match(types._case) || this.match(types._default)) {
          var isCase = this.match(types._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, "Multiple default clauses");
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
  }, {
    key: "parseThrowStatement",
    value: function parseThrowStatement(node) {
      this.next();

      if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
        this.raise(this.state.lastTokEnd, "Illegal newline after throw");
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
  }, {
    key: "parseTryStatement",
    value: function parseTryStatement(node) {
      var _this38 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, BIND_LEXICAL, null, "catch clause");
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(function () {
          return _this38.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }

      return this.finishNode(node, "TryStatement");
    }
  }, {
    key: "parseVarStatement",
    value: function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
  }, {
    key: "parseWhileStatement",
    value: function parseWhileStatement(node) {
      var _this39 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this39.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
  }, {
    key: "parseWithStatement",
    value: function parseWithStatement(node) {
      var _this40 = this;

      if (this.state.strict) {
        this.raise(this.state.start, "'with' in strict mode");
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(function () {
        return _this40.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    }
  }, {
    key: "parseEmptyStatement",
    value: function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
  }, {
    key: "parseLabeledStatement",
    value: function parseLabeledStatement(node, maybeName, expr, context) {
      for (var _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {
        var label = _this$state$labels[_i2];

        if (label.name === maybeName) {
          this.raise(expr.start, "Label '".concat(maybeName, "' is already declared"));
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];

        if (_label.statementStart === node.start) {
          _label.statementStart = this.state.start;
          _label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
  }, {
    key: "parseExpressionStatement",
    value: function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
  }, {
    key: "parseBlock",
    value: function parseBlock() {
      var allowDirectives = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var createNewLexicalScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var node = this.startNode();
      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types.braceR);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }
  }, {
    key: "isValidDirective",
    value: function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
  }, {
    key: "parseBlockBody",
    value: function parseBlockBody(node, allowDirectives, topLevel, end) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);
    }
  }, {
    key: "parseBlockOrModuleBlockBody",
    value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end) {
      var parsedNonDirective = false;
      var oldStrict;
      var octalPosition;

      while (!this.eat(end)) {
        if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
          octalPosition = this.state.octalPosition;
        }

        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
          var directive = this.stmtToDirective(stmt);
          directives.push(directive);

          if (oldStrict === undefined && directive.value.value === "use strict") {
            oldStrict = this.state.strict;
            this.setStrict(true);

            if (octalPosition) {
              this.raise(octalPosition, "Octal literal in strict mode");
            }
          }

          continue;
        }

        parsedNonDirective = true;
        body.push(stmt);
      }

      if (oldStrict === false) {
        this.setStrict(false);
      }
    }
  }, {
    key: "parseFor",
    value: function parseFor(node, init) {
      var _this41 = this;

      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this41.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
  }, {
    key: "parseForIn",
    value: function parseForIn(node, init, awaitAt) {
      var _this42 = this;

      var isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, "".concat(isForIn ? "for-in" : "for-of", " loop variable declaration may not have an initializer"));
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this42.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
  }, {
    key: "parseVar",
    value: function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else {
          if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.unexpected();
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
      }

      return node;
    }
  }, {
    key: "parseVarId",
    value: function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
    }
  }, {
    key: "parseFunction",
    value: function parseFunction(node) {
      var _this43 = this;

      var statement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FUNC_NO_FLAGS;
      var isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(this.state.start, "Generators can only be declared at the top level or inside a block");
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInClassProperty = this.state.inClassProperty;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.inClassProperty = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.scope.enter(functionFlags(node.async, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node);
      this.withTopicForbiddingContext(function () {
        _this43.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inClassProperty = oldInClassProperty;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }
  }, {
    key: "parseFunctionId",
    value: function parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    }
  }, {
    key: "parseFunctionParams",
    value: function parseFunctionParams(node, allowModifiers) {
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = true;
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
      this.state.inParameters = oldInParameters;
      this.checkYieldAwaitInDefaultParams();
    }
  }, {
    key: "registerFunctionStatementId",
    value: function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }
  }, {
    key: "parseClass",
    value: function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass);
      this.state.strict = oldStrict;
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
  }, {
    key: "isClassProperty",
    value: function isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    }
  }, {
    key: "isClassMethod",
    value: function isClassMethod() {
      return this.match(types.parenL);
    }
  }, {
    key: "isNonstaticConstructor",
    value: function isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
  }, {
    key: "parseClassBody",
    value: function parseClassBody(constructorAllowsSuper) {
      var _this44 = this;

      this.state.classLevel++;
      var state = {
        hadConstructor: false
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(function () {
        while (!_this44.eat(types.braceR)) {
          if (_this44.eat(types.semi)) {
            if (decorators.length > 0) {
              throw _this44.raise(_this44.state.lastTokEnd, "Decorators must not be followed by a semicolon");
            }

            continue;
          }

          if (_this44.match(types.at)) {
            decorators.push(_this44.parseDecorator());
            continue;
          }

          var member = _this44.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this44.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this44.parseClassMember(classBody, member, state, constructorAllowsSuper);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this44.raise(member.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?");
          }
        }
      });

      if (decorators.length) {
        throw this.raise(this.state.start, "You have trailing decorators with no method");
      }

      this.state.classLevel--;
      return this.finishNode(classBody, "ClassBody");
    }
  }, {
    key: "parseClassMember",
    value: function parseClassMember(classBody, member, state, constructorAllowsSuper) {
      var isStatic = false;
      var containsEsc = this.state.containsEsc;

      if (this.match(types.name) && this.state.value === "static") {
        var key = this.parseIdentifier(true);

        if (this.isClassMethod()) {
          var method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return;
        } else if (this.isClassProperty()) {
          var prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return;
        } else if (containsEsc) {
          throw this.unexpected();
        }

        isStatic = true;
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    }
  }, {
    key: "parseClassMemberWithIsStatic",
    value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member.static = isStatic;

      if (this.eat(types.star)) {
        method.kind = "method";
        this.parseClassPropertyName(method);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, "Constructor can't be a generator");
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parseClassPropertyName(member);
      var isPrivate = key.type === "PrivateName";
      var isSimple = key.type === "Identifier";
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, "Duplicate constructor in the same class");
          }

          state.hadConstructor = true;
          allowsDirectSuper = constructorAllowsSuper;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        var isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        this.parseClassPropertyName(method);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, "Constructor can't be an async function");
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
        method.kind = key.name;
        this.parseClassPropertyName(publicMethod);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, "Constructor can't have get/set modifier");
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
  }, {
    key: "parseClassPropertyName",
    value: function parseClassPropertyName(member) {
      var key = this.parsePropertyName(member);

      if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
        this.raise(key.start, "Classes may not have static property named prototype");
      }

      if (key.type === "PrivateName" && key.id.name === "constructor") {
        this.raise(key.start, "Classes may not have a private field named '#constructor'");
      }

      return key;
    }
  }, {
    key: "pushClassProperty",
    value: function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, "Classes may not have a field named 'constructor'");
      }

      classBody.body.push(this.parseClassProperty(prop));
    }
  }, {
    key: "pushClassPrivateProperty",
    value: function pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      classBody.body.push(this.parseClassPrivateProperty(prop));
    }
  }, {
    key: "pushClassMethod",
    value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
  }, {
    key: "pushClassPrivateMethod",
    value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true));
    }
  }, {
    key: "parsePostMemberNameModifiers",
    value: function parsePostMemberNameModifiers(methodOrProp) {}
  }, {
    key: "parseAccessModifier",
    value: function parseAccessModifier() {
      return undefined;
    }
  }, {
    key: "parseClassPrivateProperty",
    value: function parseClassPrivateProperty(node) {
      this.state.inClassProperty = true;
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
      this.semicolon();
      this.state.inClassProperty = false;
      this.scope.exit();
      return this.finishNode(node, "ClassPrivateProperty");
    }
  }, {
    key: "parseClassProperty",
    value: function parseClassProperty(node) {
      if (!node.typeAnnotation) {
        this.expectPlugin("classProperties");
      }

      this.state.inClassProperty = true;
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);

      if (this.match(types.eq)) {
        this.expectPlugin("classProperties");
        this.next();
        node.value = this.parseMaybeAssign();
      } else {
        node.value = null;
      }

      this.semicolon();
      this.state.inClassProperty = false;
      this.scope.exit();
      return this.finishNode(node, "ClassProperty");
    }
  }, {
    key: "parseClassId",
    value: function parseClassId(node, isStatement, optionalId) {
      var bindingType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BIND_CLASS;

      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, bindingType, undefined, "class name");
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, "A class name is required");
        }
      }
    }
  }, {
    key: "parseClassSuper",
    value: function parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    }
  }, {
    key: "parseExport",
    value: function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types.braceL);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types.braceL);
    }
  }, {
    key: "eatExportStar",
    value: function eatExportStar(node) {
      return this.eat(types.star);
    }
  }, {
    key: "maybeParseExportDefaultSpecifier",
    value: function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamespaceSpecifier",
    value: function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamedSpecifiers",
    value: function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        var _node$specifiers2;

        if (!node.specifiers) node.specifiers = [];

        (_node$specifiers2 = node.specifiers).push.apply(_node$specifiers2, _toConsumableArray(this.parseExportSpecifiers()));

        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportDeclaration",
    value: function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        if (this.isContextual("async")) {
          var next = this.nextTokenStart();

          if (!this.isUnparsedContextual(next, "function")) {
            this.unexpected(next, "Unexpected token, expected \"function\"");
          }
        }

        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }
  }, {
    key: "isAsyncFunction",
    value: function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
  }, {
    key: "parseExportDefaultExpression",
    value: function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
        throw this.raise(this.state.start, "Only expressions, functions or classes are allowed as the `default` export.");
      } else {
        var res = this.parseMaybeAssign();
        this.semicolon();
        return res;
      }
    }
  }, {
    key: "parseExportDeclaration",
    value: function parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
  }, {
    key: "isExportDefaultSpecifier",
    value: function isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        return this.state.value !== "async" && this.state.value !== "let";
      }

      if (!this.match(types._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, "from");
    }
  }, {
    key: "parseExportFrom",
    value: function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }
  }, {
    key: "shouldParseExportDeclaration",
    value: function shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
  }, {
    key: "checkExport",
    value: function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
        } else if (node.specifiers && node.specifiers.length) {
          for (var _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {
            var specifier = _node$specifiers[_i3];
            this.checkDuplicateExports(specifier, specifier.exported.name);

            if (!isFrom && specifier.local) {
              this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
              this.scope.checkLocalExport(specifier.local);
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {
              var declaration = _node$declaration$dec[_i4];
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

        if (!node.declaration || !isClass) {
          throw this.raise(node.start, "You can only use decorators on an export when exporting a class");
        }

        this.takeDecorators(node.declaration);
      }
    }
  }, {
    key: "checkDeclaration",
    value: function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {
          var prop = _node$properties[_i5];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {
          var elem = _node$elements[_i6];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
  }, {
    key: "checkDuplicateExports",
    value: function checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`".concat(name, "` has already been exported. Exported identifiers must be unique."));
      }

      this.state.exportedIdentifiers.push(name);
    }
  }, {
    key: "parseExportSpecifiers",
    value: function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        var node = this.startNode();
        node.local = this.parseIdentifier(true);
        node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    }
  }, {
    key: "parseImport",
    value: function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
  }, {
    key: "parseImportSource",
    value: function parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    }
  }, {
    key: "shouldParseDefaultImport",
    value: function shouldParseDefaultImport(node) {
      return this.match(types.name);
    }
  }, {
    key: "parseImportSpecifierLocal",
    value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    }
  }, {
    key: "maybeParseDefaultImportSpecifier",
    value: function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseStarImportSpecifier",
    value: function maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    }
  }, {
    key: "parseNamedImportSpecifiers",
    value: function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(this.state.start, "ES2015 named imports do not destructure. " + "Use another statement for destructuring after the import.");
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }
  }, {
    key: "parseImportSpecifier",
    value: function parseImportSpecifier(node) {
      var specifier = this.startNode();
      specifier.imported = this.parseIdentifier(true);

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
        specifier.local = specifier.imported.__clone();
      }

      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
  }]);

  return StatementParser;
}(ExpressionParser);

var Parser =
/*#__PURE__*/
function (_StatementParser) {
  _inherits(Parser, _StatementParser);

  function Parser(options, input) {
    var _this45;

    _classCallCheck(this, Parser);

    options = getOptions(options);
    _this45 = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this, options, input));

    var ScopeHandler = _this45.getScopeHandler();

    _this45.options = options;
    _this45.inModule = _this45.options.sourceType === "module";
    _this45.scope = new ScopeHandler(_this45.raise.bind(_assertThisInitialized(_this45)), _this45.inModule);
    _this45.plugins = pluginsMap(_this45.options.plugins);
    _this45.filename = options.sourceFilename;
    return _this45;
  }

  _createClass(Parser, [{
    key: "getScopeHandler",
    value: function getScopeHandler() {
      return ScopeHandler;
    }
  }, {
    key: "parse",
    value: function parse() {
      this.scope.enter(SCOPE_PROGRAM);
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }]);

  return Parser;
}(StatementParser);

function pluginsMap(plugins) {
  var pluginMap = new Map();

  for (var _i = 0; _i < plugins.length; _i++) {
    var plugin = plugins[_i];

    var _ref15 = Array.isArray(plugin) ? plugin : [plugin, {}],
        _ref16 = _slicedToArray(_ref15, 2),
        name = _ref16[0],
        options = _ref16[1];

    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
  }

  return pluginMap;
}

function parse(input, options) {
  if (options && options.sourceType === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      var parser = getParser(options, input);
      var ast = parser.parse();

      if (parser.sawUnambiguousESM) {
        return ast;
      }

      if (parser.ambiguousScriptDifferentAst) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }

      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (_unused2) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}

function parseExpression(input, options) {
  var parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}

function getParser(options, input) {
  var cls = Parser;

  if (options && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

var parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  var pluginList = mixinPluginNames.filter(function (name) {
    return hasPlugin(pluginsFromOptions, name);
  });
  var key = pluginList.join("/");
  var cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;

    for (var _i = 0; _i < pluginList.length; _i++) {
      var plugin = pluginList[_i];
      cls = mixinPlugins[plugin](cls);
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;

},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _core = require("@babel/core");

var buildForAwait = (0, _core.template)("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");

function _default(path, _ref) {
  var getAsyncIterator = _ref.getAsyncIterator;
  var node = path.node,
      scope = path.scope,
      parent = path.parent;
  var stepKey = scope.generateUidIdentifier("step");
  var stepValue = scope.generateUidIdentifier("value");
  var left = node.left;
  var declar;

  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
  } else if (_core.types.isVariableDeclaration(left)) {
    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
  }

  var template = buildForAwait({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    GET_ITERATOR: getAsyncIterator,
    OBJECT: node.right,
    STEP_VALUE: stepValue,
    STEP_KEY: stepKey
  });
  template = template.body.body;

  var isLabeledParent = _core.types.isLabeledStatement(parent);

  var tryBody = template[3].block.body;
  var loop = tryBody[0];

  if (isLabeledParent) {
    tryBody[0] = _core.types.labeledStatement(parent.label, loop);
  }

  return {
    replaceParent: isLabeledParent,
    node: template,
    declar: declar,
    loop: loop
  };
}

},{"@babel/core":19}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperRemapAsyncToGenerator = _interopRequireDefault(require("@babel/helper-remap-async-to-generator"));

var _pluginSyntaxAsyncGenerators = _interopRequireDefault(require("@babel/plugin-syntax-async-generators"));

var _core = require("@babel/core");

var _forAwait = _interopRequireDefault(require("./for-await"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  var yieldStarVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    YieldExpression: function YieldExpression(_ref, state) {
      var node = _ref.node;
      if (!node.delegate) return;
      var callee = state.addHelper("asyncGeneratorDelegate");
      node.argument = _core.types.callExpression(callee, [_core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
    }
  };
  var forAwaitVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    ForOfStatement: function ForOfStatement(path, _ref2) {
      var file = _ref2.file;
      var node = path.node;
      if (!node.await) return;
      var build = (0, _forAwait.default)(path, {
        getAsyncIterator: file.addHelper("asyncIterator")
      });
      var declar = build.declar,
          loop = build.loop;
      var block = loop.body;
      path.ensureBlock();

      if (declar) {
        block.body.push(declar);
      }

      block.body = block.body.concat(node.body.body);

      _core.types.inherits(loop, node);

      _core.types.inherits(loop.body, node.body);

      if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
      } else {
        path.replaceWithMultiple(build.node);
      }
    }
  };
  var visitor = {
    Function: function Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
      (0, _helperRemapAsyncToGenerator.default)(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator")
      });
    }
  };
  return {
    name: "proposal-async-generator-functions",
    inherits: _pluginSyntaxAsyncGenerators.default,
    visitor: {
      Program: function Program(path, state) {
        path.traverse(visitor, state);
      }
    }
  };
});

exports.default = _default;

},{"./for-await":90,"@babel/core":19,"@babel/helper-plugin-utils":79,"@babel/helper-remap-async-to-generator":81,"@babel/plugin-syntax-async-generators":98}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _pluginSyntaxDynamicImport = _interopRequireDefault(require("@babel/plugin-syntax-dynamic-import"));

var _package = require("../package.json");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "proposal-dynamic-import",
    inherits: _pluginSyntaxDynamicImport.default,
    pre: function pre() {
      this.file.set("@babel/plugin-proposal-dynamic-import", _package.version);
    },
    visitor: {
      Program: function Program() {
        var modules = this.file.get("@babel/plugin-transform-modules-*");

        if (!SUPPORTED_MODULES.includes(modules)) {
          throw new Error(MODULES_NOT_FOUND);
        }
      }
    }
  };
});

exports.default = _default;

},{"../package.json":93,"@babel/helper-plugin-utils":79,"@babel/plugin-syntax-dynamic-import":99}],93:[function(require,module,exports){
module.exports={
  "_from": "@babel/plugin-proposal-dynamic-import@^7.7.0",
  "_id": "@babel/plugin-proposal-dynamic-import@7.7.0",
  "_inBundle": false,
  "_integrity": "sha512-7poL3Xi+QFPC7sGAzEIbXUyYzGJwbc2+gSD0AkiC5k52kH2cqHdqxm5hNFfLW3cRSTcx9bN0Fl7/6zWcLLnKAQ==",
  "_location": "/@babel/plugin-proposal-dynamic-import",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "@babel/plugin-proposal-dynamic-import@^7.7.0",
    "name": "@babel/plugin-proposal-dynamic-import",
    "escapedName": "@babel%2fplugin-proposal-dynamic-import",
    "scope": "@babel",
    "rawSpec": "^7.7.0",
    "saveSpec": null,
    "fetchSpec": "^7.7.0"
  },
  "_requiredBy": [
    "/@babel/preset-env"
  ],
  "_resolved": "https://registry.npmjs.org/@babel/plugin-proposal-dynamic-import/-/plugin-proposal-dynamic-import-7.7.0.tgz",
  "_shasum": "dc02a8bad8d653fb59daf085516fa416edd2aa7f",
  "_spec": "@babel/plugin-proposal-dynamic-import@^7.7.0",
  "_where": "/local/home/ossman/devel/noVNC/node_modules/@babel/preset-env",
  "bundleDependencies": false,
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.0.0",
    "@babel/plugin-syntax-dynamic-import": "^7.2.0"
  },
  "deprecated": false,
  "description": "Transform import() expressions",
  "devDependencies": {
    "@babel/core": "^7.7.0",
    "@babel/helper-plugin-test-runner": "^7.0.0"
  },
  "gitHead": "97faa83953cb87e332554fa559a4956d202343ea",
  "keywords": [
    "babel-plugin"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "@babel/plugin-proposal-dynamic-import",
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-dynamic-import"
  },
  "version": "7.7.0"
}

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _pluginSyntaxJsonStrings() {
  var data = _interopRequireDefault(require("@babel/plugin-syntax-json-strings"));

  _pluginSyntaxJsonStrings = function _pluginSyntaxJsonStrings() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  var regex = /(\\*)([\u2028\u2029])/g;

  function replace(match, escapes, separator) {
    var isEscaped = escapes.length % 2 === 1;
    if (isEscaped) return match;
    return "".concat(escapes, "\\u").concat(separator.charCodeAt(0).toString(16));
  }

  return {
    name: "proposal-json-strings",
    inherits: _pluginSyntaxJsonStrings().default,
    visitor: {
      "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
        var node = _ref.node;
        var extra = node.extra;
        if (!extra || !extra.raw) return;
        extra.raw = extra.raw.replace(regex, replace);
      }
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79,"@babel/plugin-syntax-json-strings":100}],95:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _pluginSyntaxObjectRestSpread() {
  var data = _interopRequireDefault(require("@babel/plugin-syntax-object-rest-spread"));

  _pluginSyntaxObjectRestSpread = function _pluginSyntaxObjectRestSpread() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var ZERO_REFS = function () {
  var node = _core().types.identifier("a");

  var property = _core().types.objectProperty(_core().types.identifier("key"), node);

  var pattern = _core().types.objectPattern([property]);

  return _core().types.isReferenced(node, property, pattern) ? 1 : 0;
}();

var _default = (0, _helperPluginUtils().declare)(function (api, opts) {
  api.assertVersion(7);
  var _opts$useBuiltIns = opts.useBuiltIns,
      useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
      _opts$loose = opts.loose,
      loose = _opts$loose === void 0 ? false : _opts$loose;

  if (typeof loose !== "boolean") {
    throw new Error(".loose must be a boolean, or undefined");
  }

  function getExtendsHelper(file) {
    return useBuiltIns ? _core().types.memberExpression(_core().types.identifier("Object"), _core().types.identifier("assign")) : file.addHelper("extends");
  }

  function hasRestElement(path) {
    var foundRestElement = false;
    visitRestElements(path, function (restElement) {
      foundRestElement = true;
      restElement.stop();
    });
    return foundRestElement;
  }

  function hasObjectPatternRestElement(path) {
    var foundRestElement = false;
    visitRestElements(path, function (restElement) {
      if (restElement.parentPath.isObjectPattern()) {
        foundRestElement = true;
        restElement.stop();
      }
    });
    return foundRestElement;
  }

  function visitRestElements(path, visitor) {
    path.traverse({
      Expression: function Expression(path) {
        var parentType = path.parent.type;

        if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
          path.skip();
        }
      },
      RestElement: visitor
    });
  }

  function hasSpread(node) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        if (_core().types.isSpreadElement(prop)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  }

  function extractNormalizedKeys(path) {
    var props = path.node.properties;
    var keys = [];
    var allLiteral = true;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;

        if (_core().types.isIdentifier(prop.key) && !prop.computed) {
          keys.push(_core().types.stringLiteral(prop.key.name));
        } else if (_core().types.isTemplateLiteral(prop.key)) {
          keys.push(_core().types.cloneNode(prop.key));
        } else if (_core().types.isLiteral(prop.key)) {
          keys.push(_core().types.stringLiteral(String(prop.key.value)));
        } else {
          keys.push(_core().types.cloneNode(prop.key));
          allLiteral = false;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return {
      keys: keys,
      allLiteral: allLiteral
    };
  }

  function replaceImpureComputedKeys(path) {
    var impureComputedPropertyDeclarators = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = path.get("properties")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var propPath = _step3.value;
        var key = propPath.get("key");

        if (propPath.node.computed && !key.isPure()) {
          var name = path.scope.generateUidBasedOnNode(key.node);

          var declarator = _core().types.variableDeclarator(_core().types.identifier(name), key.node);

          impureComputedPropertyDeclarators.push(declarator);
          key.replaceWith(_core().types.identifier(name));
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return impureComputedPropertyDeclarators;
  }

  function removeUnusedExcludedKeys(path) {
    var bindings = path.getOuterBindingIdentifierPaths();
    Object.keys(bindings).forEach(function (bindingName) {
      var bindingParentPath = bindings[bindingName].parentPath;

      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
        return;
      }

      bindingParentPath.remove();
    });
  }

  function createObjectSpread(path, file, objRef) {
    var props = path.get("properties");
    var last = props[props.length - 1];

    _core().types.assertRestElement(last.node);

    var restElement = _core().types.cloneNode(last.node);

    last.remove();
    var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path);

    var _extractNormalizedKey = extractNormalizedKeys(path),
        keys = _extractNormalizedKey.keys,
        allLiteral = _extractNormalizedKey.allLiteral;

    if (keys.length === 0) {
      return [impureComputedPropertyDeclarators, restElement.argument, _core().types.callExpression(getExtendsHelper(file), [_core().types.objectExpression([]), _core().types.cloneNode(objRef)])];
    }

    var keyExpression;

    if (!allLiteral) {
      keyExpression = _core().types.callExpression(_core().types.memberExpression(_core().types.arrayExpression(keys), _core().types.identifier("map")), [file.addHelper("toPropertyKey")]);
    } else {
      keyExpression = _core().types.arrayExpression(keys);
    }

    return [impureComputedPropertyDeclarators, restElement.argument, _core().types.callExpression(file.addHelper("objectWithoutProperties".concat(loose ? "Loose" : "")), [_core().types.cloneNode(objRef), keyExpression])];
  }

  function replaceRestElement(parentPath, paramPath) {
    if (paramPath.isAssignmentPattern()) {
      replaceRestElement(parentPath, paramPath.get("left"));
      return;
    }

    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
      var elements = paramPath.get("elements");

      for (var i = 0; i < elements.length; i++) {
        replaceRestElement(parentPath, elements[i]);
      }
    }

    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
      var uid = parentPath.scope.generateUidIdentifier("ref");

      var declar = _core().types.variableDeclaration("let", [_core().types.variableDeclarator(paramPath.node, uid)]);

      parentPath.ensureBlock();
      parentPath.get("body").unshiftContainer("body", declar);
      paramPath.replaceWith(_core().types.cloneNode(uid));
    }
  }

  return {
    name: "proposal-object-rest-spread",
    inherits: _pluginSyntaxObjectRestSpread().default,
    visitor: {
      Function: function Function(path) {
        var params = path.get("params");

        for (var i = params.length - 1; i >= 0; i--) {
          replaceRestElement(params[i].parentPath, params[i]);
        }
      },
      VariableDeclarator: function VariableDeclarator(path, file) {
        if (!path.get("id").isObjectPattern()) {
          return;
        }

        var insertionPath = path;
        var originalPath = path;
        visitRestElements(path.get("id"), function (path) {
          if (!path.parentPath.isObjectPattern()) {
            return;
          }

          if (originalPath.node.id.properties.length > 1 && !_core().types.isIdentifier(originalPath.node.init)) {
            var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
            originalPath.insertBefore(_core().types.variableDeclarator(initRef, originalPath.node.init));
            originalPath.replaceWith(_core().types.variableDeclarator(originalPath.node.id, _core().types.cloneNode(initRef)));
            return;
          }

          var ref = originalPath.node.init;
          var refPropertyPath = [];
          var kind;
          path.findParent(function (path) {
            if (path.isObjectProperty()) {
              refPropertyPath.unshift(path.node.key.name);
            } else if (path.isVariableDeclarator()) {
              kind = path.parentPath.node.kind;
              return true;
            }
          });

          if (refPropertyPath.length) {
            refPropertyPath.forEach(function (prop) {
              ref = _core().types.memberExpression(ref, _core().types.identifier(prop));
            });
          }

          var objectPatternPath = path.findParent(function (path) {
            return path.isObjectPattern();
          });

          var _createObjectSpread = createObjectSpread(objectPatternPath, file, ref),
              _createObjectSpread2 = _slicedToArray(_createObjectSpread, 3),
              impureComputedPropertyDeclarators = _createObjectSpread2[0],
              argument = _createObjectSpread2[1],
              callExpression = _createObjectSpread2[2];

          if (loose) {
            removeUnusedExcludedKeys(objectPatternPath);
          }

          _core().types.assertIdentifier(argument);

          insertionPath.insertBefore(impureComputedPropertyDeclarators);
          insertionPath.insertAfter(_core().types.variableDeclarator(argument, callExpression));
          insertionPath = insertionPath.getSibling(insertionPath.key + 1);
          path.scope.registerBinding(kind, insertionPath);

          if (objectPatternPath.node.properties.length === 0) {
            objectPatternPath.findParent(function (path) {
              return path.isObjectProperty() || path.isVariableDeclarator();
            }).remove();
          }
        });
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
        var declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        var hasRest = declaration.get("declarations").some(function (path) {
          return hasRestElement(path.get("id"));
        });
        if (!hasRest) return;
        var specifiers = [];

        for (var _i2 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i2 < _Object$keys.length; _i2++) {
          var name = _Object$keys[_i2];
          specifiers.push(_core().types.exportSpecifier(_core().types.identifier(name), _core().types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core().types.exportNamedDeclaration(null, specifiers));
      },
      CatchClause: function CatchClause(path) {
        var paramPath = path.get("param");
        replaceRestElement(paramPath.parentPath, paramPath);
      },
      AssignmentExpression: function AssignmentExpression(path, file) {
        var leftPath = path.get("left");

        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
          var nodes = [];
          var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
          nodes.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(_core().types.identifier(refName), path.node.right)]));

          var _createObjectSpread3 = createObjectSpread(leftPath, file, _core().types.identifier(refName)),
              _createObjectSpread4 = _slicedToArray(_createObjectSpread3, 3),
              impureComputedPropertyDeclarators = _createObjectSpread4[0],
              argument = _createObjectSpread4[1],
              callExpression = _createObjectSpread4[2];

          if (impureComputedPropertyDeclarators.length > 0) {
            nodes.push(_core().types.variableDeclaration("var", impureComputedPropertyDeclarators));
          }

          var nodeWithoutSpread = _core().types.cloneNode(path.node);

          nodeWithoutSpread.right = _core().types.identifier(refName);
          nodes.push(_core().types.expressionStatement(nodeWithoutSpread));
          nodes.push(_core().types.toStatement(_core().types.assignmentExpression("=", argument, callExpression)));
          nodes.push(_core().types.expressionStatement(_core().types.identifier(refName)));
          path.replaceWithMultiple(nodes);
        }
      },
      ForXStatement: function ForXStatement(path) {
        var node = path.node,
            scope = path.scope;
        var leftPath = path.get("left");
        var left = node.left;

        if (!hasObjectPatternRestElement(leftPath)) {
          return;
        }

        if (!_core().types.isVariableDeclaration(left)) {
          var temp = scope.generateUidIdentifier("ref");
          node.left = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(temp)]);
          path.ensureBlock();

          if (node.body.body.length === 0 && path.isCompletionRecord()) {
            node.body.body.unshift(_core().types.expressionStatement(scope.buildUndefinedNode()));
          }

          node.body.body.unshift(_core().types.expressionStatement(_core().types.assignmentExpression("=", left, _core().types.cloneNode(temp))));
        } else {
          var pattern = left.declarations[0].id;
          var key = scope.generateUidIdentifier("ref");
          node.left = _core().types.variableDeclaration(left.kind, [_core().types.variableDeclarator(key, null)]);
          path.ensureBlock();
          node.body.body.unshift(_core().types.variableDeclaration(node.left.kind, [_core().types.variableDeclarator(pattern, _core().types.cloneNode(key))]));
        }
      },
      ArrayPattern: function ArrayPattern(path) {
        var objectPatterns = [];
        visitRestElements(path, function (path) {
          if (!path.parentPath.isObjectPattern()) {
            return;
          }

          var objectPattern = path.parentPath;
          var uid = path.scope.generateUidIdentifier("ref");
          objectPatterns.push(_core().types.variableDeclarator(objectPattern.node, uid));
          objectPattern.replaceWith(_core().types.cloneNode(uid));
          path.skip();
        });

        if (objectPatterns.length > 0) {
          var statementPath = path.getStatementParent();
          statementPath.insertAfter(_core().types.variableDeclaration(statementPath.node.kind || "var", objectPatterns));
        }
      },
      ObjectExpression: function ObjectExpression(path, file) {
        if (!hasSpread(path.node)) return;
        var args = [];
        var props = [];

        function push() {
          args.push(_core().types.objectExpression(props));
          props = [];
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = path.node.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var prop = _step4.value;

            if (_core().types.isSpreadElement(prop)) {
              push();
              args.push(prop.argument);
            } else {
              props.push(prop);
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        if (props.length) {
          push();
        }

        var helper;

        if (loose) {
          helper = getExtendsHelper(file);
        } else {
          try {
            helper = file.addHelper("objectSpread2");
          } catch (_unused) {
            this.file.declarations["objectSpread2"] = null;
            helper = file.addHelper("objectSpread");
          }
        }

        path.replaceWith(_core().types.callExpression(helper, args));
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79,"@babel/plugin-syntax-object-rest-spread":101}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _pluginSyntaxOptionalCatchBinding() {
  var data = _interopRequireDefault(require("@babel/plugin-syntax-optional-catch-binding"));

  _pluginSyntaxOptionalCatchBinding = function _pluginSyntaxOptionalCatchBinding() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "proposal-optional-catch-binding",
    inherits: _pluginSyntaxOptionalCatchBinding().default,
    visitor: {
      CatchClause: function CatchClause(path) {
        if (!path.node.param) {
          var uid = path.scope.generateUidIdentifier("unused");
          var paramPath = path.get("param");
          paramPath.replaceWith(uid);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79,"@babel/plugin-syntax-optional-catch-binding":102}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var _options$useUnicodeFl = options.useUnicodeFlag,
      useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

  if (typeof useUnicodeFlag !== "boolean") {
    throw new Error(".useUnicodeFlag must be a boolean, or undefined");
  }

  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "proposal-unicode-property-regex",
    feature: "unicodePropertyEscape",
    options: {
      useUnicodeFlag: useUnicodeFlag
    }
  });
});

exports.default = _default;

},{"@babel/helper-create-regexp-features-plugin":61,"@babel/helper-plugin-utils":79}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-async-generators",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("asyncGenerators");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-dynamic-import",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("dynamicImport");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-json-strings",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsonStrings");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-object-rest-spread",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("objectRestSpread");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-optional-catch-binding",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalCatchBinding");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "syntax-top-level-await",
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("topLevelAwait");
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var spec = options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression: function ArrowFunctionExpression(path) {
        if (!path.isArrowFunctionExpression()) return;
        path.arrowFunctionToExpression({
          allowInsertArrow: false,
          specCompliant: !!spec
        });
      }
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperRemapAsyncToGenerator = _interopRequireDefault(require("@babel/helper-remap-async-to-generator"));

var _helperModuleImports = require("@babel/helper-module-imports");

var _core = require("@babel/core");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var method = options.method,
      module = options.module;

  if (method && module) {
    return {
      name: "transform-async-to-generator",
      visitor: {
        Function: function Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          var wrapAsync = state.methodWrapper;

          if (wrapAsync) {
            wrapAsync = _core.types.cloneNode(wrapAsync);
          } else {
            wrapAsync = state.methodWrapper = (0, _helperModuleImports.addNamed)(path, method, module);
          }

          (0, _helperRemapAsyncToGenerator.default)(path, {
            wrapAsync: wrapAsync
          });
        }
      }
    };
  }

  return {
    name: "transform-async-to-generator",
    visitor: {
      Function: function Function(path, state) {
        if (!path.node.async || path.node.generator) return;
        (0, _helperRemapAsyncToGenerator.default)(path, {
          wrapAsync: state.addHelper("asyncToGenerator")
        });
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-module-imports":72,"@babel/helper-plugin-utils":79,"@babel/helper-remap-async-to-generator":81}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);

  function statementList(key, path) {
    var paths = path.get(key);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _path = _step.value;
        var func = _path.node;
        if (!_path.isFunctionDeclaration()) continue;

        var declar = _core().types.variableDeclaration("let", [_core().types.variableDeclarator(func.id, _core().types.toExpression(func))]);

        declar._blockHoist = 2;
        func.id = null;

        _path.replaceWith(declar);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return {
    name: "transform-block-scoped-functions",
    visitor: {
      BlockStatement: function BlockStatement(path) {
        var node = path.node,
            parent = path.parent;

        if (_core().types.isFunction(parent, {
          body: node
        }) || _core().types.isExportDeclaration(parent)) {
          return;
        }

        statementList("body", path);
      },
      SwitchCase: function SwitchCase(path) {
        statementList("consequent", path);
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],107:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _tdz = require("./tdz");

var _values = _interopRequireDefault(require("lodash/values"));

var _extend = _interopRequireDefault(require("lodash/extend"));

var _core = require("@babel/core");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var DONE = new WeakSet();

var _default = (0, _helperPluginUtils.declare)(function (api, opts) {
  api.assertVersion(7);
  var _opts$throwIfClosureR = opts.throwIfClosureRequired,
      throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
      _opts$tdz = opts.tdz,
      tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

  if (typeof throwIfClosureRequired !== "boolean") {
    throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
  }

  if (typeof tdzEnabled !== "boolean") {
    throw new Error(".tdz must be a boolean, or undefined");
  }

  return {
    name: "transform-block-scoping",
    visitor: {
      VariableDeclaration: function VariableDeclaration(path) {
        var node = path.node,
            parent = path.parent,
            scope = path.scope;
        if (!isBlockScoped(node)) return;
        convertBlockScopedToVar(path, null, parent, scope, true);

        if (node._tdzThis) {
          var nodes = [node];

          for (var i = 0; i < node.declarations.length; i++) {
            var decl = node.declarations[i];

            var assign = _core.types.assignmentExpression("=", decl.id, decl.init || scope.buildUndefinedNode());

            assign._ignoreBlockScopingTDZ = true;
            nodes.push(_core.types.expressionStatement(assign));
            decl.init = this.addHelper("temporalUndefined");
          }

          node._blockHoist = 2;

          if (path.isCompletionRecord()) {
            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));
          }

          path.replaceWithMultiple(nodes);
        }
      },
      Loop: function Loop(path, state) {
        var parent = path.parent,
            scope = path.scope;
        path.ensureBlock();
        var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
        var replace = blockScoping.run();
        if (replace) path.replaceWith(replace);
      },
      CatchClause: function CatchClause(path, state) {
        var parent = path.parent,
            scope = path.scope;
        var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
        blockScoping.run();
      },
      "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
        if (!ignoreBlock(path)) {
          var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
          blockScoping.run();
        }
      }
    }
  };
});

exports.default = _default;

function ignoreBlock(path) {
  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);
}

var buildRetCheck = (0, _core.template)("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

function isBlockScoped(node) {
  if (!_core.types.isVariableDeclaration(node)) return false;
  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) return true;
  if (node.kind !== "let" && node.kind !== "const") return false;
  return true;
}

function isInLoop(path) {
  var loopOrFunctionParent = path.find(function (path) {
    return path.isLoop() || path.isFunction();
  });
  return loopOrFunctionParent && loopOrFunctionParent.isLoop();
}

function convertBlockScopedToVar(path, node, parent, scope) {
  var moveBindingsToParent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (!node) {
    node = path.node;
  }

  if (isInLoop(path) && !_core.types.isFor(parent)) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];
      declar.init = declar.init || scope.buildUndefinedNode();
    }
  }

  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;
  node.kind = "var";

  if (moveBindingsToParent) {
    var parentScope = scope.getFunctionParent() || scope.getProgramParent();

    for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
      var name = _Object$keys[_i];
      var binding = scope.getOwnBinding(name);
      if (binding) binding.kind = "var";
      scope.moveBindingTo(name, parentScope);
    }
  }
}

function isVar(node) {
  return _core.types.isVariableDeclaration(node, {
    kind: "var"
  }) && !isBlockScoped(node);
}

var letReferenceBlockVisitor = _core.traverse.visitors.merge([{
  Loop: {
    enter: function enter(path, state) {
      state.loopDepth++;
    },
    exit: function exit(path, state) {
      state.loopDepth--;
    }
  },
  Function: function Function(path, state) {
    if (state.loopDepth > 0) {
      path.traverse(letReferenceFunctionVisitor, state);
    } else {
      path.traverse(_tdz.visitor, state);
    }

    return path.skip();
  }
}, _tdz.visitor]);

var letReferenceFunctionVisitor = _core.traverse.visitors.merge([{
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    var ref = state.letReferences[path.node.name];
    if (!ref) return;
    var localBinding = path.scope.getBindingIdentifier(path.node.name);
    if (localBinding && localBinding !== ref) return;
    state.closurify = true;
  }
}, _tdz.visitor]);

var hoistVarDeclarationsVisitor = {
  enter: function enter(path, self) {
    var node = path.node,
        parent = path.parent;

    if (path.isForStatement()) {
      if (isVar(node.init, node)) {
        var nodes = self.pushDeclar(node.init);

        if (nodes.length === 1) {
          node.init = nodes[0];
        } else {
          node.init = _core.types.sequenceExpression(nodes);
        }
      }
    } else if (path.isFor()) {
      if (isVar(node.left, node)) {
        self.pushDeclar(node.left);
        node.left = node.left.declarations[0].id;
      }
    } else if (isVar(node, parent)) {
      path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {
        return _core.types.expressionStatement(expr);
      }));
    } else if (path.isFunction()) {
      return path.skip();
    }
  }
};
var loopLabelVisitor = {
  LabeledStatement: function LabeledStatement(_ref, state) {
    var node = _ref.node;
    state.innerLabels.push(node.label.name);
  }
};
var continuationVisitor = {
  enter: function enter(path, state) {
    if (path.isAssignmentExpression() || path.isUpdateExpression()) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
        var name = _Object$keys2[_i2];

        if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {
          continue;
        }

        state.reassignments[name] = true;
      }
    } else if (path.isReturnStatement()) {
      state.returnStatements.push(path);
    }
  }
};

function loopNodeTo(node) {
  if (_core.types.isBreakStatement(node)) {
    return "break";
  } else if (_core.types.isContinueStatement(node)) {
    return "continue";
  }
}

var loopVisitor = {
  Loop: function Loop(path, state) {
    var oldIgnoreLabeless = state.ignoreLabeless;
    state.ignoreLabeless = true;
    path.traverse(loopVisitor, state);
    state.ignoreLabeless = oldIgnoreLabeless;
    path.skip();
  },
  Function: function Function(path) {
    path.skip();
  },
  SwitchCase: function SwitchCase(path, state) {
    var oldInSwitchCase = state.inSwitchCase;
    state.inSwitchCase = true;
    path.traverse(loopVisitor, state);
    state.inSwitchCase = oldInSwitchCase;
    path.skip();
  },
  "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
    var node = path.node,
        scope = path.scope;
    if (node[this.LOOP_IGNORE]) return;
    var replace;
    var loopText = loopNodeTo(node);

    if (loopText) {
      if (node.label) {
        if (state.innerLabels.indexOf(node.label.name) >= 0) {
          return;
        }

        loopText = "".concat(loopText, "|").concat(node.label.name);
      } else {
        if (state.ignoreLabeless) return;
        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;
      }

      state.hasBreakContinue = true;
      state.map[loopText] = node;
      replace = _core.types.stringLiteral(loopText);
    }

    if (path.isReturnStatement()) {
      state.hasReturn = true;
      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("v"), node.argument || scope.buildUndefinedNode())]);
    }

    if (replace) {
      replace = _core.types.returnStatement(replace);
      replace[this.LOOP_IGNORE] = true;
      path.skip();
      path.replaceWith(_core.types.inherits(replace, node));
    }
  }
};

var BlockScoping =
/*#__PURE__*/
function () {
  function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
    _classCallCheck(this, BlockScoping);

    this.parent = parent;
    this.scope = scope;
    this.state = state;
    this.throwIfClosureRequired = throwIfClosureRequired;
    this.tdzEnabled = tdzEnabled;
    this.blockPath = blockPath;
    this.block = blockPath.node;
    this.outsideLetReferences = Object.create(null);
    this.hasLetReferences = false;
    this.letReferences = Object.create(null);
    this.body = [];

    if (loopPath) {
      this.loopParent = loopPath.parent;
      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;
      this.loopPath = loopPath;
      this.loop = loopPath.node;
    }
  }

  _createClass(BlockScoping, [{
    key: "run",
    value: function run() {
      var block = this.block;
      if (DONE.has(block)) return;
      DONE.add(block);
      var needsClosure = this.getLetReferences();
      this.checkConstants();

      if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {
        this.updateScopeInfo();
        return;
      }

      if (!this.hasLetReferences) return;

      if (needsClosure) {
        this.wrapClosure();
      } else {
        this.remap();
      }

      this.updateScopeInfo(needsClosure);

      if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {
        return _core.types.labeledStatement(this.loopLabel, this.loop);
      }
    }
  }, {
    key: "checkConstants",
    value: function checkConstants() {
      var scope = this.scope;
      var state = this.state;

      for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = scope.bindings[name];
        if (binding.kind !== "const") continue;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var violation = _step.value;
            var readOnlyError = state.addHelper("readOnlyError");

            var throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);

            if (violation.isAssignmentExpression()) {
              violation.get("right").replaceWith(_core.types.sequenceExpression([throwNode, violation.get("right").node]));
            } else if (violation.isUpdateExpression()) {
              violation.replaceWith(_core.types.sequenceExpression([throwNode, violation.node]));
            } else if (violation.isForXStatement()) {
              violation.ensureBlock();
              violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: "updateScopeInfo",
    value: function updateScopeInfo(wrappedInClosure) {
      var blockScope = this.blockPath.scope;
      var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
      var letRefs = this.letReferences;

      for (var _i4 = 0, _Object$keys4 = Object.keys(letRefs); _i4 < _Object$keys4.length; _i4++) {
        var key = _Object$keys4[_i4];
        var ref = letRefs[key];
        var binding = blockScope.getBinding(ref.name);
        if (!binding) continue;

        if (binding.kind === "let" || binding.kind === "const") {
          binding.kind = "var";

          if (wrappedInClosure) {
            if (blockScope.hasOwnBinding(ref.name)) {
              blockScope.removeBinding(ref.name);
            }
          } else {
            blockScope.moveBindingTo(ref.name, parentScope);
          }
        }
      }
    }
  }, {
    key: "remap",
    value: function remap() {
      var letRefs = this.letReferences;
      var outsideLetRefs = this.outsideLetReferences;
      var scope = this.scope;
      var blockPathScope = this.blockPath.scope;

      for (var _i5 = 0, _Object$keys5 = Object.keys(letRefs); _i5 < _Object$keys5.length; _i5++) {
        var key = _Object$keys5[_i5];
        var ref = letRefs[key];

        if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
          if (scope.hasOwnBinding(key)) {
            scope.rename(ref.name);
          }

          if (blockPathScope.hasOwnBinding(key)) {
            blockPathScope.rename(ref.name);
          }
        }
      }

      for (var _i6 = 0, _Object$keys6 = Object.keys(outsideLetRefs); _i6 < _Object$keys6.length; _i6++) {
        var _key = _Object$keys6[_i6];
        var _ref2 = letRefs[_key];

        if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
          blockPathScope.rename(_ref2.name);
        }
      }
    }
  }, {
    key: "wrapClosure",
    value: function wrapClosure() {
      if (this.throwIfClosureRequired) {
        throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
      }

      var block = this.block;
      var outsideRefs = this.outsideLetReferences;

      if (this.loop) {
        for (var _i7 = 0, _Object$keys7 = Object.keys(outsideRefs); _i7 < _Object$keys7.length; _i7++) {
          var name = _Object$keys7[_i7];
          var id = outsideRefs[name];

          if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
            delete outsideRefs[id.name];
            delete this.letReferences[id.name];
            this.scope.rename(id.name);
            this.letReferences[id.name] = id;
            outsideRefs[id.name] = id;
          }
        }
      }

      this.has = this.checkLoop();
      this.hoistVarDeclarations();
      var args = (0, _values.default)(outsideRefs).map(function (id) {
        return _core.types.cloneNode(id);
      });
      var params = args.map(function (id) {
        return _core.types.cloneNode(id);
      });
      var isSwitch = this.blockPath.isSwitchStatement();

      var fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));

      this.addContinuations(fn);

      var call = _core.types.callExpression(_core.types.nullLiteral(), args);

      var basePath = ".callee";

      var hasYield = _core.traverse.hasType(fn.body, "YieldExpression", _core.types.FUNCTION_TYPES);

      if (hasYield) {
        fn.generator = true;
        call = _core.types.yieldExpression(call, true);
        basePath = ".argument" + basePath;
      }

      var hasAsync = _core.traverse.hasType(fn.body, "AwaitExpression", _core.types.FUNCTION_TYPES);

      if (hasAsync) {
        fn.async = true;
        call = _core.types.awaitExpression(call);
        basePath = ".argument" + basePath;
      }

      var placeholderPath;
      var index;

      if (this.has.hasReturn || this.has.hasBreakContinue) {
        var ret = this.scope.generateUid("ret");
        this.body.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));
        placeholderPath = "declarations.0.init" + basePath;
        index = this.body.length - 1;
        this.buildHas(ret);
      } else {
        this.body.push(_core.types.expressionStatement(call));
        placeholderPath = "expression" + basePath;
        index = this.body.length - 1;
      }

      var callPath;

      if (isSwitch) {
        var _this$blockPath = this.blockPath,
            parentPath = _this$blockPath.parentPath,
            listKey = _this$blockPath.listKey,
            key = _this$blockPath.key;
        this.blockPath.replaceWithMultiple(this.body);
        callPath = parentPath.get(listKey)[key + index];
      } else {
        block.body = this.body;
        callPath = this.blockPath.get("body")[index];
      }

      var placeholder = callPath.get(placeholderPath);
      var fnPath;

      if (this.loop) {
        var loopId = this.scope.generateUid("loop");
        var p = this.loopPath.insertBefore(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));
        placeholder.replaceWith(_core.types.identifier(loopId));
        fnPath = p[0].get("declarations.0.init");
      } else {
        placeholder.replaceWith(fn);
        fnPath = placeholder;
      }

      fnPath.unwrapFunctionEnvironment();
    }
  }, {
    key: "addContinuations",
    value: function addContinuations(fn) {
      var _this = this;

      var state = {
        reassignments: {},
        returnStatements: [],
        outsideReferences: this.outsideLetReferences
      };
      this.scope.traverse(fn, continuationVisitor, state);

      var _loop = function _loop(i) {
        var param = fn.params[i];
        if (!state.reassignments[param.name]) return "continue";
        var paramName = param.name;

        var newParamName = _this.scope.generateUid(param.name);

        fn.params[i] = _core.types.identifier(newParamName);

        _this.scope.rename(paramName, newParamName, fn);

        state.returnStatements.forEach(function (returnStatement) {
          returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
        });
        fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
      };

      for (var i = 0; i < fn.params.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      }
    }
  }, {
    key: "getLetReferences",
    value: function getLetReferences() {
      var _this2 = this;

      var block = this.block;
      var declarators = [];

      if (this.loop) {
        var init = this.loop.left || this.loop.init;

        if (isBlockScoped(init)) {
          declarators.push(init);
          (0, _extend.default)(this.outsideLetReferences, _core.types.getBindingIdentifiers(init));
        }
      }

      var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
        node = node || path.node;

        if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {
          if (isBlockScoped(node)) {
            convertBlockScopedToVar(path, node, block, _this2.scope);
          }

          declarators = declarators.concat(node.declarations || node);
        }

        if (_core.types.isLabeledStatement(node)) {
          addDeclarationsFromChild(path.get("body"), node.body);
        }
      };

      if (block.body) {
        var declarPaths = this.blockPath.get("body");

        for (var i = 0; i < block.body.length; i++) {
          addDeclarationsFromChild(declarPaths[i]);
        }
      }

      if (block.cases) {
        var _declarPaths = this.blockPath.get("cases");

        for (var _i8 = 0; _i8 < block.cases.length; _i8++) {
          var consequents = block.cases[_i8].consequent;

          for (var j = 0; j < consequents.length; j++) {
            var declar = consequents[j];
            addDeclarationsFromChild(_declarPaths[_i8], declar);
          }
        }
      }

      for (var _i9 = 0; _i9 < declarators.length; _i9++) {
        var _declar = declarators[_i9];

        var keys = _core.types.getBindingIdentifiers(_declar, false, true);

        (0, _extend.default)(this.letReferences, keys);
        this.hasLetReferences = true;
      }

      if (!this.hasLetReferences) return;
      var state = {
        letReferences: this.letReferences,
        closurify: false,
        loopDepth: 0,
        tdzEnabled: this.tdzEnabled,
        addHelper: function addHelper(name) {
          return _this2.state.addHelper(name);
        }
      };

      if (isInLoop(this.blockPath)) {
        state.loopDepth++;
      }

      this.blockPath.traverse(letReferenceBlockVisitor, state);
      return state.closurify;
    }
  }, {
    key: "checkLoop",
    value: function checkLoop() {
      var state = {
        hasBreakContinue: false,
        ignoreLabeless: false,
        inSwitchCase: false,
        innerLabels: [],
        hasReturn: false,
        isLoop: !!this.loop,
        map: {},
        LOOP_IGNORE: Symbol()
      };
      this.blockPath.traverse(loopLabelVisitor, state);
      this.blockPath.traverse(loopVisitor, state);
      return state;
    }
  }, {
    key: "hoistVarDeclarations",
    value: function hoistVarDeclarations() {
      this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
    }
  }, {
    key: "pushDeclar",
    value: function pushDeclar(node) {
      var declars = [];

      var names = _core.types.getBindingIdentifiers(node);

      for (var _i10 = 0, _Object$keys8 = Object.keys(names); _i10 < _Object$keys8.length; _i10++) {
        var name = _Object$keys8[_i10];
        declars.push(_core.types.variableDeclarator(names[name]));
      }

      this.body.push(_core.types.variableDeclaration(node.kind, declars));
      var replace = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        if (!declar.init) continue;

        var expr = _core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));

        replace.push(_core.types.inherits(expr, declar));
      }

      return replace;
    }
  }, {
    key: "buildHas",
    value: function buildHas(ret) {
      var body = this.body;
      var retCheck;
      var has = this.has;
      var cases = [];

      if (has.hasReturn) {
        retCheck = buildRetCheck({
          RETURN: _core.types.identifier(ret)
        });
      }

      if (has.hasBreakContinue) {
        for (var _i11 = 0, _Object$keys9 = Object.keys(has.map); _i11 < _Object$keys9.length; _i11++) {
          var key = _Object$keys9[_i11];
          cases.push(_core.types.switchCase(_core.types.stringLiteral(key), [has.map[key]]));
        }

        if (has.hasReturn) {
          cases.push(_core.types.switchCase(null, [retCheck]));
        }

        if (cases.length === 1) {
          var single = cases[0];
          body.push(_core.types.ifStatement(_core.types.binaryExpression("===", _core.types.identifier(ret), single.test), single.consequent[0]));
        } else {
          if (this.loop) {
            for (var i = 0; i < cases.length; i++) {
              var caseConsequent = cases[i].consequent[0];

              if (_core.types.isBreakStatement(caseConsequent) && !caseConsequent.label) {
                if (!this.loopLabel) {
                  this.loopLabel = this.scope.generateUidIdentifier("loop");
                }

                caseConsequent.label = _core.types.cloneNode(this.loopLabel);
              }
            }
          }

          body.push(_core.types.switchStatement(_core.types.identifier(ret), cases));
        }
      } else {
        if (has.hasReturn) {
          body.push(retCheck);
        }
      }
    }
  }]);

  return BlockScoping;
}();

},{"./tdz":108,"@babel/core":19,"@babel/helper-plugin-utils":79,"lodash/extend":1010,"lodash/values":1048}],108:[function(require,module,exports){
"use strict";

function _templateObject() {
  var data = _taggedTemplateLiteral(["", "(\"", "\")"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visitor = void 0;

var _core = require("@babel/core");

function getTDZStatus(refPath, bindingPath) {
  var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

  if (executionStatus === "before") {
    return "outside";
  } else if (executionStatus === "after") {
    return "inside";
  } else {
    return "maybe";
  }
}

function buildTDZAssert(node, state) {
  return _core.types.callExpression(state.addHelper("temporalRef"), [node, _core.types.stringLiteral(node.name)]);
}

function isReference(node, scope, state) {
  var declared = state.letReferences[node.name];
  if (!declared) return false;
  return scope.getBindingIdentifier(node.name) === declared;
}

var visitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (!state.tdzEnabled) return;
    var node = path.node,
        parent = path.parent,
        scope = path.scope;
    if (path.parentPath.isFor({
      left: node
    })) return;
    if (!isReference(node, scope, state)) return;
    var bindingPath = scope.getBinding(node.name).path;
    if (bindingPath.isFunctionDeclaration()) return;
    var status = getTDZStatus(path, bindingPath);
    if (status === "outside") return;

    if (status === "maybe") {
      var assert = buildTDZAssert(node, state);
      bindingPath.parent._tdzThis = true;
      path.skip();

      if (path.parentPath.isUpdateExpression()) {
        if (parent._ignoreBlockScopingTDZ) return;
        path.parentPath.replaceWith(_core.types.sequenceExpression([assert, parent]));
      } else {
        path.replaceWith(assert);
      }
    } else if (status === "inside") {
      path.replaceWith(_core.template.ast(_templateObject(), state.addHelper("tdz"), node.name));
    }
  },
  AssignmentExpression: {
    exit: function exit(path, state) {
      if (!state.tdzEnabled) return;
      var node = path.node;
      if (node._ignoreBlockScopingTDZ) return;
      var nodes = [];
      var ids = path.getBindingIdentifiers();

      for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        var id = ids[name];

        if (isReference(id, path.scope, state)) {
          nodes.push(id);
        }
      }

      if (nodes.length) {
        node._ignoreBlockScopingTDZ = true;
        nodes.push(node);
        path.replaceWithMultiple(nodes.map(function (n) {
          return _core.types.expressionStatement(n);
        }));
      }
    }
  }
};
exports.visitor = visitor;

},{"@babel/core":19}],109:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperAnnotateAsPure = _interopRequireDefault(require("@babel/helper-annotate-as-pure"));

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

var _helperSplitExportDeclaration = _interopRequireDefault(require("@babel/helper-split-export-declaration"));

var _core = require("@babel/core");

var _globals = _interopRequireDefault(require("globals"));

var _transformClass = _interopRequireDefault(require("./transformClass"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var getBuiltinClasses = function getBuiltinClasses(category) {
  return Object.keys(_globals.default[category]).filter(function (name) {
    return /^[A-Z]/.test(name);
  });
};

var builtinClasses = new Set([].concat(_toConsumableArray(getBuiltinClasses("builtin")), _toConsumableArray(getBuiltinClasses("browser"))));

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;
  var VISITED = Symbol();
  return {
    name: "transform-classes",
    visitor: {
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
        if (!path.get("declaration").isClassDeclaration()) return;
        (0, _helperSplitExportDeclaration.default)(path);
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var node = path.node;
        var ref = node.id || path.scope.generateUidIdentifier("class");
        path.replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));
      },
      ClassExpression: function ClassExpression(path, state) {
        var node = path.node;
        if (node[VISITED]) return;
        var inferred = (0, _helperFunctionName.default)(path);

        if (inferred && inferred !== node) {
          path.replaceWith(inferred);
          return;
        }

        node[VISITED] = true;
        path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose));

        if (path.isCallExpression()) {
          (0, _helperAnnotateAsPure.default)(path);

          if (path.get("callee").isArrowFunctionExpression()) {
            path.get("callee").arrowFunctionToExpression();
          }
        }
      }
    }
  };
});

exports.default = _default;

},{"./transformClass":110,"@babel/core":19,"@babel/helper-annotate-as-pure":57,"@babel/helper-function-name":66,"@babel/helper-plugin-utils":79,"@babel/helper-split-export-declaration":84,"globals":838}],110:[function(require,module,exports){
"use strict";

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformClass;

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

var _helperReplaceSupers = _interopRequireWildcard(require("@babel/helper-replace-supers"));

var _helperOptimiseCallExpression = _interopRequireDefault(require("@babel/helper-optimise-call-expression"));

var defineMap = _interopRequireWildcard(require("@babel/helper-define-map"));

var _core = require("@babel/core");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function buildConstructor(classRef, constructorBody, node) {
  var func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);

  _core.types.inherits(func, node);

  return func;
}

function transformClass(path, file, builtinClasses, isLoose) {
  var classState = {
    parent: undefined,
    scope: undefined,
    node: undefined,
    path: undefined,
    file: undefined,
    classId: undefined,
    classRef: undefined,
    superName: undefined,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: undefined,
    constructorBody: undefined,
    userConstructor: undefined,
    userConstructorPath: undefined,
    hasConstructor: false,
    instancePropBody: [],
    instancePropRefs: {},
    staticPropBody: [],
    body: [],
    superThises: [],
    pushedConstructor: false,
    pushedInherits: false,
    protoAlias: null,
    isLoose: false,
    hasInstanceDescriptors: false,
    hasStaticDescriptors: false,
    instanceMutatorMap: {},
    staticMutatorMap: {}
  };

  var setState = function setState(newState) {
    Object.assign(classState, newState);
  };

  var findThisesVisitor = _core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
    ThisExpression: function ThisExpression(path) {
      classState.superThises.push(path);
    }
  }]);

  function pushToMap(node, enumerable) {
    var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "value";
    var scope = arguments.length > 3 ? arguments[3] : undefined;
    var mutatorMap;

    if (node.static) {
      setState({
        hasStaticDescriptors: true
      });
      mutatorMap = classState.staticMutatorMap;
    } else {
      setState({
        hasInstanceDescriptors: true
      });
      mutatorMap = classState.instanceMutatorMap;
    }

    var map = defineMap.push(mutatorMap, node, kind, classState.file, scope);

    if (enumerable) {
      map.enumerable = _core.types.booleanLiteral(true);
    }

    return map;
  }

  function maybeCreateConstructor() {
    var hasConstructor = false;
    var paths = classState.path.get("body.body");
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _path = _step.value;
        hasConstructor = _path.equals("kind", "constructor");
        if (hasConstructor) break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (hasConstructor) return;
    var params, body;

    if (classState.isDerived) {
      var _constructor = _core.template.expression.ast(_templateObject());

      params = _constructor.params;
      body = _constructor.body;
    } else {
      params = [];
      body = _core.types.blockStatement([]);
    }

    classState.path.get("body").unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
  }

  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();

    if (classState.userConstructor) {
      var constructorBody = classState.constructorBody,
          userConstructor = classState.userConstructor,
          construct = classState.construct;
      constructorBody.body = constructorBody.body.concat(userConstructor.body.body);

      _core.types.inherits(construct, userConstructor);

      _core.types.inherits(constructorBody, userConstructor.body);
    }

    pushDescriptors();
  }

  function pushBody() {
    var classBodyPaths = classState.path.get("body.body");
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = classBodyPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _path2 = _step2.value;
        var node = _path2.node;

        if (_path2.isClassProperty()) {
          throw _path2.buildCodeFrameError("Missing class properties transform.");
        }

        if (node.decorators) {
          throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
        }

        if (_core.types.isClassMethod(node)) {
          (function () {
            var isConstructor = node.kind === "constructor";
            var replaceSupers = new _helperReplaceSupers.default({
              methodPath: _path2,
              objectRef: classState.classRef,
              superRef: classState.superName,
              isLoose: classState.isLoose,
              file: classState.file
            });
            replaceSupers.replace();
            var superReturns = [];

            _path2.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
              ReturnStatement: function ReturnStatement(path) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  superReturns.push(path);
                }
              }
            }]));

            if (isConstructor) {
              pushConstructor(superReturns, node, _path2);
            } else {
              pushMethod(node, _path2);
            }
          })();
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  function clearDescriptors() {
    setState({
      hasInstanceDescriptors: false,
      hasStaticDescriptors: false,
      instanceMutatorMap: {},
      staticMutatorMap: {}
    });
  }

  function pushDescriptors() {
    pushInheritsToBody();
    var body = classState.body;
    var instanceProps;
    var staticProps;

    if (classState.hasInstanceDescriptors) {
      instanceProps = defineMap.toClassObject(classState.instanceMutatorMap);
    }

    if (classState.hasStaticDescriptors) {
      staticProps = defineMap.toClassObject(classState.staticMutatorMap);
    }

    if (instanceProps || staticProps) {
      if (instanceProps) {
        instanceProps = defineMap.toComputedObjectFromClass(instanceProps);
      }

      if (staticProps) {
        staticProps = defineMap.toComputedObjectFromClass(staticProps);
      }

      var args = [_core.types.cloneNode(classState.classRef), _core.types.nullLiteral(), _core.types.nullLiteral()];
      if (instanceProps) args[1] = instanceProps;
      if (staticProps) args[2] = staticProps;
      var lastNonNullIndex = 0;

      for (var i = 0; i < args.length; i++) {
        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;
      }

      args = args.slice(0, lastNonNullIndex + 1);
      body.push(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("createClass"), args)));
    }

    clearDescriptors();
  }

  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    var bareSuperNode = bareSuper.node;
    var call;

    if (classState.isLoose) {
      bareSuperNode.arguments.unshift(_core.types.thisExpression());

      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
        name: "arguments"
      })) {
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"));
      } else {
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call"));
      }

      call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression());
    } else {
      bareSuperNode = (0, _helperOptimiseCallExpression.default)(_core.types.callExpression(classState.file.addHelper("getPrototypeOf"), [_core.types.cloneNode(classState.classRef)]), _core.types.thisExpression(), bareSuperNode.arguments);
      call = _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [_core.types.thisExpression(), bareSuperNode]);
    }

    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
      if (classState.superThises.length) {
        call = _core.types.assignmentExpression("=", thisRef(), call);
      }

      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));
    } else {
      bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
    }
  }

  function verifyConstructor() {
    if (!classState.isDerived) return;
    var path = classState.userConstructorPath;
    var body = path.get("body");
    path.traverse(findThisesVisitor);

    var _thisRef = function thisRef() {
      var ref = path.scope.generateDeclaredUidIdentifier("this");

      _thisRef = function thisRef() {
        return _core.types.cloneNode(ref);
      };

      return ref;
    };

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = classState.superThises[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var thisPath = _step3.value;
        var node = thisPath.node,
            parentPath = thisPath.parentPath;

        if (parentPath.isMemberExpression({
          object: node
        })) {
          thisPath.replaceWith(_thisRef());
          continue;
        }

        thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var bareSupers = new Set();
    path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
      Super: function Super(path) {
        var node = path.node,
            parentPath = path.parentPath;

        if (parentPath.isCallExpression({
          callee: node
        })) {
          bareSupers.add(parentPath);
        }
      }
    }]));
    var guaranteedSuperBeforeFinish = !!bareSupers.size;
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = bareSupers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var bareSuper = _step4.value;
        wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

        if (guaranteedSuperBeforeFinish) {
          bareSuper.find(function (parentPath) {
            if (parentPath === path) {
              return true;
            }

            if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
              guaranteedSuperBeforeFinish = false;
              return true;
            }
          });
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    var wrapReturn;

    if (classState.isLoose) {
      wrapReturn = function wrapReturn(returnArg) {
        var thisExpr = _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);

        return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
      };
    } else {
      wrapReturn = function wrapReturn(returnArg) {
        return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
      };
    }

    var bodyPaths = body.get("body");

    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
      body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
    }

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = classState.superReturns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var returnPath = _step5.value;
        returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  }

  function pushMethod(node, path) {
    var scope = path ? path.scope : classState.scope;

    if (node.kind === "method") {
      if (processMethod(node, scope)) return;
    }

    pushToMap(node, false, null, scope);
  }

  function processMethod(node, scope) {
    if (classState.isLoose && !node.decorators) {
      var classRef = classState.classRef;

      if (!node.static) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }

      var methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));

      var func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);

      _core.types.inherits(func, node);

      var key = _core.types.toComputedKey(node, node.key);

      if (_core.types.isStringLiteral(key)) {
        func = (0, _helperFunctionName.default)({
          node: func,
          id: key,
          scope: scope
        });
      }

      var expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));

      _core.types.inheritsComments(expr, node);

      classState.body.push(expr);
      return true;
    }

    return false;
  }

  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({
        protoAlias: classState.scope.generateUidIdentifier("proto")
      });

      var classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype"));

      var protoDeclaration = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);

      classState.body.push(protoDeclaration);
    }
  }

  function pushConstructor(superReturns, method, path) {
    if (path.scope.hasOwnBinding(classState.classRef.name)) {
      path.scope.rename(classState.classRef.name);
    }

    setState({
      userConstructorPath: path,
      userConstructor: method,
      hasConstructor: true,
      superReturns: superReturns
    });
    var construct = classState.construct;

    _core.types.inheritsComments(construct, method);

    construct.params = method.params;

    _core.types.inherits(construct.body, method.body);

    construct.body.directives = method.body.directives;
    pushConstructorToBody();
  }

  function pushConstructorToBody() {
    if (classState.pushedConstructor) return;
    classState.pushedConstructor = true;

    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
      pushDescriptors();
    }

    classState.body.push(classState.construct);
    pushInheritsToBody();
  }

  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    setState({
      pushedInherits: true
    });
    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));
  }

  function setupClosureParamsArgs() {
    var superName = classState.superName;
    var closureParams = [];
    var closureArgs = [];

    if (classState.isDerived) {
      var arg = classState.extendsNative ? _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [_core.types.cloneNode(superName)]) : _core.types.cloneNode(superName);
      var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
      closureParams.push(param);
      closureArgs.push(arg);
      setState({
        superName: _core.types.cloneNode(param)
      });
    }

    return {
      closureParams: closureParams,
      closureArgs: closureArgs
    };
  }

  function classTransformer(path, file, builtinClasses, isLoose) {
    setState({
      parent: path.parent,
      scope: path.scope,
      node: path.node,
      path: path,
      file: file,
      isLoose: isLoose
    });
    setState({
      classId: classState.node.id,
      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: _core.types.blockStatement([])
    });
    setState({
      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
    });
    var classRef = classState.classRef,
        node = classState.node,
        constructorBody = classState.constructorBody;
    setState({
      construct: buildConstructor(classRef, constructorBody, node)
    });
    var body = classState.body;

    var _setupClosureParamsAr = setupClosureParamsArgs(),
        closureParams = _setupClosureParamsAr.closureParams,
        closureArgs = _setupClosureParamsAr.closureArgs;

    buildBody();

    if (!classState.isLoose) {
      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));
    }

    body = body.concat(classState.staticPropBody.map(function (fn) {
      return fn(_core.types.cloneNode(classState.classRef));
    }));
    var isStrict = path.isInStrictMode();
    var constructorOnly = classState.classId && body.length === 1;

    if (constructorOnly && !isStrict) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = classState.construct.params[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var param = _step6.value;

          if (!_core.types.isIdentifier(param)) {
            constructorOnly = false;
            break;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }

    var directives = constructorOnly ? body[0].body.directives : [];

    if (!isStrict) {
      directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
    }

    if (constructorOnly) {
      return _core.types.toExpression(body[0]);
    }

    body.push(_core.types.returnStatement(_core.types.cloneNode(classState.classRef)));

    var container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));

    return _core.types.callExpression(container, closureArgs);
  }

  return classTransformer(path, file, builtinClasses, isLoose);
}

},{"@babel/core":19,"@babel/helper-define-map":64,"@babel/helper-function-name":66,"@babel/helper-optimise-call-expression":78,"@babel/helper-replace-supers":82}],111:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;
  var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
  var buildMutatorMapAssign = (0, _core().template)("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

  function getValue(prop) {
    if (_core().types.isObjectProperty(prop)) {
      return prop.value;
    } else if (_core().types.isObjectMethod(prop)) {
      return _core().types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
    }
  }

  function pushAssign(objId, prop, body) {
    if (prop.kind === "get" && prop.kind === "set") {
      pushMutatorDefine(objId, prop, body);
    } else {
      body.push(_core().types.expressionStatement(_core().types.assignmentExpression("=", _core().types.memberExpression(_core().types.cloneNode(objId), prop.key, prop.computed || _core().types.isLiteral(prop.key)), getValue(prop))));
    }
  }

  function pushMutatorDefine(_ref, prop) {
    var body = _ref.body,
        getMutatorId = _ref.getMutatorId,
        scope = _ref.scope;
    var key = !prop.computed && _core().types.isIdentifier(prop.key) ? _core().types.stringLiteral(prop.key.name) : prop.key;
    var maybeMemoise = scope.maybeGenerateMemoised(key);

    if (maybeMemoise) {
      body.push(_core().types.expressionStatement(_core().types.assignmentExpression("=", maybeMemoise, key)));
      key = maybeMemoise;
    }

    body.push.apply(body, _toConsumableArray(buildMutatorMapAssign({
      MUTATOR_MAP_REF: getMutatorId(),
      KEY: _core().types.cloneNode(key),
      VALUE: getValue(prop),
      KIND: _core().types.identifier(prop.kind)
    })));
  }

  function pushComputedPropsLoose(info) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = info.computedProps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else {
          pushAssign(_core().types.cloneNode(info.objId), prop, info.body);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function pushComputedPropsSpec(info) {
    var objId = info.objId,
        body = info.body,
        computedProps = info.computedProps,
        state = info.state;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = computedProps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;

        var key = _core().types.toComputedKey(prop);

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else if (_core().types.isStringLiteral(key, {
          value: "__proto__"
        })) {
          pushAssign(objId, prop, body);
        } else {
          if (computedProps.length === 1) {
            return _core().types.callExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
          } else {
            body.push(_core().types.expressionStatement(_core().types.callExpression(state.addHelper("defineProperty"), [_core().types.cloneNode(objId), key, getValue(prop)])));
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return {
    name: "transform-computed-properties",
    visitor: {
      ObjectExpression: {
        exit: function exit(path, state) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var hasComputed = false;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = node.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var prop = _step3.value;
              hasComputed = prop.computed === true;
              if (hasComputed) break;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          if (!hasComputed) return;
          var initProps = [];
          var computedProps = [];
          var foundComputed = false;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = node.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _prop = _step4.value;

              if (_prop.computed) {
                foundComputed = true;
              }

              if (foundComputed) {
                computedProps.push(_prop);
              } else {
                initProps.push(_prop);
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          var objId = scope.generateUidIdentifierBasedOnNode(parent);

          var initPropExpression = _core().types.objectExpression(initProps);

          var body = [];
          body.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(objId, initPropExpression)]));
          var mutatorRef;

          var getMutatorId = function getMutatorId() {
            if (!mutatorRef) {
              mutatorRef = scope.generateUidIdentifier("mutatorMap");
              body.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(mutatorRef, _core().types.objectExpression([]))]));
            }

            return _core().types.cloneNode(mutatorRef);
          };

          var single = pushComputedProps({
            scope: scope,
            objId: objId,
            body: body,
            computedProps: computedProps,
            initPropExpression: initPropExpression,
            getMutatorId: getMutatorId,
            state: state
          });

          if (mutatorRef) {
            body.push(_core().types.expressionStatement(_core().types.callExpression(state.addHelper("defineEnumerableProperties"), [_core().types.cloneNode(objId), _core().types.cloneNode(mutatorRef)])));
          }

          if (single) {
            path.replaceWith(single);
          } else {
            body.push(_core().types.expressionStatement(_core().types.cloneNode(objId)));
            path.replaceWithMultiple(body);
          }
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],112:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var _options$loose = options.loose,
      loose = _options$loose === void 0 ? false : _options$loose,
      _options$useBuiltIns = options.useBuiltIns,
      useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

  if (typeof loose !== "boolean") {
    throw new Error(".loose must be a boolean or undefined");
  }

  var arrayOnlySpread = loose;

  function getExtendsHelper(file) {
    return useBuiltIns ? _core().types.memberExpression(_core().types.identifier("Object"), _core().types.identifier("assign")) : file.addHelper("extends");
  }

  function variableDeclarationHasPattern(node) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var declar = _step.value;

        if (_core().types.isPattern(declar.id)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  }

  function hasRest(pattern) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = pattern.elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var elem = _step2.value;

        if (_core().types.isRestElement(elem)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return false;
  }

  function hasObjectRest(pattern) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = pattern.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var elem = _step3.value;

        if (_core().types.isRestElement(elem)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return false;
  }

  var STOP_TRAVERSAL = {};

  var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
    if (!ancestors.length) {
      return;
    }

    if (_core().types.isIdentifier(node) && _core().types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
      state.deopt = true;
      throw STOP_TRAVERSAL;
    }
  };

  var DestructuringTransformer =
  /*#__PURE__*/
  function () {
    function DestructuringTransformer(opts) {
      _classCallCheck(this, DestructuringTransformer);

      this.blockHoist = opts.blockHoist;
      this.operator = opts.operator;
      this.arrays = {};
      this.nodes = opts.nodes || [];
      this.scope = opts.scope;
      this.kind = opts.kind;
      this.arrayOnlySpread = opts.arrayOnlySpread;
      this.addHelper = opts.addHelper;
    }

    _createClass(DestructuringTransformer, [{
      key: "buildVariableAssignment",
      value: function buildVariableAssignment(id, init) {
        var op = this.operator;
        if (_core().types.isMemberExpression(id)) op = "=";
        var node;

        if (op) {
          node = _core().types.expressionStatement(_core().types.assignmentExpression(op, id, _core().types.cloneNode(init) || this.scope.buildUndefinedNode()));
        } else {
          node = _core().types.variableDeclaration(this.kind, [_core().types.variableDeclarator(id, _core().types.cloneNode(init))]);
        }

        node._blockHoist = this.blockHoist;
        return node;
      }
    }, {
      key: "buildVariableDeclaration",
      value: function buildVariableDeclaration(id, init) {
        var declar = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(_core().types.cloneNode(id), _core().types.cloneNode(init))]);

        declar._blockHoist = this.blockHoist;
        return declar;
      }
    }, {
      key: "push",
      value: function push(id, _init) {
        var init = _core().types.cloneNode(_init);

        if (_core().types.isObjectPattern(id)) {
          this.pushObjectPattern(id, init);
        } else if (_core().types.isArrayPattern(id)) {
          this.pushArrayPattern(id, init);
        } else if (_core().types.isAssignmentPattern(id)) {
          this.pushAssignmentPattern(id, init);
        } else {
          this.nodes.push(this.buildVariableAssignment(id, init));
        }
      }
    }, {
      key: "toArray",
      value: function toArray(node, count) {
        if (this.arrayOnlySpread || _core().types.isIdentifier(node) && this.arrays[node.name]) {
          return node;
        } else {
          return this.scope.toArray(node, count);
        }
      }
    }, {
      key: "pushAssignmentPattern",
      value: function pushAssignmentPattern(_ref, valueRef) {
        var left = _ref.left,
            right = _ref.right;
        var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));

        var tempConditional = _core().types.conditionalExpression(_core().types.binaryExpression("===", _core().types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core().types.cloneNode(tempId));

        if (_core().types.isPattern(left)) {
          var patternId;
          var node;

          if (this.kind === "const") {
            patternId = this.scope.generateUidIdentifier(tempId.name);
            node = this.buildVariableDeclaration(patternId, tempConditional);
          } else {
            patternId = tempId;
            node = _core().types.expressionStatement(_core().types.assignmentExpression("=", _core().types.cloneNode(tempId), tempConditional));
          }

          this.nodes.push(node);
          this.push(left, patternId);
        } else {
          this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
      }
    }, {
      key: "pushObjectRest",
      value: function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        var keys = [];
        var allLiteral = true;

        for (var i = 0; i < pattern.properties.length; i++) {
          var prop = pattern.properties[i];
          if (i >= spreadPropIndex) break;
          if (_core().types.isRestElement(prop)) continue;
          var key = prop.key;

          if (_core().types.isIdentifier(key) && !prop.computed) {
            keys.push(_core().types.stringLiteral(key.name));
          } else if (_core().types.isTemplateLiteral(prop.key)) {
            keys.push(_core().types.cloneNode(prop.key));
          } else if (_core().types.isLiteral(key)) {
            keys.push(_core().types.stringLiteral(String(key.value)));
          } else {
            keys.push(_core().types.cloneNode(key));
            allLiteral = false;
          }
        }

        var value;

        if (keys.length === 0) {
          value = _core().types.callExpression(getExtendsHelper(this), [_core().types.objectExpression([]), _core().types.cloneNode(objRef)]);
        } else {
          var keyExpression = _core().types.arrayExpression(keys);

          if (!allLiteral) {
            keyExpression = _core().types.callExpression(_core().types.memberExpression(keyExpression, _core().types.identifier("map")), [this.addHelper("toPropertyKey")]);
          }

          value = _core().types.callExpression(this.addHelper("objectWithoutProperties".concat(loose ? "Loose" : "")), [_core().types.cloneNode(objRef), keyExpression]);
        }

        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
      }
    }, {
      key: "pushObjectProperty",
      value: function pushObjectProperty(prop, propRef) {
        if (_core().types.isLiteral(prop.key)) prop.computed = true;
        var pattern = prop.value;

        var objRef = _core().types.memberExpression(_core().types.cloneNode(propRef), prop.key, prop.computed);

        if (_core().types.isPattern(pattern)) {
          this.push(pattern, objRef);
        } else {
          this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
      }
    }, {
      key: "pushObjectPattern",
      value: function pushObjectPattern(pattern, objRef) {
        if (!pattern.properties.length) {
          this.nodes.push(_core().types.expressionStatement(_core().types.callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
        }

        if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
          var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
          this.nodes.push(this.buildVariableDeclaration(temp, objRef));
          objRef = temp;
        }

        if (hasObjectRest(pattern)) {
          var copiedPattern;

          for (var i = 0; i < pattern.properties.length; i++) {
            var prop = pattern.properties[i];

            if (_core().types.isRestElement(prop)) {
              break;
            }

            var key = prop.key;

            if (prop.computed && !this.scope.isPure(key)) {
              var name = this.scope.generateUidIdentifierBasedOnNode(key);
              this.nodes.push(this.buildVariableDeclaration(name, key));

              if (!copiedPattern) {
                copiedPattern = pattern = Object.assign({}, pattern, {
                  properties: pattern.properties.slice()
                });
              }

              copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                key: name
              });
            }
          }
        }

        for (var _i = 0; _i < pattern.properties.length; _i++) {
          var _prop = pattern.properties[_i];

          if (_core().types.isRestElement(_prop)) {
            this.pushObjectRest(pattern, objRef, _prop, _i);
          } else {
            this.pushObjectProperty(_prop, objRef);
          }
        }
      }
    }, {
      key: "canUnpackArrayPattern",
      value: function canUnpackArrayPattern(pattern, arr) {
        if (!_core().types.isArrayExpression(arr)) return false;
        if (pattern.elements.length > arr.elements.length) return;

        if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
          return false;
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = pattern.elements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var elem = _step4.value;
            if (!elem) return false;
            if (_core().types.isMemberExpression(elem)) return false;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = arr.elements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _elem = _step5.value;
            if (_core().types.isSpreadElement(_elem)) return false;
            if (_core().types.isCallExpression(_elem)) return false;
            if (_core().types.isMemberExpression(_elem)) return false;
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        var bindings = _core().types.getBindingIdentifiers(pattern);

        var state = {
          deopt: false,
          bindings: bindings
        };

        try {
          _core().types.traverse(arr, arrayUnpackVisitor, state);
        } catch (e) {
          if (e !== STOP_TRAVERSAL) throw e;
        }

        return !state.deopt;
      }
    }, {
      key: "pushUnpackedArrayPattern",
      value: function pushUnpackedArrayPattern(pattern, arr) {
        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];

          if (_core().types.isRestElement(elem)) {
            this.push(elem.argument, _core().types.arrayExpression(arr.elements.slice(i)));
          } else {
            this.push(elem, arr.elements[i]);
          }
        }
      }
    }, {
      key: "pushArrayPattern",
      value: function pushArrayPattern(pattern, arrayRef) {
        if (!pattern.elements) return;

        if (this.canUnpackArrayPattern(pattern, arrayRef)) {
          return this.pushUnpackedArrayPattern(pattern, arrayRef);
        }

        var count = !hasRest(pattern) && pattern.elements.length;
        var toArray = this.toArray(arrayRef, count);

        if (_core().types.isIdentifier(toArray)) {
          arrayRef = toArray;
        } else {
          arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
          this.arrays[arrayRef.name] = true;
          this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
        }

        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];
          if (!elem) continue;
          var elemRef = void 0;

          if (_core().types.isRestElement(elem)) {
            elemRef = this.toArray(arrayRef);
            elemRef = _core().types.callExpression(_core().types.memberExpression(elemRef, _core().types.identifier("slice")), [_core().types.numericLiteral(i)]);
            elem = elem.argument;
          } else {
            elemRef = _core().types.memberExpression(arrayRef, _core().types.numericLiteral(i), true);
          }

          this.push(elem, elemRef);
        }
      }
    }, {
      key: "init",
      value: function init(pattern, ref) {
        if (!_core().types.isArrayExpression(ref) && !_core().types.isMemberExpression(ref)) {
          var memo = this.scope.maybeGenerateMemoised(ref, true);

          if (memo) {
            this.nodes.push(this.buildVariableDeclaration(memo, _core().types.cloneNode(ref)));
            ref = memo;
          }
        }

        this.push(pattern, ref);
        return this.nodes;
      }
    }]);

    return DestructuringTransformer;
  }();

  return {
    name: "transform-destructuring",
    visitor: {
      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
        var declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasPattern(declaration.node)) return;
        var specifiers = [];

        for (var _i2 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i2 < _Object$keys.length; _i2++) {
          var name = _Object$keys[_i2];
          specifiers.push(_core().types.exportSpecifier(_core().types.identifier(name), _core().types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core().types.exportNamedDeclaration(null, specifiers));
      },
      ForXStatement: function ForXStatement(path) {
        var _this = this;

        var node = path.node,
            scope = path.scope;
        var left = node.left;

        if (_core().types.isPattern(left)) {
          var temp = scope.generateUidIdentifier("ref");
          node.left = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(temp)]);
          path.ensureBlock();

          if (node.body.body.length === 0 && path.isCompletionRecord()) {
            node.body.body.unshift(_core().types.expressionStatement(scope.buildUndefinedNode()));
          }

          node.body.body.unshift(_core().types.expressionStatement(_core().types.assignmentExpression("=", left, temp)));
          return;
        }

        if (!_core().types.isVariableDeclaration(left)) return;
        var pattern = left.declarations[0].id;
        if (!_core().types.isPattern(pattern)) return;
        var key = scope.generateUidIdentifier("ref");
        node.left = _core().types.variableDeclaration(left.kind, [_core().types.variableDeclarator(key, null)]);
        var nodes = [];
        var destructuring = new DestructuringTransformer({
          kind: left.kind,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread: arrayOnlySpread,
          addHelper: function addHelper(name) {
            return _this.addHelper(name);
          }
        });
        destructuring.init(pattern, key);
        path.ensureBlock();
        var block = node.body;
        block.body = nodes.concat(block.body);
      },
      CatchClause: function CatchClause(_ref2) {
        var _this2 = this;

        var node = _ref2.node,
            scope = _ref2.scope;
        var pattern = node.param;
        if (!_core().types.isPattern(pattern)) return;
        var ref = scope.generateUidIdentifier("ref");
        node.param = ref;
        var nodes = [];
        var destructuring = new DestructuringTransformer({
          kind: "let",
          scope: scope,
          nodes: nodes,
          arrayOnlySpread: arrayOnlySpread,
          addHelper: function addHelper(name) {
            return _this2.addHelper(name);
          }
        });
        destructuring.init(pattern, ref);
        node.body.body = nodes.concat(node.body.body);
      },
      AssignmentExpression: function AssignmentExpression(path) {
        var _this3 = this;

        var node = path.node,
            scope = path.scope;
        if (!_core().types.isPattern(node.left)) return;
        var nodes = [];
        var destructuring = new DestructuringTransformer({
          operator: node.operator,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread: arrayOnlySpread,
          addHelper: function addHelper(name) {
            return _this3.addHelper(name);
          }
        });
        var ref;

        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
          ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
          nodes.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(ref, node.right)]));

          if (_core().types.isArrayExpression(node.right)) {
            destructuring.arrays[ref.name] = true;
          }
        }

        destructuring.init(node.left, ref || node.right);

        if (ref) {
          if (path.parentPath.isArrowFunctionExpression()) {
            path.replaceWith(_core().types.blockStatement([]));
            nodes.push(_core().types.returnStatement(_core().types.cloneNode(ref)));
          } else {
            nodes.push(_core().types.expressionStatement(_core().types.cloneNode(ref)));
          }
        }

        path.replaceWithMultiple(nodes);
      },
      VariableDeclaration: function VariableDeclaration(path) {
        var _this4 = this;

        var node = path.node,
            scope = path.scope,
            parent = path.parent;
        if (_core().types.isForXStatement(parent)) return;
        if (!parent || !path.container) return;
        if (!variableDeclarationHasPattern(node)) return;
        var nodeKind = node.kind;
        var nodes = [];
        var declar;

        for (var i = 0; i < node.declarations.length; i++) {
          declar = node.declarations[i];
          var patternId = declar.init;
          var pattern = declar.id;
          var destructuring = new DestructuringTransformer({
            blockHoist: node._blockHoist,
            nodes: nodes,
            scope: scope,
            kind: node.kind,
            arrayOnlySpread: arrayOnlySpread,
            addHelper: function addHelper(name) {
              return _this4.addHelper(name);
            }
          });

          if (_core().types.isPattern(pattern)) {
            destructuring.init(pattern, patternId);

            if (+i !== node.declarations.length - 1) {
              _core().types.inherits(nodes[nodes.length - 1], declar);
            }
          } else {
            nodes.push(_core().types.inherits(destructuring.buildVariableAssignment(declar.id, _core().types.cloneNode(declar.init)), declar));
          }
        }

        var tail = null;
        var nodesOut = [];

        for (var _i3 = 0, _nodes = nodes; _i3 < _nodes.length; _i3++) {
          var _node = _nodes[_i3];

          if (tail !== null && _core().types.isVariableDeclaration(_node)) {
            var _tail$declarations;

            (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _toConsumableArray(_node.declarations));
          } else {
            _node.kind = nodeKind;
            nodesOut.push(_node);
            tail = _core().types.isVariableDeclaration(_node) ? _node : null;
          }
        }

        for (var _i4 = 0, _nodesOut = nodesOut; _i4 < _nodesOut.length; _i4++) {
          var nodeOut = _nodesOut[_i4];
          if (!nodeOut.declarations) continue;
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = nodeOut.declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var declaration = _step6.value;
              var name = declaration.id.name;

              if (scope.bindings[name]) {
                scope.bindings[name].kind = nodeOut.kind;
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }

        if (nodesOut.length === 1) {
          path.replaceWith(nodesOut[0]);
        } else {
          path.replaceWithMultiple(nodesOut);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-dotall-regex",
    feature: "dotAllFlag"
  });
});

exports.default = _default;

},{"@babel/helper-create-regexp-features-plugin":61,"@babel/helper-plugin-utils":79}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function getName(key) {
  if (_core().types.isIdentifier(key)) {
    return key.name;
  }

  return key.value.toString();
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-duplicate-keys",
    visitor: {
      ObjectExpression: function ObjectExpression(path) {
        var node = path.node;
        var plainProps = node.properties.filter(function (prop) {
          return !_core().types.isSpreadElement(prop) && !prop.computed;
        });
        var alreadySeenData = Object.create(null);
        var alreadySeenGetters = Object.create(null);
        var alreadySeenSetters = Object.create(null);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = plainProps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var prop = _step.value;
            var name = getName(prop.key);
            var isDuplicate = false;

            switch (prop.kind) {
              case "get":
                if (alreadySeenData[name] || alreadySeenGetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenGetters[name] = true;
                break;

              case "set":
                if (alreadySeenData[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenSetters[name] = true;
                break;

              default:
                if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenData[name] = true;
            }

            if (isDuplicate) {
              prop.computed = true;
              prop.key = _core().types.stringLiteral(name);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _helperBuilderBinaryAssignmentOperatorVisitor() {
  var data = _interopRequireDefault(require("@babel/helper-builder-binary-assignment-operator-visitor"));

  _helperBuilderBinaryAssignmentOperatorVisitor = function _helperBuilderBinaryAssignmentOperatorVisitor() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-exponentiation-operator",
    visitor: (0, _helperBuilderBinaryAssignmentOperatorVisitor().default)({
      operator: "**",
      build: function build(left, right) {
        return _core().types.callExpression(_core().types.memberExpression(_core().types.identifier("Math"), _core().types.identifier("pow")), [left, right]);
      }
    })
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-builder-binary-assignment-operator-visitor":58,"@babel/helper-plugin-utils":79}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose,
      assumeArray = options.assumeArray;

  if (loose === true && assumeArray === true) {
    throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
  }

  if (assumeArray) {
    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement: function ForOfStatement(path) {
          var scope = path.scope;
          var _path$node = path.node,
              left = _path$node.left,
              right = _path$node.right,
              body = _path$node.body;
          var i = scope.generateUidIdentifier("i");
          var array = scope.maybeGenerateMemoised(right, true);
          var inits = [_core().types.variableDeclarator(i, _core().types.numericLiteral(0))];

          if (array) {
            inits.push(_core().types.variableDeclarator(array, right));
          } else {
            array = right;
          }

          var item = _core().types.memberExpression(_core().types.cloneNode(array), _core().types.cloneNode(i), true);

          var assignment;

          if (_core().types.isVariableDeclaration(left)) {
            assignment = left;
            assignment.declarations[0].init = item;
          } else {
            assignment = _core().types.expressionStatement(_core().types.assignmentExpression("=", left, item));
          }

          var block = _core().types.toBlock(body);

          block.body.unshift(assignment);
          path.replaceWith(_core().types.forStatement(_core().types.variableDeclaration("let", inits), _core().types.binaryExpression("<", _core().types.cloneNode(i), _core().types.memberExpression(_core().types.cloneNode(array), _core().types.identifier("length"))), _core().types.updateExpression("++", _core().types.cloneNode(i)), block));
        }
      }
    };
  }

  var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
  var buildForOfArray = (0, _core().template)("\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  ");
  var buildForOfLoose = (0, _core().template)("\n    for (var LOOP_OBJECT = OBJECT,\n             IS_ARRAY = Array.isArray(LOOP_OBJECT),\n             INDEX = 0,\n             LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n      INTERMEDIATE;\n      if (IS_ARRAY) {\n        if (INDEX >= LOOP_OBJECT.length) break;\n        ID = LOOP_OBJECT[INDEX++];\n      } else {\n        INDEX = LOOP_OBJECT.next();\n        if (INDEX.done) break;\n        ID = INDEX.value;\n      }\n    }\n  ");
  var buildForOf = (0, _core().template)("\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY = undefined;\n    try {\n      for (\n        var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n        !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n        ITERATOR_COMPLETION = true\n      ) {}\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  ");

  function _ForOfStatementArray(path) {
    var node = path.node,
        scope = path.scope;
    var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
    var iterationKey = scope.generateUidIdentifier("i");
    var loop = buildForOfArray({
      BODY: node.body,
      KEY: iterationKey,
      NAME: right,
      ARR: node.right
    });

    _core().types.inherits(loop, node);

    _core().types.ensureBlock(loop);

    var iterationValue = _core().types.memberExpression(_core().types.cloneNode(right), _core().types.cloneNode(iterationKey), true);

    var left = node.left;

    if (_core().types.isVariableDeclaration(left)) {
      left.declarations[0].init = iterationValue;
      loop.body.body.unshift(left);
    } else {
      loop.body.body.unshift(_core().types.expressionStatement(_core().types.assignmentExpression("=", left, iterationValue)));
    }

    if (path.parentPath.isLabeledStatement()) {
      loop = _core().types.labeledStatement(path.parentPath.node.label, loop);
    }

    return [loop];
  }

  function replaceWithArray(path) {
    if (path.parentPath.isLabeledStatement()) {
      path.parentPath.replaceWithMultiple(_ForOfStatementArray(path));
    } else {
      path.replaceWithMultiple(_ForOfStatementArray(path));
    }
  }

  return {
    name: "transform-for-of",
    visitor: {
      ForOfStatement: function ForOfStatement(path, state) {
        var right = path.get("right");

        if (right.isArrayExpression() || right.isGenericType("Array") || _core().types.isArrayTypeAnnotation(right.getTypeAnnotation())) {
          replaceWithArray(path);
          return;
        }

        var node = path.node;
        var build = pushComputedProps(path, state);
        var declar = build.declar;
        var loop = build.loop;
        var block = loop.body;
        path.ensureBlock();

        if (declar) {
          block.body.push(declar);
        }

        block.body = block.body.concat(node.body.body);

        _core().types.inherits(loop, node);

        _core().types.inherits(loop.body, node.body);

        if (build.replaceParent) {
          path.parentPath.replaceWithMultiple(build.node);
          path.remove();
        } else {
          path.replaceWithMultiple(build.node);
        }
      }
    }
  };

  function pushComputedPropsLoose(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar, id, intermediate;

    if (_core().types.isIdentifier(left) || _core().types.isPattern(left) || _core().types.isMemberExpression(left)) {
      id = left;
      intermediate = null;
    } else if (_core().types.isVariableDeclaration(left)) {
      id = scope.generateUidIdentifier("ref");
      declar = _core().types.variableDeclaration(left.kind, [_core().types.variableDeclarator(left.declarations[0].id, _core().types.identifier(id.name))]);
      intermediate = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(_core().types.identifier(id.name))]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type ".concat(left.type, " in ForStatement"));
    }

    var iteratorKey = scope.generateUidIdentifier("iterator");
    var isArrayKey = scope.generateUidIdentifier("isArray");
    var loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate
    });

    var isLabeledParent = _core().types.isLabeledStatement(parent);

    var labeled;

    if (isLabeledParent) {
      labeled = _core().types.labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop
    };
  }

  function pushComputedPropsSpec(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar;
    var stepKey = scope.generateUid("step");

    var stepValue = _core().types.memberExpression(_core().types.identifier(stepKey), _core().types.identifier("value"));

    if (_core().types.isIdentifier(left) || _core().types.isPattern(left) || _core().types.isMemberExpression(left)) {
      declar = _core().types.expressionStatement(_core().types.assignmentExpression("=", left, stepValue));
    } else if (_core().types.isVariableDeclaration(left)) {
      declar = _core().types.variableDeclaration(left.kind, [_core().types.variableDeclarator(left.declarations[0].id, stepValue)]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type ".concat(left.type, " in ForStatement"));
    }

    var template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: _core().types.identifier(stepKey),
      OBJECT: node.right
    });

    var isLabeledParent = _core().types.isLabeledStatement(parent);

    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = _core().types.labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template
    };
  }
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-function-name",
    visitor: {
      FunctionExpression: {
        exit: function exit(path) {
          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
            var replacement = (0, _helperFunctionName.default)(path);
            if (replacement) path.replaceWith(replacement);
          }
        }
      },
      ObjectProperty: function ObjectProperty(path) {
        var value = path.get("value");

        if (value.isFunction()) {
          var newNode = (0, _helperFunctionName.default)(value);
          if (newNode) value.replaceWith(newNode);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/helper-function-name":66,"@babel/helper-plugin-utils":79}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-literals",
    visitor: {
      NumericLiteral: function NumericLiteral(_ref) {
        var node = _ref.node;

        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
          node.extra = undefined;
        }
      },
      StringLiteral: function StringLiteral(_ref2) {
        var node = _ref2.node;

        if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
          node.extra = undefined;
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/helper-plugin-utils":79}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-member-expression-literals",
    visitor: {
      MemberExpression: {
        exit: function exit(_ref) {
          var node = _ref.node;
          var prop = node.property;

          if (!node.computed && _core().types.isIdentifier(prop) && !_core().types.isValidES3Identifier(prop.name)) {
            node.property = _core().types.stringLiteral(prop.name);
            node.computed = true;
          }
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],120:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _helperModuleTransforms() {
  var data = require("@babel/helper-module-transforms");

  _helperModuleTransforms = function _helperModuleTransforms() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _utils() {
  var data = require("babel-plugin-dynamic-import-node/utils");

  _utils = function _utils() {
    return data;
  };

  return data;
}

var buildWrapper = (0, _core().template)("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
var buildAnonymousWrapper = (0, _core().template)("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

function injectWrapper(path, wrapper) {
  var _path$node = path.node,
      body = _path$node.body,
      directives = _path$node.directives;
  path.node.directives = [];
  path.node.body = [];
  var amdWrapper = path.pushContainer("body", wrapper)[0];
  var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
    return arg.isFunctionExpression();
  })[0].get("body");
  amdFactory.pushContainer("directives", directives);
  amdFactory.pushContainer("body", body);
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose,
      allowTopLevelThis = options.allowTopLevelThis,
      strict = options.strict,
      strictMode = options.strictMode,
      noInterop = options.noInterop;
  return {
    name: "transform-modules-amd",
    pre: function pre() {
      this.file.set("@babel/plugin-transform-modules-*", "amd");
    },
    visitor: {
      CallExpression: function CallExpression(path, state) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (!path.get("callee").isImport()) return;
        var requireId = state.requireId,
            resolveId = state.resolveId,
            rejectId = state.rejectId;

        if (!requireId) {
          requireId = path.scope.generateUidIdentifier("require");
          state.requireId = requireId;
        }

        if (!resolveId || !rejectId) {
          resolveId = path.scope.generateUidIdentifier("resolve");
          rejectId = path.scope.generateUidIdentifier("reject");
          state.resolveId = resolveId;
          state.rejectId = rejectId;
        }

        var result = _core().types.identifier("imported");

        if (!noInterop) result = (0, _helperModuleTransforms().wrapInterop)(path, result, "namespace");
        path.replaceWith(_core().template.expression.ast(_templateObject(), resolveId, rejectId, requireId, (0, _utils().getImportSource)(_core().types, path.node), resolveId, result, rejectId));
      },
      Program: {
        exit: function exit(path, _ref) {
          var requireId = _ref.requireId;

          if (!(0, _helperModuleTransforms().isModule)(path)) {
            if (requireId) {
              injectWrapper(path, buildAnonymousWrapper({
                REQUIRE: requireId
              }));
            }

            return;
          }

          var amdArgs = [];
          var importNames = [];

          if (requireId) {
            amdArgs.push(_core().types.stringLiteral("require"));
            importNames.push(requireId);
          }

          var moduleName = this.getModuleName();
          if (moduleName) moduleName = _core().types.stringLiteral(moduleName);

          var _ref2 = (0, _helperModuleTransforms().rewriteModuleStatementsAndPrepareHeader)(path, {
            loose: loose,
            strict: strict,
            strictMode: strictMode,
            allowTopLevelThis: allowTopLevelThis,
            noInterop: noInterop
          }),
              meta = _ref2.meta,
              headers = _ref2.headers;

          if ((0, _helperModuleTransforms().hasExports)(meta)) {
            amdArgs.push(_core().types.stringLiteral("exports"));
            importNames.push(_core().types.identifier(meta.exportName));
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = meta.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              amdArgs.push(_core().types.stringLiteral(source));
              importNames.push(_core().types.identifier(metadata.name));

              if (!(0, _helperModuleTransforms().isSideEffectImport)(metadata)) {
                var interop = (0, _helperModuleTransforms().wrapInterop)(path, _core().types.identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = _core().types.expressionStatement(_core().types.assignmentExpression("=", _core().types.identifier(metadata.name), interop));

                  header.loc = metadata.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, _toConsumableArray((0, _helperModuleTransforms().buildNamespaceInitStatements)(meta, metadata, loose)));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          (0, _helperModuleTransforms().ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
          injectWrapper(path, buildWrapper({
            MODULE_NAME: moduleName,
            AMD_ARGUMENTS: _core().types.arrayExpression(amdArgs),
            IMPORT_NAMES: importNames
          }));
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-module-transforms":74,"@babel/helper-plugin-utils":79,"babel-plugin-dynamic-import-node/utils":283}],121:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n                  var ", " = ", ";\n                "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperModuleTransforms = require("@babel/helper-module-transforms");

var _helperSimpleAccess = _interopRequireDefault(require("@babel/helper-simple-access"));

var _core = require("@babel/core");

var _utils = require("babel-plugin-dynamic-import-node/utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var transformImportCall = (0, _utils.createDynamicImportTransform)(api);
  var loose = options.loose,
      _options$strictNamesp = options.strictNamespace,
      strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
      _options$mjsStrictNam = options.mjsStrictNamespace,
      mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
      allowTopLevelThis = options.allowTopLevelThis,
      strict = options.strict,
      strictMode = options.strictMode,
      noInterop = options.noInterop,
      _options$lazy = options.lazy,
      lazy = _options$lazy === void 0 ? false : _options$lazy,
      _options$allowCommonJ = options.allowCommonJSExports,
      allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;

  if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
    return typeof item === "string";
  }))) {
    throw new Error(".lazy must be a boolean, array of strings, or a function");
  }

  if (typeof strictNamespace !== "boolean") {
    throw new Error(".strictNamespace must be a boolean, or undefined");
  }

  if (typeof mjsStrictNamespace !== "boolean") {
    throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
  }

  var getAssertion = function getAssertion(localName) {
    return _core.template.expression.ast(_templateObject(), localName);
  };

  var moduleExportsVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      var localName = path.node.name;
      if (localName !== "module" && localName !== "exports") return;
      var localBinding = path.scope.getBinding(localName);
      var rootBinding = this.scope.getBinding(localName);

      if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
        value: path.node
      }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
        left: path.node
      }) || path.isAssignmentExpression({
        left: path.node
      })) {
        return;
      }

      path.replaceWith(getAssertion(localName));
    },
    AssignmentExpression: function AssignmentExpression(path) {
      var _this = this;

      var left = path.get("left");

      if (left.isIdentifier()) {
        var localName = path.node.name;
        if (localName !== "module" && localName !== "exports") return;
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = this.scope.getBinding(localName);
        if (rootBinding !== localBinding) return;
        var right = path.get("right");
        right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
      } else if (left.isPattern()) {
        var ids = left.getOuterBindingIdentifiers();
        var _localName = Object.keys(ids).filter(function (localName) {
          if (localName !== "module" && localName !== "exports") return false;
          return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
        })[0];

        if (_localName) {
          var _right = path.get("right");

          _right.replaceWith(_core.types.sequenceExpression([_right.node, getAssertion(_localName)]));
        }
      }
    }
  };
  return {
    name: "transform-modules-commonjs",
    pre: function pre() {
      this.file.set("@babel/plugin-transform-modules-*", "commonjs");
    },
    visitor: {
      CallExpression: function CallExpression(path) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (!path.get("callee").isImport()) return;
        var scope = path.scope;

        do {
          scope.rename("require");
        } while (scope = scope.parent);

        transformImportCall(this, path.get("callee"));
      },
      Program: {
        exit: function exit(path, state) {
          if (!(0, _helperModuleTransforms.isModule)(path)) return;
          path.scope.rename("exports");
          path.scope.rename("module");
          path.scope.rename("require");
          path.scope.rename("__filename");
          path.scope.rename("__dirname");

          if (!allowCommonJSExports) {
            (0, _helperSimpleAccess.default)(path, new Set(["module", "exports"]));
            path.traverse(moduleExportsVisitor, {
              scope: path.scope
            });
          }

          var moduleName = this.getModuleName();
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);

          var _ref = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
            exportName: "exports",
            loose: loose,
            strict: strict,
            strictMode: strictMode,
            allowTopLevelThis: allowTopLevelThis,
            noInterop: noInterop,
            lazy: lazy,
            esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
          }),
              meta = _ref.meta,
              headers = _ref.headers;

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = meta.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              var loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);

              var header = void 0;

              if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                if (metadata.lazy) throw new Error("Assertion failure");
                header = _core.types.expressionStatement(loadExpr);
              } else {
                var init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;

                if (metadata.lazy) {
                  header = _core.template.ast(_templateObject2(), metadata.name, init, metadata.name);
                } else {
                  header = _core.template.ast(_templateObject3(), metadata.name, init);
                }
              }

              header.loc = metadata.loc;
              headers.push(header);
              headers.push.apply(headers, _toConsumableArray((0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose)));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-module-transforms":74,"@babel/helper-plugin-utils":79,"@babel/helper-simple-access":83,"babel-plugin-dynamic-import-node/utils":283}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperHoistVariables = _interopRequireDefault(require("@babel/helper-hoist-variables"));

var _core = require("@babel/core");

var _utils = require("babel-plugin-dynamic-import-node/utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var buildTemplate = (0, _core.template)("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n");
var buildExportAll = (0, _core.template)("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";

function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
  var statements = [];

  if (exportNames.length === 1) {
    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
  } else if (!exportStarTarget) {
    var objectProperties = [];

    for (var i = 0; i < exportNames.length; i++) {
      var exportName = exportNames[i];
      var exportValue = exportValues[i];
      objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
  } else {
    var exportObj = path.scope.generateUid("exportObj");
    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: _core.types.identifier(exportObj),
      TARGET: exportStarTarget
    }));

    for (var _i = 0; _i < exportNames.length; _i++) {
      var _exportName = exportNames[_i];
      var _exportValue = exportValues[_i];
      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(_exportName)), _exportValue)));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
  }

  return statements;
}

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var _options$systemGlobal = options.systemGlobal,
      systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal;
  var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
  var reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
      var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        var exprs = [path.node];

        for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
          var _name = _Object$keys[_i2];

          if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
            return;
          }

          var _exportedNames = this.exports[_name];
          if (!_exportedNames) return;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _exportedNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var exportedName = _step.value;
              exprs.push(this.buildCall(exportedName, _core.types.identifier(_name)).expression);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        path.replaceWith(_core.types.sequenceExpression(exprs));
        return;
      }

      if (!arg.isIdentifier()) return;
      var name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      var exportedNames = this.exports[name];
      if (!exportedNames) return;
      var node = path.node;
      var isPostUpdateExpression = path.isUpdateExpression({
        prefix: false
      });

      if (isPostUpdateExpression) {
        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = exportedNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _exportedName = _step2.value;
          node = this.buildCall(_exportedName, node).expression;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (isPostUpdateExpression) {
        node = _core.types.sequenceExpression([node, path.node]);
      }

      path.replaceWith(node);
    }
  };
  return {
    name: "transform-modules-systemjs",
    pre: function pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },
    visitor: {
      CallExpression: function CallExpression(path, state) {
        if (_core.types.isImport(path.node.callee)) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            console.warn(MISSING_PLUGIN_WARNING);
          }

          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [(0, _utils.getImportSource)(_core.types, path.node)]));
        }
      },
      MetaProperty: function MetaProperty(path, state) {
        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
        }
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
        }
      },
      Program: {
        enter: function enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
        },
        exit: function exit(path, state) {
          var undefinedIdent = path.scope.buildUndefinedNode();
          var exportIdent = path.scope.generateUid("export");
          var contextIdent = state.contextIdent;
          var exportMap = Object.create(null);
          var modules = [];
          var beforeBody = [];
          var setters = [];
          var sources = [];
          var variableIds = [];
          var removedPaths = [];

          function addExportName(key, val) {
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
          }

          function pushModule(source, key, specifiers) {
            var module;
            modules.forEach(function (m) {
              if (m.key === source) {
                module = m;
              }
            });

            if (!module) {
              modules.push(module = {
                key: source,
                imports: [],
                exports: []
              });
            }

            module[key] = module[key].concat(specifiers);
          }

          function buildExportCall(name, val) {
            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
          }

          var exportNames = [];
          var exportValues = [];
          var body = path.get("body");
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _path = _step3.value;

              if (_path.isFunctionDeclaration()) {
                beforeBody.push(_path.node);
                removedPaths.push(_path);
              } else if (_path.isClassDeclaration()) {
                variableIds.push(_path.node.id);

                _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(_path.node.id), _core.types.toExpression(_path.node))));
              } else if (_path.isImportDeclaration()) {
                var source = _path.node.source.value;
                pushModule(source, "imports", _path.node.specifiers);

                for (var _i4 = 0, _Object$keys2 = Object.keys(_path.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
                  var name = _Object$keys2[_i4];

                  _path.scope.removeBinding(name);

                  variableIds.push(_core.types.identifier(name));
                }

                _path.remove();
              } else if (_path.isExportAllDeclaration()) {
                pushModule(_path.node.source.value, "exports", _path.node);

                _path.remove();
              } else if (_path.isExportDefaultDeclaration()) {
                var declar = _path.get("declaration");

                var id = declar.node.id;

                if (declar.isClassDeclaration()) {
                  if (id) {
                    exportNames.push("default");
                    exportValues.push(undefinedIdent);
                    variableIds.push(id);
                    addExportName(id.name, "default");

                    _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));
                  } else {
                    exportNames.push("default");
                    exportValues.push(_core.types.toExpression(declar.node));
                    removedPaths.push(_path);
                  }
                } else if (declar.isFunctionDeclaration()) {
                  if (id) {
                    beforeBody.push(declar.node);
                    exportNames.push("default");
                    exportValues.push(_core.types.cloneNode(id));
                    addExportName(id.name, "default");
                  } else {
                    exportNames.push("default");
                    exportValues.push(_core.types.toExpression(declar.node));
                  }

                  removedPaths.push(_path);
                } else {
                  _path.replaceWith(buildExportCall("default", declar.node));
                }
              } else if (_path.isExportNamedDeclaration()) {
                var _declar = _path.get("declaration");

                if (_declar.node) {
                  _path.replaceWith(_declar);

                  if (_path.isFunction()) {
                    var node = _declar.node;
                    var _name2 = node.id.name;
                    addExportName(_name2, _name2);
                    beforeBody.push(node);
                    exportNames.push(_name2);
                    exportValues.push(_core.types.cloneNode(node.id));
                    removedPaths.push(_path);
                  } else if (_path.isClass()) {
                    var _name3 = _declar.node.id.name;
                    exportNames.push(_name3);
                    exportValues.push(undefinedIdent);
                    variableIds.push(_declar.node.id);

                    _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(_declar.node.id), _core.types.toExpression(_declar.node))));

                    addExportName(_name3, _name3);
                  } else {
                    for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
                      var _name4 = _Object$keys3[_i5];
                      addExportName(_name4, _name4);
                    }
                  }
                } else {
                  var specifiers = _path.node.specifiers;

                  if (specifiers && specifiers.length) {
                    if (_path.node.source) {
                      pushModule(_path.node.source.value, "exports", specifiers);

                      _path.remove();
                    } else {
                      var nodes = [];
                      var _iteratorNormalCompletion6 = true;
                      var _didIteratorError6 = false;
                      var _iteratorError6 = undefined;

                      try {
                        for (var _iterator6 = specifiers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                          var specifier = _step6.value;

                          var binding = _path.scope.getBinding(specifier.local.name);

                          if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                            exportNames.push(specifier.exported.name);
                            exportValues.push(_core.types.cloneNode(specifier.local));
                          } else if (!binding) {
                            nodes.push(buildExportCall(specifier.exported.name, specifier.local));
                          }

                          addExportName(specifier.local.name, specifier.exported.name);
                        }
                      } catch (err) {
                        _didIteratorError6 = true;
                        _iteratorError6 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                            _iterator6.return();
                          }
                        } finally {
                          if (_didIteratorError6) {
                            throw _iteratorError6;
                          }
                        }
                      }

                      _path.replaceWithMultiple(nodes);
                    }
                  } else {
                    _path.remove();
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          modules.forEach(function (specifiers) {
            var setterBody = [];
            var target = path.scope.generateUid(specifiers.key);
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = specifiers.imports[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var specifier = _step4.value;

                if (_core.types.isImportNamespaceSpecifier(specifier)) {
                  setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
                } else if (_core.types.isImportDefaultSpecifier(specifier)) {
                  specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
                }

                if (_core.types.isImportSpecifier(specifier)) {
                  setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported))));
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (specifiers.exports.length) {
              var _exportNames = [];
              var _exportValues = [];
              var hasExportStar = false;
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = specifiers.exports[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var node = _step5.value;

                  if (_core.types.isExportAllDeclaration(node)) {
                    hasExportStar = true;
                  } else if (_core.types.isExportSpecifier(node)) {
                    _exportNames.push(node.exported.name);

                    _exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local));
                  } else {}
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? _core.types.identifier(target) : null));
            }

            sources.push(_core.types.stringLiteral(specifiers.key));
            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));
          });
          var moduleName = this.getModuleName();
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          (0, _helperHoistVariables.default)(path, function (id, name, hasInit) {
            variableIds.push(id);

            if (!hasInit) {
              exportNames.push(name);
              exportValues.push(undefinedIdent);
            }
          }, null);

          if (variableIds.length) {
            beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map(function (id) {
              return _core.types.variableDeclarator(id);
            })));
          }

          if (exportNames.length) {
            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null));
          }

          path.traverse(reassignmentVisitor, {
            exports: exportMap,
            buildCall: buildExportCall,
            scope: path.scope
          });

          for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
            var _path2 = _removedPaths[_i3];

            _path2.remove();
          }

          path.node.body = [buildTemplate({
            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: _core.types.arrayExpression(setters),
            SOURCES: _core.types.arrayExpression(sources),
            BODY: path.node.body,
            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
          })];
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-hoist-variables":68,"@babel/helper-plugin-utils":79,"babel-plugin-dynamic-import-node/utils":283}],123:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _path = require("path");

var _helperModuleTransforms = require("@babel/helper-module-transforms");

var _core = require("@babel/core");

var buildPrerequisiteAssignment = (0, _core.template)("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
var buildWrapper = (0, _core.template)("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis === \"object\" ? globalThis\n      : typeof self === \"object\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var globals = options.globals,
      exactGlobals = options.exactGlobals,
      loose = options.loose,
      allowTopLevelThis = options.allowTopLevelThis,
      strict = options.strict,
      strictMode = options.strictMode,
      noInterop = options.noInterop;

  function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
    var moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, _path.extname)(filename));

    var globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename)));

    var initAssignments = [];

    if (exactGlobals) {
      var globalName = browserGlobals[moduleNameOrBasename];

      if (globalName) {
        initAssignments = [];
        var members = globalName.split(".");
        globalToAssign = members.slice(1).reduce(function (accum, curr) {
          initAssignments.push(buildPrerequisiteAssignment({
            GLOBAL_REFERENCE: _core.types.cloneNode(accum)
          }));
          return _core.types.memberExpression(accum, _core.types.identifier(curr));
        }, _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
      }
    }

    initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")))));
    return initAssignments;
  }

  function buildBrowserArg(browserGlobals, exactGlobals, source) {
    var memberExpression;

    if (exactGlobals) {
      var globalRef = browserGlobals[source];

      if (globalRef) {
        memberExpression = globalRef.split(".").reduce(function (accum, curr) {
          return _core.types.memberExpression(accum, _core.types.identifier(curr));
        }, _core.types.identifier("global"));
      } else {
        memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
      }
    } else {
      var requireName = (0, _path.basename)(source, (0, _path.extname)(source));
      var globalName = browserGlobals[requireName] || requireName;
      memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
    }

    return memberExpression;
  }

  return {
    name: "transform-modules-umd",
    visitor: {
      Program: {
        exit: function exit(path) {
          if (!(0, _helperModuleTransforms.isModule)(path)) return;
          var browserGlobals = globals || {};
          var moduleName = this.getModuleName();
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);

          var _ref = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
            loose: loose,
            strict: strict,
            strictMode: strictMode,
            allowTopLevelThis: allowTopLevelThis,
            noInterop: noInterop
          }),
              meta = _ref.meta,
              headers = _ref.headers;

          var amdArgs = [];
          var commonjsArgs = [];
          var browserArgs = [];
          var importNames = [];

          if ((0, _helperModuleTransforms.hasExports)(meta)) {
            amdArgs.push(_core.types.stringLiteral("exports"));
            commonjsArgs.push(_core.types.identifier("exports"));
            browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")));
            importNames.push(_core.types.identifier(meta.exportName));
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = meta.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              amdArgs.push(_core.types.stringLiteral(source));
              commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]));
              browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
              importNames.push(_core.types.identifier(metadata.name));

              if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                var interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));

                  header.loc = meta.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, _toConsumableArray((0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose)));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
          var _path$node = path.node,
              body = _path$node.body,
              directives = _path$node.directives;
          path.node.directives = [];
          path.node.body = [];
          var umdWrapper = path.pushContainer("body", [buildWrapper({
            MODULE_NAME: moduleName,
            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
            COMMONJS_ARGUMENTS: commonjsArgs,
            BROWSER_ARGUMENTS: browserArgs,
            IMPORT_NAMES: importNames,
            GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
          })])[0];
          var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
          umdFactory.pushContainer("directives", directives);
          umdFactory.pushContainer("body", body);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-module-transforms":74,"@babel/helper-plugin-utils":79,"path":1052}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");

function _default(core, options) {
  var _options$runtime = options.runtime,
      runtime = _options$runtime === void 0 ? true : _options$runtime;

  if (typeof runtime !== "boolean") {
    throw new Error("The 'runtime' option must be boolean");
  }

  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-named-capturing-groups-regex",
    feature: "namedCaptureGroups",
    options: {
      runtime: runtime
    }
  });
}

},{"@babel/helper-create-regexp-features-plugin":61}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-new-target",
    visitor: {
      MetaProperty: function MetaProperty(path) {
        var meta = path.get("meta");
        var property = path.get("property");
        var scope = path.scope;

        if (meta.isIdentifier({
          name: "new"
        }) && property.isIdentifier({
          name: "target"
        })) {
          var func = path.findParent(function (path) {
            if (path.isClass()) return true;

            if (path.isFunction() && !path.isArrowFunctionExpression()) {
              if (path.isClassMethod({
                kind: "constructor"
              })) {
                return false;
              }

              return true;
            }

            return false;
          });

          if (!func) {
            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
          }

          var node = func.node;

          if (!node.id) {
            if (func.isMethod()) {
              path.replaceWith(scope.buildUndefinedNode());
              return;
            }

            node.id = scope.generateUidIdentifier("target");
          }

          var _constructor = _core().types.memberExpression(_core().types.thisExpression(), _core().types.identifier("constructor"));

          if (func.isClass()) {
            path.replaceWith(_constructor);
            return;
          }

          path.replaceWith(_core().types.conditionalExpression(_core().types.binaryExpression("instanceof", _core().types.thisExpression(), _core().types.cloneNode(node.id)), _constructor, scope.buildUndefinedNode()));
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _helperReplaceSupers() {
  var data = _interopRequireDefault(require("@babel/helper-replace-supers"));

  _helperReplaceSupers = function _helperReplaceSupers() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function replacePropertySuper(path, getObjectRef, file) {
  var replaceSupers = new (_helperReplaceSupers().default)({
    getObjectRef: getObjectRef,
    methodPath: path,
    file: file
  });
  replaceSupers.replace();
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-object-super",
    visitor: {
      ObjectExpression: function ObjectExpression(path, state) {
        var objectRef;

        var getObjectRef = function getObjectRef() {
          return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
        };

        path.get("properties").forEach(function (propPath) {
          if (!propPath.isMethod()) return;
          replacePropertySuper(propPath, getObjectRef, state);
        });

        if (objectRef) {
          path.scope.push({
            id: _core().types.cloneNode(objectRef)
          });
          path.replaceWith(_core().types.assignmentExpression("=", _core().types.cloneNode(objectRef), path.node));
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79,"@babel/helper-replace-supers":82}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

var _params = _interopRequireDefault(require("./params"));

var _rest = _interopRequireDefault(require("./rest"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;
  return {
    name: "transform-parameters",
    visitor: {
      Function: function Function(path) {
        if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
          return param.isRestElement() || param.isAssignmentPattern();
        })) {
          path.arrowFunctionToExpression();
        }

        var convertedRest = (0, _rest.default)(path);
        var convertedParams = (0, _params.default)(path, loose);

        if (convertedRest || convertedParams) {
          path.scope.crawl();
        }
      }
    }
  };
});

exports.default = _default;

},{"./params":128,"./rest":129,"@babel/helper-plugin-utils":79}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convertFunctionParams;

function _helperCallDelegate() {
  var data = _interopRequireDefault(require("@babel/helper-call-delegate"));

  _helperCallDelegate = function _helperCallDelegate() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var buildDefaultParam = (0, _core().template)("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
var buildLooseDefaultParam = (0, _core().template)("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
var buildLooseDestructuredDefaultParam = (0, _core().template)("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
var buildSafeArgumentsAccess = (0, _core().template)("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");

function isSafeBinding(scope, node) {
  if (!scope.hasOwnBinding(node.name)) return true;

  var _scope$getOwnBinding = scope.getOwnBinding(node.name),
      kind = _scope$getOwnBinding.kind;

  return kind === "param" || kind === "local";
}

var iifeVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    var scope = path.scope,
        node = path.node;

    if (node.name === "eval" || !isSafeBinding(scope, node)) {
      state.iife = true;
      path.stop();
    }
  },
  Scope: function Scope(path) {
    path.skip();
  }
};

function convertFunctionParams(path, loose) {
  var node = path.node,
      scope = path.scope;
  var state = {
    iife: false,
    scope: scope
  };
  var body = [];
  var params = path.get("params");
  var firstOptionalIndex = null;

  for (var i = 0; i < params.length; i++) {
    var param = params[i];
    var paramIsAssignmentPattern = param.isAssignmentPattern();

    if (paramIsAssignmentPattern && (loose || node.kind === "set")) {
      var left = param.get("left");
      var right = param.get("right");
      var undefinedNode = scope.buildUndefinedNode();

      if (left.isIdentifier()) {
        body.push(buildLooseDefaultParam({
          ASSIGNMENT_IDENTIFIER: _core().types.cloneNode(left.node),
          DEFAULT_VALUE: right.node,
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(left.node);
      } else if (left.isObjectPattern() || left.isArrayPattern()) {
        var paramName = scope.generateUidIdentifier();
        body.push(buildLooseDestructuredDefaultParam({
          ASSIGNMENT_IDENTIFIER: left.node,
          DEFAULT_VALUE: right.node,
          PARAMETER_NAME: _core().types.cloneNode(paramName),
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(paramName);
      }
    } else if (paramIsAssignmentPattern) {
      if (firstOptionalIndex === null) firstOptionalIndex = i;

      var _left = param.get("left");

      var _right = param.get("right");

      if (!state.iife) {
        if (_right.isIdentifier() && !isSafeBinding(scope, _right.node)) {
          state.iife = true;
        } else {
          _right.traverse(iifeVisitor, state);
        }
      }

      var defNode = buildDefaultParam({
        VARIABLE_NAME: _left.node,
        DEFAULT_VALUE: _right.node,
        ARGUMENT_KEY: _core().types.numericLiteral(i)
      });
      body.push(defNode);
    } else if (firstOptionalIndex !== null) {
      var _defNode = buildSafeArgumentsAccess([param.node, _core().types.numericLiteral(i)]);

      body.push(_defNode);
    } else if (param.isObjectPattern() || param.isArrayPattern()) {
      var uid = path.scope.generateUidIdentifier("ref");

      var _defNode2 = _core().types.variableDeclaration("let", [_core().types.variableDeclarator(param.node, uid)]);

      body.push(_defNode2);
      param.replaceWith(_core().types.cloneNode(uid));
    }

    if (!state.iife && !param.isIdentifier()) {
      param.traverse(iifeVisitor, state);
    }
  }

  if (body.length === 0) return false;

  if (firstOptionalIndex !== null) {
    node.params = node.params.slice(0, firstOptionalIndex);
  }

  path.ensureBlock();

  if (state.iife) {
    body.push((0, _helperCallDelegate().default)(path, scope));
    path.set("body", _core().types.blockStatement(body));
  } else {
    path.get("body").unshiftContainer("body", body);
  }

  return true;
}

},{"@babel/core":19,"@babel/helper-call-delegate":59}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convertFunctionRest;

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var buildRest = (0, _core().template)("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
var restIndex = (0, _core().template)("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
var restIndexImpure = (0, _core().template)("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
var restLength = (0, _core().template)("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

function referencesRest(path, state) {
  if (path.node.name === state.name) {
    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
  }

  return false;
}

var memberExpressionOptimisationVisitor = {
  Scope: function Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
      path.skip();
    }
  },
  Flow: function Flow(path) {
    if (path.isTypeCastExpression()) return;
    path.skip();
  },
  Function: function Function(path, state) {
    var oldNoOptimise = state.noOptimise;
    state.noOptimise = true;
    path.traverse(memberExpressionOptimisationVisitor, state);
    state.noOptimise = oldNoOptimise;
    path.skip();
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    var node = path.node;

    if (node.name === "arguments") {
      state.deopted = true;
    }

    if (!referencesRest(path, state)) return;

    if (state.noOptimise) {
      state.deopted = true;
    } else {
      var parentPath = path.parentPath;

      if (parentPath.listKey === "params" && parentPath.key < state.offset) {
        return;
      }

      if (parentPath.isMemberExpression({
        object: node
      })) {
        var grandparentPath = parentPath.parentPath;
        var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
          operator: "delete"
        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

        if (argsOptEligible) {
          if (parentPath.node.computed) {
            if (parentPath.get("property").isBaseType("number")) {
              state.candidates.push({
                cause: "indexGetter",
                path: path
              });
              return;
            }
          } else if (parentPath.node.property.name === "length") {
            state.candidates.push({
              cause: "lengthGetter",
              path: path
            });
            return;
          }
        }
      }

      if (state.offset === 0 && parentPath.isSpreadElement()) {
        var call = parentPath.parentPath;

        if (call.isCallExpression() && call.node.arguments.length === 1) {
          state.candidates.push({
            cause: "argSpread",
            path: path
          });
          return;
        }
      }

      state.references.push(path);
    }
  },
  BindingIdentifier: function BindingIdentifier(path, state) {
    if (referencesRest(path, state)) {
      state.deopted = true;
    }
  }
};

function hasRest(node) {
  var length = node.params.length;
  return length > 0 && _core().types.isRestElement(node.params[length - 1]);
}

function optimiseIndexGetter(path, argsId, offset) {
  var offsetLiteral = _core().types.numericLiteral(offset);

  var index;

  if (_core().types.isNumericLiteral(path.parent.property)) {
    index = _core().types.numericLiteral(path.parent.property.value + offset);
  } else if (offset === 0) {
    index = path.parent.property;
  } else {
    index = _core().types.binaryExpression("+", path.parent.property, _core().types.cloneNode(offsetLiteral));
  }

  var scope = path.scope;

  if (!scope.isPure(index)) {
    var temp = scope.generateUidIdentifierBasedOnNode(index);
    scope.push({
      id: temp,
      kind: "var"
    });
    path.parentPath.replaceWith(restIndexImpure({
      ARGUMENTS: argsId,
      OFFSET: offsetLiteral,
      INDEX: index,
      REF: _core().types.cloneNode(temp)
    }));
  } else {
    var parentPath = path.parentPath;
    parentPath.replaceWith(restIndex({
      ARGUMENTS: argsId,
      OFFSET: offsetLiteral,
      INDEX: index
    }));
    var offsetTestPath = parentPath.get("test").get("left");
    var valRes = offsetTestPath.evaluate();

    if (valRes.confident) {
      if (valRes.value === true) {
        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
      } else {
        parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
      }
    }
  }
}

function optimiseLengthGetter(path, argsId, offset) {
  if (offset) {
    path.parentPath.replaceWith(restLength({
      ARGUMENTS: argsId,
      OFFSET: _core().types.numericLiteral(offset)
    }));
  } else {
    path.replaceWith(argsId);
  }
}

function convertFunctionRest(path) {
  var node = path.node,
      scope = path.scope;
  if (!hasRest(node)) return false;
  var rest = node.params.pop().argument;

  var argsId = _core().types.identifier("arguments");

  if (_core().types.isPattern(rest)) {
    var pattern = rest;
    rest = scope.generateUidIdentifier("ref");

    var declar = _core().types.variableDeclaration("let", [_core().types.variableDeclarator(pattern, rest)]);

    node.body.body.unshift(declar);
  }

  var state = {
    references: [],
    offset: node.params.length,
    argumentsNode: argsId,
    outerBinding: scope.getBindingIdentifier(rest.name),
    candidates: [],
    name: rest.name,
    deopted: false
  };
  path.traverse(memberExpressionOptimisationVisitor, state);

  if (!state.deopted && !state.references.length) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = state.candidates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ref = _step.value;
        var _path = _ref.path,
            cause = _ref.cause;

        var clonedArgsId = _core().types.cloneNode(argsId);

        switch (cause) {
          case "indexGetter":
            optimiseIndexGetter(_path, clonedArgsId, state.offset);
            break;

          case "lengthGetter":
            optimiseLengthGetter(_path, clonedArgsId, state.offset);
            break;

          default:
            _path.replaceWith(clonedArgsId);

        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }

  state.references = state.references.concat(state.candidates.map(function (_ref2) {
    var path = _ref2.path;
    return path;
  }));

  var start = _core().types.numericLiteral(node.params.length);

  var key = scope.generateUidIdentifier("key");
  var len = scope.generateUidIdentifier("len");
  var arrKey, arrLen;

  if (node.params.length) {
    arrKey = _core().types.binaryExpression("-", _core().types.cloneNode(key), _core().types.cloneNode(start));
    arrLen = _core().types.conditionalExpression(_core().types.binaryExpression(">", _core().types.cloneNode(len), _core().types.cloneNode(start)), _core().types.binaryExpression("-", _core().types.cloneNode(len), _core().types.cloneNode(start)), _core().types.numericLiteral(0));
  } else {
    arrKey = _core().types.identifier(key.name);
    arrLen = _core().types.identifier(len.name);
  }

  var loop = buildRest({
    ARGUMENTS: argsId,
    ARRAY_KEY: arrKey,
    ARRAY_LEN: arrLen,
    START: start,
    ARRAY: rest,
    KEY: key,
    LEN: len
  });

  if (state.deopted) {
    node.body.body.unshift(loop);
  } else {
    var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
    target.findParent(function (path) {
      if (path.isLoop()) {
        target = path;
      } else {
        return path.isFunction();
      }
    });
    target.insertBefore(loop);
  }

  return true;
}

},{"@babel/core":19}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-property-literals",
    visitor: {
      ObjectProperty: {
        exit: function exit(_ref) {
          var node = _ref.node;
          var key = node.key;

          if (!node.computed && _core().types.isIdentifier(key) && !_core().types.isValidES3Identifier(key.name)) {
            node.key = _core().types.stringLiteral(key.name);
          }
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _regeneratorTransform.default;
  }
});

var _regeneratorTransform = _interopRequireDefault(require("regenerator-transform"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

},{"regenerator-transform":1058}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-reserved-words",
    visitor: {
      "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
        if (!_core().types.isValidES3Identifier(path.node.name)) {
          path.scope.rename(path.node.name);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-shorthand-properties",
    visitor: {
      ObjectMethod: function ObjectMethod(path) {
        var node = path.node;

        if (node.kind === "method") {
          var func = _core().types.functionExpression(null, node.params, node.body, node.generator, node.async);

          func.returnType = node.returnType;
          path.replaceWith(_core().types.objectProperty(node.key, func, node.computed));
        }
      },
      ObjectProperty: function ObjectProperty(_ref) {
        var node = _ref.node;

        if (node.shorthand) {
          node.shorthand = false;
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;

  function getSpreadLiteral(spread, scope) {
    if (loose && !_core().types.isIdentifier(spread.argument, {
      name: "arguments"
    })) {
      return spread.argument;
    } else {
      return scope.toArray(spread.argument, true);
    }
  }

  function hasSpread(nodes) {
    for (var i = 0; i < nodes.length; i++) {
      if (_core().types.isSpreadElement(nodes[i])) {
        return true;
      }
    }

    return false;
  }

  function push(_props, nodes) {
    if (!_props.length) return _props;
    nodes.push(_core().types.arrayExpression(_props));
    return [];
  }

  function build(props, scope) {
    var nodes = [];
    var _props = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        if (_core().types.isSpreadElement(prop)) {
          _props = push(_props, nodes);
          nodes.push(getSpreadLiteral(prop, scope));
        } else {
          _props.push(prop);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    push(_props, nodes);
    return nodes;
  }

  return {
    name: "transform-spread",
    visitor: {
      ArrayExpression: function ArrayExpression(path) {
        var node = path.node,
            scope = path.scope;
        var elements = node.elements;
        if (!hasSpread(elements)) return;
        var nodes = build(elements, scope);
        var first = nodes[0];

        if (nodes.length === 1 && first !== elements[0].argument) {
          path.replaceWith(first);
          return;
        }

        if (!_core().types.isArrayExpression(first)) {
          first = _core().types.arrayExpression([]);
        } else {
          nodes.shift();
        }

        path.replaceWith(_core().types.callExpression(_core().types.memberExpression(first, _core().types.identifier("concat")), nodes));
      },
      CallExpression: function CallExpression(path) {
        var node = path.node,
            scope = path.scope;
        var args = node.arguments;
        if (!hasSpread(args)) return;
        var calleePath = path.get("callee");
        if (calleePath.isSuper()) return;
        var contextLiteral = scope.buildUndefinedNode();
        node.arguments = [];
        var nodes;

        if (args.length === 1 && args[0].argument.name === "arguments") {
          nodes = [args[0].argument];
        } else {
          nodes = build(args, scope);
        }

        var first = nodes.shift();

        if (nodes.length) {
          node.arguments.push(_core().types.callExpression(_core().types.memberExpression(first, _core().types.identifier("concat")), nodes));
        } else {
          node.arguments.push(first);
        }

        var callee = node.callee;

        if (calleePath.isMemberExpression()) {
          var temp = scope.maybeGenerateMemoised(callee.object);

          if (temp) {
            callee.object = _core().types.assignmentExpression("=", temp, callee.object);
            contextLiteral = temp;
          } else {
            contextLiteral = _core().types.cloneNode(callee.object);
          }

          _core().types.appendToMemberExpression(callee, _core().types.identifier("apply"));
        } else {
          node.callee = _core().types.memberExpression(node.callee, _core().types.identifier("apply"));
        }

        if (_core().types.isSuper(contextLiteral)) {
          contextLiteral = _core().types.thisExpression();
        }

        node.arguments.unshift(_core().types.cloneNode(contextLiteral));
      },
      NewExpression: function NewExpression(path) {
        var node = path.node,
            scope = path.scope;
        var args = node.arguments;
        if (!hasSpread(args)) return;
        var nodes = build(args, scope);
        var first = nodes.shift();

        if (nodes.length) {
          args = _core().types.callExpression(_core().types.memberExpression(first, _core().types.identifier("concat")), nodes);
        } else {
          args = first;
        }

        path.replaceWith(_core().types.callExpression(path.hub.addHelper("construct"), [node.callee, args]));
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function regex() {
  var data = _interopRequireWildcard(require("@babel/helper-regex"));

  regex = function regex() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-sticky-regex",
    visitor: {
      RegExpLiteral: function RegExpLiteral(path) {
        var node = path.node;
        if (!regex().is(node, "y")) return;
        path.replaceWith(_core().types.newExpression(_core().types.identifier("RegExp"), [_core().types.stringLiteral(node.pattern), _core().types.stringLiteral(node.flags)]));
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79,"@babel/helper-regex":80}],136:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          function ", "() {\n            const data = ", ";\n            ", " = function() { return data };\n            return data;\n          } \n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;
  var helperName = "taggedTemplateLiteral";
  if (loose) helperName += "Loose";

  function buildConcatCallExpressions(items) {
    var avail = true;
    return items.reduce(function (left, right) {
      var canBeInserted = _core().types.isLiteral(right);

      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }

      if (canBeInserted && _core().types.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }

      return _core().types.callExpression(_core().types.memberExpression(left, _core().types.identifier("concat")), [right]);
    });
  }

  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression: function TaggedTemplateExpression(path) {
        var node = path.node;
        var quasi = node.quasi;
        var strings = [];
        var raws = [];
        var isStringsRawEqual = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = quasi.quasis[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var elem = _step.value;
            var _elem$value = elem.value,
                raw = _elem$value.raw,
                cooked = _elem$value.cooked;
            var value = cooked == null ? path.scope.buildUndefinedNode() : _core().types.stringLiteral(cooked);
            strings.push(value);
            raws.push(_core().types.stringLiteral(raw));

            if (raw !== cooked) {
              isStringsRawEqual = false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var scope = path.scope.getProgramParent();
        var templateObject = scope.generateUidIdentifier("templateObject");
        var helperId = this.addHelper(helperName);
        var callExpressionInput = [_core().types.arrayExpression(strings)];

        if (!isStringsRawEqual) {
          callExpressionInput.push(_core().types.arrayExpression(raws));
        }

        var lazyLoad = _core().template.ast(_templateObject(), templateObject, _core().types.callExpression(helperId, callExpressionInput), templateObject);

        scope.path.unshiftContainer("body", lazyLoad);
        path.replaceWith(_core().types.callExpression(node.tag, [_core().types.callExpression(_core().types.cloneNode(templateObject), [])].concat(_toConsumableArray(quasi.expressions))));
      },
      TemplateLiteral: function TemplateLiteral(path) {
        var nodes = [];
        var expressions = path.get("expressions");
        var index = 0;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = path.node.quasis[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var elem = _step2.value;

            if (elem.value.cooked) {
              nodes.push(_core().types.stringLiteral(elem.value.cooked));
            }

            if (index < expressions.length) {
              var expr = expressions[index++];
              var node = expr.node;

              if (!_core().types.isStringLiteral(node, {
                value: ""
              })) {
                nodes.push(node);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var considerSecondNode = !loose || !_core().types.isStringLiteral(nodes[1]);

        if (!_core().types.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(_core().types.stringLiteral(""));
        }

        var root = nodes[0];

        if (loose) {
          for (var i = 1; i < nodes.length; i++) {
            root = _core().types.binaryExpression("+", root, nodes[i]);
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExpressions(nodes);
        }

        path.replaceWith(root);
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  var data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(function (api) {
  api.assertVersion(7);
  return {
    name: "transform-typeof-symbol",
    visitor: {
      Scope: function Scope(_ref) {
        var scope = _ref.scope;

        if (!scope.getBinding("Symbol")) {
          return;
        }

        scope.rename("Symbol");
      },
      UnaryExpression: function UnaryExpression(path) {
        var node = path.node,
            parent = path.parent;
        if (node.operator !== "typeof") return;

        if (path.parentPath.isBinaryExpression() && _core().types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
          var opposite = path.getOpposite();

          if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
            return;
          }
        }

        var helper = this.addHelper("typeof");
        var isUnderHelper = path.findParent(function (path) {
          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
        });

        if (isUnderHelper) {
          return;
        }

        var call = _core().types.callExpression(helper, [node.argument]);

        var arg = path.get("argument");

        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
          var unary = _core().types.unaryExpression("typeof", _core().types.cloneNode(node.argument));

          path.replaceWith(_core().types.conditionalExpression(_core().types.binaryExpression("===", unary, _core().types.stringLiteral("undefined")), _core().types.stringLiteral("undefined"), call));
        } else {
          path.replaceWith(call);
        }
      }
    }
  };
});

exports.default = _default;

},{"@babel/core":19,"@babel/helper-plugin-utils":79}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-unicode-regex",
    feature: "unicodeFlag"
  });
});

exports.default = _default;

},{"@babel/helper-create-regexp-features-plugin":61,"@babel/helper-plugin-utils":79}],139:[function(require,module,exports){
module.exports={
  "es6.module": {
    "edge": "16",
    "firefox": "60",
    "chrome": "61",
    "safari": "10.1",
    "opera": "48",
    "ios_saf": "10.3",
    "and_chr": "71",
    "and_ff": "64"
  }
}

},{}],140:[function(require,module,exports){
module.exports={
  "es6.array.copy-within": {
    "chrome": "45",
    "edge": "12",
    "firefox": "32",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "5",
    "opera": "32",
    "electron": "0.35"
  },
  "es6.array.every": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.fill": {
    "chrome": "45",
    "edge": "12",
    "firefox": "31",
    "safari": "7.1",
    "node": "4",
    "ios": "8",
    "samsung": "5",
    "opera": "32",
    "electron": "0.35"
  },
  "es6.array.filter": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.find": {
    "chrome": "45",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "4",
    "ios": "8",
    "samsung": "5",
    "opera": "32",
    "electron": "0.35"
  },
  "es6.array.find-index": {
    "chrome": "45",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "4",
    "ios": "8",
    "samsung": "5",
    "opera": "32",
    "electron": "0.35"
  },
  "es7.array.flat-map": {
    "chrome": "69",
    "firefox": "62",
    "safari": "12",
    "node": "11",
    "ios": "12",
    "opera": "56",
    "electron": "4"
  },
  "es6.array.for-each": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.from": {
    "chrome": "51",
    "edge": "15",
    "firefox": "36",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es7.array.includes": {
    "chrome": "47",
    "edge": "14",
    "firefox": "43",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "34",
    "electron": "0.36"
  },
  "es6.array.index-of": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.is-array": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "4",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.iterator": {
    "chrome": "38",
    "edge": "12",
    "firefox": "28",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.array.last-index-of": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.map": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.of": {
    "chrome": "45",
    "edge": "12",
    "firefox": "25",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "5",
    "opera": "32",
    "electron": "0.35"
  },
  "es6.array.reduce": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "3",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.reduce-right": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "3",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.some": {
    "chrome": "5",
    "opera": "10.10",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.array.sort": {
    "chrome": "63",
    "opera": "50",
    "edge": "12",
    "firefox": "5",
    "safari": "12",
    "node": "10",
    "ie": "9",
    "ios": "12",
    "samsung": "8.2",
    "electron": "3.1"
  },
  "es6.array.species": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.date.now": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "2",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.date.to-iso-string": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "3.5",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.date.to-json": {
    "chrome": "5",
    "opera": "12.10",
    "edge": "12",
    "firefox": "4",
    "safari": "10",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "10",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.date.to-primitive": {
    "chrome": "47",
    "edge": "15",
    "firefox": "44",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "34",
    "electron": "0.36"
  },
  "es6.date.to-string": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "10",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.function.bind": {
    "chrome": "7",
    "opera": "12",
    "edge": "12",
    "firefox": "4",
    "safari": "5.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "5"
  },
  "es6.function.has-instance": {
    "chrome": "51",
    "edge": "15",
    "firefox": "50",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.function.name": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "14",
    "firefox": "2",
    "safari": "4",
    "node": "0.10",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.map": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.math.acosh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.asinh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.atanh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.cbrt": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.clz32": {
    "chrome": "38",
    "edge": "12",
    "firefox": "31",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.cosh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.expm1": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.fround": {
    "chrome": "38",
    "edge": "12",
    "firefox": "26",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.hypot": {
    "chrome": "38",
    "edge": "12",
    "firefox": "27",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.imul": {
    "chrome": "30",
    "edge": "12",
    "firefox": "23",
    "safari": "7",
    "node": "0.12",
    "android": "4.4",
    "ios": "7",
    "samsung": "2.1",
    "opera": "17",
    "electron": "0.2"
  },
  "es6.math.log1p": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.log10": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.log2": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.sign": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.sinh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.tanh": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.math.trunc": {
    "chrome": "38",
    "edge": "12",
    "firefox": "25",
    "safari": "7.1",
    "node": "0.12",
    "ios": "8",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.number.constructor": {
    "chrome": "41",
    "edge": "12",
    "firefox": "36",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.number.epsilon": {
    "chrome": "34",
    "edge": "12",
    "firefox": "25",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.is-finite": {
    "chrome": "19",
    "edge": "12",
    "firefox": "16",
    "safari": "9",
    "node": "0.12",
    "android": "4.1",
    "ios": "9",
    "samsung": "2.1",
    "electron": "0.2"
  },
  "es6.number.is-integer": {
    "chrome": "34",
    "edge": "12",
    "firefox": "16",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.is-nan": {
    "chrome": "19",
    "edge": "12",
    "firefox": "15",
    "safari": "9",
    "node": "0.12",
    "android": "4.1",
    "ios": "9",
    "samsung": "2.1",
    "electron": "0.2"
  },
  "es6.number.is-safe-integer": {
    "chrome": "34",
    "edge": "12",
    "firefox": "32",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.max-safe-integer": {
    "chrome": "34",
    "edge": "12",
    "firefox": "31",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.min-safe-integer": {
    "chrome": "34",
    "edge": "12",
    "firefox": "31",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.parse-float": {
    "chrome": "34",
    "edge": "12",
    "firefox": "25",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.number.parse-int": {
    "chrome": "34",
    "edge": "12",
    "firefox": "25",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es6.object.assign": {
    "chrome": "49",
    "edge": "13",
    "firefox": "36",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.object.create": {
    "chrome": "5",
    "opera": "12",
    "edge": "12",
    "firefox": "4",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es7.object.define-getter": {
    "chrome": "62",
    "edge": "16",
    "firefox": "48",
    "safari": "9",
    "node": "8.10",
    "ios": "9",
    "samsung": "8.2",
    "opera": "49",
    "electron": "3.1"
  },
  "es7.object.define-setter": {
    "chrome": "62",
    "edge": "16",
    "firefox": "48",
    "safari": "9",
    "node": "8.10",
    "ios": "9",
    "samsung": "8.2",
    "opera": "49",
    "electron": "3.1"
  },
  "es6.object.define-property": {
    "chrome": "5",
    "opera": "12",
    "edge": "12",
    "firefox": "4",
    "safari": "5.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.object.define-properties": {
    "chrome": "5",
    "opera": "12",
    "edge": "12",
    "firefox": "4",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es7.object.entries": {
    "chrome": "54",
    "edge": "14",
    "firefox": "47",
    "safari": "10.1",
    "node": "7",
    "ios": "10.3",
    "samsung": "6.2",
    "opera": "41",
    "electron": "1.5"
  },
  "es6.object.freeze": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.get-own-property-descriptor": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es7.object.get-own-property-descriptors": {
    "chrome": "54",
    "edge": "15",
    "firefox": "50",
    "safari": "10.1",
    "node": "7",
    "ios": "10.3",
    "samsung": "6.2",
    "opera": "41",
    "electron": "1.5"
  },
  "es6.object.get-own-property-names": {
    "chrome": "40",
    "edge": "12",
    "firefox": "33",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "27",
    "electron": "0.21"
  },
  "es6.object.get-prototype-of": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es7.object.lookup-getter": {
    "chrome": "62",
    "firefox": "36",
    "safari": "9",
    "node": "8.10",
    "ios": "9",
    "samsung": "8.2",
    "opera": "49",
    "electron": "3.1"
  },
  "es7.object.lookup-setter": {
    "chrome": "62",
    "firefox": "36",
    "safari": "9",
    "node": "8.10",
    "ios": "9",
    "samsung": "8.2",
    "opera": "49",
    "electron": "3.1"
  },
  "es6.object.prevent-extensions": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.to-string": {
    "chrome": "57",
    "edge": "15",
    "firefox": "51",
    "safari": "10",
    "node": "8",
    "ios": "10",
    "samsung": "7.2",
    "opera": "44",
    "electron": "1.7"
  },
  "es6.object.is": {
    "chrome": "19",
    "edge": "12",
    "firefox": "22",
    "safari": "9",
    "node": "0.12",
    "android": "4.1",
    "ios": "9",
    "samsung": "2.1",
    "electron": "0.2"
  },
  "es6.object.is-frozen": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.is-sealed": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.is-extensible": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.keys": {
    "chrome": "40",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "27",
    "electron": "0.21"
  },
  "es6.object.seal": {
    "chrome": "44",
    "edge": "12",
    "firefox": "35",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "es6.object.set-prototype-of": {
    "chrome": "34",
    "edge": "12",
    "firefox": "31",
    "safari": "9",
    "node": "0.12",
    "ie": "11",
    "ios": "9",
    "samsung": "2.1",
    "opera": "21",
    "electron": "0.2"
  },
  "es7.object.values": {
    "chrome": "54",
    "edge": "14",
    "firefox": "47",
    "safari": "10.1",
    "node": "7",
    "ios": "10.3",
    "samsung": "6.2",
    "opera": "41",
    "electron": "1.5"
  },
  "es6.promise": {
    "chrome": "51",
    "edge": "14",
    "firefox": "45",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es7.promise.finally": {
    "chrome": "63",
    "edge": "18",
    "firefox": "58",
    "safari": "11.1",
    "node": "10",
    "ios": "11.3",
    "samsung": "8.2",
    "opera": "50",
    "electron": "3.1"
  },
  "es6.reflect.apply": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.construct": {
    "chrome": "49",
    "edge": "13",
    "firefox": "49",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.define-property": {
    "chrome": "49",
    "edge": "13",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.delete-property": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.get": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.get-own-property-descriptor": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.get-prototype-of": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.has": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.is-extensible": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.own-keys": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.prevent-extensions": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.set": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.reflect.set-prototype-of": {
    "chrome": "49",
    "edge": "12",
    "firefox": "42",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.regexp.constructor": {
    "chrome": "50",
    "firefox": "40",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.regexp.flags": {
    "chrome": "49",
    "firefox": "37",
    "safari": "9",
    "node": "6",
    "ios": "9",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "es6.regexp.match": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.regexp.replace": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.regexp.split": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.regexp.search": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.regexp.to-string": {
    "chrome": "50",
    "firefox": "39",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "es6.set": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.symbol": {
    "chrome": "51",
    "firefox": "51",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es7.symbol.async-iterator": {
    "chrome": "63",
    "firefox": "57",
    "safari": "12",
    "node": "10",
    "ios": "12",
    "samsung": "8.2",
    "opera": "50",
    "electron": "3.1"
  },
  "es6.string.anchor": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.big": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.blink": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.bold": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.code-point-at": {
    "chrome": "41",
    "edge": "12",
    "firefox": "29",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.ends-with": {
    "chrome": "41",
    "edge": "12",
    "firefox": "29",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.fixed": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.fontcolor": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.fontsize": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.from-code-point": {
    "chrome": "41",
    "edge": "12",
    "firefox": "29",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.includes": {
    "chrome": "41",
    "edge": "12",
    "firefox": "40",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.italics": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.iterator": {
    "chrome": "38",
    "edge": "12",
    "firefox": "36",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "es6.string.link": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es7.string.pad-start": {
    "chrome": "57",
    "edge": "15",
    "firefox": "48",
    "safari": "10",
    "node": "8",
    "ios": "10",
    "samsung": "7.2",
    "opera": "44",
    "electron": "1.7"
  },
  "es7.string.pad-end": {
    "chrome": "57",
    "edge": "15",
    "firefox": "48",
    "safari": "10",
    "node": "8",
    "ios": "10",
    "samsung": "7.2",
    "opera": "44",
    "electron": "1.7"
  },
  "es6.string.raw": {
    "chrome": "41",
    "edge": "12",
    "firefox": "34",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.repeat": {
    "chrome": "41",
    "edge": "12",
    "firefox": "24",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.small": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.starts-with": {
    "chrome": "41",
    "edge": "12",
    "firefox": "29",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "es6.string.strike": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.sub": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.sup": {
    "chrome": "5",
    "edge": "12",
    "firefox": "17",
    "safari": "6",
    "node": "0.10",
    "android": "4",
    "ios": "7",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.string.trim": {
    "chrome": "5",
    "opera": "10.50",
    "edge": "12",
    "firefox": "3.5",
    "safari": "4",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es7.string.trim-left": {
    "chrome": "66",
    "firefox": "61",
    "safari": "12",
    "node": "10",
    "ios": "12",
    "opera": "53",
    "electron": "3.1"
  },
  "es7.string.trim-right": {
    "chrome": "66",
    "firefox": "61",
    "safari": "12",
    "node": "10",
    "ios": "12",
    "opera": "53",
    "electron": "3.1"
  },
  "es6.typed.array-buffer": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.data-view": {
    "chrome": "5",
    "opera": "12",
    "edge": "12",
    "firefox": "15",
    "safari": "5.1",
    "node": "0.10",
    "ie": "10",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "1.1"
  },
  "es6.typed.int8-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.uint8-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.uint8-clamped-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.int16-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.uint16-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.int32-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.uint32-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.float32-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.typed.float64-array": {
    "chrome": "51",
    "edge": "13",
    "firefox": "48",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.weak-map": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "9",
    "node": "6.5",
    "ios": "9",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "es6.weak-set": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "9",
    "node": "6.5",
    "ios": "9",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  }
}

},{}],141:[function(require,module,exports){
"use strict";

module.exports = new Map(); // async -> regenerator is better than async -> generator -> regenerator

ifIncluded("transform-regenerator").isUnnecessary("transform-async-to-generator");

function ifIncluded(name) {
  var set = new Set();
  module.exports.set(name, set);
  return {
    isUnnecessary: function isUnnecessary(name) {
      set.add(name);
      return this;
    }
  };
}

},{}],142:[function(require,module,exports){
module.exports={
  "transform-template-literals": {
    "chrome": "41",
    "edge": "13",
    "firefox": "34",
    "node": "4",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "transform-literals": {
    "chrome": "44",
    "edge": "12",
    "firefox": "53",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "transform-function-name": {
    "chrome": "51",
    "firefox": "53",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "transform-arrow-functions": {
    "chrome": "47",
    "edge": "13",
    "firefox": "45",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "34",
    "electron": "0.36"
  },
  "transform-block-scoped-functions": {
    "chrome": "41",
    "edge": "12",
    "firefox": "46",
    "safari": "10",
    "node": "4",
    "ie": "11",
    "ios": "10",
    "samsung": "3.4",
    "opera": "28",
    "electron": "0.24"
  },
  "transform-classes": {
    "chrome": "46",
    "edge": "13",
    "firefox": "45",
    "safari": "10",
    "node": "5",
    "ios": "10",
    "samsung": "5",
    "opera": "33",
    "electron": "0.36"
  },
  "transform-object-super": {
    "chrome": "46",
    "edge": "13",
    "firefox": "45",
    "safari": "10",
    "node": "5",
    "ios": "10",
    "samsung": "5",
    "opera": "33",
    "electron": "0.36"
  },
  "transform-shorthand-properties": {
    "chrome": "43",
    "edge": "12",
    "firefox": "33",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "4",
    "opera": "30",
    "electron": "0.29"
  },
  "transform-duplicate-keys": {
    "chrome": "42",
    "edge": "12",
    "firefox": "34",
    "safari": "9",
    "node": "4",
    "ios": "9",
    "samsung": "3.4",
    "opera": "29",
    "electron": "0.27"
  },
  "transform-computed-properties": {
    "chrome": "44",
    "edge": "12",
    "firefox": "34",
    "safari": "7.1",
    "node": "4",
    "ios": "8",
    "samsung": "4",
    "opera": "31",
    "electron": "0.31"
  },
  "transform-for-of": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "transform-sticky-regex": {
    "chrome": "49",
    "edge": "13",
    "firefox": "3",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "transform-dotall-regex": {
    "chrome": "62",
    "safari": "11.1",
    "node": "8.10",
    "ios": "11.3",
    "samsung": "8.2",
    "opera": "49",
    "electron": "3.1"
  },
  "transform-unicode-regex": {
    "chrome": "50",
    "edge": "13",
    "firefox": "46",
    "safari": "12",
    "node": "6",
    "ios": "12",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "transform-spread": {
    "chrome": "46",
    "edge": "13",
    "firefox": "36",
    "safari": "10",
    "node": "5",
    "ios": "10",
    "samsung": "5",
    "opera": "33",
    "electron": "0.36"
  },
  "transform-parameters": {
    "chrome": "49",
    "edge": "18",
    "firefox": "53",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "transform-destructuring": {
    "chrome": "51",
    "edge": "15",
    "firefox": "53",
    "safari": "10",
    "node": "6.5",
    "ios": "10",
    "samsung": "5",
    "opera": "38",
    "electron": "1.2"
  },
  "transform-block-scoping": {
    "chrome": "49",
    "edge": "14",
    "firefox": "51",
    "safari": "11",
    "node": "6",
    "ios": "11",
    "samsung": "5",
    "opera": "36",
    "electron": "1"
  },
  "transform-typeof-symbol": {
    "chrome": "38",
    "edge": "12",
    "firefox": "36",
    "safari": "9",
    "node": "0.12",
    "ios": "9",
    "samsung": "3",
    "opera": "25",
    "electron": "0.2"
  },
  "transform-new-target": {
    "chrome": "46",
    "edge": "14",
    "firefox": "41",
    "safari": "10",
    "node": "5",
    "ios": "10",
    "samsung": "5",
    "opera": "33",
    "electron": "0.36"
  },
  "transform-regenerator": {
    "chrome": "50",
    "edge": "13",
    "firefox": "53",
    "safari": "10",
    "node": "6",
    "ios": "10",
    "samsung": "5",
    "opera": "37",
    "electron": "1.1"
  },
  "transform-exponentiation-operator": {
    "chrome": "52",
    "edge": "14",
    "firefox": "52",
    "safari": "10.1",
    "node": "7",
    "ios": "10.3",
    "samsung": "6.2",
    "opera": "39",
    "electron": "1.3"
  },
  "transform-async-to-generator": {
    "chrome": "55",
    "edge": "15",
    "firefox": "52",
    "safari": "11",
    "node": "7.6",
    "ios": "11",
    "samsung": "6.2",
    "opera": "42",
    "electron": "1.6"
  },
  "proposal-async-generator-functions": {
    "chrome": "63",
    "firefox": "57",
    "safari": "12",
    "node": "10",
    "ios": "12",
    "samsung": "8.2",
    "opera": "50",
    "electron": "3.1"
  },
  "proposal-object-rest-spread": {
    "chrome": "60",
    "firefox": "55",
    "safari": "11.1",
    "node": "8.3",
    "ios": "11.3",
    "samsung": "8.2",
    "opera": "47",
    "electron": "2.1"
  },
  "proposal-unicode-property-regex": {
    "chrome": "64",
    "safari": "11.1",
    "node": "10",
    "ios": "11.3",
    "opera": "51",
    "electron": "3.1"
  },
  "proposal-json-strings": {
    "chrome": "66",
    "firefox": "62",
    "safari": "12",
    "node": "10",
    "ios": "12",
    "opera": "53",
    "electron": "3.1"
  },
  "proposal-optional-catch-binding": {
    "chrome": "66",
    "firefox": "58",
    "safari": "11.1",
    "node": "10",
    "ios": "11.3",
    "opera": "53",
    "electron": "3.1"
  },
  "transform-named-capturing-groups-regex": {
    "chrome": "64",
    "safari": "11.1",
    "node": "10",
    "ios": "11.3",
    "opera": "51",
    "electron": "3.1"
  },
  "transform-member-expression-literals": {
    "chrome": "7",
    "opera": "12",
    "edge": "12",
    "firefox": "2",
    "safari": "5.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "5"
  },
  "transform-property-literals": {
    "chrome": "7",
    "opera": "12",
    "edge": "12",
    "firefox": "2",
    "safari": "5.1",
    "node": "0.10",
    "ie": "9",
    "android": "4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "5"
  },
  "transform-reserved-words": {
    "chrome": "13",
    "opera": "10.50",
    "edge": "12",
    "firefox": "2",
    "safari": "3.1",
    "node": "0.10",
    "ie": "9",
    "android": "4.4",
    "ios": "6",
    "phantom": "2",
    "samsung": "2.1",
    "electron": "0.2"
  }
}

},{}],143:[function(require,module,exports){
"use strict";

// These mappings represent the syntax proposals that have been
// shipped by browsers, and are enabled by the `shippedProposals` option.
var proposalPlugins = {};
var pluginSyntaxMap = new Map([["proposal-async-generator-functions", "syntax-async-generators"], ["proposal-object-rest-spread", "syntax-object-rest-spread"], ["proposal-optional-catch-binding", "syntax-optional-catch-binding"], ["proposal-unicode-property-regex", null], ["proposal-json-strings", "syntax-json-strings"]]);
module.exports = {
  proposalPlugins: proposalPlugins,
  pluginSyntaxMap: pluginSyntaxMap
};

},{}],144:[function(require,module,exports){
"use strict";

module.exports = {
  safari: "tp"
};

},{}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  "syntax-async-generators": require("@babel/plugin-syntax-async-generators"),
  "syntax-dynamic-import": require("@babel/plugin-syntax-dynamic-import"),
  "syntax-json-strings": require("@babel/plugin-syntax-json-strings"),
  "syntax-object-rest-spread": require("@babel/plugin-syntax-object-rest-spread"),
  "syntax-optional-catch-binding": require("@babel/plugin-syntax-optional-catch-binding"),
  "syntax-top-level-await": require("@babel/plugin-syntax-top-level-await"),
  "transform-async-to-generator": require("@babel/plugin-transform-async-to-generator"),
  "proposal-async-generator-functions": require("@babel/plugin-proposal-async-generator-functions"),
  "proposal-dynamic-import": require("@babel/plugin-proposal-dynamic-import"),
  "proposal-json-strings": require("@babel/plugin-proposal-json-strings"),
  "transform-arrow-functions": require("@babel/plugin-transform-arrow-functions"),
  "transform-block-scoped-functions": require("@babel/plugin-transform-block-scoped-functions"),
  "transform-block-scoping": require("@babel/plugin-transform-block-scoping"),
  "transform-classes": require("@babel/plugin-transform-classes"),
  "transform-computed-properties": require("@babel/plugin-transform-computed-properties"),
  "transform-destructuring": require("@babel/plugin-transform-destructuring"),
  "transform-dotall-regex": require("@babel/plugin-transform-dotall-regex"),
  "transform-duplicate-keys": require("@babel/plugin-transform-duplicate-keys"),
  "transform-for-of": require("@babel/plugin-transform-for-of"),
  "transform-function-name": require("@babel/plugin-transform-function-name"),
  "transform-literals": require("@babel/plugin-transform-literals"),
  "transform-member-expression-literals": require("@babel/plugin-transform-member-expression-literals"),
  "transform-modules-amd": require("@babel/plugin-transform-modules-amd"),
  "transform-modules-commonjs": require("@babel/plugin-transform-modules-commonjs"),
  "transform-modules-systemjs": require("@babel/plugin-transform-modules-systemjs"),
  "transform-modules-umd": require("@babel/plugin-transform-modules-umd"),
  "transform-named-capturing-groups-regex": require("@babel/plugin-transform-named-capturing-groups-regex"),
  "transform-object-super": require("@babel/plugin-transform-object-super"),
  "transform-parameters": require("@babel/plugin-transform-parameters"),
  "transform-property-literals": require("@babel/plugin-transform-property-literals"),
  "transform-reserved-words": require("@babel/plugin-transform-reserved-words"),
  "transform-shorthand-properties": require("@babel/plugin-transform-shorthand-properties"),
  "transform-spread": require("@babel/plugin-transform-spread"),
  "transform-sticky-regex": require("@babel/plugin-transform-sticky-regex"),
  "transform-template-literals": require("@babel/plugin-transform-template-literals"),
  "transform-typeof-symbol": require("@babel/plugin-transform-typeof-symbol"),
  "transform-unicode-regex": require("@babel/plugin-transform-unicode-regex"),
  "transform-exponentiation-operator": require("@babel/plugin-transform-exponentiation-operator"),
  "transform-new-target": require("@babel/plugin-transform-new-target"),
  "proposal-object-rest-spread": require("@babel/plugin-proposal-object-rest-spread"),
  "proposal-optional-catch-binding": require("@babel/plugin-proposal-optional-catch-binding"),
  "transform-regenerator": require("@babel/plugin-transform-regenerator"),
  "proposal-unicode-property-regex": require("@babel/plugin-proposal-unicode-property-regex")
};
exports.default = _default;

},{"@babel/plugin-proposal-async-generator-functions":91,"@babel/plugin-proposal-dynamic-import":92,"@babel/plugin-proposal-json-strings":94,"@babel/plugin-proposal-object-rest-spread":95,"@babel/plugin-proposal-optional-catch-binding":96,"@babel/plugin-proposal-unicode-property-regex":97,"@babel/plugin-syntax-async-generators":98,"@babel/plugin-syntax-dynamic-import":99,"@babel/plugin-syntax-json-strings":100,"@babel/plugin-syntax-object-rest-spread":101,"@babel/plugin-syntax-optional-catch-binding":102,"@babel/plugin-syntax-top-level-await":103,"@babel/plugin-transform-arrow-functions":104,"@babel/plugin-transform-async-to-generator":105,"@babel/plugin-transform-block-scoped-functions":106,"@babel/plugin-transform-block-scoping":107,"@babel/plugin-transform-classes":109,"@babel/plugin-transform-computed-properties":111,"@babel/plugin-transform-destructuring":112,"@babel/plugin-transform-dotall-regex":113,"@babel/plugin-transform-duplicate-keys":114,"@babel/plugin-transform-exponentiation-operator":115,"@babel/plugin-transform-for-of":116,"@babel/plugin-transform-function-name":117,"@babel/plugin-transform-literals":118,"@babel/plugin-transform-member-expression-literals":119,"@babel/plugin-transform-modules-amd":120,"@babel/plugin-transform-modules-commonjs":121,"@babel/plugin-transform-modules-systemjs":122,"@babel/plugin-transform-modules-umd":123,"@babel/plugin-transform-named-capturing-groups-regex":124,"@babel/plugin-transform-new-target":125,"@babel/plugin-transform-object-super":126,"@babel/plugin-transform-parameters":127,"@babel/plugin-transform-property-literals":130,"@babel/plugin-transform-regenerator":131,"@babel/plugin-transform-reserved-words":132,"@babel/plugin-transform-shorthand-properties":133,"@babel/plugin-transform-spread":134,"@babel/plugin-transform-sticky-regex":135,"@babel/plugin-transform-template-literals":136,"@babel/plugin-transform-typeof-symbol":137,"@babel/plugin-transform-unicode-regex":138}],146:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logUsagePolyfills = exports.logEntryPolyfills = exports.logPluginOrPolyfill = void 0;

var _semver = _interopRequireDefault(require("semver"));

var _utils = require("./utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var wordEnds = function wordEnds(size) {
  return size > 1 ? "s" : "";
};

var logPluginOrPolyfill = function logPluginOrPolyfill(item, targetVersions, list) {
  var minVersions = list[item] || {};
  var filteredList = Object.keys(targetVersions).reduce(function (result, env) {
    var minVersion = minVersions[env];
    var targetVersion = targetVersions[env];

    if (!minVersion) {
      result[env] = (0, _utils.prettifyVersion)(targetVersion);
    } else {
      var minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
      var targetIsUnreleased = (0, _utils.isUnreleasedVersion)(targetVersion, env);

      if (!targetIsUnreleased && (minIsUnreleased || _semver.default.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion)))) {
        result[env] = (0, _utils.prettifyVersion)(targetVersion);
      }
    }

    return result;
  }, {});
  var formattedTargets = JSON.stringify(filteredList).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
  console.log("  ".concat(item, " ").concat(formattedTargets));
};

exports.logPluginOrPolyfill = logPluginOrPolyfill;

var logEntryPolyfills = function logEntryPolyfills(polyfillName, importPolyfillIncluded, polyfills, filename, polyfillTargets, allBuiltInsList) {
  if (process.env.BABEL_ENV === "test") {
    filename = filename.replace(/\\/g, "/");
  }

  if (!importPolyfillIncluded) {
    console.log("\n[".concat(filename, "] Import of ").concat(polyfillName, " was not found."));
    return;
  }

  if (!polyfills.size) {
    console.log("\n[".concat(filename, "] Based on your targets, polyfills were not added."));
    return;
  }

  console.log("\n[".concat(filename, "] Replaced ").concat(polyfillName, " entries with the following polyfill").concat(wordEnds(polyfills.size), ":"));
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = polyfills[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var polyfill = _step.value;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

exports.logEntryPolyfills = logEntryPolyfills;

var logUsagePolyfills = function logUsagePolyfills(polyfills, filename, polyfillTargets, allBuiltInsList) {
  if (process.env.BABEL_ENV === "test") {
    filename = filename.replace(/\\/g, "/");
  }

  if (!polyfills.size) {
    console.log("\n[".concat(filename, "] Based on your code and targets, core-js polyfills were not added."));
    return;
  }

  console.log("\n[".concat(filename, "] Added following core-js polyfill").concat(wordEnds(polyfills.size), ":"));
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = polyfills[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var polyfill = _step2.value;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

exports.logUsagePolyfills = logUsagePolyfills;

}).call(this,require('_process'))
},{"./utils":164,"_process":1054,"semver":1070}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPluginRequired = isPluginRequired;
exports.default = _default;
exports.removeUnnecessaryItems = removeUnnecessaryItems;

var _semver = _interopRequireDefault(require("semver"));

var _utils = require("./utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isPluginRequired(supportedEnvironments, plugin) {
  var targetEnvironments = Object.keys(supportedEnvironments);

  if (targetEnvironments.length === 0) {
    return true;
  }

  var isRequiredForEnvironments = targetEnvironments.filter(function (environment) {
    if (!plugin[environment]) {
      return true;
    }

    var lowestImplementedVersion = plugin[environment];
    var lowestTargetedVersion = supportedEnvironments[environment];

    if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
      return false;
    }

    if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
      return true;
    }

    if (!_semver.default.valid(lowestTargetedVersion.toString())) {
      throw new Error("Invalid version passed for target \"".concat(environment, "\": \"").concat(lowestTargetedVersion, "\". ") + "Versions must be in semver format (major.minor.patch)");
    }

    return _semver.default.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
  });
  return isRequiredForEnvironments.length > 0;
}

function _default(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
  var result = new Set();

  for (var item in list) {
    if (!excludes.has(item) && (isPluginRequired(targets, list[item]) || includes.has(item))) {
      result.add(item);
    } else if (pluginSyntaxMap) {
      var shippedProposalsSyntax = pluginSyntaxMap.get(item);

      if (shippedProposalsSyntax) {
        result.add(shippedProposalsSyntax);
      }
    }
  }

  if (defaultIncludes) {
    defaultIncludes.forEach(function (item) {
      return !excludes.has(item) && result.add(item);
    });
  }

  if (defaultExcludes) {
    defaultExcludes.forEach(function (item) {
      return !includes.has(item) && result.delete(item);
    });
  }

  return result;
}

function removeUnnecessaryItems(items, overlapping) {
  items.forEach(function (item) {
    var names = overlapping.get(item);
    if (names) names.forEach(function (name) {
      return items.delete(name);
    });
  });
}

},{"./utils":164,"semver":1070}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var defaultExcludesForLooseMode = ["transform-typeof-symbol"];

function _default(_ref) {
  var loose = _ref.loose;
  return loose ? defaultExcludesForLooseMode : null;
}

},{}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isPluginRequired", {
  enumerable: true,
  get: function get() {
    return _filterItems.isPluginRequired;
  }
});
exports.default = exports.getPolyfillPlugins = exports.getModulesPluginNames = exports.transformIncludesAndExcludes = void 0;

var _semver = require("semver");

var _debug = require("./debug");

var _getOptionSpecificExcludes = _interopRequireDefault(require("./get-option-specific-excludes"));

var _filterItems = _interopRequireWildcard(require("./filter-items"));

var _moduleTransformations = _interopRequireDefault(require("./module-transformations"));

var _normalizeOptions = _interopRequireDefault(require("./normalize-options"));

var _plugins = _interopRequireDefault(require("../data/plugins.json"));

var _shippedProposals = require("../data/shipped-proposals");

var _overlappingPlugins = _interopRequireDefault(require("../data/overlapping-plugins"));

var _usagePlugin = _interopRequireDefault(require("./polyfills/corejs2/usage-plugin"));

var _usagePlugin2 = _interopRequireDefault(require("./polyfills/corejs3/usage-plugin"));

var _usagePlugin3 = _interopRequireDefault(require("./polyfills/regenerator/usage-plugin"));

var _entryPlugin = _interopRequireDefault(require("./polyfills/corejs2/entry-plugin"));

var _entryPlugin2 = _interopRequireDefault(require("./polyfills/corejs3/entry-plugin"));

var _entryPlugin3 = _interopRequireDefault(require("./polyfills/regenerator/entry-plugin"));

var _targetsParser = _interopRequireDefault(require("./targets-parser"));

var _availablePlugins = _interopRequireDefault(require("./available-plugins"));

var _utils = require("./utils");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var pluginListWithoutProposals = (0, _utils.filterStageFromList)(_plugins.default, _shippedProposals.proposalPlugins);

var getPlugin = function getPlugin(pluginName) {
  var plugin = _availablePlugins.default[pluginName];

  if (!plugin) {
    throw new Error("Could not find plugin \"".concat(pluginName, "\". Ensure there is an entry in ./available-plugins.js for it."));
  }

  return plugin;
};

var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
  return opts.reduce(function (result, opt) {
    var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
    result[target].add(opt);
    return result;
  }, {
    all: opts,
    plugins: new Set(),
    builtIns: new Set()
  });
};

exports.transformIncludesAndExcludes = transformIncludesAndExcludes;

var getModulesPluginNames = function getModulesPluginNames(_ref) {
  var modules = _ref.modules,
      transformations = _ref.transformations,
      shouldTransformESM = _ref.shouldTransformESM,
      shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
      shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
  var modulesPluginNames = [];

  if (modules !== false && transformations[modules]) {
    if (shouldTransformESM) {
      modulesPluginNames.push(transformations[modules]);
    }

    if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
      modulesPluginNames.push("proposal-dynamic-import");
    } else {
      if (shouldTransformDynamicImport) {
        console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
      }

      modulesPluginNames.push("syntax-dynamic-import");
    }
  } else {
    modulesPluginNames.push("syntax-dynamic-import");
  }

  if (shouldParseTopLevelAwait) {
    modulesPluginNames.push("syntax-top-level-await");
  }

  return modulesPluginNames;
};

exports.getModulesPluginNames = getModulesPluginNames;

var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
  var useBuiltIns = _ref2.useBuiltIns,
      corejs = _ref2.corejs,
      polyfillTargets = _ref2.polyfillTargets,
      include = _ref2.include,
      exclude = _ref2.exclude,
      proposals = _ref2.proposals,
      shippedProposals = _ref2.shippedProposals,
      regenerator = _ref2.regenerator,
      debug = _ref2.debug;
  var polyfillPlugins = [];

  if (useBuiltIns === "usage" || useBuiltIns === "entry") {
    var pluginOptions = {
      corejs: corejs,
      polyfillTargets: polyfillTargets,
      include: include,
      exclude: exclude,
      proposals: proposals,
      shippedProposals: shippedProposals,
      regenerator: regenerator,
      debug: debug
    };

    if (corejs) {
      if (useBuiltIns === "usage") {
        if (corejs.major === 2) {
          polyfillPlugins.push([_usagePlugin.default, pluginOptions]);
        } else {
          polyfillPlugins.push([_usagePlugin2.default, pluginOptions]);
        }

        if (regenerator) {
          polyfillPlugins.push([_usagePlugin3.default, pluginOptions]);
        }
      } else {
        if (corejs.major === 2) {
          polyfillPlugins.push([_entryPlugin.default, pluginOptions]);
        } else {
          polyfillPlugins.push([_entryPlugin2.default, pluginOptions]);

          if (!regenerator) {
            polyfillPlugins.push([_entryPlugin3.default, pluginOptions]);
          }
        }
      }
    }
  }

  return polyfillPlugins;
};

exports.getPolyfillPlugins = getPolyfillPlugins;

function supportsStaticESM(caller) {
  return !!(caller && caller.supportsStaticESM);
}

function supportsDynamicImport(caller) {
  return !!(caller && caller.supportsDynamicImport);
}

function supportsTopLevelAwait(caller) {
  return !!(caller && caller.supportsTopLevelAwait);
}

var _default = (0, _helperPluginUtils.declare)(function (api, opts) {
  api.assertVersion(7);

  var _ref3 = (0, _normalizeOptions.default)(opts),
      configPath = _ref3.configPath,
      debug = _ref3.debug,
      optionsExclude = _ref3.exclude,
      forceAllTransforms = _ref3.forceAllTransforms,
      ignoreBrowserslistConfig = _ref3.ignoreBrowserslistConfig,
      optionsInclude = _ref3.include,
      loose = _ref3.loose,
      modules = _ref3.modules,
      shippedProposals = _ref3.shippedProposals,
      spec = _ref3.spec,
      optionsTargets = _ref3.targets,
      useBuiltIns = _ref3.useBuiltIns,
      _ref3$corejs = _ref3.corejs,
      corejs = _ref3$corejs.version,
      proposals = _ref3$corejs.proposals;

  var hasUglifyTarget = false;

  if (optionsTargets && optionsTargets.uglify) {
    hasUglifyTarget = true;
    delete optionsTargets.uglify;
    console.log("");
    console.log("The uglify target has been deprecated. Set the top level");
    console.log("option `forceAllTransforms: true` instead.");
    console.log("");
  }

  if (optionsTargets && optionsTargets.esmodules && optionsTargets.browsers) {
    console.log("");
    console.log("@babel/preset-env: esmodules and browsers targets have been specified together.");
    console.log("`browsers` target, `".concat(optionsTargets.browsers, "` will be ignored."));
    console.log("");
  }

  var targets = (0, _targetsParser.default)(optionsTargets, {
    ignoreBrowserslistConfig: ignoreBrowserslistConfig,
    configPath: configPath
  });
  var include = transformIncludesAndExcludes(optionsInclude);
  var exclude = transformIncludesAndExcludes(optionsExclude);
  var transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
  var modulesPluginNames = getModulesPluginNames({
    modules: modules,
    transformations: _moduleTransformations.default,
    shouldTransformESM: modules !== "auto" || !api.caller || !api.caller(supportsStaticESM),
    shouldTransformDynamicImport: modules !== "auto" || !api.caller || !api.caller(supportsDynamicImport),
    shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
  });
  var pluginNames = (0, _filterItems.default)(shippedProposals ? _plugins.default : pluginListWithoutProposals, include.plugins, exclude.plugins, transformTargets, modulesPluginNames, (0, _getOptionSpecificExcludes.default)({
    loose: loose
  }), _shippedProposals.pluginSyntaxMap);
  (0, _filterItems.removeUnnecessaryItems)(pluginNames, _overlappingPlugins.default);
  var polyfillPlugins = getPolyfillPlugins({
    useBuiltIns: useBuiltIns,
    corejs: corejs,
    polyfillTargets: targets,
    include: include.builtIns,
    exclude: exclude.builtIns,
    proposals: proposals,
    shippedProposals: shippedProposals,
    regenerator: pluginNames.has("transform-regenerator"),
    debug: debug
  });
  var pluginUseBuiltIns = useBuiltIns !== false;
  var plugins = Array.from(pluginNames).map(function (pluginName) {
    return [getPlugin(pluginName), {
      spec: spec,
      loose: loose,
      useBuiltIns: pluginUseBuiltIns
    }];
  }).concat(polyfillPlugins);

  if (debug) {
    console.log("@babel/preset-env: `DEBUG` option");
    console.log("\nUsing targets:");
    console.log(JSON.stringify((0, _utils.prettifyTargets)(targets), null, 2));
    console.log("\nUsing modules transform: ".concat(modules.toString()));
    console.log("\nUsing plugins:");
    pluginNames.forEach(function (pluginName) {
      (0, _debug.logPluginOrPolyfill)(pluginName, targets, _plugins.default);
    });

    if (!useBuiltIns) {
      console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
    } else {
      console.log("\nUsing polyfills with `".concat(useBuiltIns, "` option:"));
    }
  }

  return {
    plugins: plugins
  };
});

exports.default = _default;

},{"../data/overlapping-plugins":141,"../data/plugins.json":142,"../data/shipped-proposals":143,"./available-plugins":145,"./debug":146,"./filter-items":147,"./get-option-specific-excludes":148,"./module-transformations":150,"./normalize-options":151,"./polyfills/corejs2/entry-plugin":154,"./polyfills/corejs2/usage-plugin":156,"./polyfills/corejs3/entry-plugin":158,"./polyfills/corejs3/usage-plugin":160,"./polyfills/regenerator/entry-plugin":161,"./polyfills/regenerator/usage-plugin":162,"./targets-parser":163,"./utils":164,"@babel/helper-plugin-utils":79,"semver":1070}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  auto: "transform-modules-commonjs",
  amd: "transform-modules-amd",
  commonjs: "transform-modules-commonjs",
  cjs: "transform-modules-commonjs",
  systemjs: "transform-modules-systemjs",
  umd: "transform-modules-umd"
};
exports.default = _default;

},{}],151:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeCoreJSOption = normalizeCoreJSOption;
exports.default = normalizeOptions;
exports.validateUseBuiltInsOption = exports.validateModulesOption = exports.validateIgnoreBrowserslistConfig = exports.validateBoolOption = exports.validateConfigPathOption = exports.checkDuplicateIncludeExcludes = exports.normalizePluginName = void 0;

var _data = _interopRequireDefault(require("core-js-compat/data"));

var _invariant = _interopRequireDefault(require("invariant"));

var _semver = require("semver");

var _corejs2BuiltIns = _interopRequireDefault(require("../data/corejs2-built-ins.json"));

var _plugins = _interopRequireDefault(require("../data/plugins.json"));

var _moduleTransformations = _interopRequireDefault(require("./module-transformations"));

var _options = require("./options");

var _getPlatformSpecificDefault = require("./polyfills/corejs2/get-platform-specific-default");

var _targetsParser = require("./targets-parser");

var _utils = require("./utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var validateTopLevelOptions = function validateTopLevelOptions(options) {
  var validOptions = Object.keys(_options.TopLevelOptions);

  for (var option in options) {
    if (!_options.TopLevelOptions[option]) {
      throw new Error("Invalid Option: ".concat(option, " is not a valid top-level option.\n        Maybe you meant to use '").concat((0, _utils.findSuggestion)(validOptions, option), "'?"));
    }
  }
};

var allPluginsList = Object.keys(_plugins.default);
var modulePlugins = ["proposal-dynamic-import"].concat(_toConsumableArray(Object.keys(_moduleTransformations.default).map(function (m) {
  return _moduleTransformations.default[m];
})));

var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
  return new Set([].concat(_toConsumableArray(allPluginsList), _toConsumableArray(type === "exclude" ? modulePlugins : []), _toConsumableArray(corejs ? corejs == 2 ? [].concat(_toConsumableArray(Object.keys(_corejs2BuiltIns.default)), _toConsumableArray(_getPlatformSpecificDefault.defaultWebIncludes)) : Object.keys(_data.default) : [])));
};

var pluginToRegExp = function pluginToRegExp(plugin) {
  if (plugin instanceof RegExp) return plugin;

  try {
    return new RegExp("^".concat(normalizePluginName(plugin), "$"));
  } catch (e) {
    return null;
  }
};

var selectPlugins = function selectPlugins(regexp, type, corejs) {
  return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
    return regexp instanceof RegExp && regexp.test(item);
  });
};

var flatten = function flatten(array) {
  var _ref;

  return (_ref = []).concat.apply(_ref, _toConsumableArray(array));
};

var expandIncludesAndExcludes = function expandIncludesAndExcludes() {
  var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var type = arguments.length > 1 ? arguments[1] : undefined;
  var corejs = arguments.length > 2 ? arguments[2] : undefined;
  if (plugins.length === 0) return [];
  var selectedPlugins = plugins.map(function (plugin) {
    return selectPlugins(pluginToRegExp(plugin), type, corejs);
  });
  var invalidRegExpList = plugins.filter(function (p, i) {
    return selectedPlugins[i].length === 0;
  });
  (0, _invariant.default)(invalidRegExpList.length === 0, "Invalid Option: The plugins/built-ins '".concat(invalidRegExpList.join(", "), "' passed to the '").concat(type, "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env"));
  return flatten(selectedPlugins);
};

var normalizePluginName = function normalizePluginName(plugin) {
  return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
};

exports.normalizePluginName = normalizePluginName;

var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes() {
  var include = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var duplicates = include.filter(function (opt) {
    return exclude.indexOf(opt) >= 0;
  });
  (0, _invariant.default)(duplicates.length === 0, "Invalid Option: The plugins/built-ins '".concat(duplicates.join(", "), "' were found in both the \"include\" and\n    \"exclude\" options."));
};

exports.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;

var normalizeTargets = function normalizeTargets(targets) {
  if ((0, _targetsParser.isBrowsersQueryValid)(targets)) {
    return {
      browsers: targets
    };
  }

  return Object.assign({}, targets);
};

var validateConfigPathOption = function validateConfigPathOption() {
  var configPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();
  (0, _invariant.default)(typeof configPath === "string", "Invalid Option: The configPath option '".concat(configPath, "' is invalid, only strings are allowed."));
  return configPath;
};

exports.validateConfigPathOption = validateConfigPathOption;

var validateBoolOption = function validateBoolOption(name, value, defaultValue) {
  if (typeof value === "undefined") {
    value = defaultValue;
  }

  if (typeof value !== "boolean") {
    throw new Error("Preset env: '".concat(name, "' option must be a boolean."));
  }

  return value;
};

exports.validateBoolOption = validateBoolOption;

var validateIgnoreBrowserslistConfig = function validateIgnoreBrowserslistConfig(ignoreBrowserslistConfig) {
  return validateBoolOption(_options.TopLevelOptions.ignoreBrowserslistConfig, ignoreBrowserslistConfig, false);
};

exports.validateIgnoreBrowserslistConfig = validateIgnoreBrowserslistConfig;

var validateModulesOption = function validateModulesOption() {
  var modulesOpt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _options.ModulesOption.auto;
  (0, _invariant.default)(_options.ModulesOption[modulesOpt.toString()] || _options.ModulesOption[modulesOpt.toString()] === _options.ModulesOption.false, "Invalid Option: The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
  return modulesOpt;
};

exports.validateModulesOption = validateModulesOption;

var validateUseBuiltInsOption = function validateUseBuiltInsOption() {
  var builtInsOpt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  (0, _invariant.default)(_options.UseBuiltInsOption[builtInsOpt.toString()] || _options.UseBuiltInsOption[builtInsOpt.toString()] === _options.UseBuiltInsOption.false, "Invalid Option: The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
  return builtInsOpt;
};

exports.validateUseBuiltInsOption = validateUseBuiltInsOption;

function normalizeCoreJSOption(corejs, useBuiltIns) {
  var proposals = false;
  var rawVersion;

  if (useBuiltIns && corejs === undefined) {
    rawVersion = 2;
    console.warn("\nWARNING: We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n");
  } else if (_typeof(corejs) === "object" && corejs !== null) {
    rawVersion = corejs.version;
    proposals = Boolean(corejs.proposals);
  } else {
    rawVersion = corejs;
  }

  var version = rawVersion ? (0, _semver.coerce)(String(rawVersion)) : false;

  if (!useBuiltIns && version) {
    console.log("\nThe `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
  }

  if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
    throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
  }

  return {
    version: version,
    proposals: proposals
  };
}

function normalizeOptions(opts) {
  validateTopLevelOptions(opts);
  var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
  var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
  var include = expandIncludesAndExcludes(opts.include, _options.TopLevelOptions.include, !!corejs.version && corejs.version.major);
  var exclude = expandIncludesAndExcludes(opts.exclude, _options.TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
  checkDuplicateIncludeExcludes(include, exclude);
  var shippedProposals = validateBoolOption(_options.TopLevelOptions.shippedProposals, opts.shippedProposals, false) || corejs.proposals;
  return {
    configPath: validateConfigPathOption(opts.configPath),
    corejs: corejs,
    debug: validateBoolOption(_options.TopLevelOptions.debug, opts.debug, false),
    include: include,
    exclude: exclude,
    forceAllTransforms: validateBoolOption(_options.TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
    ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(opts.ignoreBrowserslistConfig),
    loose: validateBoolOption(_options.TopLevelOptions.loose, opts.loose, false),
    modules: validateModulesOption(opts.modules),
    shippedProposals: shippedProposals,
    spec: validateBoolOption(_options.TopLevelOptions.spec, opts.spec, false),
    targets: normalizeTargets(opts.targets),
    useBuiltIns: useBuiltIns
  };
}

}).call(this,require('_process'))
},{"../data/corejs2-built-ins.json":140,"../data/plugins.json":142,"./module-transformations":150,"./options":152,"./polyfills/corejs2/get-platform-specific-default":155,"./targets-parser":163,"./utils":164,"_process":1054,"core-js-compat/data":303,"invariant":840,"semver":1070}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TargetNames = exports.UseBuiltInsOption = exports.ModulesOption = exports.TopLevelOptions = void 0;
var TopLevelOptions = {
  configPath: "configPath",
  corejs: "corejs",
  debug: "debug",
  exclude: "exclude",
  forceAllTransforms: "forceAllTransforms",
  ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
  include: "include",
  loose: "loose",
  modules: "modules",
  shippedProposals: "shippedProposals",
  spec: "spec",
  targets: "targets",
  useBuiltIns: "useBuiltIns"
};
exports.TopLevelOptions = TopLevelOptions;
var ModulesOption = {
  false: false,
  auto: "auto",
  amd: "amd",
  commonjs: "commonjs",
  cjs: "cjs",
  systemjs: "systemjs",
  umd: "umd"
};
exports.ModulesOption = ModulesOption;
var UseBuiltInsOption = {
  false: false,
  entry: "entry",
  usage: "usage"
};
exports.UseBuiltInsOption = UseBuiltInsOption;
var TargetNames = {
  esmodules: "esmodules",
  node: "node",
  browsers: "browsers",
  chrome: "chrome",
  opera: "opera",
  edge: "edge",
  firefox: "firefox",
  safari: "safari",
  ie: "ie",
  ios: "ios",
  android: "android",
  electron: "electron",
  samsung: "samsung",
  uglify: "uglify"
};
exports.TargetNames = TargetNames;

},{}],153:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StaticProperties = exports.InstanceProperties = exports.BuiltIns = void 0;
var ArrayNatureIterators = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
var CommonIterators = ["es6.string.iterator"].concat(ArrayNatureIterators);
var PromiseDependencies = ["es6.object.to-string", "es6.promise"];
var BuiltIns = {
  DataView: "es6.typed.data-view",
  Float32Array: "es6.typed.float32-array",
  Float64Array: "es6.typed.float64-array",
  Int8Array: "es6.typed.int8-array",
  Int16Array: "es6.typed.int16-array",
  Int32Array: "es6.typed.int32-array",
  Map: ["es6.map"].concat(_toConsumableArray(CommonIterators)),
  Number: "es6.number.constructor",
  Promise: PromiseDependencies,
  RegExp: ["es6.regexp.constructor"],
  Set: ["es6.set"].concat(_toConsumableArray(CommonIterators)),
  Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
  Uint8Array: "es6.typed.uint8-array",
  Uint8ClampedArray: "es6.typed.uint8-clamped-array",
  Uint16Array: "es6.typed.uint16-array",
  Uint32Array: "es6.typed.uint32-array",
  WeakMap: ["es6.weak-map"].concat(_toConsumableArray(CommonIterators)),
  WeakSet: ["es6.weak-set"].concat(_toConsumableArray(CommonIterators))
};
exports.BuiltIns = BuiltIns;
var InstanceProperties = {
  __defineGetter__: ["es7.object.define-getter"],
  __defineSetter__: ["es7.object.define-setter"],
  __lookupGetter__: ["es7.object.lookup-getter"],
  __lookupSetter__: ["es7.object.lookup-setter"],
  anchor: ["es6.string.anchor"],
  big: ["es6.string.big"],
  bind: ["es6.function.bind"],
  blink: ["es6.string.blink"],
  bold: ["es6.string.bold"],
  codePointAt: ["es6.string.code-point-at"],
  copyWithin: ["es6.array.copy-within"],
  endsWith: ["es6.string.ends-with"],
  entries: ArrayNatureIterators,
  every: ["es6.array.is-array"],
  fill: ["es6.array.fill"],
  filter: ["es6.array.filter"],
  finally: ["es7.promise.finally"].concat(PromiseDependencies),
  find: ["es6.array.find"],
  findIndex: ["es6.array.find-index"],
  fixed: ["es6.string.fixed"],
  flags: ["es6.regexp.flags"],
  flatMap: ["es7.array.flat-map"],
  fontcolor: ["es6.string.fontcolor"],
  fontsize: ["es6.string.fontsize"],
  forEach: ["es6.array.for-each"],
  includes: ["es6.string.includes", "es7.array.includes"],
  indexOf: ["es6.array.index-of"],
  italics: ["es6.string.italics"],
  keys: ArrayNatureIterators,
  lastIndexOf: ["es6.array.last-index-of"],
  link: ["es6.string.link"],
  map: ["es6.array.map"],
  match: ["es6.regexp.match"],
  name: ["es6.function.name"],
  padStart: ["es7.string.pad-start"],
  padEnd: ["es7.string.pad-end"],
  reduce: ["es6.array.reduce"],
  reduceRight: ["es6.array.reduce-right"],
  repeat: ["es6.string.repeat"],
  replace: ["es6.regexp.replace"],
  search: ["es6.regexp.search"],
  slice: ["es6.array.slice"],
  small: ["es6.string.small"],
  some: ["es6.array.some"],
  sort: ["es6.array.sort"],
  split: ["es6.regexp.split"],
  startsWith: ["es6.string.starts-with"],
  strike: ["es6.string.strike"],
  sub: ["es6.string.sub"],
  sup: ["es6.string.sup"],
  toISOString: ["es6.date.to-iso-string"],
  toJSON: ["es6.date.to-json"],
  toString: ["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"],
  trim: ["es6.string.trim"],
  trimEnd: ["es7.string.trim-right"],
  trimLeft: ["es7.string.trim-left"],
  trimRight: ["es7.string.trim-right"],
  trimStart: ["es7.string.trim-left"],
  values: ArrayNatureIterators
};
exports.InstanceProperties = InstanceProperties;
var StaticProperties = {
  Array: {
    from: ["es6.array.from", "es6.string.iterator"],
    isArray: "es6.array.is-array",
    of: "es6.array.of"
  },
  Date: {
    now: "es6.date.now"
  },
  Object: {
    assign: "es6.object.assign",
    create: "es6.object.create",
    defineProperty: "es6.object.define-property",
    defineProperties: "es6.object.define-properties",
    entries: "es7.object.entries",
    freeze: "es6.object.freeze",
    getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
    getOwnPropertySymbols: "es6.symbol",
    is: "es6.object.is",
    isExtensible: "es6.object.is-extensible",
    isFrozen: "es6.object.is-frozen",
    isSealed: "es6.object.is-sealed",
    keys: "es6.object.keys",
    preventExtensions: "es6.object.prevent-extensions",
    seal: "es6.object.seal",
    setPrototypeOf: "es6.object.set-prototype-of",
    values: "es7.object.values"
  },
  Math: {
    acosh: "es6.math.acosh",
    asinh: "es6.math.asinh",
    atanh: "es6.math.atanh",
    cbrt: "es6.math.cbrt",
    clz32: "es6.math.clz32",
    cosh: "es6.math.cosh",
    expm1: "es6.math.expm1",
    fround: "es6.math.fround",
    hypot: "es6.math.hypot",
    imul: "es6.math.imul",
    log1p: "es6.math.log1p",
    log10: "es6.math.log10",
    log2: "es6.math.log2",
    sign: "es6.math.sign",
    sinh: "es6.math.sinh",
    tanh: "es6.math.tanh",
    trunc: "es6.math.trunc"
  },
  String: {
    fromCodePoint: "es6.string.from-code-point",
    raw: "es6.string.raw"
  },
  Number: {
    EPSILON: "es6.number.epsilon",
    MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
    MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
    isFinite: "es6.number.is-finite",
    isInteger: "es6.number.is-integer",
    isSafeInteger: "es6.number.is-safe-integer",
    isNaN: "es6.number.is-nan",
    parseFloat: "es6.number.parse-float",
    parseInt: "es6.number.parse-int"
  },
  Promise: {
    all: CommonIterators,
    race: CommonIterators
  },
  Reflect: {
    apply: "es6.reflect.apply",
    construct: "es6.reflect.construct",
    defineProperty: "es6.reflect.define-property",
    deleteProperty: "es6.reflect.delete-property",
    get: "es6.reflect.get",
    getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
    getPrototypeOf: "es6.reflect.get-prototype-of",
    has: "es6.reflect.has",
    isExtensible: "es6.reflect.is-extensible",
    ownKeys: "es6.reflect.own-keys",
    preventExtensions: "es6.reflect.prevent-extensions",
    set: "es6.reflect.set",
    setPrototypeOf: "es6.reflect.set-prototype-of"
  }
};
exports.StaticProperties = StaticProperties;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _corejs2BuiltIns = _interopRequireDefault(require("../../../data/corejs2-built-ins.json"));

var _getPlatformSpecificDefault = _interopRequireDefault(require("./get-platform-specific-default"));

var _filterItems = _interopRequireDefault(require("../../filter-items"));

var _utils = require("../../utils");

var _debug = require("../../debug");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _default(_, _ref) {
  var include = _ref.include,
      exclude = _ref.exclude,
      polyfillTargets = _ref.polyfillTargets,
      regenerator = _ref.regenerator,
      debug = _ref.debug;
  var polyfills = (0, _filterItems.default)(_corejs2BuiltIns.default, include, exclude, polyfillTargets, (0, _getPlatformSpecificDefault.default)(polyfillTargets));
  var isPolyfillImport = {
    ImportDeclaration: function ImportDeclaration(path) {
      if ((0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path))) {
        this.replaceBySeparateModulesImport(path);
      }
    },
    Program: function Program(path) {
      var _this = this;

      path.get("body").forEach(function (bodyPath) {
        if ((0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath))) {
          _this.replaceBySeparateModulesImport(bodyPath);
        }
      });
    }
  };
  return {
    name: "corejs2-entry",
    visitor: isPolyfillImport,
    pre: function pre() {
      this.importPolyfillIncluded = false;

      this.replaceBySeparateModulesImport = function (path) {
        this.importPolyfillIncluded = true;

        if (regenerator) {
          (0, _utils.createImport)(path, "regenerator-runtime");
        }

        var modules = Array.from(polyfills).reverse();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var module = _step.value;
            (0, _utils.createImport)(path, module);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        path.remove();
      };
    },
    post: function post() {
      if (debug) {
        (0, _debug.logEntryPolyfills)("@babel/polyfill", this.importPolyfillIncluded, polyfills, this.file.opts.filename, polyfillTargets, _corejs2BuiltIns.default);
      }
    }
  };
}

},{"../../../data/corejs2-built-ins.json":140,"../../debug":146,"../../filter-items":147,"../../utils":164,"./get-platform-specific-default":155}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.defaultWebIncludes = void 0;
var defaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
exports.defaultWebIncludes = defaultWebIncludes;

function _default(targets) {
  var targetNames = Object.keys(targets);
  var isAnyTarget = !targetNames.length;
  var isWebTarget = targetNames.some(function (name) {
    return name !== "node";
  });
  return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
}

},{}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _corejs2BuiltIns = _interopRequireDefault(require("../../../data/corejs2-built-ins.json"));

var _getPlatformSpecificDefault = _interopRequireDefault(require("./get-platform-specific-default"));

var _filterItems = _interopRequireDefault(require("../../filter-items"));

var _builtInDefinitions = require("./built-in-definitions");

var _utils = require("../../utils");

var _debug = require("../../debug");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@babel/polyfill'` call or use `useBuiltIns: 'entry'` instead.";

function _default(_ref2, _ref3) {
  var t = _ref2.types;
  var include = _ref3.include,
      exclude = _ref3.exclude,
      polyfillTargets = _ref3.polyfillTargets,
      debug = _ref3.debug;
  var polyfills = (0, _filterItems.default)(_corejs2BuiltIns.default, include, exclude, polyfillTargets, (0, _getPlatformSpecificDefault.default)(polyfillTargets));
  var addAndRemovePolyfillImports = {
    ImportDeclaration: function ImportDeclaration(path) {
      if ((0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path))) {
        console.warn(NO_DIRECT_POLYFILL_IMPORT);
        path.remove();
      }
    },
    Program: function Program(path) {
      path.get("body").forEach(function (bodyPath) {
        if ((0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath))) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT);
          bodyPath.remove();
        }
      });
    },
    ReferencedIdentifier: function ReferencedIdentifier(_ref4) {
      var name = _ref4.node.name,
          parent = _ref4.parent,
          scope = _ref4.scope;
      if (t.isMemberExpression(parent)) return;
      if (!(0, _utils.has)(_builtInDefinitions.BuiltIns, name)) return;
      if (scope.getBindingIdentifier(name)) return;
      var BuiltInDependencies = _builtInDefinitions.BuiltIns[name];
      this.addUnsupported(BuiltInDependencies);
    },
    CallExpression: function CallExpression(path) {
      if (path.node.arguments.length) return;
      var callee = path.node.callee;
      if (!t.isMemberExpression(callee)) return;
      if (!callee.computed) return;

      if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
        return;
      }

      this.addImport("web.dom.iterable");
    },
    BinaryExpression: function BinaryExpression(path) {
      if (path.node.operator !== "in") return;
      if (!path.get("left").matchesPattern("Symbol.iterator")) return;
      this.addImport("web.dom.iterable");
    },
    YieldExpression: function YieldExpression(path) {
      if (path.node.delegate) {
        this.addImport("web.dom.iterable");
      }
    },
    MemberExpression: {
      enter: function enter(path) {
        var node = path.node;
        var object = node.object,
            property = node.property;
        if ((0, _utils.isNamespaced)(path.get("object"))) return;
        var evaluatedPropType = object.name;
        var propertyName = "";
        var instanceType = "";

        if (node.computed) {
          if (t.isStringLiteral(property)) {
            propertyName = property.value;
          } else {
            var result = path.get("property").evaluate();

            if (result.confident && result.value) {
              propertyName = result.value;
            }
          }
        } else {
          propertyName = property.name;
        }

        if (path.scope.getBindingIdentifier(object.name)) {
          var _result = path.get("object").evaluate();

          if (_result.value) {
            instanceType = (0, _utils.getType)(_result.value);
          } else if (_result.deopt && _result.deopt.isIdentifier()) {
            evaluatedPropType = _result.deopt.node.name;
          }
        }

        if ((0, _utils.has)(_builtInDefinitions.StaticProperties, evaluatedPropType)) {
          var BuiltInProperties = _builtInDefinitions.StaticProperties[evaluatedPropType];

          if ((0, _utils.has)(BuiltInProperties, propertyName)) {
            var StaticPropertyDependencies = BuiltInProperties[propertyName];
            this.addUnsupported(StaticPropertyDependencies);
          }
        }

        if ((0, _utils.has)(_builtInDefinitions.InstanceProperties, propertyName)) {
          var InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[propertyName];

          if (instanceType) {
            InstancePropertyDependencies = InstancePropertyDependencies.filter(function (module) {
              return module.includes(instanceType);
            });
          }

          this.addUnsupported(InstancePropertyDependencies);
        }
      },
      exit: function exit(path) {
        var name = path.node.object.name;
        if (!(0, _utils.has)(_builtInDefinitions.BuiltIns, name)) return;
        if (path.scope.getBindingIdentifier(name)) return;
        var BuiltInDependencies = _builtInDefinitions.BuiltIns[name];
        this.addUnsupported(BuiltInDependencies);
      }
    },
    VariableDeclarator: function VariableDeclarator(path) {
      var node = path.node;
      var id = node.id,
          init = node.init;
      if (!t.isObjectPattern(id)) return;
      if (init && path.scope.getBindingIdentifier(init.name)) return;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = id.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;
          var key = _ref.key;

          if (!node.computed && t.isIdentifier(key) && (0, _utils.has)(_builtInDefinitions.InstanceProperties, key.name)) {
            var InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[key.name];
            this.addUnsupported(InstancePropertyDependencies);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
  return {
    name: "corejs2-usage",
    pre: function pre(_ref5) {
      var path = _ref5.path;
      this.polyfillsSet = new Set();

      this.addImport = function (builtIn) {
        if (!this.polyfillsSet.has(builtIn)) {
          this.polyfillsSet.add(builtIn);
          (0, _utils.createImport)(path, builtIn);
        }
      };

      this.addUnsupported = function (builtIn) {
        var modules = Array.isArray(builtIn) ? builtIn : [builtIn];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var module = _step2.value;

            if (polyfills.has(module)) {
              this.addImport(module);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      };
    },
    post: function post() {
      if (debug) {
        (0, _debug.logUsagePolyfills)(this.polyfillsSet, this.file.opts.filename, polyfillTargets, _corejs2BuiltIns.default);
      }
    },
    visitor: addAndRemovePolyfillImports
  };
}

},{"../../../data/corejs2-built-ins.json":140,"../../debug":146,"../../filter-items":147,"../../utils":164,"./built-in-definitions":153,"./get-platform-specific-default":155}],157:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PossibleGlobalObjects = exports.CommonInstanceDependencies = exports.StaticProperties = exports.InstanceProperties = exports.BuiltIns = exports.PromiseDependencies = exports.CommonIterators = void 0;
var ArrayNatureIterators = ["es.array.iterator", "web.dom-collections.iterator"];
var CommonIterators = ["es.string.iterator"].concat(ArrayNatureIterators);
exports.CommonIterators = CommonIterators;
var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators);
var CommonIteratorsWithTag = ["es.object.to-string"].concat(_toConsumableArray(CommonIterators));
var TypedArrayDependencies = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
var TypedArrayStaticMethods = {
  from: "es.typed-array.from",
  of: "es.typed-array.of"
};
var PromiseDependencies = ["es.promise", "es.object.to-string"];
exports.PromiseDependencies = PromiseDependencies;
var PromiseDependenciesWithIterators = [].concat(PromiseDependencies, _toConsumableArray(CommonIterators));
var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(_toConsumableArray(CommonIteratorsWithTag));
var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(_toConsumableArray(CommonIteratorsWithTag));
var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag));
var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag));
var URLSearchParamsDependencies = ["web.url"].concat(_toConsumableArray(CommonIteratorsWithTag));
var BuiltIns = {
  AggregateError: ["esnext.aggregate-error"].concat(_toConsumableArray(CommonIterators)),
  ArrayBuffer: ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"],
  DataView: ["es.data-view", "es.array-buffer.slice", "es.object.to-string"],
  Date: ["es.date.to-string"],
  Float32Array: ["es.typed-array.float32-array"].concat(TypedArrayDependencies),
  Float64Array: ["es.typed-array.float64-array"].concat(TypedArrayDependencies),
  Int8Array: ["es.typed-array.int8-array"].concat(TypedArrayDependencies),
  Int16Array: ["es.typed-array.int16-array"].concat(TypedArrayDependencies),
  Int32Array: ["es.typed-array.int32-array"].concat(TypedArrayDependencies),
  Uint8Array: ["es.typed-array.uint8-array"].concat(TypedArrayDependencies),
  Uint8ClampedArray: ["es.typed-array.uint8-clamped-array"].concat(TypedArrayDependencies),
  Uint16Array: ["es.typed-array.uint16-array"].concat(TypedArrayDependencies),
  Uint32Array: ["es.typed-array.uint32-array"].concat(TypedArrayDependencies),
  Map: MapDependencies,
  Number: ["es.number.constructor"],
  Observable: ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(_toConsumableArray(CommonIteratorsWithTag)),
  Promise: PromiseDependencies,
  RegExp: ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"],
  Set: SetDependencies,
  Symbol: SymbolDependencies,
  URL: ["web.url"].concat(_toConsumableArray(URLSearchParamsDependencies)),
  URLSearchParams: URLSearchParamsDependencies,
  WeakMap: WeakMapDependencies,
  WeakSet: WeakSetDependencies,
  clearImmediate: ["web.immediate"],
  compositeKey: ["esnext.composite-key"],
  compositeSymbol: ["esnext.composite-symbol"].concat(SymbolDependencies),
  fetch: PromiseDependencies,
  globalThis: ["esnext.global-this"],
  parseFloat: ["es.parse-float"],
  parseInt: ["es.parse-int"],
  queueMicrotask: ["web.queue-microtask"],
  setTimeout: ["web.timers"],
  setInterval: ["web.timers"],
  setImmediate: ["web.immediate"]
};
exports.BuiltIns = BuiltIns;
var InstanceProperties = {
  at: ["esnext.string.at"],
  anchor: ["es.string.anchor"],
  big: ["es.string.big"],
  bind: ["es.function.bind"],
  blink: ["es.string.blink"],
  bold: ["es.string.bold"],
  codePointAt: ["es.string.code-point-at"],
  codePoints: ["esnext.string.code-points"],
  concat: ["es.array.concat"],
  copyWithin: ["es.array.copy-within"],
  description: ["es.symbol", "es.symbol.description"],
  endsWith: ["es.string.ends-with"],
  entries: ArrayNatureIteratorsWithTag,
  every: ["es.array.every"],
  exec: ["es.regexp.exec"],
  fill: ["es.array.fill"],
  filter: ["es.array.filter"],
  finally: ["es.promise.finally"].concat(PromiseDependencies),
  find: ["es.array.find"],
  findIndex: ["es.array.find-index"],
  fixed: ["es.string.fixed"],
  flags: ["es.regexp.flags"],
  flat: ["es.array.flat", "es.array.unscopables.flat"],
  flatMap: ["es.array.flat-map", "es.array.unscopables.flat-map"],
  fontcolor: ["es.string.fontcolor"],
  fontsize: ["es.string.fontsize"],
  forEach: ["es.array.for-each", "web.dom-collections.for-each"],
  includes: ["es.array.includes", "es.string.includes"],
  indexOf: ["es.array.index-of"],
  italics: ["es.string.italics"],
  join: ["es.array.join"],
  keys: ArrayNatureIteratorsWithTag,
  lastIndex: ["esnext.array.last-index"],
  lastIndexOf: ["es.array.last-index-of"],
  lastItem: ["esnext.array.last-item"],
  link: ["es.string.link"],
  match: ["es.string.match", "es.regexp.exec"],
  matchAll: ["esnext.string.match-all"],
  map: ["es.array.map"],
  name: ["es.function.name"],
  padEnd: ["es.string.pad-end"],
  padStart: ["es.string.pad-start"],
  reduce: ["es.array.reduce"],
  reduceRight: ["es.array.reduce-right"],
  repeat: ["es.string.repeat"],
  replace: ["es.string.replace", "es.regexp.exec"],
  replaceAll: ["esnext.string.replace-all"],
  reverse: ["es.array.reverse"],
  search: ["es.string.search", "es.regexp.exec"],
  slice: ["es.array.slice"],
  small: ["es.string.small"],
  some: ["es.array.some"],
  sort: ["es.array.sort"],
  splice: ["es.array.splice"],
  split: ["es.string.split", "es.regexp.exec"],
  startsWith: ["es.string.starts-with"],
  strike: ["es.string.strike"],
  sub: ["es.string.sub"],
  sup: ["es.string.sup"],
  toFixed: ["es.number.to-fixed"],
  toISOString: ["es.date.to-iso-string"],
  toJSON: ["es.date.to-json", "web.url.to-json"],
  toPrecision: ["es.number.to-precision"],
  toString: ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"],
  trim: ["es.string.trim"],
  trimEnd: ["es.string.trim-end"],
  trimLeft: ["es.string.trim-start"],
  trimRight: ["es.string.trim-end"],
  trimStart: ["es.string.trim-start"],
  values: ArrayNatureIteratorsWithTag,
  __defineGetter__: ["es.object.define-getter"],
  __defineSetter__: ["es.object.define-setter"],
  __lookupGetter__: ["es.object.lookup-getter"],
  __lookupSetter__: ["es.object.lookup-setter"]
};
exports.InstanceProperties = InstanceProperties;
var StaticProperties = {
  Array: {
    from: ["es.array.from", "es.string.iterator"],
    isArray: ["es.array.is-array"],
    of: ["es.array.of"]
  },
  Date: {
    now: "es.date.now"
  },
  Object: {
    assign: "es.object.assign",
    create: "es.object.create",
    defineProperty: "es.object.define-property",
    defineProperties: "es.object.define-properties",
    entries: "es.object.entries",
    freeze: "es.object.freeze",
    fromEntries: ["es.object.from-entries", "es.array.iterator"],
    getOwnPropertyDescriptor: "es.object.get-own-property-descriptor",
    getOwnPropertyDescriptors: "es.object.get-own-property-descriptors",
    getOwnPropertyNames: "es.object.get-own-property-names",
    getOwnPropertySymbols: "es.symbol",
    getPrototypeOf: "es.object.get-prototype-of",
    is: "es.object.is",
    isExtensible: "es.object.is-extensible",
    isFrozen: "es.object.is-frozen",
    isSealed: "es.object.is-sealed",
    keys: "es.object.keys",
    preventExtensions: "es.object.prevent-extensions",
    seal: "es.object.seal",
    setPrototypeOf: "es.object.set-prototype-of",
    values: "es.object.values"
  },
  Math: {
    DEG_PER_RAD: "esnext.math.deg-per-rad",
    RAD_PER_DEG: "esnext.math.rad-per-deg",
    acosh: "es.math.acosh",
    asinh: "es.math.asinh",
    atanh: "es.math.atanh",
    cbrt: "es.math.cbrt",
    clamp: "esnext.math.clamp",
    clz32: "es.math.clz32",
    cosh: "es.math.cosh",
    degrees: "esnext.math.degrees",
    expm1: "es.math.expm1",
    fround: "es.math.fround",
    fscale: "esnext.math.fscale",
    hypot: "es.math.hypot",
    iaddh: "esnext.math.iaddh",
    imul: "es.math.imul",
    imulh: "esnext.math.imulh",
    isubh: "esnext.math.isubh",
    log1p: "es.math.log1p",
    log10: "es.math.log10",
    log2: "es.math.log2",
    radians: "esnext.math.radians",
    scale: "esnext.math.scale",
    seededPRNG: "esnext.math.seeded-prng",
    sign: "es.math.sign",
    signbit: "esnext.math.signbit",
    sinh: "es.math.sinh",
    tanh: "es.math.tanh",
    trunc: "es.math.trunc",
    umulh: "esnext.math.umulh"
  },
  String: {
    fromCodePoint: "es.string.from-code-point",
    raw: "es.string.raw"
  },
  Number: {
    EPSILON: "es.number.epsilon",
    MIN_SAFE_INTEGER: "es.number.min-safe-integer",
    MAX_SAFE_INTEGER: "es.number.max-safe-integer",
    fromString: "esnext.number.from-string",
    isFinite: "es.number.is-finite",
    isInteger: "es.number.is-integer",
    isSafeInteger: "es.number.is-safe-integer",
    isNaN: "es.number.is-nan",
    parseFloat: "es.number.parse-float",
    parseInt: "es.number.parse-int"
  },
  Map: {
    from: ["esnext.map.from"].concat(_toConsumableArray(MapDependencies)),
    groupBy: ["esnext.map.group-by"].concat(_toConsumableArray(MapDependencies)),
    keyBy: ["esnext.map.key-by"].concat(_toConsumableArray(MapDependencies)),
    of: ["esnext.map.of"].concat(_toConsumableArray(MapDependencies))
  },
  Set: {
    from: ["esnext.set.from"].concat(_toConsumableArray(SetDependencies)),
    of: ["esnext.set.of"].concat(_toConsumableArray(SetDependencies))
  },
  WeakMap: {
    from: ["esnext.weak-map.from"].concat(_toConsumableArray(WeakMapDependencies)),
    of: ["esnext.weak-map.of"].concat(_toConsumableArray(WeakMapDependencies))
  },
  WeakSet: {
    from: ["esnext.weak-set.from"].concat(_toConsumableArray(WeakSetDependencies)),
    of: ["esnext.weak-set.of"].concat(_toConsumableArray(WeakSetDependencies))
  },
  Promise: {
    all: PromiseDependenciesWithIterators,
    allSettled: ["esnext.promise.all-settled"].concat(_toConsumableArray(PromiseDependenciesWithIterators)),
    any: ["esnext.promise.any"].concat(_toConsumableArray(PromiseDependenciesWithIterators)),
    race: PromiseDependenciesWithIterators,
    try: ["esnext.promise.try"].concat(_toConsumableArray(PromiseDependenciesWithIterators))
  },
  Reflect: {
    apply: "es.reflect.apply",
    construct: "es.reflect.construct",
    defineMetadata: "esnext.reflect.define-metadata",
    defineProperty: "es.reflect.define-property",
    deleteMetadata: "esnext.reflect.delete-metadata",
    deleteProperty: "es.reflect.delete-property",
    get: "es.reflect.get",
    getMetadata: "esnext.reflect.get-metadata",
    getMetadataKeys: "esnext.reflect.get-metadata-keys",
    getOwnMetadata: "esnext.reflect.get-own-metadata",
    getOwnMetadataKeys: "esnext.reflect.get-own-metadata-keys",
    getOwnPropertyDescriptor: "es.reflect.get-own-property-descriptor",
    getPrototypeOf: "es.reflect.get-prototype-of",
    has: "es.reflect.has",
    hasMetadata: "esnext.reflect.has-metadata",
    hasOwnMetadata: "esnext.reflect.has-own-metadata",
    isExtensible: "es.reflect.is-extensible",
    metadata: "esnext.reflect.metadata",
    ownKeys: "es.reflect.own-keys",
    preventExtensions: "es.reflect.prevent-extensions",
    set: "es.reflect.set",
    setPrototypeOf: "es.reflect.set-prototype-of"
  },
  Symbol: {
    asyncIterator: ["es.symbol.async-iterator"],
    dispose: ["esnext.symbol.dispose"],
    hasInstance: ["es.symbol.has-instance", "es.function.has-instance"],
    isConcatSpreadable: ["es.symbol.is-concat-spreadable", "es.array.concat"],
    iterator: ["es.symbol.iterator"].concat(_toConsumableArray(CommonIteratorsWithTag)),
    match: ["es.symbol.match", "es.string.match"],
    observable: ["esnext.symbol.observable"],
    patternMatch: ["esnext.symbol.pattern-match"],
    replace: ["es.symbol.replace", "es.string.replace"],
    search: ["es.symbol.search", "es.string.search"],
    species: ["es.symbol.species", "es.array.species"],
    split: ["es.symbol.split", "es.string.split"],
    toPrimitive: ["es.symbol.to-primitive", "es.date.to-primitive"],
    toStringTag: ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"],
    unscopables: ["es.symbol.unscopables"]
  },
  ArrayBuffer: {
    isView: ["es.array-buffer.is-view"]
  },
  Int8Array: TypedArrayStaticMethods,
  Uint8Array: TypedArrayStaticMethods,
  Uint8ClampedArray: TypedArrayStaticMethods,
  Int16Array: TypedArrayStaticMethods,
  Uint16Array: TypedArrayStaticMethods,
  Int32Array: TypedArrayStaticMethods,
  Uint32Array: TypedArrayStaticMethods,
  Float32Array: TypedArrayStaticMethods,
  Float64Array: TypedArrayStaticMethods
};
exports.StaticProperties = StaticProperties;
var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);
exports.CommonInstanceDependencies = CommonInstanceDependencies;
var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);
exports.PossibleGlobalObjects = PossibleGlobalObjects;

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _data = _interopRequireDefault(require("core-js-compat/data"));

var _entries = _interopRequireDefault(require("core-js-compat/entries"));

var _getModulesListForTargetVersion = _interopRequireDefault(require("core-js-compat/get-modules-list-for-target-version"));

var _filterItems = _interopRequireDefault(require("../../filter-items"));

var _utils = require("../../utils");

var _debug = require("../../debug");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isBabelPolyfillSource(source) {
  return source === "@babel/polyfill" || source === "babel-polyfill";
}

function isCoreJSSource(source) {
  if (typeof source === "string") {
    source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
  }

  return (0, _utils.has)(_entries.default, source) && _entries.default[source];
}

var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";

function _default(_, _ref) {
  var corejs = _ref.corejs,
      include = _ref.include,
      exclude = _ref.exclude,
      polyfillTargets = _ref.polyfillTargets,
      debug = _ref.debug;
  var polyfills = (0, _filterItems.default)(_data.default, include, exclude, polyfillTargets, null);
  var available = new Set((0, _getModulesListForTargetVersion.default)(corejs.version));

  function shouldReplace(source, modules) {
    if (!modules) return false;

    if (modules.length === 1 && polyfills.has(modules[0]) && available.has(modules[0]) && (0, _utils.getModulePath)(modules[0]) === source) {
      return false;
    }

    return true;
  }

  var isPolyfillImport = {
    ImportDeclaration: function ImportDeclaration(path) {
      var source = (0, _utils.getImportSource)(path);
      if (!source) return;

      if (isBabelPolyfillSource(source)) {
        console.warn(BABEL_POLYFILL_DEPRECATION);
      } else {
        var modules = isCoreJSSource(source);

        if (shouldReplace(source, modules)) {
          this.replaceBySeparateModulesImport(path, modules);
        }
      }
    },
    Program: {
      enter: function enter(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          var source = (0, _utils.getRequireSource)(bodyPath);
          if (!source) return;

          if (isBabelPolyfillSource(source)) {
            console.warn(BABEL_POLYFILL_DEPRECATION);
          } else {
            var modules = isCoreJSSource(source);

            if (shouldReplace(source, modules)) {
              _this.replaceBySeparateModulesImport(bodyPath, modules);
            }
          }
        });
      },
      exit: function exit(path) {
        var _this2 = this;

        var filtered = (0, _utils.intersection)(polyfills, this.polyfillsSet, available);
        var reversed = Array.from(filtered).reverse();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = reversed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var module = _step.value;

            if (!this.injectedPolyfills.has(module)) {
              (0, _utils.createImport)(path, module);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        filtered.forEach(function (module) {
          return _this2.injectedPolyfills.add(module);
        });
      }
    }
  };
  return {
    name: "corejs3-entry",
    visitor: isPolyfillImport,
    pre: function pre() {
      this.injectedPolyfills = new Set();
      this.polyfillsSet = new Set();

      this.replaceBySeparateModulesImport = function (path, modules) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var module = _step2.value;
            this.polyfillsSet.add(module);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        path.remove();
      };
    },
    post: function post() {
      if (debug) {
        (0, _debug.logEntryPolyfills)("core-js", this.injectedPolyfills.size > 0, this.injectedPolyfills, this.file.opts.filename, polyfillTargets, _data.default);
      }
    }
  };
}

},{"../../debug":146,"../../filter-items":147,"../../utils":164,"core-js-compat/data":303,"core-js-compat/entries":304,"core-js-compat/get-modules-list-for-target-version":305}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = ["esnext.global-this", "esnext.string.match-all"];
exports.default = _default;

},{}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _data = _interopRequireDefault(require("core-js-compat/data"));

var _shippedProposals = _interopRequireDefault(require("./shipped-proposals"));

var _getModulesListForTargetVersion = _interopRequireDefault(require("core-js-compat/get-modules-list-for-target-version"));

var _filterItems = _interopRequireDefault(require("../../filter-items"));

var _builtInDefinitions = require("./built-in-definitions");

var _utils = require("../../utils");

var _debug = require("../../debug");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.";
var corejs3PolyfillsWithoutProposals = Object.keys(_data.default).filter(function (name) {
  return !name.startsWith("esnext.");
}).reduce(function (memo, key) {
  memo[key] = _data.default[key];
  return memo;
}, {});

var corejs3PolyfillsWithShippedProposals = _shippedProposals.default.reduce(function (memo, key) {
  memo[key] = _data.default[key];
  return memo;
}, Object.assign({}, corejs3PolyfillsWithoutProposals));

function _default(_, _ref) {
  var corejs = _ref.corejs,
      include = _ref.include,
      exclude = _ref.exclude,
      polyfillTargets = _ref.polyfillTargets,
      proposals = _ref.proposals,
      shippedProposals = _ref.shippedProposals,
      debug = _ref.debug;
  var polyfills = (0, _filterItems.default)(proposals ? _data.default : shippedProposals ? corejs3PolyfillsWithShippedProposals : corejs3PolyfillsWithoutProposals, include, exclude, polyfillTargets, null);
  var available = new Set((0, _getModulesListForTargetVersion.default)(corejs.version));

  function resolveKey(path, computed) {
    var node = path.node,
        parent = path.parent,
        scope = path.scope;
    if (path.isStringLiteral()) return node.value;
    var name = node.name;
    var isIdentifier = path.isIdentifier();
    if (isIdentifier && !(computed || parent.computed)) return name;

    if (!isIdentifier || scope.getBindingIdentifier(name)) {
      var _path$evaluate = path.evaluate(),
          value = _path$evaluate.value;

      if (typeof value === "string") return value;
    }
  }

  function resolveSource(path) {
    var node = path.node,
        scope = path.scope;
    var builtIn, instanceType;

    if (node) {
      builtIn = node.name;

      if (!path.isIdentifier() || scope.getBindingIdentifier(builtIn)) {
        var _path$evaluate2 = path.evaluate(),
            deopt = _path$evaluate2.deopt,
            value = _path$evaluate2.value;

        if (value !== undefined) {
          instanceType = (0, _utils.getType)(value);
        } else if (deopt && deopt.isIdentifier()) {
          builtIn = deopt.node.name;
        }
      }
    }

    return {
      builtIn: builtIn,
      instanceType: instanceType,
      isNamespaced: (0, _utils.isNamespaced)(path)
    };
  }

  var addAndRemovePolyfillImports = {
    ImportDeclaration: function ImportDeclaration(path) {
      if ((0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path))) {
        console.warn(NO_DIRECT_POLYFILL_IMPORT);
        path.remove();
      }
    },
    Program: {
      enter: function enter(path) {
        path.get("body").forEach(function (bodyPath) {
          if ((0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath))) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT);
            bodyPath.remove();
          }
        });
      },
      exit: function exit(path) {
        var _this = this;

        var filtered = (0, _utils.intersection)(polyfills, this.polyfillsSet, available);
        var reversed = Array.from(filtered).reverse();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = reversed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var module = _step.value;

            if (!this.injectedPolyfills.has(module)) {
              (0, _utils.createImport)(path, module);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        filtered.forEach(function (module) {
          return _this.injectedPolyfills.add(module);
        });
      }
    },
    Import: function Import() {
      this.addUnsupported(_builtInDefinitions.PromiseDependencies);
    },
    Function: function Function(_ref2) {
      var node = _ref2.node;

      if (node.async) {
        this.addUnsupported(_builtInDefinitions.PromiseDependencies);
      }
    },
    "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern() {
      this.addUnsupported(_builtInDefinitions.CommonIterators);
    },
    SpreadElement: function SpreadElement(_ref3) {
      var parentPath = _ref3.parentPath;

      if (!parentPath.isObjectExpression()) {
        this.addUnsupported(_builtInDefinitions.CommonIterators);
      }
    },
    YieldExpression: function YieldExpression(_ref4) {
      var node = _ref4.node;

      if (node.delegate) {
        this.addUnsupported(_builtInDefinitions.CommonIterators);
      }
    },
    ReferencedIdentifier: function ReferencedIdentifier(_ref5) {
      var name = _ref5.node.name,
          scope = _ref5.scope;
      if (scope.getBindingIdentifier(name)) return;
      this.addBuiltInDependencies(name);
    },
    MemberExpression: function MemberExpression(path) {
      var source = resolveSource(path.get("object"));
      var key = resolveKey(path.get("property"));
      this.addPropertyDependencies(source, key);
    },
    ObjectPattern: function ObjectPattern(path) {
      var parentPath = path.parentPath,
          parent = path.parent,
          key = path.key;
      var source;

      if (parentPath.isVariableDeclarator()) {
        source = resolveSource(parentPath.get("init"));
      } else if (parentPath.isAssignmentExpression()) {
        source = resolveSource(parentPath.get("right"));
      } else if (parentPath.isFunctionExpression()) {
        var grand = parentPath.parentPath;

        if (grand.isCallExpression() || grand.isNewExpression()) {
          if (grand.node.callee === parent) {
            source = resolveSource(grand.get("arguments")[key]);
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = path.get("properties")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var property = _step2.value;

          if (property.isObjectProperty()) {
            var _key = resolveKey(property.get("key"));

            this.addPropertyDependencies(source, _key);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    },
    BinaryExpression: function BinaryExpression(path) {
      if (path.node.operator !== "in") return;
      var source = resolveSource(path.get("right"));
      var key = resolveKey(path.get("left"), true);
      this.addPropertyDependencies(source, key);
    }
  };
  return {
    name: "corejs3-usage",
    pre: function pre() {
      this.injectedPolyfills = new Set();
      this.polyfillsSet = new Set();

      this.addUnsupported = function (builtIn) {
        var modules = Array.isArray(builtIn) ? builtIn : [builtIn];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var module = _step3.value;
            this.polyfillsSet.add(module);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      };

      this.addBuiltInDependencies = function (builtIn) {
        if ((0, _utils.has)(_builtInDefinitions.BuiltIns, builtIn)) {
          var BuiltInDependencies = _builtInDefinitions.BuiltIns[builtIn];
          this.addUnsupported(BuiltInDependencies);
        }
      };

      this.addPropertyDependencies = function () {
        var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var key = arguments.length > 1 ? arguments[1] : undefined;
        var builtIn = source.builtIn,
            instanceType = source.instanceType,
            isNamespaced = source.isNamespaced;
        if (isNamespaced) return;

        if (_builtInDefinitions.PossibleGlobalObjects.has(builtIn)) {
          this.addBuiltInDependencies(key);
        } else if ((0, _utils.has)(_builtInDefinitions.StaticProperties, builtIn)) {
          var BuiltInProperties = _builtInDefinitions.StaticProperties[builtIn];

          if ((0, _utils.has)(BuiltInProperties, key)) {
            var StaticPropertyDependencies = BuiltInProperties[key];
            return this.addUnsupported(StaticPropertyDependencies);
          }
        }

        if (!(0, _utils.has)(_builtInDefinitions.InstanceProperties, key)) return;
        var InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[key];

        if (instanceType) {
          InstancePropertyDependencies = InstancePropertyDependencies.filter(function (m) {
            return m.includes(instanceType) || _builtInDefinitions.CommonInstanceDependencies.has(m);
          });
        }

        this.addUnsupported(InstancePropertyDependencies);
      };
    },
    post: function post() {
      if (debug) {
        (0, _debug.logUsagePolyfills)(this.injectedPolyfills, this.file.opts.filename, polyfillTargets, _data.default);
      }
    },
    visitor: addAndRemovePolyfillImports
  };
}

},{"../../debug":146,"../../filter-items":147,"../../utils":164,"./built-in-definitions":157,"./shipped-proposals":159,"core-js-compat/data":303,"core-js-compat/get-modules-list-for-target-version":305}],161:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _utils = require("../../utils");

function isRegeneratorSource(source) {
  return source === "regenerator-runtime/runtime";
}

function _default() {
  var visitor = {
    ImportDeclaration: function ImportDeclaration(path) {
      if (isRegeneratorSource((0, _utils.getImportSource)(path))) {
        this.regeneratorImportExcluded = true;
        path.remove();
      }
    },
    Program: function Program(path) {
      var _this = this;

      path.get("body").forEach(function (bodyPath) {
        if (isRegeneratorSource((0, _utils.getRequireSource)(bodyPath))) {
          _this.regeneratorImportExcluded = true;
          bodyPath.remove();
        }
      });
    }
  };
  return {
    name: "regenerator-entry",
    visitor: visitor,
    pre: function pre() {
      this.regeneratorImportExcluded = false;
    },
    post: function post() {
      if (this.opts.debug && this.regeneratorImportExcluded) {
        var filename = this.file.opts.filename;

        if (process.env.BABEL_ENV === "test") {
          filename = filename.replace(/\\/g, "/");
        }

        console.log("\n[".concat(filename, "] Based on your targets, regenerator-runtime import excluded."));
      }
    }
  };
}

}).call(this,require('_process'))
},{"../../utils":164,"_process":1054}],162:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _utils = require("../../utils");

function _default() {
  return {
    name: "regenerator-usage",
    pre: function pre() {
      this.usesRegenerator = false;
    },
    visitor: {
      Function: function Function(path) {
        var node = path.node;

        if (!this.usesRegenerator && (node.generator || node.async)) {
          this.usesRegenerator = true;
          (0, _utils.createImport)(path, "regenerator-runtime");
        }
      }
    },
    post: function post() {
      if (this.opts.debug && this.usesRegenerator) {
        var filename = this.file.opts.filename;

        if (process.env.BABEL_ENV === "test") {
          filename = filename.replace(/\\/g, "/");
        }

        console.log("\n[".concat(filename, "] Based on your code and targets, added regenerator-runtime."));
      }
    }
  };
}

}).call(this,require('_process'))
},{"../../utils":164,"_process":1054}],163:[function(require,module,exports){
(function (process){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.semverMin = exports.isBrowsersQueryValid = void 0;

var _browserslist = _interopRequireDefault(require("browserslist"));

var _invariant = _interopRequireDefault(require("invariant"));

var _semver = _interopRequireDefault(require("semver"));

var _utils = require("./utils");

var _builtInModules = _interopRequireDefault(require("../data/built-in-modules.json"));

var _options = require("./options");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var browserslistDefaults = _browserslist.default.defaults;
var validBrowserslistTargets = [].concat(_toConsumableArray(Object.keys(_browserslist.default.data)), _toConsumableArray(Object.keys(_browserslist.default.aliases)));

var objectToBrowserslist = function objectToBrowserslist(object) {
  return Object.keys(object).reduce(function (list, targetName) {
    if (validBrowserslistTargets.indexOf(targetName) >= 0) {
      var targetVersion = object[targetName];
      return list.concat("".concat(targetName, " ").concat(targetVersion));
    }

    return list;
  }, []);
};

var validateTargetNames = function validateTargetNames(targets) {
  var validTargets = Object.keys(_options.TargetNames);

  for (var target in targets) {
    if (!_options.TargetNames[target]) {
      throw new Error("Invalid Option: '".concat(target, "' is not a valid target\n        Maybe you meant to use '").concat((0, _utils.findSuggestion)(validTargets, target), "'?"));
    }
  }
};

var browserNameMap = {
  and_chr: "chrome",
  and_ff: "firefox",
  android: "android",
  chrome: "chrome",
  edge: "edge",
  firefox: "firefox",
  ie: "ie",
  ie_mob: "ie",
  ios_saf: "ios",
  node: "node",
  op_mob: "opera",
  opera: "opera",
  safari: "safari",
  samsung: "samsung"
};

var isBrowsersQueryValid = function isBrowsersQueryValid(browsers) {
  return typeof browsers === "string" || Array.isArray(browsers);
};

exports.isBrowsersQueryValid = isBrowsersQueryValid;

var validateBrowsers = function validateBrowsers(browsers) {
  (0, _invariant.default)(typeof browsers === "undefined" || isBrowsersQueryValid(browsers), "Invalid Option: '".concat(browsers, "' is not a valid browserslist query"));
  return browsers;
};

var semverMin = function semverMin(first, second) {
  return first && _semver.default.lt(first, second) ? first : second;
};

exports.semverMin = semverMin;

var mergeBrowsers = function mergeBrowsers(fromQuery, fromTarget) {
  return Object.keys(fromTarget).reduce(function (queryObj, targKey) {
    if (targKey !== _options.TargetNames.browsers) {
      queryObj[targKey] = fromTarget[targKey];
    }

    return queryObj;
  }, fromQuery);
};

var getLowestVersions = function getLowestVersions(browsers) {
  return browsers.reduce(function (all, browser) {
    var _browser$split = browser.split(" "),
        _browser$split2 = _slicedToArray(_browser$split, 2),
        browserName = _browser$split2[0],
        browserVersion = _browser$split2[1];

    var normalizedBrowserName = browserNameMap[browserName];

    if (!normalizedBrowserName) {
      return all;
    }

    try {
      var splitVersion = browserVersion.split("-")[0].toLowerCase();
      var isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, browserName);

      if (!all[normalizedBrowserName]) {
        all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);
        return all;
      }

      var version = all[normalizedBrowserName];
      var isUnreleased = (0, _utils.isUnreleasedVersion)(version, browserName);

      if (isUnreleased && isSplitUnreleased) {
        all[normalizedBrowserName] = (0, _utils.getLowestUnreleased)(version, splitVersion, browserName);
      } else if (isUnreleased) {
        all[normalizedBrowserName] = (0, _utils.semverify)(splitVersion);
      } else if (!isUnreleased && !isSplitUnreleased) {
        var parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
        all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
      }
    } catch (e) {}

    return all;
  }, {});
};

var outputDecimalWarning = function outputDecimalWarning(decimalTargets) {
  if (!decimalTargets || !decimalTargets.length) {
    return;
  }

  console.log("Warning, the following targets are using a decimal version:");
  console.log("");
  decimalTargets.forEach(function (_ref) {
    var target = _ref.target,
        value = _ref.value;
    return console.log("  ".concat(target, ": ").concat(value));
  });
  console.log("");
  console.log("We recommend using a string for minor/patch versions to avoid numbers like 6.10");
  console.log("getting parsed as 6.1, which can lead to unexpected behavior.");
  console.log("");
};

var semverifyTarget = function semverifyTarget(target, value) {
  try {
    return (0, _utils.semverify)(value);
  } catch (error) {
    throw new Error("Invalid Option: '".concat(value, "' is not a valid value for 'targets.").concat(target, "'."));
  }
};

var targetParserMap = {
  __default: function __default(target, value) {
    var version = (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
    return [target, version];
  },
  node: function node(target, value) {
    var parsed = value === true || value === "current" ? process.versions.node : semverifyTarget(target, value);
    return [target, parsed];
  }
};

var getTargets = function getTargets() {
  var targets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var targetOpts = {};
  validateTargetNames(targets);

  if (targets.esmodules) {
    var supportsESModules = _builtInModules.default["es6.module"];
    targets.browsers = Object.keys(supportsESModules).map(function (browser) {
      return "".concat(browser, " ").concat(supportsESModules[browser]);
    }).join(", ");
  }

  var browsersquery = validateBrowsers(targets.browsers);
  var hasTargets = Object.keys(targets).length > 0;
  var shouldParseBrowsers = !!targets.browsers;
  var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

  if (shouldParseBrowsers || shouldSearchForConfig) {
    if (!hasTargets) {
      _browserslist.default.defaults = objectToBrowserslist(targets);
    }

    var browsers = (0, _browserslist.default)(browsersquery, {
      path: options.configPath,
      mobileToDesktop: true
    });
    var queryBrowsers = getLowestVersions(browsers);
    targets = mergeBrowsers(queryBrowsers, targets);
    _browserslist.default.defaults = browserslistDefaults;
  }

  var parsed = Object.keys(targets).filter(function (value) {
    return value !== _options.TargetNames.esmodules;
  }).sort().reduce(function (results, target) {
    if (target !== _options.TargetNames.browsers) {
      var value = targets[target];

      if (typeof value === "number" && value % 1 !== 0) {
        results.decimalWarnings.push({
          target: target,
          value: value
        });
      }

      var parser = targetParserMap[target] || targetParserMap.__default;

      var _parser = parser(target, value),
          _parser2 = _slicedToArray(_parser, 2),
          parsedTarget = _parser2[0],
          parsedValue = _parser2[1];

      if (parsedValue) {
        results.targets[parsedTarget] = parsedValue;
      }
    }

    return results;
  }, {
    targets: targetOpts,
    decimalWarnings: []
  });
  outputDecimalWarning(parsed.decimalWarnings);
  return parsed.targets;
};

var _default = getTargets;
exports.default = _default;

}).call(this,require('_process'))
},{"../data/built-in-modules.json":139,"./options":152,"./utils":164,"_process":1054,"browserslist":288,"invariant":840,"semver":1070}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getType = getType;
exports.semverify = semverify;
exports.intersection = intersection;
exports.findSuggestion = findSuggestion;
exports.prettifyVersion = prettifyVersion;
exports.prettifyTargets = prettifyTargets;
exports.isUnreleasedVersion = isUnreleasedVersion;
exports.getLowestUnreleased = getLowestUnreleased;
exports.filterStageFromList = filterStageFromList;
exports.getImportSource = getImportSource;
exports.getRequireSource = getRequireSource;
exports.isPolyfillSource = isPolyfillSource;
exports.getModulePath = getModulePath;
exports.createImport = createImport;
exports.isNamespaced = isNamespaced;
exports.has = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _invariant = _interopRequireDefault(require("invariant"));

var _semver = _interopRequireDefault(require("semver"));

var _jsLevenshtein = _interopRequireDefault(require("js-levenshtein"));

var _helperModuleImports = require("@babel/helper-module-imports");

var _unreleasedLabels = _interopRequireDefault(require("../data/unreleased-labels"));

var _targetsParser = require("./targets-parser");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var has = Object.hasOwnProperty.call.bind(Object.hasOwnProperty);
exports.has = has;

function getType(target) {
  return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
}

var versionRegExp = /^(\d+|\d+.\d+)$/;

function semverify(version) {
  if (typeof version === "string" && _semver.default.valid(version)) {
    return version;
  }

  (0, _invariant.default)(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'".concat(version, "' is not a valid version"));
  var split = version.toString().split(".");

  while (split.length < 3) {
    split.push("0");
  }

  return split.join(".");
}

function intersection(first, second, third) {
  var result = new Set();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = first[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var el = _step.value;
      if (second.has(el) && third.has(el)) result.add(el);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

function findSuggestion(options, option) {
  var levenshteinValue = Infinity;
  return options.reduce(function (suggestion, validOption) {
    var value = (0, _jsLevenshtein.default)(validOption, option);

    if (value < levenshteinValue) {
      levenshteinValue = value;
      return validOption;
    }

    return suggestion;
  }, "");
}

function prettifyVersion(version) {
  if (typeof version !== "string") {
    return version;
  }

  var parts = [_semver.default.major(version)];

  var minor = _semver.default.minor(version);

  var patch = _semver.default.patch(version);

  if (minor || patch) {
    parts.push(minor);
  }

  if (patch) {
    parts.push(patch);
  }

  return parts.join(".");
}

function prettifyTargets(targets) {
  return Object.keys(targets).reduce(function (results, target) {
    var value = targets[target];
    var unreleasedLabel = _unreleasedLabels.default[target];

    if (typeof value === "string" && unreleasedLabel !== value) {
      value = prettifyVersion(value);
    }

    results[target] = value;
    return results;
  }, {});
}

function isUnreleasedVersion(version, env) {
  var unreleasedLabel = _unreleasedLabels.default[env];
  return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
}

function getLowestUnreleased(a, b, env) {
  var unreleasedLabel = _unreleasedLabels.default[env];
  var hasUnreleased = [a, b].some(function (item) {
    return item === unreleasedLabel;
  });

  if (hasUnreleased) {
    return a === hasUnreleased ? b : a || b;
  }

  return (0, _targetsParser.semverMin)(a, b);
}

function filterStageFromList(list, stageList) {
  return Object.keys(list).reduce(function (result, item) {
    if (!stageList[item]) {
      result[item] = list[item];
    }

    return result;
  }, {});
}

function getImportSource(_ref) {
  var node = _ref.node;
  if (node.specifiers.length === 0) return node.source.value;
}

function getRequireSource(_ref2) {
  var node = _ref2.node;
  if (!t.isExpressionStatement(node)) return;
  var expression = node.expression;
  var isRequire = t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0]);
  if (isRequire) return expression.arguments[0].value;
}

function isPolyfillSource(source) {
  return source === "@babel/polyfill" || source === "core-js";
}

var modulePathMap = {
  "regenerator-runtime": "regenerator-runtime/runtime"
};

function getModulePath(mod) {
  return modulePathMap[mod] || "core-js/modules/".concat(mod);
}

function createImport(path, mod) {
  return (0, _helperModuleImports.addSideEffect)(path, getModulePath(mod));
}

function isNamespaced(path) {
  if (!path.node) return false;
  var binding = path.scope.getBinding(path.node.name);
  if (!binding) return false;
  return binding.path.isImportNamespaceSpecifier();
}

},{"../data/unreleased-labels":144,"./targets-parser":163,"@babel/helper-module-imports":72,"@babel/types":242,"invariant":840,"js-levenshtein":842,"semver":1070}],165:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTemplateBuilder;

var _options = require("./options");

var _string = _interopRequireDefault(require("./string"));

var _literal = _interopRequireDefault(require("./literal"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var NO_PLACEHOLDER = (0, _options.validate)({
  placeholderPattern: false
});

function createTemplateBuilder(formatter, defaultOpts) {
  var templateFnCache = new WeakMap();
  var templateAstCache = new WeakMap();
  var cachedOpts = defaultOpts || (0, _options.validate)(null);
  return Object.assign(function (tpl) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof tpl === "string") {
      if (args.length > 1) throw new Error("Unexpected extra params.");
      return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
    } else if (Array.isArray(tpl)) {
      var builder = templateFnCache.get(tpl);

      if (!builder) {
        builder = (0, _literal.default)(formatter, tpl, cachedOpts);
        templateFnCache.set(tpl, builder);
      }

      return extendedTrace(builder(args));
    } else if (_typeof(tpl) === "object" && tpl) {
      if (args.length > 0) throw new Error("Unexpected extra params.");
      return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
    }

    throw new Error("Unexpected template param ".concat(_typeof(tpl)));
  }, {
    ast: function ast(tpl) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
      } else if (Array.isArray(tpl)) {
        var builder = templateAstCache.get(tpl);

        if (!builder) {
          builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
          templateAstCache.set(tpl, builder);
        }

        return builder(args)();
      }

      throw new Error("Unexpected template param ".concat(_typeof(tpl)));
    }
  });
}

function extendedTrace(fn) {
  var rootStack = "";

  try {
    throw new Error();
  } catch (error) {
    if (error.stack) {
      rootStack = error.stack.split("\n").slice(3).join("\n");
    }
  }

  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      err.stack += "\n    =============\n".concat(rootStack);
      throw err;
    }
  };
}

},{"./literal":168,"./options":169,"./string":172}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;

function makeStatementFormatter(fn) {
  return {
    code: function code(str) {
      return "/* @babel/template */;\n".concat(str);
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return fn(ast.program.body.slice(1));
    }
  };
}

var smart = makeStatementFormatter(function (body) {
  if (body.length > 1) {
    return body;
  } else {
    return body[0];
  }
});
exports.smart = smart;
var statements = makeStatementFormatter(function (body) {
  return body;
});
exports.statements = statements;
var statement = makeStatementFormatter(function (body) {
  if (body.length === 0) {
    throw new Error("Found nothing to return.");
  }

  if (body.length > 1) {
    throw new Error("Found multiple statements but wanted one");
  }

  return body[0];
});
exports.statement = statement;
var expression = {
  code: function code(str) {
    return "(\n".concat(str, "\n)");
  },
  validate: function validate(_ref) {
    var program = _ref.program;

    if (program.body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    var expression = program.body[0].expression;

    if (expression.start === 0) {
      throw new Error("Parse result included parens.");
    }
  },
  unwrap: function unwrap(ast) {
    return ast.program.body[0].expression;
  }
};
exports.expression = expression;
var program = {
  code: function code(str) {
    return str;
  },
  validate: function validate() {},
  unwrap: function unwrap(ast) {
    return ast.program;
  }
};
exports.program = program;

},{}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.program = exports.expression = exports.statements = exports.statement = exports.smart = void 0;

var formatters = _interopRequireWildcard(require("./formatters"));

var _builder = _interopRequireDefault(require("./builder"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var smart = (0, _builder.default)(formatters.smart);
exports.smart = smart;
var statement = (0, _builder.default)(formatters.statement);
exports.statement = statement;
var statements = (0, _builder.default)(formatters.statements);
exports.statements = statements;
var expression = (0, _builder.default)(formatters.expression);
exports.expression = expression;
var program = (0, _builder.default)(formatters.program);
exports.program = program;

var _default = Object.assign(smart.bind(undefined), {
  smart: smart,
  statement: statement,
  statements: statements,
  expression: expression,
  program: program,
  ast: smart.ast
});

exports.default = _default;

},{"./builder":165,"./formatters":166}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = literalTemplate;

var _options = require("./options");

var _parse = _interopRequireDefault(require("./parse"));

var _populate = _interopRequireDefault(require("./populate"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function literalTemplate(formatter, tpl, opts) {
  var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
      metadata = _buildLiteralData.metadata,
      names = _buildLiteralData.names;

  return function (arg) {
    var defaultReplacements = arg.reduce(function (acc, replacement, i) {
      acc[names[i]] = replacement;
      return acc;
    }, {});
    return function (arg) {
      var replacements = (0, _options.normalizeReplacements)(arg);

      if (replacements) {
        Object.keys(replacements).forEach(function (key) {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
            throw new Error("Unexpected replacement overlap.");
          }
        });
      }

      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
    };
  };
}

function buildLiteralData(formatter, tpl, opts) {
  var names;
  var nameSet;
  var metadata;
  var prefix = "";

  do {
    prefix += "$";
    var result = buildTemplateCode(tpl, prefix);
    names = result.names;
    nameSet = new Set(names);
    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
  } while (metadata.placeholders.some(function (placeholder) {
    return placeholder.isDuplicate && nameSet.has(placeholder.name);
  }));

  return {
    metadata: metadata,
    names: names
  };
}

function buildTemplateCode(tpl, prefix) {
  var names = [];
  var code = tpl[0];

  for (var i = 1; i < tpl.length; i++) {
    var value = "".concat(prefix).concat(i - 1);
    names.push(value);
    code += value + tpl[i];
  }

  return {
    names: names,
    code: code
  };
}

},{"./options":169,"./parse":170,"./populate":171}],169:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = merge;
exports.validate = validate;
exports.normalizeReplacements = normalizeReplacements;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function merge(a, b) {
  var _b$placeholderWhiteli = b.placeholderWhitelist,
      placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
      _b$placeholderPattern = b.placeholderPattern,
      placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
      _b$preserveComments = b.preserveComments,
      preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
      _b$syntacticPlacehold = b.syntacticPlaceholders,
      syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
  return {
    parser: Object.assign({}, a.parser, {}, b.parser),
    placeholderWhitelist: placeholderWhitelist,
    placeholderPattern: placeholderPattern,
    preserveComments: preserveComments,
    syntacticPlaceholders: syntacticPlaceholders
  };
}

function validate(opts) {
  if (opts != null && _typeof(opts) !== "object") {
    throw new Error("Unknown template options.");
  }

  var _ref = opts || {},
      placeholderWhitelist = _ref.placeholderWhitelist,
      placeholderPattern = _ref.placeholderPattern,
      preserveComments = _ref.preserveComments,
      syntacticPlaceholders = _ref.syntacticPlaceholders,
      parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);

  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
  }

  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
  }

  if (preserveComments != null && typeof preserveComments !== "boolean") {
    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
  }

  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
  }

  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
  }

  return {
    parser: parser,
    placeholderWhitelist: placeholderWhitelist || undefined,
    placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
    preserveComments: preserveComments == null ? false : preserveComments,
    syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
  };
}

function normalizeReplacements(replacements) {
  if (Array.isArray(replacements)) {
    return replacements.reduce(function (acc, replacement, i) {
      acc["$" + i] = replacement;
      return acc;
    }, {});
  } else if (_typeof(replacements) === "object" || replacements == null) {
    return replacements || undefined;
  }

  throw new Error("Template replacements must be an array, object, null, or undefined");
}

},{}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseAndBuildMetadata;

var t = _interopRequireWildcard(require("@babel/types"));

var _parser = require("@babel/parser");

var _codeFrame = require("@babel/code-frame");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var PATTERN = /^[_$A-Z0-9]+$/;

function parseAndBuildMetadata(formatter, code, opts) {
  var ast = parseWithCodeFrame(code, opts.parser);
  var placeholderWhitelist = opts.placeholderWhitelist,
      placeholderPattern = opts.placeholderPattern,
      preserveComments = opts.preserveComments,
      syntacticPlaceholders = opts.syntacticPlaceholders;
  t.removePropertiesDeep(ast, {
    preserveComments: preserveComments
  });
  formatter.validate(ast);
  var syntactic = {
    placeholders: [],
    placeholderNames: new Set()
  };
  var legacy = {
    placeholders: [],
    placeholderNames: new Set()
  };
  var isLegacyRef = {
    value: undefined
  };
  t.traverse(ast, placeholderVisitorHandler, {
    syntactic: syntactic,
    legacy: legacy,
    isLegacyRef: isLegacyRef,
    placeholderWhitelist: placeholderWhitelist,
    placeholderPattern: placeholderPattern,
    syntacticPlaceholders: syntacticPlaceholders
  });
  return Object.assign({
    ast: ast
  }, isLegacyRef.value ? legacy : syntactic);
}

function placeholderVisitorHandler(node, ancestors, state) {
  var name;

  if (t.isPlaceholder(node)) {
    if (state.syntacticPlaceholders === false) {
      throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
    } else {
      name = node.name.name;
      state.isLegacyRef.value = false;
    }
  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
    return;
  } else if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {
    name = node.name;
    state.isLegacyRef.value = true;
  } else if (t.isStringLiteral(node)) {
    name = node.value;
    state.isLegacyRef.value = true;
  } else {
    return;
  }

  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
  }

  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {
    return;
  }

  ancestors = ancestors.slice();
  var _ancestors = ancestors[ancestors.length - 1],
      parent = _ancestors.node,
      key = _ancestors.key;
  var type;

  if (t.isStringLiteral(node) || t.isPlaceholder(node, {
    expectedNode: "StringLiteral"
  })) {
    type = "string";
  } else if (t.isNewExpression(parent) && key === "arguments" || t.isCallExpression(parent) && key === "arguments" || t.isFunction(parent) && key === "params") {
    type = "param";
  } else if (t.isExpressionStatement(parent) && !t.isPlaceholder(node)) {
    type = "statement";
    ancestors = ancestors.slice(0, -1);
  } else if (t.isStatement(node) && t.isPlaceholder(node)) {
    type = "statement";
  } else {
    type = "other";
  }

  var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
      placeholders = _ref.placeholders,
      placeholderNames = _ref.placeholderNames;

  placeholders.push({
    name: name,
    type: type,
    resolve: function resolve(ast) {
      return resolveAncestors(ast, ancestors);
    },
    isDuplicate: placeholderNames.has(name)
  });
  placeholderNames.add(name);
}

function resolveAncestors(ast, ancestors) {
  var parent = ast;

  for (var i = 0; i < ancestors.length - 1; i++) {
    var _ancestors$i = ancestors[i],
        _key = _ancestors$i.key,
        _index = _ancestors$i.index;

    if (_index === undefined) {
      parent = parent[_key];
    } else {
      parent = parent[_key][_index];
    }
  }

  var _ancestors2 = ancestors[ancestors.length - 1],
      key = _ancestors2.key,
      index = _ancestors2.index;
  return {
    parent: parent,
    key: key,
    index: index
  };
}

function parseWithCodeFrame(code, parserOpts) {
  parserOpts = Object.assign({
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    sourceType: "module"
  }, parserOpts, {
    plugins: (parserOpts.plugins || []).concat("placeholders")
  });

  try {
    return (0, _parser.parse)(code, parserOpts);
  } catch (err) {
    var loc = err.loc;

    if (loc) {
      err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
        start: loc
      });
      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
    }

    throw err;
  }
}

},{"@babel/code-frame":1,"@babel/parser":89,"@babel/types":242}],171:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = populatePlaceholders;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function populatePlaceholders(metadata, replacements) {
  var ast = t.cloneNode(metadata.ast);

  if (replacements) {
    metadata.placeholders.forEach(function (placeholder) {
      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
        var placeholderName = placeholder.name;
        throw new Error("Error: No substitution given for \"".concat(placeholderName, "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['").concat(placeholderName, "'])}\n            - { placeholderPattern: /^").concat(placeholderName, "$/ }"));
      }
    });
    Object.keys(replacements).forEach(function (key) {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error("Unknown substitution \"".concat(key, "\" given"));
      }
    });
  }

  metadata.placeholders.slice().reverse().forEach(function (placeholder) {
    try {
      applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
    } catch (e) {
      e.message = "@babel/template placeholder \"".concat(placeholder.name, "\": ").concat(e.message);
      throw e;
    }
  });
  return ast;
}

function applyReplacement(placeholder, ast, replacement) {
  if (placeholder.isDuplicate) {
    if (Array.isArray(replacement)) {
      replacement = replacement.map(function (node) {
        return t.cloneNode(node);
      });
    } else if (_typeof(replacement) === "object") {
      replacement = t.cloneNode(replacement);
    }
  }

  var _placeholder$resolve = placeholder.resolve(ast),
      parent = _placeholder$resolve.parent,
      key = _placeholder$resolve.key,
      index = _placeholder$resolve.index;

  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = t.stringLiteral(replacement);
    }

    if (!replacement || !t.isStringLiteral(replacement)) {
      throw new Error("Expected string substitution");
    }
  } else if (placeholder.type === "statement") {
    if (index === undefined) {
      if (!replacement) {
        replacement = t.emptyStatement();
      } else if (Array.isArray(replacement)) {
        replacement = t.blockStatement(replacement);
      } else if (typeof replacement === "string") {
        replacement = t.expressionStatement(t.identifier(replacement));
      } else if (!t.isStatement(replacement)) {
        replacement = t.expressionStatement(replacement);
      }
    } else {
      if (replacement && !Array.isArray(replacement)) {
        if (typeof replacement === "string") {
          replacement = t.identifier(replacement);
        }

        if (!t.isStatement(replacement)) {
          replacement = t.expressionStatement(replacement);
        }
      }
    }
  } else if (placeholder.type === "param") {
    if (typeof replacement === "string") {
      replacement = t.identifier(replacement);
    }

    if (index === undefined) throw new Error("Assertion failure.");
  } else {
    if (typeof replacement === "string") {
      replacement = t.identifier(replacement);
    }

    if (Array.isArray(replacement)) {
      throw new Error("Cannot replace single expression with an array.");
    }
  }

  if (index === undefined) {
    t.validate(parent, key, replacement);
    parent[key] = replacement;
  } else {
    var items = parent[key].slice();

    if (placeholder.type === "statement" || placeholder.type === "param") {
      if (replacement == null) {
        items.splice(index, 1);
      } else if (Array.isArray(replacement)) {
        items.splice.apply(items, [index, 1].concat(_toConsumableArray(replacement)));
      } else {
        items[index] = replacement;
      }
    } else {
      items[index] = replacement;
    }

    t.validate(parent, key, items);
    parent[key] = items;
  }
}

},{"@babel/types":242}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stringTemplate;

var _options = require("./options");

var _parse = _interopRequireDefault(require("./parse"));

var _populate = _interopRequireDefault(require("./populate"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function stringTemplate(formatter, code, opts) {
  code = formatter.code(code);
  var metadata;
  return function (arg) {
    var replacements = (0, _options.normalizeReplacements)(arg);
    if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
    return formatter.unwrap((0, _populate.default)(metadata, replacements));
  };
}

},{"./options":169,"./parse":170,"./populate":171}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearPath = clearPath;
exports.clearScope = clearScope;
exports.scope = exports.path = void 0;
var path = new WeakMap();
exports.path = path;
var scope = new WeakMap();
exports.scope = scope;

function clear() {
  clearPath();
  clearScope();
}

function clearPath() {
  exports.path = path = new WeakMap();
}

function clearScope() {
  exports.scope = scope = new WeakMap();
}

},{}],174:[function(require,module,exports){
(function (process){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("./path"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var testing = process.env.NODE_ENV === "test";

var TraversalContext =
/*#__PURE__*/
function () {
  function TraversalContext(scope, opts, state, parentPath) {
    _classCallCheck(this, TraversalContext);

    this.queue = null;
    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  _createClass(TraversalContext, [{
    key: "shouldVisit",
    value: function shouldVisit(node) {
      var opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node.type]) return true;
      var keys = t.VISITOR_KEYS[node.type];
      if (!keys || !keys.length) return false;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          if (node[key]) return true;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: "create",
    value: function create(node, obj, key, listKey) {
      return _path.default.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey: listKey
      });
    }
  }, {
    key: "maybeQueue",
    value: function maybeQueue(path, notPriority) {
      if (this.trap) {
        throw new Error("Infinite cycle detected");
      }

      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    }
  }, {
    key: "visitMultiple",
    value: function visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      var queue = [];

      for (var key = 0; key < container.length; key++) {
        var node = container[key];

        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }

      return this.visitQueue(queue);
    }
  }, {
    key: "visitSingle",
    value: function visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    }
  }, {
    key: "visitQueue",
    value: function visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      var visited = [];
      var stop = false;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = queue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var path = _step2.value;
          path.resync();

          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            path.pushContext(this);
          }

          if (path.key === null) continue;

          if (testing && queue.length >= 10000) {
            this.trap = true;
          }

          if (visited.indexOf(path.node) >= 0) continue;
          visited.push(path.node);

          if (path.visit()) {
            stop = true;
            break;
          }

          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = queue[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _path2 = _step3.value;

          _path2.popContext();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.queue = null;
      return stop;
    }
  }, {
    key: "visit",
    value: function visit(node, key) {
      var nodes = node[key];
      if (!nodes) return false;

      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    }
  }]);

  return TraversalContext;
}();

exports.default = TraversalContext;

}).call(this,require('_process'))
},{"./path":183,"@babel/types":242,"_process":1054}],175:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var Hub =
/*#__PURE__*/
function () {
  function Hub() {
    _classCallCheck(this, Hub);
  }

  _createClass(Hub, [{
    key: "getCode",
    value: function getCode() {}
  }, {
    key: "getScope",
    value: function getScope() {}
  }, {
    key: "addHelper",
    value: function addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
  }, {
    key: "buildError",
    value: function buildError(node, msg) {
      var Error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeError;
      return new Error(msg);
    }
  }]);

  return Hub;
}();

exports.default = Hub;

},{}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;
Object.defineProperty(exports, "NodePath", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});
Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function get() {
    return _scope.default;
  }
});
Object.defineProperty(exports, "Hub", {
  enumerable: true,
  get: function get() {
    return _hub.default;
  }
});
exports.visitors = void 0;

var _context = _interopRequireDefault(require("./context"));

var visitors = _interopRequireWildcard(require("./visitors"));

exports.visitors = visitors;

var _includes = _interopRequireDefault(require("lodash/includes"));

var t = _interopRequireWildcard(require("@babel/types"));

var cache = _interopRequireWildcard(require("./cache"));

var _path = _interopRequireDefault(require("./path"));

var _scope = _interopRequireDefault(require("./scope"));

var _hub = _interopRequireDefault(require("./hub"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + "Instead of that you tried to traverse a ".concat(parent.type, " node without ") + "passing scope and parentPath.");
    }
  }

  if (!t.VISITOR_KEYS[parent.type]) {
    return;
  }

  visitors.explode(opts);
  traverse.node(parent, opts, scope, state, parentPath);
}

traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.cheap = function (node, enter) {
  return t.traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;
  var context = new _context.default(scope, opts, state, parentPath);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

traverse.clearNode = function (node, opts) {
  t.removeProperties(node, opts);
  cache.path.delete(node);
};

traverse.removeProperties = function (tree, opts) {
  t.traverseFast(tree, traverse.clearNode, opts);
  return tree;
};

function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, type, blacklistTypes) {
  if ((0, _includes.default)(blacklistTypes, tree.type)) return false;
  if (tree.type === type) return true;
  var state = {
    has: false,
    type: type
  };
  traverse(tree, {
    noScope: true,
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, null, state);
  return state.has;
};

traverse.cache = cache;

},{"./cache":173,"./context":174,"./hub":175,"./path":183,"./scope":195,"./visitors":197,"@babel/types":242,"lodash/includes":1015}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findParent = findParent;
exports.find = find;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getAncestry = getAncestry;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.inType = inType;

var t = _interopRequireWildcard(require("@babel/types"));

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function findParent(callback) {
  var path = this;

  while (path = path.parentPath) {
    if (callback(path)) return path;
  }

  return null;
}

function find(callback) {
  var path = this;

  do {
    if (callback(path)) return path;
  } while (path = path.parentPath);

  return null;
}

function getFunctionParent() {
  return this.findParent(function (p) {
    return p.isFunction();
  });
}

function getStatementParent() {
  var path = this;

  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  }

  return path;
}

function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    var earliest;
    var keys = t.VISITOR_KEYS[deepest.type];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ancestries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var ancestry = _step.value;
        var path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        var earliestKeyIndex = keys.indexOf(earliest.parentKey);
        var currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return earliest;
  });
}

function getDeepestCommonAncestorFrom(paths, filter) {
  var _this = this;

  if (!paths.length) {
    return this;
  }

  if (paths.length === 1) {
    return paths[0];
  }

  var minDepth = Infinity;
  var lastCommonIndex, lastCommon;
  var ancestries = paths.map(function (path) {
    var ancestry = [];

    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== _this);

    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }

    return ancestry;
  });
  var first = ancestries[0];

  depthLoop: for (var i = 0; i < minDepth; i++) {
    var shouldMatch = first[i];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = ancestries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ancestry = _step2.value;

        if (ancestry[i] !== shouldMatch) {
          break depthLoop;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }

  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}

function getAncestry() {
  var path = this;
  var paths = [];

  do {
    paths.push(path);
  } while (path = path.parentPath);

  return paths;
}

function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
  return !!this.findParent(function (parent) {
    return parent === maybeAncestor;
  });
}

function inType() {
  var path = this;

  while (path) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = arguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var type = _step3.value;
        if (path.node.type === type) return true;
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    path = path.parentPath;
  }

  return false;
}

},{"./index":183,"@babel/types":242}],178:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
exports.addComment = addComment;
exports.addComments = addComments;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function shareCommentsWithSiblings() {
  if (typeof this.key === "string") return;
  var node = this.node;
  if (!node) return;
  var trailing = node.trailingComments;
  var leading = node.leadingComments;
  if (!trailing && !leading) return;
  var prev = this.getSibling(this.key - 1);
  var next = this.getSibling(this.key + 1);
  var hasPrev = Boolean(prev.node);
  var hasNext = Boolean(next.node);

  if (hasPrev && hasNext) {} else if (hasPrev) {
    prev.addComments("trailing", trailing);
  } else if (hasNext) {
    next.addComments("leading", leading);
  }
}

function addComment(type, content, line) {
  t.addComment(this.node, type, content, line);
}

function addComments(type, comments) {
  t.addComments(this.node, type, comments);
}

},{"@babel/types":242}],179:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.call = call;
exports._call = _call;
exports.isBlacklisted = isBlacklisted;
exports.visit = visit;
exports.skip = skip;
exports.skipKey = skipKey;
exports.stop = stop;
exports.setScope = setScope;
exports.setContext = setContext;
exports.resync = resync;
exports._resyncParent = _resyncParent;
exports._resyncKey = _resyncKey;
exports._resyncList = _resyncList;
exports._resyncRemoved = _resyncRemoved;
exports.popContext = popContext;
exports.pushContext = pushContext;
exports.setup = setup;
exports.setKey = setKey;
exports.requeue = requeue;
exports._getQueueContexts = _getQueueContexts;

var _index = _interopRequireDefault(require("../index"));

var _index2 = require("./index");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function call(key) {
  var opts = this.opts;
  this.debug(key);

  if (this.node) {
    if (this._call(opts[key])) return true;
  }

  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }

  return false;
}

function _call(fns) {
  if (!fns) return false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fn = _step.value;
      if (!fn) continue;
      var node = this.node;
      if (!node) return true;
      var ret = fn.call(this.state, this, this.state);

      if (ret && _typeof(ret) === "object" && typeof ret.then === "function") {
        throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
      }

      if (ret) {
        throw new Error("Unexpected return value from visitor method ".concat(fn));
      }

      if (this.node !== node) return true;
      if (this._traverseFlags > 0) return true;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

function isBlacklisted() {
  var blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}

function visit() {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
    this.debug("Skip...");
    return this.shouldStop;
  }

  this.debug("Recursing into...");

  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

  this.call("exit");
  return this.shouldStop;
}

function skip() {
  this.shouldSkip = true;
}

function skipKey(key) {
  if (this.skipKeys == null) {
    this.skipKeys = {};
  }

  this.skipKeys[key] = true;
}

function stop() {
  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;
}

function setScope() {
  if (this.opts && this.opts.noScope) return;
  var path = this.parentPath;
  var target;

  while (path && !target) {
    if (path.opts && path.opts.noScope) return;
    target = path.scope;
    path = path.parentPath;
  }

  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}

function setContext(context) {
  if (this.skipKeys != null) {
    this.skipKeys = {};
  }

  this._traverseFlags = 0;

  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }

  this.setScope();
  return this;
}

function resync() {
  if (this.removed) return;

  this._resyncParent();

  this._resyncList();

  this._resyncKey();
}

function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}

function _resyncKey() {
  if (!this.container) return;
  if (this.node === this.container[this.key]) return;

  if (Array.isArray(this.container)) {
    for (var i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];

      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }

  this.key = null;
}

function _resyncList() {
  if (!this.parent || !this.inList) return;
  var newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;
  this.container = newContainer || null;
}

function _resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved();
  }
}

function popContext() {
  this.contexts.pop();

  if (this.contexts.length > 0) {
    this.setContext(this.contexts[this.contexts.length - 1]);
  } else {
    this.setContext(undefined);
  }
}

function pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}

function setup(parentPath, container, listKey, key) {
  this.listKey = listKey;
  this.container = container;
  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}

function setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}

function requeue() {
  var pathToQueue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
  if (pathToQueue.removed) return;
  var contexts = this.contexts;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = contexts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var context = _step2.value;
      context.maybeQueue(pathToQueue);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function _getQueueContexts() {
  var path = this;
  var contexts = this.contexts;

  while (!contexts.length) {
    path = path.parentPath;
    if (!path) break;
    contexts = path.contexts;
  }

  return contexts;
}

},{"../index":176,"./index":183}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toComputedKey = toComputedKey;
exports.ensureBlock = ensureBlock;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
exports.arrowFunctionToExpression = arrowFunctionToExpression;

var t = _interopRequireWildcard(require("@babel/types"));

var _helperFunctionName = _interopRequireDefault(require("@babel/helper-function-name"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function toComputedKey() {
  var node = this.node;
  var key;

  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }

  return key;
}

function ensureBlock() {
  var body = this.get("body");
  var bodyNode = body.node;

  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement");
  }

  if (!bodyNode) {
    throw new Error("Can't convert node without a body");
  }

  if (body.isBlockStatement()) {
    return bodyNode;
  }

  var statements = [];
  var stringPath = "body";
  var key;
  var listKey;

  if (body.isStatement()) {
    listKey = "body";
    key = 0;
    statements.push(body.node);
  } else {
    stringPath += ".body.0";

    if (this.isFunction()) {
      key = "argument";
      statements.push(t.returnStatement(body.node));
    } else {
      key = "expression";
      statements.push(t.expressionStatement(body.node));
    }
  }

  this.node.body = t.blockStatement(statements);
  var parentPath = this.get(stringPath);
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
}

function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}

function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  }

  hoistFunctionEnvironment(this);
}

function arrowFunctionToExpression() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$allowInsertArrow = _ref.allowInsertArrow,
      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
      _ref$specCompliant = _ref.specCompliant,
      specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;

  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  }

  var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
  this.ensureBlock();
  this.node.type = "FunctionExpression";

  if (specCompliant) {
    var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

    if (checkBinding) {
      this.parentPath.scope.push({
        id: checkBinding,
        init: t.objectExpression([])
      });
    }

    this.get("body").unshiftContainer("body", t.expressionStatement(t.callExpression(this.hub.addHelper("newArrowCheck"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));
    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier("bind")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));
  }
}

function hoistFunctionEnvironment(fnPath) {
  var specCompliant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var thisEnvFn = fnPath.findParent(function (p) {
    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
      static: false
    });
  });
  var inConstructor = thisEnvFn && thisEnvFn.node.kind === "constructor";

  if (thisEnvFn.isClassProperty()) {
    throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
  }

  var _getScopeInformation = getScopeInformation(fnPath),
      thisPaths = _getScopeInformation.thisPaths,
      argumentsPaths = _getScopeInformation.argumentsPaths,
      newTargetPaths = _getScopeInformation.newTargetPaths,
      superProps = _getScopeInformation.superProps,
      superCalls = _getScopeInformation.superCalls;

  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
    }

    var allSuperCalls = [];
    thisEnvFn.traverse({
      Function: function Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ClassProperty: function ClassProperty(child) {
        child.skip();
      },
      CallExpression: function CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    var superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(function (superCall) {
      var callee = t.identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
    });
  }

  if (argumentsPaths.length > 0) {
    var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
      return t.identifier("arguments");
    });
    argumentsPaths.forEach(function (argumentsChild) {
      var argsRef = t.identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    });
  }

  if (newTargetPaths.length > 0) {
    var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
      return t.metaProperty(t.identifier("new"), t.identifier("target"));
    });
    newTargetPaths.forEach(function (targetChild) {
      var targetRef = t.identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    });
  }

  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
    }

    var flatSuperProps = superProps.reduce(function (acc, superProp) {
      return acc.concat(standardizeSuperProperty(superProp));
    }, []);
    flatSuperProps.forEach(function (superProp) {
      var key = superProp.node.computed ? "" : superProp.get("property").node.name;
      var isAssignment = superProp.parentPath.isAssignmentExpression({
        left: superProp.node
      });
      var isCall = superProp.parentPath.isCallExpression({
        callee: superProp.node
      });
      var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
      var args = [];

      if (superProp.node.computed) {
        args.push(superProp.get("property").node);
      }

      if (isAssignment) {
        var value = superProp.parentPath.node.right;
        args.push(value);
      }

      var call = t.callExpression(t.identifier(superBinding), args);

      if (isCall) {
        superProp.parentPath.unshiftContainer("arguments", t.thisExpression());
        superProp.replaceWith(t.memberExpression(call, t.identifier("call")));
        thisPaths.push(superProp.parentPath.get("arguments.0"));
      } else if (isAssignment) {
        superProp.parentPath.replaceWith(call);
      } else {
        superProp.replaceWith(call);
      }
    });
  }

  var thisBinding;

  if (thisPaths.length > 0 || specCompliant) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);

    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {
      thisPaths.forEach(function (thisChild) {
        var thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      });
      if (specCompliant) thisBinding = null;
    }
  }

  return thisBinding;
}

function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
    var assignmentPath = superProp.parentPath;
    var op = assignmentPath.node.operator.slice(0, -1);
    var value = assignmentPath.node.right;
    assignmentPath.node.operator = "=";

    if (superProp.node.computed) {
      var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      assignmentPath.get("left").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression("=", tmp, superProp.node.property), true));
      assignmentPath.get("right").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));
    } else {
      assignmentPath.get("left").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));
      assignmentPath.get("right").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));
    }

    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
  } else if (superProp.parentPath.isUpdateExpression()) {
    var updateExpr = superProp.parentPath;

    var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
    var parts = [t.assignmentExpression("=", _tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression("=", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression("+", t.identifier(_tmp.name), t.numericLiteral(1)))];

    if (!superProp.parentPath.node.prefix) {
      parts.push(t.identifier(_tmp.name));
    }

    updateExpr.replaceWith(t.sequenceExpression(parts));
    var left = updateExpr.get("expressions.0.right");
    var right = updateExpr.get("expressions.1.left");
    return [left, right];
  }

  return [superProp];
}

function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}

function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, "this", function (thisBinding) {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();
    var supers = new WeakSet();
    thisEnvFn.traverse({
      Function: function Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ClassProperty: function ClassProperty(child) {
        child.skip();
      },
      CallExpression: function CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, t.assignmentExpression("=", t.identifier(thisBinding), t.identifier("this"))]);
      }
    });
  });
}

function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, "supercall", function () {
    var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));
  });
}

function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  var op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, "superprop_".concat(op, ":").concat(propName || ""), function () {
    var argsList = [];
    var fnBody;

    if (propName) {
      fnBody = t.memberExpression(t.super(), t.identifier(propName));
    } else {
      var method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);
    }

    if (isAssignment) {
      var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = t.assignmentExpression("=", fnBody, t.identifier(valueIdent.name));
    }

    return t.arrowFunctionExpression(argsList, fnBody);
  });
}

function getBinding(thisEnvFn, key, init) {
  var cacheKey = "binding:" + key;
  var data = thisEnvFn.getData(cacheKey);

  if (!data) {
    var id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data)
    });
  }

  return data;
}

function getScopeInformation(fnPath) {
  var thisPaths = [];
  var argumentsPaths = [];
  var newTargetPaths = [];
  var superProps = [];
  var superCalls = [];
  fnPath.traverse({
    ClassProperty: function ClassProperty(child) {
      child.skip();
    },
    Function: function Function(child) {
      if (child.isArrowFunctionExpression()) return;
      child.skip();
    },
    ThisExpression: function ThisExpression(child) {
      thisPaths.push(child);
    },
    JSXIdentifier: function JSXIdentifier(child) {
      if (child.node.name !== "this") return;

      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }

      thisPaths.push(child);
    },
    CallExpression: function CallExpression(child) {
      if (child.get("callee").isSuper()) superCalls.push(child);
    },
    MemberExpression: function MemberExpression(child) {
      if (child.get("object").isSuper()) superProps.push(child);
    },
    ReferencedIdentifier: function ReferencedIdentifier(child) {
      if (child.node.name !== "arguments") return;
      argumentsPaths.push(child);
    },
    MetaProperty: function MetaProperty(child) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      })) return;
      if (!child.get("property").isIdentifier({
        name: "target"
      })) return;
      newTargetPaths.push(child);
    }
  });
  return {
    thisPaths: thisPaths,
    argumentsPaths: argumentsPaths,
    newTargetPaths: newTargetPaths,
    superProps: superProps,
    superCalls: superCalls
  };
}

},{"@babel/helper-function-name":66,"@babel/types":242}],181:[function(require,module,exports){
(function (global){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.evaluateTruthy = evaluateTruthy;
exports.evaluate = evaluate;
var VALID_CALLEES = ["String", "Number", "Math"];
var INVALID_METHODS = ["random"];

function evaluateTruthy() {
  var res = this.evaluate();
  if (res.confident) return !!res.value;
}

function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}

function evaluateCached(path, state) {
  var node = path.node;
  var seen = state.seen;

  if (seen.has(node)) {
    var existing = seen.get(node);

    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    var item = {
      resolved: false
    };
    seen.set(node, item);

    var val = _evaluate(path, state);

    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }

    return val;
  }
}

function _evaluate(path, state) {
  if (!state.confident) return;
  var node = path.node;

  if (path.isSequenceExpression()) {
    var exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }

  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return node.value;
  }

  if (path.isNullLiteral()) {
    return null;
  }

  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, node.quasis, state);
  }

  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
    var object = path.get("tag.object");
    var name = object.node.name;
    var property = path.get("tag.property");

    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === "raw") {
      return evaluateQuasis(path, node.quasi.quasis, state, true);
    }
  }

  if (path.isConditionalExpression()) {
    var testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;

    if (testResult) {
      return evaluateCached(path.get("consequent"), state);
    } else {
      return evaluateCached(path.get("alternate"), state);
    }
  }

  if (path.isExpressionWrapper()) {
    return evaluateCached(path.get("expression"), state);
  }

  if (path.isMemberExpression() && !path.parentPath.isCallExpression({
    callee: node
  })) {
    var _property = path.get("property");

    var _object = path.get("object");

    if (_object.isLiteral() && _property.isIdentifier()) {
      var value = _object.node.value;

      var type = _typeof(value);

      if (type === "number" || type === "string") {
        return value[_property.node.name];
      }
    }
  }

  if (path.isReferencedIdentifier()) {
    var binding = path.scope.getBinding(node.name);

    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }

    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }

    if (binding && binding.hasValue) {
      return binding.value;
    } else {
      if (node.name === "undefined") {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (node.name === "Infinity") {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (node.name === "NaN") {
        return binding ? deopt(binding.path, state) : NaN;
      }

      var resolved = path.resolve();

      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }

  if (path.isUnaryExpression({
    prefix: true
  })) {
    if (node.operator === "void") {
      return undefined;
    }

    var argument = path.get("argument");

    if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
      return "function";
    }

    var arg = evaluateCached(argument, state);
    if (!state.confident) return;

    switch (node.operator) {
      case "!":
        return !arg;

      case "+":
        return +arg;

      case "-":
        return -arg;

      case "~":
        return ~arg;

      case "typeof":
        return _typeof(arg);
    }
  }

  if (path.isArrayExpression()) {
    var arr = [];
    var elems = path.get("elements");
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = elems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var elem = _step.value;
        var elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elem, state);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return arr;
  }

  if (path.isObjectExpression()) {
    var obj = {};
    var props = path.get("properties");
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;

        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        var keyPath = prop.get("key");
        var key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(keyPath, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        var valuePath = prop.get("value");

        var _value = valuePath.evaluate();

        if (!_value.confident) {
          return deopt(valuePath, state);
        }

        _value = _value.value;
        obj[key] = _value;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return obj;
  }

  if (path.isLogicalExpression()) {
    var wasConfident = state.confident;
    var left = evaluateCached(path.get("left"), state);
    var leftConfident = state.confident;
    state.confident = wasConfident;
    var right = evaluateCached(path.get("right"), state);
    var rightConfident = state.confident;

    switch (node.operator) {
      case "||":
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;

      case "&&":
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
    }
  }

  if (path.isBinaryExpression()) {
    var _left = evaluateCached(path.get("left"), state);

    if (!state.confident) return;

    var _right = evaluateCached(path.get("right"), state);

    if (!state.confident) return;

    switch (node.operator) {
      case "-":
        return _left - _right;

      case "+":
        return _left + _right;

      case "/":
        return _left / _right;

      case "*":
        return _left * _right;

      case "%":
        return _left % _right;

      case "**":
        return Math.pow(_left, _right);

      case "<":
        return _left < _right;

      case ">":
        return _left > _right;

      case "<=":
        return _left <= _right;

      case ">=":
        return _left >= _right;

      case "==":
        return _left == _right;

      case "!=":
        return _left != _right;

      case "===":
        return _left === _right;

      case "!==":
        return _left !== _right;

      case "|":
        return _left | _right;

      case "&":
        return _left & _right;

      case "^":
        return _left ^ _right;

      case "<<":
        return _left << _right;

      case ">>":
        return _left >> _right;

      case ">>>":
        return _left >>> _right;
    }
  }

  if (path.isCallExpression()) {
    var callee = path.get("callee");
    var context;
    var func;

    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
      func = global[node.callee.name];
    }

    if (callee.isMemberExpression()) {
      var _object2 = callee.get("object");

      var _property2 = callee.get("property");

      if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
        context = global[_object2.node.name];
        func = context[_property2.node.name];
      }

      if (_object2.isLiteral() && _property2.isIdentifier()) {
        var _type = _typeof(_object2.node.value);

        if (_type === "string" || _type === "number") {
          context = _object2.node.value;
          func = context[_property2.node.name];
        }
      }
    }

    if (func) {
      var args = path.get("arguments").map(function (arg) {
        return evaluateCached(arg, state);
      });
      if (!state.confident) return;
      return func.apply(context, args);
    }
  }

  deopt(path, state);
}

function evaluateQuasis(path, quasis, state) {
  var raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var str = "";
  var i = 0;
  var exprs = path.get("expressions");
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = quasis[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var elem = _step3.value;
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      var expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (!state.confident) return;
  return str;
}

function evaluate() {
  var state = {
    confident: true,
    deoptPath: null,
    seen: new Map()
  };
  var value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOpposite = getOpposite;
exports.getCompletionRecords = getCompletionRecords;
exports.getSibling = getSibling;
exports.getPrevSibling = getPrevSibling;
exports.getNextSibling = getNextSibling;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.get = get;
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

var _index = _interopRequireDefault(require("./index"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}

function addCompletionRecords(path, paths) {
  if (path) return paths.concat(path.getCompletionRecords());
  return paths;
}

function completionRecordForSwitch(cases, paths) {
  var isLastCaseWithConsequent = true;

  for (var i = cases.length - 1; i >= 0; i--) {
    var switchCase = cases[i];
    var consequent = switchCase.get("consequent");
    var breakStatement = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      findBreak: for (var _iterator = consequent[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var statement = _step.value;

        if (statement.isBlockStatement()) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = statement.get("body")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var statementInBlock = _step2.value;

              if (statementInBlock.isBreakStatement()) {
                breakStatement = statementInBlock;
                break findBreak;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else if (statement.isBreakStatement()) {
          breakStatement = statement;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (breakStatement) {
      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {
        breakStatement = breakStatement.parentPath;
      }

      var prevSibling = breakStatement.getPrevSibling();

      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {
        paths = addCompletionRecords(prevSibling, paths);
        breakStatement.remove();
      } else {
        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());
        paths = addCompletionRecords(breakStatement, paths);
      }
    } else if (isLastCaseWithConsequent) {
      (function () {
        var statementFinder = function statementFinder(statement) {
          return !statement.isBlockStatement() || statement.get("body").some(statementFinder);
        };

        var hasConsequent = consequent.some(statementFinder);

        if (hasConsequent) {
          paths = addCompletionRecords(consequent[consequent.length - 1], paths);
          isLastCaseWithConsequent = false;
        }
      })();
    }
  }

  return paths;
}

function getCompletionRecords() {
  var paths = [];

  if (this.isIfStatement()) {
    paths = addCompletionRecords(this.get("consequent"), paths);
    paths = addCompletionRecords(this.get("alternate"), paths);
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else if (this.isProgram() || this.isBlockStatement()) {
    paths = addCompletionRecords(this.get("body").pop(), paths);
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    paths = addCompletionRecords(this.get("block"), paths);
    paths = addCompletionRecords(this.get("handler"), paths);
  } else if (this.isCatchClause()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else if (this.isSwitchStatement()) {
    paths = completionRecordForSwitch(this.get("cases"), paths);
  } else {
    paths.push(this);
  }

  return paths;
}

function getSibling(key) {
  return _index.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  });
}

function getPrevSibling() {
  return this.getSibling(this.key - 1);
}

function getNextSibling() {
  return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(++_key);
  var siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }

  return siblings;
}

function getAllPrevSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(--_key);
  var siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }

  return siblings;
}

function get(key, context) {
  if (context === true) context = this.context;
  var parts = key.split(".");

  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _getKey(key, context) {
  var _this = this;

  var node = this.node;
  var container = node[key];

  if (Array.isArray(container)) {
    return container.map(function (_, i) {
      return _index.default.get({
        listKey: key,
        parentPath: _this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _index.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _getPattern(parts, context) {
  var path = this;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = parts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var part = _step3.value;

      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return path;
}

function getBindingIdentifiers(duplicates) {
  return t.getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers(duplicates) {
  return t.getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths() {
  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var path = this;
  var search = [].concat(path);
  var ids = Object.create(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;
    if (!id.node) continue;
    var keys = t.getBindingIdentifiers.keys[id.node.type];

    if (id.isIdentifier()) {
      if (duplicates) {
        var _ids = ids[id.node.name] = ids[id.node.name] || [];

        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }

      continue;
    }

    if (id.isExportDeclaration()) {
      var declaration = id.get("declaration");

      if (declaration.isDeclaration()) {
        search.push(declaration);
      }

      continue;
    }

    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }

      if (id.isFunctionExpression()) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var child = id.get(key);

        if (Array.isArray(child) || child.node) {
          search = search.concat(child);
        }
      }
    }
  }

  return ids;
}

function getOuterBindingIdentifierPaths(duplicates) {
  return this.getBindingIdentifierPaths(duplicates, true);
}

},{"./index":183,"@babel/types":242}],183:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;

var virtualTypes = _interopRequireWildcard(require("./lib/virtual-types"));

var _debug = _interopRequireDefault(require("debug"));

var _index = _interopRequireDefault(require("../index"));

var _scope = _interopRequireDefault(require("../scope"));

var t = _interopRequireWildcard(require("@babel/types"));

var _cache = require("../cache");

var _generator = _interopRequireDefault(require("@babel/generator"));

var NodePath_ancestry = _interopRequireWildcard(require("./ancestry"));

var NodePath_inference = _interopRequireWildcard(require("./inference"));

var NodePath_replacement = _interopRequireWildcard(require("./replacement"));

var NodePath_evaluation = _interopRequireWildcard(require("./evaluation"));

var NodePath_conversion = _interopRequireWildcard(require("./conversion"));

var NodePath_introspection = _interopRequireWildcard(require("./introspection"));

var NodePath_context = _interopRequireWildcard(require("./context"));

var NodePath_removal = _interopRequireWildcard(require("./removal"));

var NodePath_modification = _interopRequireWildcard(require("./modification"));

var NodePath_family = _interopRequireWildcard(require("./family"));

var NodePath_comments = _interopRequireWildcard(require("./comments"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _debug2 = (0, _debug.default)("babel");

var REMOVED = 1 << 0;
exports.REMOVED = REMOVED;
var SHOULD_STOP = 1 << 1;
exports.SHOULD_STOP = SHOULD_STOP;
var SHOULD_SKIP = 1 << 2;
exports.SHOULD_SKIP = SHOULD_SKIP;

var NodePath =
/*#__PURE__*/
function () {
  function NodePath(hub, parent) {
    _classCallCheck(this, NodePath);

    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = null;
    this._traverseFlags = 0;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
  }

  _createClass(NodePath, [{
    key: "getScope",
    value: function getScope(scope) {
      return this.isScope() ? new _scope.default(this) : scope;
    }
  }, {
    key: "setData",
    value: function setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    }
  }, {
    key: "getData",
    value: function getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      var val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    }
  }, {
    key: "buildCodeFrameError",
    value: function buildCodeFrameError(msg) {
      var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;
      return this.hub.buildError(this.node, msg, Error);
    }
  }, {
    key: "traverse",
    value: function traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
  }, {
    key: "set",
    value: function set(key, node) {
      t.validate(this.node, key, node);
      this.node[key] = node;
    }
  }, {
    key: "getPathLocation",
    value: function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = "".concat(path.listKey, "[").concat(key, "]");
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    }
  }, {
    key: "debug",
    value: function debug(message) {
      if (!_debug2.enabled) return;

      _debug2("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(message));
    }
  }, {
    key: "toString",
    value: function toString() {
      return (0, _generator.default)(this.node).code;
    }
  }, {
    key: "inList",
    get: function get() {
      return !!this.listKey;
    },
    set: function set(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
  }, {
    key: "parentKey",
    get: function get() {
      return this.listKey || this.key;
    }
  }, {
    key: "shouldSkip",
    get: function get() {
      return !!(this._traverseFlags & SHOULD_SKIP);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= SHOULD_SKIP;
      } else {
        this._traverseFlags &= ~SHOULD_SKIP;
      }
    }
  }, {
    key: "shouldStop",
    get: function get() {
      return !!(this._traverseFlags & SHOULD_STOP);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= SHOULD_STOP;
      } else {
        this._traverseFlags &= ~SHOULD_STOP;
      }
    }
  }, {
    key: "removed",
    get: function get() {
      return !!(this._traverseFlags & REMOVED);
    },
    set: function set(v) {
      if (v) {
        this._traverseFlags |= REMOVED;
      } else {
        this._traverseFlags &= ~REMOVED;
      }
    }
  }], [{
    key: "get",
    value: function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];
      var paths = _cache.path.get(parent) || [];

      if (!_cache.path.has(parent)) {
        _cache.path.set(parent, paths);
      }

      var path;

      for (var i = 0; i < paths.length; i++) {
        var pathCheck = paths[i];

        if (pathCheck.node === targetNode) {
          path = pathCheck;
          break;
        }
      }

      if (!path) {
        path = new NodePath(hub, parent);
        paths.push(path);
      }

      path.setup(parentPath, container, listKey, key);
      return path;
    }
  }]);

  return NodePath;
}();

exports.default = NodePath;
Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  var _loop = function _loop() {
    var type = _step.value;
    var typeKey = "is".concat(type);
    var fn = t[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert".concat(type)] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type ".concat(type));
      }
    };
  };

  for (var _iterator = t.TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    _loop();
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return != null) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

var _loop2 = function _loop2() {
  var type = _Object$keys[_i];
  if (type[0] === "_") return "continue";
  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);
  var virtualType = virtualTypes[type];

  NodePath.prototype["is".concat(type)] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
};

for (var _i = 0, _Object$keys = Object.keys(virtualTypes); _i < _Object$keys.length; _i++) {
  var _ret = _loop2();

  if (_ret === "continue") continue;
}

},{"../cache":173,"../index":176,"../scope":195,"./ancestry":177,"./comments":178,"./context":179,"./conversion":180,"./evaluation":181,"./family":182,"./inference":184,"./introspection":187,"./lib/virtual-types":190,"./modification":191,"./removal":192,"./replacement":193,"@babel/generator":51,"@babel/types":242,"debug":198}],184:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeAnnotation = getTypeAnnotation;
exports._getTypeAnnotation = _getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.couldBeBaseType = couldBeBaseType;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.isGenericType = isGenericType;

var inferers = _interopRequireWildcard(require("./inferers"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function getTypeAnnotation() {
  if (this.typeAnnotation) return this.typeAnnotation;
  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();
  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
  return this.typeAnnotation = type;
}

function _getTypeAnnotation() {
  var node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      var declar = this.parentPath.parentPath;
      var declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return t.stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return t.anyTypeAnnotation();
      }

      return t.voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  var inferer = inferers[node.type];

  if (inferer) {
    return inferer.call(this, node);
  }

  inferer = inferers[this.parentPath.type];

  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}

function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return t.isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return t.isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return t.isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return t.isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return t.isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return t.isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return t.isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error("Unknown base type ".concat(baseName));
    }
  }
}

function couldBeBaseType(name) {
  var type = this.getTypeAnnotation();
  if (t.isAnyTypeAnnotation(type)) return true;

  if (t.isUnionTypeAnnotation(type)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = type.types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var type2 = _step.value;

        if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}

function baseTypeStrictlyMatches(right) {
  var left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();

  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}

function isGenericType(genericName) {
  var type = this.getTypeAnnotation();
  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {
    name: genericName
  });
}

},{"./inferers":186,"@babel/types":242}],185:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _default(node) {
  if (!this.isReferenced()) return;
  var binding = this.scope.getBinding(node.name);

  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
    }
  }

  if (node.name === "undefined") {
    return t.voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return t.numberTypeAnnotation();
  } else if (node.name === "arguments") {}
}

function getTypeAnnotationBindingConstantViolations(binding, path, name) {
  var types = [];
  var functionConstantViolations = [];
  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
  var testType = getConditionalAnnotation(binding, path, name);

  if (testType) {
    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
    constantViolations = constantViolations.filter(function (path) {
      return testConstantViolations.indexOf(path) < 0;
    });
    types.push(testType.typeAnnotation);
  }

  if (constantViolations.length) {
    constantViolations = constantViolations.concat(functionConstantViolations);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var violation = _step.value;
        types.push(violation.getTypeAnnotation());
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (types.length) {
    return t.createUnionTypeAnnotation(types);
  }
}

function getConstantViolationsBefore(binding, path, functions) {
  var violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(function (violation) {
    violation = violation.resolve();

    var status = violation._guessExecutionStatusRelativeTo(path);

    if (functions && status === "unknown") functions.push(violation);
    return status === "before";
  });
}

function inferAnnotationFromBinaryExpression(name, path) {
  var operator = path.node.operator;
  var right = path.get("right").resolve();
  var left = path.get("left").resolve();
  var target;

  if (left.isIdentifier({
    name: name
  })) {
    target = right;
  } else if (right.isIdentifier({
    name: name
  })) {
    target = left;
  }

  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    }

    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    }

    return;
  }

  if (operator !== "===" && operator !== "==") return;
  var typeofPath;
  var typePath;

  if (left.isUnaryExpression({
    operator: "typeof"
  })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({
    operator: "typeof"
  })) {
    typeofPath = right;
    typePath = left;
  }

  if (!typeofPath) return;
  if (!typeofPath.get("argument").isIdentifier({
    name: name
  })) return;
  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;
  var typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;
  return t.createTypeAnnotationBasedOnTypeof(typeValue);
}

function getParentConditionalPath(binding, path, name) {
  var parentPath;

  while (parentPath = path.parentPath) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      }

      return parentPath;
    }

    if (parentPath.isFunction()) {
      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
    }

    path = parentPath;
  }
}

function getConditionalAnnotation(binding, path, name) {
  var ifStatement = getParentConditionalPath(binding, path, name);
  if (!ifStatement) return;
  var test = ifStatement.get("test");
  var paths = [test];
  var types = [];

  for (var i = 0; i < paths.length; i++) {
    var _path = paths[i];

    if (_path.isLogicalExpression()) {
      if (_path.node.operator === "&&") {
        paths.push(_path.get("left"));
        paths.push(_path.get("right"));
      }
    } else if (_path.isBinaryExpression()) {
      var type = inferAnnotationFromBinaryExpression(name, _path);
      if (type) types.push(type);
    }
  }

  if (types.length) {
    return {
      typeAnnotation: t.createUnionTypeAnnotation(types),
      ifStatement: ifStatement
    };
  }

  return getConditionalAnnotation(ifStatement, name);
}

},{"@babel/types":242}],186:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableDeclarator = VariableDeclarator;
exports.TypeCastExpression = TypeCastExpression;
exports.NewExpression = NewExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.UnaryExpression = UnaryExpression;
exports.BinaryExpression = BinaryExpression;
exports.LogicalExpression = LogicalExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.SequenceExpression = SequenceExpression;
exports.ParenthesizedExpression = ParenthesizedExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.UpdateExpression = UpdateExpression;
exports.StringLiteral = StringLiteral;
exports.NumericLiteral = NumericLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.RegExpLiteral = RegExpLiteral;
exports.ObjectExpression = ObjectExpression;
exports.ArrayExpression = ArrayExpression;
exports.RestElement = RestElement;
exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
exports.CallExpression = CallExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function get() {
    return _infererReference.default;
  }
});

var t = _interopRequireWildcard(require("@babel/types"));

var _infererReference = _interopRequireDefault(require("./inferer-reference"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function VariableDeclarator() {
  var id = this.get("id");
  if (!id.isIdentifier()) return;
  var init = this.get("init");
  var type = init.getTypeAnnotation();

  if (type && type.type === "AnyTypeAnnotation") {
    if (init.isCallExpression() && init.get("callee").isIdentifier({
      name: "Array"
    }) && !init.scope.hasBinding("Array", true)) {
      type = ArrayExpression();
    }
  }

  return type;
}

function TypeCastExpression(node) {
  return node.typeAnnotation;
}

TypeCastExpression.validParent = true;

function NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    return t.genericTypeAnnotation(node.callee);
  }
}

function TemplateLiteral() {
  return t.stringTypeAnnotation();
}

function UnaryExpression(node) {
  var operator = node.operator;

  if (operator === "void") {
    return t.voidTypeAnnotation();
  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.stringTypeAnnotation();
  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  }
}

function BinaryExpression(node) {
  var operator = node.operator;

  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  } else if (operator === "+") {
    var right = this.get("right");
    var left = this.get("left");

    if (left.isBaseType("number") && right.isBaseType("number")) {
      return t.numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      return t.stringTypeAnnotation();
    }

    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);
  }
}

function LogicalExpression() {
  return t.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
}

function ConditionalExpression() {
  return t.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
}

function SequenceExpression() {
  return this.get("expressions").pop().getTypeAnnotation();
}

function ParenthesizedExpression() {
  return this.get("expression").getTypeAnnotation();
}

function AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}

function UpdateExpression(node) {
  var operator = node.operator;

  if (operator === "++" || operator === "--") {
    return t.numberTypeAnnotation();
  }
}

function StringLiteral() {
  return t.stringTypeAnnotation();
}

function NumericLiteral() {
  return t.numberTypeAnnotation();
}

function BooleanLiteral() {
  return t.booleanTypeAnnotation();
}

function NullLiteral() {
  return t.nullLiteralTypeAnnotation();
}

function RegExpLiteral() {
  return t.genericTypeAnnotation(t.identifier("RegExp"));
}

function ObjectExpression() {
  return t.genericTypeAnnotation(t.identifier("Object"));
}

function ArrayExpression() {
  return t.genericTypeAnnotation(t.identifier("Array"));
}

function RestElement() {
  return ArrayExpression();
}

RestElement.validParent = true;

function Func() {
  return t.genericTypeAnnotation(t.identifier("Function"));
}

var isArrayFrom = t.buildMatchMemberExpression("Array.from");
var isObjectKeys = t.buildMatchMemberExpression("Object.keys");
var isObjectValues = t.buildMatchMemberExpression("Object.values");
var isObjectEntries = t.buildMatchMemberExpression("Object.entries");

function CallExpression() {
  var callee = this.node.callee;

  if (isObjectKeys(callee)) {
    return t.arrayTypeAnnotation(t.stringTypeAnnotation());
  } else if (isArrayFrom(callee) || isObjectValues(callee)) {
    return t.arrayTypeAnnotation(t.anyTypeAnnotation());
  } else if (isObjectEntries(callee)) {
    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));
  }

  return resolveCall(this.get("callee"));
}

function TaggedTemplateExpression() {
  return resolveCall(this.get("tag"));
}

function resolveCall(callee) {
  callee = callee.resolve();

  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
      } else {
        return t.genericTypeAnnotation(t.identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {}
    }
  }
}

},{"./inferer-reference":185,"@babel/types":242}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchesPattern = matchesPattern;
exports.has = has;
exports.isStatic = isStatic;
exports.isnt = isnt;
exports.equals = equals;
exports.isNodeType = isNodeType;
exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
exports.isCompletionRecord = isCompletionRecord;
exports.isStatementOrBlock = isStatementOrBlock;
exports.referencesImport = referencesImport;
exports.getSource = getSource;
exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
exports.resolve = resolve;
exports._resolve = _resolve;
exports.isConstantExpression = isConstantExpression;
exports.isInStrictMode = isInStrictMode;
exports.is = void 0;

var _includes = _interopRequireDefault(require("lodash/includes"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function matchesPattern(pattern, allowPartial) {
  return t.matchesPattern(this.node, pattern, allowPartial);
}

function has(key) {
  var val = this.node && this.node[key];

  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

function isStatic() {
  return this.scope.isStatic(this.node);
}

var is = has;
exports.is = is;

function isnt(key) {
  return !this.has(key);
}

function equals(key, value) {
  return this.node[key] === value;
}

function isNodeType(type) {
  return t.isType(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }

  if (this.isExpression()) {
    return t.isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return t.isExpression(replacement);
  }

  return false;
}

function isCompletionRecord(allowInsideFunction) {
  var path = this;
  var first = true;

  do {
    var container = path.container;

    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _includes.default)(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;
  var binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;
  var path = binding.path;
  var parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;

  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }

  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }

  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }

  return false;
}

function getSource() {
  var node = this.node;

  if (node.end) {
    var code = this.hub.getCode();
    if (code) return code.slice(node.start, node.end);
  }

  return "";
}

function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function getOuterFunction(path) {
  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
}

function isExecutionUncertain(type, key) {
  switch (type) {
    case "LogicalExpression":
      return key === "right";

    case "ConditionalExpression":
    case "IfStatement":
      return key === "consequent" || key === "alternate";

    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return key === "body";

    case "ForStatement":
      return key === "body" || key === "update";

    case "SwitchStatement":
      return key === "cases";

    case "TryStatement":
      return key === "handler";

    case "AssignmentPattern":
      return key === "right";

    case "OptionalMemberExpression":
      return key === "property";

    case "OptionalCallExpression":
      return key === "arguments";

    default:
      return false;
  }
}

function isExecutionUncertainInList(paths, maxIndex) {
  for (var i = 0; i < maxIndex; i++) {
    var path = paths[i];

    if (isExecutionUncertain(path.parent.type, path.parentKey)) {
      return true;
    }
  }

  return false;
}

function _guessExecutionStatusRelativeTo(target) {
  var funcParent = {
    this: getOuterFunction(this),
    target: getOuterFunction(target)
  };

  if (funcParent.target.node !== funcParent.this.node) {
    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
  }

  var paths = {
    target: target.getAncestry(),
    this: this.getAncestry()
  };
  if (paths.target.indexOf(this) >= 0) return "after";
  if (paths.this.indexOf(target) >= 0) return "before";
  var commonPath;
  var commonIndex = {
    target: 0,
    this: 0
  };

  while (!commonPath && commonIndex.this < paths.this.length) {
    var path = paths.this[commonIndex.this];
    commonIndex.target = paths.target.indexOf(path);

    if (commonIndex.target >= 0) {
      commonPath = path;
    } else {
      commonIndex.this++;
    }
  }

  if (!commonPath) {
    throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
  }

  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
    return "unknown";
  }

  var divergence = {
    this: paths.this[commonIndex.this - 1],
    target: paths.target[commonIndex.target - 1]
  };

  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
    return divergence.target.key > divergence.this.key ? "before" : "after";
  }

  var keys = t.VISITOR_KEYS[commonPath.type];
  var keyPosition = {
    this: keys.indexOf(divergence.this.parentKey),
    target: keys.indexOf(divergence.target.parentKey)
  };
  return keyPosition.target > keyPosition.this ? "before" : "after";
}

var executionOrderCheckedNodes = new WeakSet();

function _guessExecutionStatusRelativeToDifferentFunctions(target) {
  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
    return "unknown";
  }

  var binding = target.scope.getBinding(target.node.id.name);
  if (!binding.references) return "before";
  var referencePaths = binding.referencePaths;
  var allStatus;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = referencePaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var path = _step.value;
      var childOfFunction = !!path.find(function (path) {
        return path.node === target.node;
      });
      if (childOfFunction) continue;

      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }

      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);

      var status = this._guessExecutionStatusRelativeTo(path);

      executionOrderCheckedNodes.delete(path.node);

      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return allStatus;
}

function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
  if (resolved && resolved.indexOf(this) >= 0) return;
  resolved = resolved || [];
  resolved.push(this);

  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {}
  } else if (this.isReferencedIdentifier()) {
    var binding = this.scope.getBinding(this.node.name);
    if (!binding) return;
    if (!binding.constant) return;
    if (binding.kind === "module") return;

    if (binding.path !== this) {
      var ret = binding.path.resolve(dangerous, resolved);
      if (this.find(function (parent) {
        return parent.node === ret.node;
      })) return;
      return ret;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {
    var targetKey = this.toComputedKey();
    if (!t.isLiteral(targetKey)) return;
    var targetName = targetKey.value;
    var target = this.get("object").resolve(dangerous, resolved);

    if (target.isObjectExpression()) {
      var props = target.get("properties");
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prop = _step2.value;
          if (!prop.isProperty()) continue;
          var key = prop.get("key");
          var match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match) return prop.get("value").resolve(dangerous, resolved);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      var elems = target.get("elements");
      var elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}

function isConstantExpression() {
  if (this.isIdentifier()) {
    var binding = this.scope.getBinding(this.node.name);
    if (!binding) return false;
    return binding.constant;
  }

  if (this.isLiteral()) {
    if (this.isRegExpLiteral()) {
      return false;
    }

    if (this.isTemplateLiteral()) {
      return this.get("expressions").every(function (expression) {
        return expression.isConstantExpression();
      });
    }

    return true;
  }

  if (this.isUnaryExpression()) {
    if (this.get("operator").node !== "void") {
      return false;
    }

    return this.get("argument").isConstantExpression();
  }

  if (this.isBinaryExpression()) {
    return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
  }

  return false;
}

function isInStrictMode() {
  var start = this.isProgram() ? this : this.parentPath;
  var strictParent = start.find(function (path) {
    if (path.isProgram({
      sourceType: "module"
    })) return true;
    if (path.isClass()) return true;
    if (!path.isProgram() && !path.isFunction()) return false;

    if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
      return false;
    }

    var node = path.node;
    if (path.isFunction()) node = node.body;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = node.directives[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var directive = _step3.value;

        if (directive.value.value === "use strict") {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  });
  return !!strictParent;
}

},{"@babel/types":242,"lodash/includes":1015}],188:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var referenceVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
      return;
    }

    if (path.node.name === "this") {
      var scope = path.scope;

      do {
        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }
      } while (scope = scope.parent);

      if (scope) state.breakOnScopePaths.push(scope.path);
    }

    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var violation = _step.value;

        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (binding !== state.scope.getBinding(path.node.name)) return;
    state.bindings[path.node.name] = binding;
  }
};

var PathHoister =
/*#__PURE__*/
function () {
  function PathHoister(path, scope) {
    _classCallCheck(this, PathHoister);

    this.breakOnScopePaths = [];
    this.bindings = {};
    this.mutableBinding = false;
    this.scopes = [];
    this.scope = scope;
    this.path = path;
    this.attachAfter = false;
  }

  _createClass(PathHoister, [{
    key: "isCompatibleScope",
    value: function isCompatibleScope(scope) {
      for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var binding = this.bindings[key];

        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "getCompatibleScopes",
    value: function getCompatibleScopes() {
      var scope = this.path.scope;

      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }

        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    }
  }, {
    key: "getAttachmentPath",
    value: function getAttachmentPath() {
      var path = this._getAttachmentPath();

      if (!path) return;
      var targetScope = path.scope;

      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }

      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          if (!targetScope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];

          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }

          var bindingParentPath = this.getAttachmentParentForPath(binding.path);

          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = binding.constantViolations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var violationPath = _step2.value;

                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }
      }

      return path;
    }
  }, {
    key: "_getAttachmentPath",
    value: function _getAttachmentPath() {
      var scopes = this.scopes;
      var scope = scopes.pop();
      if (!scope) return;

      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope) return;
          var bodies = scope.path.get("body").get("body");

          for (var i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }
  }, {
    key: "getNextScopeAttachmentParent",
    value: function getNextScopeAttachmentParent() {
      var scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    }
  }, {
    key: "getAttachmentParentForPath",
    value: function getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    }
  }, {
    key: "hasOwnParamBindings",
    value: function hasOwnParamBindings(scope) {
      for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        if (!scope.hasOwnBinding(name)) continue;
        var binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant) return true;
      }

      return false;
    }
  }, {
    key: "run",
    value: function run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      var attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      var uid = attachTo.scope.generateUidIdentifier("ref");
      var declarator = t.variableDeclarator(uid, this.path.node);
      var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration("var", [declarator])]),
          _attachTo$insertFn2 = _slicedToArray(_attachTo$insertFn, 1),
          attached = _attachTo$insertFn2[0];

      var parent = this.path.parentPath;

      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = t.JSXExpressionContainer(uid);
      }

      this.path.replaceWith(t.cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  }]);

  return PathHoister;
}();

exports.default = PathHoister;

},{"@babel/types":242}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hooks = void 0;
var hooks = [function (self, parent) {
  var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

  if (removeParent) {
    parent.remove();
    return true;
  }
}, function (self, parent) {
  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
    parent.replaceWith(parent.node.expressions[0]);
    return true;
  }
}, function (self, parent) {
  if (parent.isBinary()) {
    if (self.key === "left") {
      parent.replaceWith(parent.node.right);
    } else {
      parent.replaceWith(parent.node.left);
    }

    return true;
  }
}, function (self, parent) {
  if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
    self.replaceWith({
      type: "BlockStatement",
      body: []
    });
    return true;
  }
}];
exports.hooks = hooks;

},{}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],
  checkPath: function checkPath(path, opts) {
    var node = path.node,
        parent = path.parent;

    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
      if (t.isJSXIdentifier(node, opts)) {
        if (t.react.isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }

    return t.isReferenced(node, parent, path.parentPath.parent);
  }
};
exports.ReferencedIdentifier = ReferencedIdentifier;
var ReferencedMemberExpression = {
  types: ["MemberExpression"],
  checkPath: function checkPath(_ref) {
    var node = _ref.node,
        parent = _ref.parent;
    return t.isMemberExpression(node) && t.isReferenced(node, parent);
  }
};
exports.ReferencedMemberExpression = ReferencedMemberExpression;
var BindingIdentifier = {
  types: ["Identifier"],
  checkPath: function checkPath(path) {
    var node = path.node,
        parent = path.parent;
    var grandparent = path.parentPath.parent;
    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);
  }
};
exports.BindingIdentifier = BindingIdentifier;
var Statement = {
  types: ["Statement"],
  checkPath: function checkPath(_ref2) {
    var node = _ref2.node,
        parent = _ref2.parent;

    if (t.isStatement(node)) {
      if (t.isVariableDeclaration(node)) {
        if (t.isForXStatement(parent, {
          left: node
        })) return false;
        if (t.isForStatement(parent, {
          init: node
        })) return false;
      }

      return true;
    } else {
      return false;
    }
  }
};
exports.Statement = Statement;
var Expression = {
  types: ["Expression"],
  checkPath: function checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return t.isExpression(path.node);
    }
  }
};
exports.Expression = Expression;
var Scope = {
  types: ["Scopable"],
  checkPath: function checkPath(path) {
    return t.isScope(path.node, path.parent);
  }
};
exports.Scope = Scope;
var Referenced = {
  checkPath: function checkPath(path) {
    return t.isReferenced(path.node, path.parent);
  }
};
exports.Referenced = Referenced;
var BlockScoped = {
  checkPath: function checkPath(path) {
    return t.isBlockScoped(path.node);
  }
};
exports.BlockScoped = BlockScoped;
var Var = {
  types: ["VariableDeclaration"],
  checkPath: function checkPath(path) {
    return t.isVar(path.node);
  }
};
exports.Var = Var;
var User = {
  checkPath: function checkPath(path) {
    return path.node && !!path.node.loc;
  }
};
exports.User = User;
var Generated = {
  checkPath: function checkPath(path) {
    return !path.isUser();
  }
};
exports.Generated = Generated;
var Pure = {
  checkPath: function checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }
};
exports.Pure = Pure;
var Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
  checkPath: function checkPath(_ref3) {
    var node = _ref3.node;

    if (t.isFlow(node)) {
      return true;
    } else if (t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t.isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
};
exports.Flow = Flow;
var RestProperty = {
  types: ["RestElement"],
  checkPath: function checkPath(path) {
    return path.parentPath && path.parentPath.isObjectPattern();
  }
};
exports.RestProperty = RestProperty;
var SpreadProperty = {
  types: ["RestElement"],
  checkPath: function checkPath(path) {
    return path.parentPath && path.parentPath.isObjectExpression();
  }
};
exports.SpreadProperty = SpreadProperty;
var ExistentialTypeParam = {
  types: ["ExistsTypeAnnotation"]
};
exports.ExistentialTypeParam = ExistentialTypeParam;
var NumericLiteralTypeAnnotation = {
  types: ["NumberLiteralTypeAnnotation"]
};
exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
var ForAwaitStatement = {
  types: ["ForOfStatement"],
  checkPath: function checkPath(_ref4) {
    var node = _ref4.node;
    return node.await === true;
  }
};
exports.ForAwaitStatement = ForAwaitStatement;

},{"@babel/types":242}],191:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertBefore = insertBefore;
exports._containerInsert = _containerInsert;
exports._containerInsertBefore = _containerInsertBefore;
exports._containerInsertAfter = _containerInsertAfter;
exports.insertAfter = insertAfter;
exports.updateSiblingKeys = updateSiblingKeys;
exports._verifyNodeList = _verifyNodeList;
exports.unshiftContainer = unshiftContainer;
exports.pushContainer = pushContainer;
exports.hoist = hoist;

var _cache = require("../cache");

var _hoister = _interopRequireDefault(require("./lib/hoister"));

var _index = _interopRequireDefault(require("./index"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function insertBefore(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  var parentPath = this.parentPath;

  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
    return parentPath.insertBefore(nodes);
  } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
    if (this.node) nodes.push(this.node);
    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertBefore(nodes);
  } else if (this.isStatementOrBlock()) {
    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));
    return this.unshiftContainer("body", nodes);
  } else {
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
  }
}

function _containerInsert(from, nodes) {
  var _this$container;

  this.updateSiblingKeys(from, nodes.length);
  var paths = [];

  (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(_toConsumableArray(nodes)));

  for (var i = 0; i < nodes.length; i++) {
    var to = from + i;
    var path = this.getSibling(to);
    paths.push(path);

    if (this.context && this.context.queue) {
      path.pushContext(this.context);
    }
  }

  var contexts = this._getQueueContexts();

  for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
    var _path = _paths[_i];

    _path.setScope();

    _path.debug("Inserted.");

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = contexts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var context = _step.value;
        context.maybeQueue(_path, true);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return paths;
}

function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}

function _containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}

function insertAfter(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  var parentPath = this.parentPath;

  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
    return parentPath.insertAfter(nodes.map(function (node) {
      return t.isExpression(node) ? t.expressionStatement(node) : node;
    }));
  } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
    if (this.node) {
      var scope = this.scope;

      if (parentPath.isMethod({
        computed: true,
        key: this.node
      })) {
        scope = scope.parent;
      }

      var temp = scope.generateDeclaredUidIdentifier();
      nodes.unshift(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(temp), this.node)));
      nodes.push(t.expressionStatement(t.cloneNode(temp)));
    }

    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertAfter(nodes);
  } else if (this.isStatementOrBlock()) {
    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));
    return this.pushContainer("body", nodes);
  } else {
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
  }
}

function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;

  var paths = _cache.path.get(this.parent);

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];

    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}

function _verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }

  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var msg = void 0;

    if (!node) {
      msg = "has falsy node";
    } else if (_typeof(node) !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof _index.default) {
      msg = "has a NodePath when it expected a raw object";
    }

    if (msg) {
      var type = Array.isArray(node) ? "array" : _typeof(node);
      throw new Error("Node list ".concat(msg, " with the index of ").concat(i, " and type of ").concat(type));
    }
  }

  return nodes;
}

function unshiftContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var path = _index.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey: listKey,
    key: 0
  });

  return path._containerInsertBefore(nodes);
}

function pushContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  var container = this.node[listKey];

  var path = _index.default.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey: listKey,
    key: container.length
  });

  return path.replaceWithMultiple(nodes);
}

function hoist() {
  var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;
  var hoister = new _hoister.default(this, scope);
  return hoister.run();
}

},{"../cache":173,"./index":183,"./lib/hoister":188,"@babel/types":242}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = remove;
exports._removeFromScope = _removeFromScope;
exports._callRemovalHooks = _callRemovalHooks;
exports._remove = _remove;
exports._markRemoved = _markRemoved;
exports._assertUnremoved = _assertUnremoved;

var _removalHooks = require("./lib/removal-hooks");

var _index = require("./index");

function remove() {
  this._assertUnremoved();

  this.resync();

  this._removeFromScope();

  if (this._callRemovalHooks()) {
    this._markRemoved();

    return;
  }

  this.shareCommentsWithSiblings();

  this._remove();

  this._markRemoved();
}

function _removeFromScope() {
  var _this = this;

  var bindings = this.getBindingIdentifiers();
  Object.keys(bindings).forEach(function (name) {
    return _this.scope.removeBinding(name);
  });
}

function _callRemovalHooks() {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _removalHooks.hooks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fn = _step.value;
      if (fn(this, this.parentPath)) return true;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}

function _markRemoved() {
  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
  this.node = null;
}

function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
}

},{"./index":183,"./lib/removal-hooks":189}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;
exports.replaceWith = replaceWith;
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;

var _codeFrame = require("@babel/code-frame");

var _index = _interopRequireDefault(require("../index"));

var _index2 = _interopRequireDefault(require("./index"));

var _parser = require("@babel/parser");

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var hoistVariablesVisitor = {
  Function: function Function(path) {
    path.skip();
  },
  VariableDeclaration: function VariableDeclaration(path) {
    if (path.node.kind !== "var") return;
    var bindings = path.getBindingIdentifiers();

    for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      path.scope.push({
        id: bindings[key]
      });
    }

    var exprs = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = path.node.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var declar = _step.value;

        if (declar.init) {
          exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    path.replaceWithMultiple(exprs);
  }
};

function replaceWithMultiple(nodes) {
  this.resync();
  nodes = this._verifyNodeList(nodes);
  t.inheritLeadingComments(nodes[0], this.node);
  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  var paths = this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }

  return paths;
}

function replaceWithSourceString(replacement) {
  this.resync();

  try {
    replacement = "(".concat(replacement, ")");
    replacement = (0, _parser.parse)(replacement);
  } catch (err) {
    var loc = err.loc;

    if (loc) {
      err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      });
      err.code = "BABEL_REPLACE_SOURCE_ERROR";
    }

    throw err;
  }

  replacement = replacement.program.body[0].expression;

  _index.default.removeProperties(replacement);

  return this.replaceWith(replacement);
}

function replaceWith(replacement) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  if (replacement instanceof _index2.default) {
    replacement = replacement.node;
  }

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return [this];
  }

  if (this.isProgram() && !t.isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  var nodePath = "";

  if (this.isNodeType("Statement") && t.isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
      replacement = t.expressionStatement(replacement);
      nodePath = "expression";
    }
  }

  if (this.isNodeType("Expression") && t.isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  var oldNode = this.node;

  if (oldNode) {
    t.inheritsComments(replacement, oldNode);
    t.removeComments(oldNode);
  }

  this._replaceWith(replacement);

  this.type = replacement.type;
  this.setScope();
  this.requeue();
  return [nodePath ? this.get(nodePath) : this];
}

function _replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    t.validate(this.parent, this.key, [node]);
  } else {
    t.validate(this.parent, this.key, node);
  }

  this.debug("Replace with ".concat(node && node.type));
  this.node = this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes) {
  this.resync();
  var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);

  if (toSequenceExpression) {
    return this.replaceWith(toSequenceExpression)[0].get("expressions");
  }

  var functionParent = this.getFunctionParent();
  var isParentAsync = functionParent && functionParent.is("async");
  var container = t.arrowFunctionExpression([], t.blockStatement(nodes));
  this.replaceWith(t.callExpression(container, []));
  this.traverse(hoistVariablesVisitor);
  var completionRecords = this.get("callee").getCompletionRecords();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = completionRecords[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var path = _step2.value;
      if (!path.isExpressionStatement()) continue;
      var loop = path.findParent(function (path) {
        return path.isLoop();
      });

      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          var _callee = this.get("callee");

          uid = _callee.scope.generateDeclaredUidIdentifier("ret");

          _callee.get("body").pushContainer("body", t.returnStatement(t.cloneNode(uid)));

          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = t.identifier(uid.name);
        }

        path.get("expression").replaceWith(t.assignmentExpression("=", t.cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(t.returnStatement(path.node.expression));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var callee = this.get("callee");
  callee.arrowFunctionToExpression();

  if (isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", t.FUNCTION_TYPES)) {
    callee.set("async", true);
    this.replaceWith(t.awaitExpression(this.node));
  }

  return callee.get("body.body");
}

function replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);

      var paths = this._containerInsertAfter(nodes);

      this.remove();
      return paths;
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}

},{"../index":176,"./index":183,"@babel/code-frame":1,"@babel/parser":89,"@babel/types":242}],194:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var Binding =
/*#__PURE__*/
function () {
  function Binding(_ref) {
    var identifier = _ref.identifier,
        scope = _ref.scope,
        path = _ref.path,
        kind = _ref.kind;

    _classCallCheck(this, Binding);

    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;
    this.constantViolations = [];
    this.constant = true;
    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;
    this.clearValue();
  }

  _createClass(Binding, [{
    key: "deoptValue",
    value: function deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    }
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }
  }, {
    key: "reassign",
    value: function reassign(path) {
      this.constant = false;

      if (this.constantViolations.indexOf(path) !== -1) {
        return;
      }

      this.constantViolations.push(path);
    }
  }, {
    key: "reference",
    value: function reference(path) {
      if (this.referencePaths.indexOf(path) !== -1) {
        return;
      }

      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    }
  }, {
    key: "dereference",
    value: function dereference() {
      this.references--;
      this.referenced = !!this.references;
    }
  }]);

  return Binding;
}();

exports.default = Binding;

},{}],195:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _includes = _interopRequireDefault(require("lodash/includes"));

var _repeat = _interopRequireDefault(require("lodash/repeat"));

var _renamer = _interopRequireDefault(require("./lib/renamer"));

var _index = _interopRequireDefault(require("../index"));

var _defaults = _interopRequireDefault(require("lodash/defaults"));

var _binding = _interopRequireDefault(require("./binding"));

var _globals = _interopRequireDefault(require("globals"));

var t = _interopRequireWildcard(require("@babel/types"));

var _cache = require("../cache");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function gatherNodeParts(node, parts) {
  if (t.isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var specifier = _step.value;
          gatherNodeParts(specifier, parts);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t.isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t.isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.property, parts);
  } else if (t.isIdentifier(node)) {
    parts.push(node.name);
  } else if (t.isLiteral(node)) {
    parts.push(node.value);
  } else if (t.isCallExpression(node)) {
    gatherNodeParts(node.callee, parts);
  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;
        gatherNodeParts(prop.key || prop.argument, parts);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } else if (t.isPrivateName(node)) {
    gatherNodeParts(node.id, parts);
  } else if (t.isThisExpression(node)) {
    parts.push("this");
  } else if (t.isSuper(node)) {
    parts.push("super");
  }
}

var collectorVisitor = {
  For: function For(path) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = t.FOR_INIT_KEYS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var key = _step3.value;
        var declar = path.get(key);

        if (declar.isVar()) {
          var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  },
  Declaration: function Declaration(path) {
    if (path.isBlockScoped()) return;

    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
      return;
    }

    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
    parent.registerDeclaration(path);
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement: function ForXStatement(path, state) {
    var left = path.get("left");

    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(path);
    }
  },
  ExportDeclaration: {
    exit: function exit(path) {
      var node = path.node,
          scope = path.scope;
      var declar = node.declaration;

      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
        var id = declar.id;
        if (!id) return;
        var binding = scope.getBinding(id.name);
        if (binding) binding.reference(path);
      } else if (t.isVariableDeclaration(declar)) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = declar.declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var decl = _step4.value;

            for (var _i = 0, _Object$keys = Object.keys(t.getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {
              var name = _Object$keys[_i];

              var _binding2 = scope.getBinding(name);

              if (_binding2) _binding2.reference(path);
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    }
  },
  LabeledStatement: function LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression: function AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression: function UpdateExpression(path, state) {
    state.constantViolations.push(path);
  },
  UnaryExpression: function UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path);
    }
  },
  BlockScoped: function BlockScoped(path) {
    var scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var id = path.node.id;
    if (!id) return;
    var name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },
  Block: function Block(path) {
    var paths = path.get("body");
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = paths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var bodyPath = _step5.value;

        if (bodyPath.isFunctionDeclaration()) {
          path.scope.getBlockParent().registerDeclaration(bodyPath);
        }
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  }
};
var uid = 0;

var Scope =
/*#__PURE__*/
function () {
  function Scope(path) {
    _classCallCheck(this, Scope);

    var node = path.node;

    var cached = _cache.scope.get(node);

    if (cached && cached.path === path) {
      return cached;
    }

    _cache.scope.set(node, this);

    this.uid = uid++;
    this.block = node;
    this.path = path;
    this.labels = new Map();
  }

  _createClass(Scope, [{
    key: "traverse",
    value: function traverse(node, opts, state) {
      (0, _index.default)(node, opts, this, state, this.path);
    }
  }, {
    key: "generateDeclaredUidIdentifier",
    value: function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return t.cloneNode(id);
    }
  }, {
    key: "generateUidIdentifier",
    value: function generateUidIdentifier(name) {
      return t.identifier(this.generateUid(name));
    }
  }, {
    key: "generateUid",
    value: function generateUid() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
      name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      var uid;
      var i = 0;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      var program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    }
  }, {
    key: "_generateUid",
    value: function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_".concat(id);
    }
  }, {
    key: "generateUidBasedOnNode",
    value: function generateUidBasedOnNode(parent, defaultName) {
      var node = parent;

      if (t.isAssignmentExpression(parent)) {
        node = parent.left;
      } else if (t.isVariableDeclarator(parent)) {
        node = parent.id;
      } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
        node = node.key;
      }

      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
  }, {
    key: "generateUidIdentifierBasedOnNode",
    value: function generateUidIdentifierBasedOnNode(parent, defaultName) {
      return t.identifier(this.generateUidBasedOnNode(parent, defaultName));
    }
  }, {
    key: "isStatic",
    value: function isStatic(node) {
      if (t.isThisExpression(node) || t.isSuper(node)) {
        return true;
      }

      if (t.isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    }
  }, {
    key: "maybeGenerateMemoised",
    value: function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id: id
          });
          return t.cloneNode(id);
        }

        return id;
      }
    }
  }, {
    key: "checkBlockScopedCollisions",
    value: function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

      if (duplicate) {
        throw this.hub.buildError(id, "Duplicate declaration \"".concat(name, "\""), TypeError);
      }
    }
  }, {
    key: "rename",
    value: function rename(oldName, newName, block) {
      var binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new _renamer.default(binding, oldName, newName).rename(block);
      }
    }
  }, {
    key: "_renameFromMap",
    value: function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    }
  }, {
    key: "dump",
    value: function dump() {
      var sep = (0, _repeat.default)("-", 60);
      console.log(sep);
      var scope = this;

      do {
        console.log("#", scope.block.type);

        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          var binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    }
  }, {
    key: "toArray",
    value: function toArray(node, i) {
      if (t.isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (t.isArrayExpression(node)) {
        return node;
      }

      if (t.isIdentifier(node, {
        name: "arguments"
      })) {
        return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [node]);
      }

      var helperName;
      var args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(t.numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      return t.callExpression(this.hub.addHelper(helperName), args);
    }
  }, {
    key: "hasLabel",
    value: function hasLabel(name) {
      return !!this.getLabel(name);
    }
  }, {
    key: "getLabel",
    value: function getLabel(name) {
      return this.labels.get(name);
    }
  }, {
    key: "registerLabel",
    value: function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    }
  }, {
    key: "registerDeclaration",
    value: function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var declar = _step6.value;
            this.registerBinding(path.node.kind, declar);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } else if (path.isClassDeclaration()) {
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var specifiers = path.get("specifiers");
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = specifiers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var specifier = _step7.value;
            this.registerBinding("module", specifier);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
              _iterator7.return();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");

        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    }
  }, {
    key: "buildUndefinedNode",
    value: function buildUndefinedNode() {
      return t.unaryExpression("void", t.numericLiteral(0), true);
    }
  }, {
    key: "registerConstantViolation",
    value: function registerConstantViolation(path) {
      var ids = path.getBindingIdentifiers();

      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = this.getBinding(name);
        if (binding) binding.reassign(path);
      }
    }
  }, {
    key: "registerBinding",
    value: function registerBinding(kind, path) {
      var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;
      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = declarators[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var declar = _step8.value;
            this.registerBinding(kind, declar);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        return;
      }

      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);

      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
        var name = _Object$keys4[_i4];
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = ids[name][Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var id = _step9.value;
            var local = this.getOwnBinding(name);

            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }

            parent.references[name] = true;

            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind: kind
              });
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }
    }
  }, {
    key: "addGlobal",
    value: function addGlobal(node) {
      this.globals[node.name] = node;
    }
  }, {
    key: "hasUid",
    value: function hasUid(name) {
      var scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    }
  }, {
    key: "hasGlobal",
    value: function hasGlobal(name) {
      var scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    }
  }, {
    key: "hasReference",
    value: function hasReference(name) {
      var scope = this;

      do {
        if (scope.references[name]) return true;
      } while (scope = scope.parent);

      return false;
    }
  }, {
    key: "isPure",
    value: function isPure(node, constantsOnly) {
      if (t.isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (t.isClass(node)) {
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (t.isClassBody(node)) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = node.body[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var method = _step10.value;
            if (!this.isPure(method, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }

        return true;
      } else if (t.isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (t.isArrayExpression(node)) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = node.elements[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var elem = _step11.value;
            if (!this.isPure(elem, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        return true;
      } else if (t.isObjectExpression(node)) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = node.properties[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var prop = _step12.value;
            if (!this.isPure(prop, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
              _iterator12.return();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }

        return true;
      } else if (t.isClassMethod(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (node.kind === "get" || node.kind === "set") return false;
        return true;
      } else if (t.isProperty(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        return this.isPure(node.value, constantsOnly);
      } else if (t.isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (t.isTaggedTemplateExpression(node)) {
        return t.matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (t.isTemplateLiteral(node)) {
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = node.expressions[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var expression = _step13.value;
            if (!this.isPure(expression, constantsOnly)) return false;
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
              _iterator13.return();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }

        return true;
      } else {
        return t.isPureish(node);
      }
    }
  }, {
    key: "setData",
    value: function setData(key, val) {
      return this.data[key] = val;
    }
  }, {
    key: "getData",
    value: function getData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    }
  }, {
    key: "removeData",
    value: function removeData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.references) this.crawl();
    }
  }, {
    key: "crawl",
    value: function crawl() {
      var path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);

      if (path.isLoop()) {
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = t.FOR_INIT_KEYS[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var key = _step14.value;
            var node = path.get(key);
            if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
              _iterator14.return();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }
      }

      if (path.isFunctionExpression() && path.has("id")) {
        if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
          this.registerBinding("local", path.get("id"), path);
        }
      }

      if (path.isClassExpression() && path.has("id")) {
        if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
          this.registerBinding("local", path);
        }
      }

      if (path.isFunction()) {
        var params = path.get("params");
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = params[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var param = _step15.value;
            this.registerBinding("param", param);
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
              _iterator15.return();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }
      }

      if (path.isCatchClause()) {
        this.registerBinding("let", path);
      }

      var parent = this.getProgramParent();
      if (parent.crawling) return;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      path.traverse(collectorVisitor, state);
      this.crawling = false;
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = state.assignments[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var _path = _step16.value;

          var ids = _path.getBindingIdentifiers();

          var programParent = void 0;

          for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
            var name = _Object$keys5[_i5];
            if (_path.scope.getBinding(name)) continue;
            programParent = programParent || _path.scope.getProgramParent();
            programParent.addGlobal(ids[name]);
          }

          _path.scope.registerConstantViolation(_path);
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
            _iterator16.return();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = state.references[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var ref = _step17.value;
          var binding = ref.scope.getBinding(ref.node.name);

          if (binding) {
            binding.reference(ref);
          } else {
            ref.scope.getProgramParent().addGlobal(ref.node);
          }
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
            _iterator17.return();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = state.constantViolations[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var _path2 = _step18.value;

          _path2.scope.registerConstantViolation(_path2);
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
            _iterator18.return();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }
    }
  }, {
    key: "push",
    value: function push(opts) {
      var path = this.path;

      if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      var unique = opts.unique;
      var kind = opts.kind || "var";
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:".concat(kind, ":").concat(blockHoist);
      var declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        var declar = t.variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;

        var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

        var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);

        declarPath = _path$unshiftContaine2[0];
        if (!unique) path.setData(dataKey, declarPath);
      }

      var declarator = t.variableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator);
      this.registerBinding(kind, declarPath.get("declarations").pop());
    }
  }, {
    key: "getProgramParent",
    value: function getProgramParent() {
      var scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    }
  }, {
    key: "getFunctionParent",
    value: function getFunctionParent() {
      var scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    }
  }, {
    key: "getBlockParent",
    value: function getBlockParent() {
      var scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
  }, {
    key: "getAllBindings",
    value: function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;

      do {
        (0, _defaults.default)(ids, scope.bindings);
        scope = scope.parent;
      } while (scope);

      return ids;
    }
  }, {
    key: "getAllBindingsOfKind",
    value: function getAllBindingsOfKind() {
      var ids = Object.create(null);
      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = arguments[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var kind = _step19.value;
          var scope = this;

          do {
            for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
              var name = _Object$keys6[_i6];
              var binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }

            scope = scope.parent;
          } while (scope);
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
            _iterator19.return();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      return ids;
    }
  }, {
    key: "bindingIdentifierEquals",
    value: function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    }
  }, {
    key: "getBinding",
    value: function getBinding(name) {
      var scope = this;

      do {
        var binding = scope.getOwnBinding(name);
        if (binding) return binding;
      } while (scope = scope.parent);
    }
  }, {
    key: "getOwnBinding",
    value: function getOwnBinding(name) {
      return this.bindings[name];
    }
  }, {
    key: "getBindingIdentifier",
    value: function getBindingIdentifier(name) {
      var info = this.getBinding(name);
      return info && info.identifier;
    }
  }, {
    key: "getOwnBindingIdentifier",
    value: function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding && binding.identifier;
    }
  }, {
    key: "hasOwnBinding",
    value: function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
  }, {
    key: "hasBinding",
    value: function hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;
      if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;
      return false;
    }
  }, {
    key: "parentHasBinding",
    value: function parentHasBinding(name, noGlobals) {
      return this.parent && this.parent.hasBinding(name, noGlobals);
    }
  }, {
    key: "moveBindingTo",
    value: function moveBindingTo(name, scope) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    }
  }, {
    key: "removeOwnBinding",
    value: function removeOwnBinding(name) {
      delete this.bindings[name];
    }
  }, {
    key: "removeBinding",
    value: function removeBinding(name) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
      }

      var scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    }
  }, {
    key: "parent",
    get: function get() {
      var parent = this.path.findParent(function (p) {
        return p.isScope();
      });
      return parent && parent.scope;
    }
  }, {
    key: "parentBlock",
    get: function get() {
      return this.path.parent;
    }
  }, {
    key: "hub",
    get: function get() {
      return this.path.hub;
    }
  }]);

  return Scope;
}();

exports.default = Scope;
Scope.globals = Object.keys(_globals.default.builtin);
Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

},{"../cache":173,"../index":176,"./binding":194,"./lib/renamer":196,"@babel/types":242,"globals":838,"lodash/defaults":1007,"lodash/includes":1015,"lodash/repeat":1039}],196:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _binding = _interopRequireDefault(require("../binding"));

var _helperSplitExportDeclaration = _interopRequireDefault(require("@babel/helper-split-export-declaration"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var renameVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
    var node = _ref.node;

    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },
  Scope: function Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path.skip();
    }
  },
  "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
    var ids = path.getOuterBindingIdentifiers();

    for (var name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  }
};

var Renamer =
/*#__PURE__*/
function () {
  function Renamer(binding, oldName, newName) {
    _classCallCheck(this, Renamer);

    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  _createClass(Renamer, [{
    key: "maybeConvertFromExportDeclaration",
    value: function maybeConvertFromExportDeclaration(parentDeclar) {
      var maybeExportDeclar = parentDeclar.parentPath;

      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }

      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
        return;
      }

      (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
    }
  }, {
    key: "maybeConvertFromClassFunctionDeclaration",
    value: function maybeConvertFromClassFunctionDeclaration(path) {
      return;
      if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;
      if (this.binding.kind !== "hoisted") return;
      path.node.id = t.identifier(this.oldName);
      path.node._blockHoist = 3;
      path.replaceWith(t.variableDeclaration("let", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));
    }
  }, {
    key: "maybeConvertFromClassFunctionExpression",
    value: function maybeConvertFromClassFunctionExpression(path) {
      return;
      if (!path.isFunctionExpression() && !path.isClassExpression()) return;
      if (this.binding.kind !== "local") return;
      path.node.id = t.identifier(this.oldName);
      this.binding.scope.parent.push({
        id: t.identifier(this.newName)
      });
      path.replaceWith(t.assignmentExpression("=", t.identifier(this.newName), path.node));
    }
  }, {
    key: "rename",
    value: function rename(block) {
      var binding = this.binding,
          oldName = this.oldName,
          newName = this.newName;
      var scope = binding.scope,
          path = binding.path;
      var parentDeclar = path.find(function (path) {
        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
      });

      if (parentDeclar) {
        var bindingIds = parentDeclar.getOuterBindingIdentifiers();

        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }

      scope.traverse(block || scope.block, renameVisitor, this);

      if (!block) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }

      if (binding.type === "hoisted") {}

      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
        this.maybeConvertFromClassFunctionExpression(parentDeclar);
      }
    }
  }]);

  return Renamer;
}();

exports.default = Renamer;

},{"../binding":194,"@babel/helper-split-export-declaration":84,"@babel/types":242}],197:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.explode = explode;
exports.verify = verify;
exports.merge = merge;

var virtualTypes = _interopRequireWildcard(require("./path/lib/virtual-types"));

var t = _interopRequireWildcard(require("@babel/types"));

var _clone = _interopRequireDefault(require("lodash/clone"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
    var nodeType = _Object$keys[_i];
    if (shouldIgnoreKey(nodeType)) continue;
    var parts = nodeType.split("|");
    if (parts.length === 1) continue;
    var fns = visitor[nodeType];
    delete visitor[nodeType];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;
        visitor[part] = fns;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  verify(visitor);
  delete visitor.__esModule;
  ensureEntranceObjects(visitor);
  ensureCallbackArrays(visitor);

  for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {
    var _nodeType = _Object$keys2[_i2];
    if (shouldIgnoreKey(_nodeType)) continue;
    var wrapper = virtualTypes[_nodeType];
    if (!wrapper) continue;
    var _fns = visitor[_nodeType];

    for (var _i5 = 0, _Object$keys5 = Object.keys(_fns); _i5 < _Object$keys5.length; _i5++) {
      var _type = _Object$keys5[_i5];
      _fns[_type] = wrapCheck(wrapper, _fns[_type]);
    }

    delete visitor[_nodeType];

    if (wrapper.types) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = wrapper.types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var type = _step2.value;

          if (visitor[type]) {
            mergePair(visitor[type], _fns);
          } else {
            visitor[type] = _fns;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else {
      mergePair(visitor, _fns);
    }
  }

  for (var _i3 = 0, _Object$keys3 = Object.keys(visitor); _i3 < _Object$keys3.length; _i3++) {
    var _nodeType2 = _Object$keys3[_i3];
    if (shouldIgnoreKey(_nodeType2)) continue;
    var _fns2 = visitor[_nodeType2];
    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType2];
    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType2];

    if (deprecratedKey) {
      console.trace("Visitor defined for ".concat(_nodeType2, " but it has been renamed to ").concat(deprecratedKey));
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;
    delete visitor[_nodeType2];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = aliases[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var alias = _step3.value;
        var existing = visitor[alias];

        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = (0, _clone.default)(_fns2);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {
    var _nodeType3 = _Object$keys4[_i4];
    if (shouldIgnoreKey(_nodeType3)) continue;
    ensureCallbackArrays(visitor[_nodeType3]);
  }

  return visitor;
}

function verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
  }

  for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {
    var nodeType = _Object$keys6[_i6];

    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (shouldIgnoreKey(nodeType)) continue;

    if (t.TYPES.indexOf(nodeType) < 0) {
      throw new Error("You gave us a visitor for the node type ".concat(nodeType, " but it's not a valid type"));
    }

    var visitors = visitor[nodeType];

    if (_typeof(visitors) === "object") {
      for (var _i7 = 0, _Object$keys7 = Object.keys(visitors); _i7 < _Object$keys7.length; _i7++) {
        var visitorKey = _Object$keys7[_i7];

        if (visitorKey === "enter" || visitorKey === "exit") {
          validateVisitorMethods("".concat(nodeType, ".").concat(visitorKey), visitors[visitorKey]);
        } else {
          throw new Error("You passed `traverse()` a visitor object with the property " + "".concat(nodeType, " that has the invalid property ").concat(visitorKey));
        }
      }
    }
  }

  visitor._verified = true;
}

function validateVisitorMethods(path, val) {
  var fns = [].concat(val);
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = fns[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var fn = _step4.value;

      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in ".concat(path, " with type ").concat(_typeof(fn)));
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }
}

function merge(visitors) {
  var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var wrapper = arguments.length > 2 ? arguments[2] : undefined;
  var rootVisitor = {};

  for (var i = 0; i < visitors.length; i++) {
    var visitor = visitors[i];
    var state = states[i];
    explode(visitor);

    for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {
      var type = _Object$keys8[_i8];
      var visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  var newVisitor = {};

  var _loop = function _loop() {
    var key = _Object$keys9[_i9];
    var fns = oldVisitor[key];
    if (!Array.isArray(fns)) return "continue";
    fns = fns.map(function (fn) {
      var newFn = fn;

      if (state) {
        newFn = function newFn(path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      return newFn;
    });
    newVisitor[key] = fns;
  };

  for (var _i9 = 0, _Object$keys9 = Object.keys(oldVisitor); _i9 < _Object$keys9.length; _i9++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  return newVisitor;
}

function ensureEntranceObjects(obj) {
  for (var _i10 = 0, _Object$keys10 = Object.keys(obj); _i10 < _Object$keys10.length; _i10++) {
    var key = _Object$keys10[_i10];
    if (shouldIgnoreKey(key)) continue;
    var fns = obj[key];

    if (typeof fns === "function") {
      obj[key] = {
        enter: fns
      };
    }
  }
}

function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function wrapCheck(wrapper, fn) {
  var newFn = function newFn(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };

  newFn.toString = function () {
    return fn.toString();
  };

  return newFn;
}

function shouldIgnoreKey(key) {
  if (key[0] === "_") return true;
  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "blacklist" || key === "noScope" || key === "skipKeys") {
    return true;
  }

  return false;
}

function mergePair(dest, src) {
  for (var _i11 = 0, _Object$keys11 = Object.keys(src); _i11 < _Object$keys11.length; _i11++) {
    var key = _Object$keys11[_i11];
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}

},{"./path/lib/virtual-types":190,"@babel/types":242,"lodash/clone":1004}],198:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./common":199,"_process":1054,"dup":34}],199:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35,"ms":200}],200:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertNode;

var _isNode = _interopRequireDefault(require("../validators/isNode"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function assertNode(node) {
  if (!(0, _isNode.default)(node)) {
    var type = node && node.type || JSON.stringify(node);
    throw new TypeError("Not a valid node of type \"".concat(type, "\""));
  }
}

},{"../validators/isNode":263}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertPlaceholder = assertPlaceholder;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImport = assertImport;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumMember = assertEnumMember;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(require("../../validators/is"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error("Expected type \"".concat(type, "\" with option ").concat(JSON.stringify(opts), ", ") + "but instead got \"".concat(node.type, "\"."));
  }
}

function assertArrayExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("InterpreterDirective", node, opts);
}

function assertDirective(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BreakStatement", node, opts);
}

function assertCallExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("CallExpression", node, opts);
}

function assertCatchClause(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExpressionStatement", node, opts);
}

function assertFile(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("File", node, opts);
}

function assertForInStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ForInStatement", node, opts);
}

function assertForStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Identifier", node, opts);
}

function assertIfStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("MemberExpression", node, opts);
}

function assertNewExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NewExpression", node, opts);
}

function assertProgram(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Program", node, opts);
}

function assertObjectExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectProperty", node, opts);
}

function assertRestElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("RestElement", node, opts);
}

function assertReturnStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("SequenceExpression", node, opts);
}

function assertParenthesizedExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ParenthesizedExpression", node, opts);
}

function assertSwitchCase(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("WhileStatement", node, opts);
}

function assertWithStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassBody", node, opts);
}

function assertClassDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassDeclaration", node, opts);
}

function assertClassExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassExpression", node, opts);
}

function assertExportAllDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("MetaProperty", node, opts);
}

function assertClassMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("SpreadElement", node, opts);
}

function assertSuper(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("YieldExpression", node, opts);
}

function assertAnyTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("StringTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("VoidTypeAnnotation", node, opts);
}

function assertEnumDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumDeclaration", node, opts);
}

function assertEnumBooleanBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumBooleanBody", node, opts);
}

function assertEnumNumberBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumNumberBody", node, opts);
}

function assertEnumStringBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumStringBody", node, opts);
}

function assertEnumSymbolBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumSymbolBody", node, opts);
}

function assertEnumBooleanMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumBooleanMember", node, opts);
}

function assertEnumNumberMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumNumberMember", node, opts);
}

function assertEnumStringMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumStringMember", node, opts);
}

function assertEnumDefaultedMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumDefaultedMember", node, opts);
}

function assertJSXAttribute(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXText", node, opts);
}

function assertJSXFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Noop", node, opts);
}

function assertPlaceholder(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Placeholder", node, opts);
}

function assertV8IntrinsicIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("V8IntrinsicIdentifier", node, opts);
}

function assertArgumentPlaceholder(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ArgumentPlaceholder", node, opts);
}

function assertAwaitExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("AwaitExpression", node, opts);
}

function assertBindExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BindExpression", node, opts);
}

function assertClassProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassProperty", node, opts);
}

function assertOptionalMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("OptionalMemberExpression", node, opts);
}

function assertPipelineTopicExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertOptionalCallExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("OptionalCallExpression", node, opts);
}

function assertClassPrivateProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ClassPrivateMethod", node, opts);
}

function assertImport(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Import", node, opts);
}

function assertDecorator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Decorator", node, opts);
}

function assertDoExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportDefaultSpecifier", node, opts);
}

function assertExportNamespaceSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportNamespaceSpecifier", node, opts);
}

function assertPrivateName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("PrivateName", node, opts);
}

function assertBigIntLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BigIntLiteral", node, opts);
}

function assertTSParameterProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSAnyKeyword", node, opts);
}

function assertTSBooleanKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSBooleanKeyword", node, opts);
}

function assertTSBigIntKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSBigIntKeyword", node, opts);
}

function assertTSNeverKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSNeverKeyword", node, opts);
}

function assertTSNullKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSNullKeyword", node, opts);
}

function assertTSNumberKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSObjectKeyword", node, opts);
}

function assertTSStringKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSSymbolKeyword", node, opts);
}

function assertTSUndefinedKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSUndefinedKeyword", node, opts);
}

function assertTSUnknownKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSUnknownKeyword", node, opts);
}

function assertTSVoidKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSVoidKeyword", node, opts);
}

function assertTSThisType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSRestType", node, opts);
}

function assertTSUnionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeParameter", node, opts);
}

function assertExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Expression", node, opts);
}

function assertBinary(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Binary", node, opts);
}

function assertScopable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Scopable", node, opts);
}

function assertBlockParent(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("BlockParent", node, opts);
}

function assertBlock(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Block", node, opts);
}

function assertStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Statement", node, opts);
}

function assertTerminatorless(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("CompletionStatement", node, opts);
}

function assertConditional(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Conditional", node, opts);
}

function assertLoop(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Loop", node, opts);
}

function assertWhile(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("While", node, opts);
}

function assertExpressionWrapper(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExpressionWrapper", node, opts);
}

function assertFor(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("For", node, opts);
}

function assertForXStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ForXStatement", node, opts);
}

function assertFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Function", node, opts);
}

function assertFunctionParent(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FunctionParent", node, opts);
}

function assertPureish(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Pureish", node, opts);
}

function assertDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Declaration", node, opts);
}

function assertPatternLike(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("PatternLike", node, opts);
}

function assertLVal(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("LVal", node, opts);
}

function assertTSEntityName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSEntityName", node, opts);
}

function assertLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Literal", node, opts);
}

function assertImmutable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("UserWhitespacable", node, opts);
}

function assertMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Method", node, opts);
}

function assertObjectMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ObjectMember", node, opts);
}

function assertProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Property", node, opts);
}

function assertUnaryLike(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("UnaryLike", node, opts);
}

function assertPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Pattern", node, opts);
}

function assertClass(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Class", node, opts);
}

function assertModuleDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Flow", node, opts);
}

function assertFlowType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("FlowPredicate", node, opts);
}

function assertEnumBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumBody", node, opts);
}

function assertEnumMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("EnumMember", node, opts);
}

function assertJSX(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("JSX", node, opts);
}

function assertPrivate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("Private", node, opts);
}

function assertTSTypeElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSTypeElement", node, opts);
}

function assertTSType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assert("TSType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}

},{"../../validators/is":258}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = builder;

var _clone = _interopRequireDefault(require("lodash/clone"));

var _definitions = require("../definitions");

var _validate = _interopRequireDefault(require("../validators/validate"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function builder(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var keys = _definitions.BUILDER_KEYS[type];
  var countArgs = args.length;

  if (countArgs > keys.length) {
    throw new Error("".concat(type, ": Too many arguments passed. Received ").concat(countArgs, " but can receive no more than ").concat(keys.length));
  }

  var node = {
    type: type
  };
  var i = 0;
  keys.forEach(function (key) {
    var field = _definitions.NODE_FIELDS[type][key];
    var arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = (0, _clone.default)(field.default);
    node[key] = arg;
    i++;
  });

  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    (0, _validate.default)(node, key, node[key]);
  }

  return node;
}

},{"../definitions":236,"../validators/validate":276,"lodash/clone":1004}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTypeAnnotationBasedOnTypeof;

var _generated = require("../generated");

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return (0, _generated.stringTypeAnnotation)();
  } else if (type === "number") {
    return (0, _generated.numberTypeAnnotation)();
  } else if (type === "undefined") {
    return (0, _generated.voidTypeAnnotation)();
  } else if (type === "boolean") {
    return (0, _generated.booleanTypeAnnotation)();
  } else if (type === "function") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
  } else if (type === "object") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
  } else if (type === "symbol") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}

},{"../generated":206}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createUnionTypeAnnotation;

var _generated = require("../generated");

var _removeTypeDuplicates = _interopRequireDefault(require("../../modifications/flow/removeTypeDuplicates"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function createUnionTypeAnnotation(types) {
  var flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.unionTypeAnnotation)(flattened);
  }
}

},{"../../modifications/flow/removeTypeDuplicates":244,"../generated":206}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayExpression = exports.ArrayExpression = ArrayExpression;
exports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;
exports.binaryExpression = exports.BinaryExpression = BinaryExpression;
exports.interpreterDirective = exports.InterpreterDirective = InterpreterDirective;
exports.directive = exports.Directive = Directive;
exports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;
exports.blockStatement = exports.BlockStatement = BlockStatement;
exports.breakStatement = exports.BreakStatement = BreakStatement;
exports.callExpression = exports.CallExpression = CallExpression;
exports.catchClause = exports.CatchClause = CatchClause;
exports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;
exports.continueStatement = exports.ContinueStatement = ContinueStatement;
exports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;
exports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;
exports.emptyStatement = exports.EmptyStatement = EmptyStatement;
exports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;
exports.file = exports.File = File;
exports.forInStatement = exports.ForInStatement = ForInStatement;
exports.forStatement = exports.ForStatement = ForStatement;
exports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;
exports.functionExpression = exports.FunctionExpression = FunctionExpression;
exports.identifier = exports.Identifier = Identifier;
exports.ifStatement = exports.IfStatement = IfStatement;
exports.labeledStatement = exports.LabeledStatement = LabeledStatement;
exports.stringLiteral = exports.StringLiteral = StringLiteral;
exports.numericLiteral = exports.NumericLiteral = NumericLiteral;
exports.nullLiteral = exports.NullLiteral = NullLiteral;
exports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;
exports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;
exports.logicalExpression = exports.LogicalExpression = LogicalExpression;
exports.memberExpression = exports.MemberExpression = MemberExpression;
exports.newExpression = exports.NewExpression = NewExpression;
exports.program = exports.Program = Program;
exports.objectExpression = exports.ObjectExpression = ObjectExpression;
exports.objectMethod = exports.ObjectMethod = ObjectMethod;
exports.objectProperty = exports.ObjectProperty = ObjectProperty;
exports.restElement = exports.RestElement = RestElement;
exports.returnStatement = exports.ReturnStatement = ReturnStatement;
exports.sequenceExpression = exports.SequenceExpression = SequenceExpression;
exports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;
exports.switchCase = exports.SwitchCase = SwitchCase;
exports.switchStatement = exports.SwitchStatement = SwitchStatement;
exports.thisExpression = exports.ThisExpression = ThisExpression;
exports.throwStatement = exports.ThrowStatement = ThrowStatement;
exports.tryStatement = exports.TryStatement = TryStatement;
exports.unaryExpression = exports.UnaryExpression = UnaryExpression;
exports.updateExpression = exports.UpdateExpression = UpdateExpression;
exports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;
exports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;
exports.whileStatement = exports.WhileStatement = WhileStatement;
exports.withStatement = exports.WithStatement = WithStatement;
exports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;
exports.arrayPattern = exports.ArrayPattern = ArrayPattern;
exports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.classBody = exports.ClassBody = ClassBody;
exports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;
exports.classExpression = exports.ClassExpression = ClassExpression;
exports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;
exports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;
exports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;
exports.forOfStatement = exports.ForOfStatement = ForOfStatement;
exports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;
exports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
exports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;
exports.metaProperty = exports.MetaProperty = MetaProperty;
exports.classMethod = exports.ClassMethod = ClassMethod;
exports.objectPattern = exports.ObjectPattern = ObjectPattern;
exports.spreadElement = exports.SpreadElement = SpreadElement;
exports.super = exports.Super = Super;
exports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.templateElement = exports.TemplateElement = TemplateElement;
exports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;
exports.yieldExpression = exports.YieldExpression = YieldExpression;
exports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.classImplements = exports.ClassImplements = ClassImplements;
exports.declareClass = exports.DeclareClass = DeclareClass;
exports.declareFunction = exports.DeclareFunction = DeclareFunction;
exports.declareInterface = exports.DeclareInterface = DeclareInterface;
exports.declareModule = exports.DeclareModule = DeclareModule;
exports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;
exports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;
exports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;
exports.declareVariable = exports.DeclareVariable = DeclareVariable;
exports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;
exports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;
exports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;
exports.inferredPredicate = exports.InferredPredicate = InferredPredicate;
exports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;
exports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;
exports.interfaceTypeAnnotation = exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
exports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.objectTypeInternalSlot = exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;
exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.opaqueType = exports.OpaqueType = OpaqueType;
exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
exports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;
exports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.typeAlias = exports.TypeAlias = TypeAlias;
exports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;
exports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;
exports.typeParameter = exports.TypeParameter = TypeParameter;
exports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;
exports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.variance = exports.Variance = Variance;
exports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports.enumDeclaration = exports.EnumDeclaration = EnumDeclaration;
exports.enumBooleanBody = exports.EnumBooleanBody = EnumBooleanBody;
exports.enumNumberBody = exports.EnumNumberBody = EnumNumberBody;
exports.enumStringBody = exports.EnumStringBody = EnumStringBody;
exports.enumSymbolBody = exports.EnumSymbolBody = EnumSymbolBody;
exports.enumBooleanMember = exports.EnumBooleanMember = EnumBooleanMember;
exports.enumNumberMember = exports.EnumNumberMember = EnumNumberMember;
exports.enumStringMember = exports.EnumStringMember = EnumStringMember;
exports.enumDefaultedMember = exports.EnumDefaultedMember = EnumDefaultedMember;
exports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;
exports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;
exports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;
exports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.jSXText = exports.jsxText = exports.JSXText = JSXText;
exports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;
exports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;
exports.noop = exports.Noop = Noop;
exports.placeholder = exports.Placeholder = Placeholder;
exports.v8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
exports.argumentPlaceholder = exports.ArgumentPlaceholder = ArgumentPlaceholder;
exports.awaitExpression = exports.AwaitExpression = AwaitExpression;
exports.bindExpression = exports.BindExpression = BindExpression;
exports.classProperty = exports.ClassProperty = ClassProperty;
exports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
exports.pipelineTopicExpression = exports.PipelineTopicExpression = PipelineTopicExpression;
exports.pipelineBareFunction = exports.PipelineBareFunction = PipelineBareFunction;
exports.pipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
exports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;
exports.classPrivateProperty = exports.ClassPrivateProperty = ClassPrivateProperty;
exports.classPrivateMethod = exports.ClassPrivateMethod = ClassPrivateMethod;
exports.import = exports.Import = Import;
exports.decorator = exports.Decorator = Decorator;
exports.doExpression = exports.DoExpression = DoExpression;
exports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
exports.privateName = exports.PrivateName = PrivateName;
exports.bigIntLiteral = exports.BigIntLiteral = BigIntLiteral;
exports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;
exports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;
exports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
exports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;
exports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;
exports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;
exports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = exports.TSBigIntKeyword = TSBigIntKeyword;
exports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;
exports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;
exports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = exports.TSUnknownKeyword = TSUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;
exports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;
exports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;
exports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;
exports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;
exports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;
exports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;
exports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;
exports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;
exports.tSOptionalType = exports.tsOptionalType = exports.TSOptionalType = TSOptionalType;
exports.tSRestType = exports.tsRestType = exports.TSRestType = TSRestType;
exports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;
exports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;
exports.tSConditionalType = exports.tsConditionalType = exports.TSConditionalType = TSConditionalType;
exports.tSInferType = exports.tsInferType = exports.TSInferType = TSInferType;
exports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;
exports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;
exports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;
exports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
exports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
exports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;
exports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;
exports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;
exports.tSImportType = exports.tsImportType = exports.TSImportType = TSImportType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;
exports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;
exports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;
exports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;
exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
exports.restProperty = exports.RestProperty = RestProperty;
exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(require("../builder"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function ArrayExpression() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _builder.default).apply(void 0, ["ArrayExpression"].concat(args));
}

function AssignmentExpression() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return (0, _builder.default).apply(void 0, ["AssignmentExpression"].concat(args));
}

function BinaryExpression() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return (0, _builder.default).apply(void 0, ["BinaryExpression"].concat(args));
}

function InterpreterDirective() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return (0, _builder.default).apply(void 0, ["InterpreterDirective"].concat(args));
}

function Directive() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  return (0, _builder.default).apply(void 0, ["Directive"].concat(args));
}

function DirectiveLiteral() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  return (0, _builder.default).apply(void 0, ["DirectiveLiteral"].concat(args));
}

function BlockStatement() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  return (0, _builder.default).apply(void 0, ["BlockStatement"].concat(args));
}

function BreakStatement() {
  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    args[_key8] = arguments[_key8];
  }

  return (0, _builder.default).apply(void 0, ["BreakStatement"].concat(args));
}

function CallExpression() {
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  return (0, _builder.default).apply(void 0, ["CallExpression"].concat(args));
}

function CatchClause() {
  for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    args[_key10] = arguments[_key10];
  }

  return (0, _builder.default).apply(void 0, ["CatchClause"].concat(args));
}

function ConditionalExpression() {
  for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
    args[_key11] = arguments[_key11];
  }

  return (0, _builder.default).apply(void 0, ["ConditionalExpression"].concat(args));
}

function ContinueStatement() {
  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
    args[_key12] = arguments[_key12];
  }

  return (0, _builder.default).apply(void 0, ["ContinueStatement"].concat(args));
}

function DebuggerStatement() {
  for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
    args[_key13] = arguments[_key13];
  }

  return (0, _builder.default).apply(void 0, ["DebuggerStatement"].concat(args));
}

function DoWhileStatement() {
  for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
    args[_key14] = arguments[_key14];
  }

  return (0, _builder.default).apply(void 0, ["DoWhileStatement"].concat(args));
}

function EmptyStatement() {
  for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return (0, _builder.default).apply(void 0, ["EmptyStatement"].concat(args));
}

function ExpressionStatement() {
  for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
    args[_key16] = arguments[_key16];
  }

  return (0, _builder.default).apply(void 0, ["ExpressionStatement"].concat(args));
}

function File() {
  for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
    args[_key17] = arguments[_key17];
  }

  return (0, _builder.default).apply(void 0, ["File"].concat(args));
}

function ForInStatement() {
  for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
    args[_key18] = arguments[_key18];
  }

  return (0, _builder.default).apply(void 0, ["ForInStatement"].concat(args));
}

function ForStatement() {
  for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
    args[_key19] = arguments[_key19];
  }

  return (0, _builder.default).apply(void 0, ["ForStatement"].concat(args));
}

function FunctionDeclaration() {
  for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
    args[_key20] = arguments[_key20];
  }

  return (0, _builder.default).apply(void 0, ["FunctionDeclaration"].concat(args));
}

function FunctionExpression() {
  for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
    args[_key21] = arguments[_key21];
  }

  return (0, _builder.default).apply(void 0, ["FunctionExpression"].concat(args));
}

function Identifier() {
  for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
    args[_key22] = arguments[_key22];
  }

  return (0, _builder.default).apply(void 0, ["Identifier"].concat(args));
}

function IfStatement() {
  for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
    args[_key23] = arguments[_key23];
  }

  return (0, _builder.default).apply(void 0, ["IfStatement"].concat(args));
}

function LabeledStatement() {
  for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
    args[_key24] = arguments[_key24];
  }

  return (0, _builder.default).apply(void 0, ["LabeledStatement"].concat(args));
}

function StringLiteral() {
  for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
    args[_key25] = arguments[_key25];
  }

  return (0, _builder.default).apply(void 0, ["StringLiteral"].concat(args));
}

function NumericLiteral() {
  for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
    args[_key26] = arguments[_key26];
  }

  return (0, _builder.default).apply(void 0, ["NumericLiteral"].concat(args));
}

function NullLiteral() {
  for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
    args[_key27] = arguments[_key27];
  }

  return (0, _builder.default).apply(void 0, ["NullLiteral"].concat(args));
}

function BooleanLiteral() {
  for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
    args[_key28] = arguments[_key28];
  }

  return (0, _builder.default).apply(void 0, ["BooleanLiteral"].concat(args));
}

function RegExpLiteral() {
  for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
    args[_key29] = arguments[_key29];
  }

  return (0, _builder.default).apply(void 0, ["RegExpLiteral"].concat(args));
}

function LogicalExpression() {
  for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
    args[_key30] = arguments[_key30];
  }

  return (0, _builder.default).apply(void 0, ["LogicalExpression"].concat(args));
}

function MemberExpression() {
  for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
    args[_key31] = arguments[_key31];
  }

  return (0, _builder.default).apply(void 0, ["MemberExpression"].concat(args));
}

function NewExpression() {
  for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
    args[_key32] = arguments[_key32];
  }

  return (0, _builder.default).apply(void 0, ["NewExpression"].concat(args));
}

function Program() {
  for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
    args[_key33] = arguments[_key33];
  }

  return (0, _builder.default).apply(void 0, ["Program"].concat(args));
}

function ObjectExpression() {
  for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
    args[_key34] = arguments[_key34];
  }

  return (0, _builder.default).apply(void 0, ["ObjectExpression"].concat(args));
}

function ObjectMethod() {
  for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
    args[_key35] = arguments[_key35];
  }

  return (0, _builder.default).apply(void 0, ["ObjectMethod"].concat(args));
}

function ObjectProperty() {
  for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
    args[_key36] = arguments[_key36];
  }

  return (0, _builder.default).apply(void 0, ["ObjectProperty"].concat(args));
}

function RestElement() {
  for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
    args[_key37] = arguments[_key37];
  }

  return (0, _builder.default).apply(void 0, ["RestElement"].concat(args));
}

function ReturnStatement() {
  for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
    args[_key38] = arguments[_key38];
  }

  return (0, _builder.default).apply(void 0, ["ReturnStatement"].concat(args));
}

function SequenceExpression() {
  for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
    args[_key39] = arguments[_key39];
  }

  return (0, _builder.default).apply(void 0, ["SequenceExpression"].concat(args));
}

function ParenthesizedExpression() {
  for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
    args[_key40] = arguments[_key40];
  }

  return (0, _builder.default).apply(void 0, ["ParenthesizedExpression"].concat(args));
}

function SwitchCase() {
  for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
    args[_key41] = arguments[_key41];
  }

  return (0, _builder.default).apply(void 0, ["SwitchCase"].concat(args));
}

function SwitchStatement() {
  for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
    args[_key42] = arguments[_key42];
  }

  return (0, _builder.default).apply(void 0, ["SwitchStatement"].concat(args));
}

function ThisExpression() {
  for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
    args[_key43] = arguments[_key43];
  }

  return (0, _builder.default).apply(void 0, ["ThisExpression"].concat(args));
}

function ThrowStatement() {
  for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
    args[_key44] = arguments[_key44];
  }

  return (0, _builder.default).apply(void 0, ["ThrowStatement"].concat(args));
}

function TryStatement() {
  for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
    args[_key45] = arguments[_key45];
  }

  return (0, _builder.default).apply(void 0, ["TryStatement"].concat(args));
}

function UnaryExpression() {
  for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
    args[_key46] = arguments[_key46];
  }

  return (0, _builder.default).apply(void 0, ["UnaryExpression"].concat(args));
}

function UpdateExpression() {
  for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
    args[_key47] = arguments[_key47];
  }

  return (0, _builder.default).apply(void 0, ["UpdateExpression"].concat(args));
}

function VariableDeclaration() {
  for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
    args[_key48] = arguments[_key48];
  }

  return (0, _builder.default).apply(void 0, ["VariableDeclaration"].concat(args));
}

function VariableDeclarator() {
  for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
    args[_key49] = arguments[_key49];
  }

  return (0, _builder.default).apply(void 0, ["VariableDeclarator"].concat(args));
}

function WhileStatement() {
  for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
    args[_key50] = arguments[_key50];
  }

  return (0, _builder.default).apply(void 0, ["WhileStatement"].concat(args));
}

function WithStatement() {
  for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
    args[_key51] = arguments[_key51];
  }

  return (0, _builder.default).apply(void 0, ["WithStatement"].concat(args));
}

function AssignmentPattern() {
  for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
    args[_key52] = arguments[_key52];
  }

  return (0, _builder.default).apply(void 0, ["AssignmentPattern"].concat(args));
}

function ArrayPattern() {
  for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
    args[_key53] = arguments[_key53];
  }

  return (0, _builder.default).apply(void 0, ["ArrayPattern"].concat(args));
}

function ArrowFunctionExpression() {
  for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
    args[_key54] = arguments[_key54];
  }

  return (0, _builder.default).apply(void 0, ["ArrowFunctionExpression"].concat(args));
}

function ClassBody() {
  for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
    args[_key55] = arguments[_key55];
  }

  return (0, _builder.default).apply(void 0, ["ClassBody"].concat(args));
}

function ClassDeclaration() {
  for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
    args[_key56] = arguments[_key56];
  }

  return (0, _builder.default).apply(void 0, ["ClassDeclaration"].concat(args));
}

function ClassExpression() {
  for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
    args[_key57] = arguments[_key57];
  }

  return (0, _builder.default).apply(void 0, ["ClassExpression"].concat(args));
}

function ExportAllDeclaration() {
  for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
    args[_key58] = arguments[_key58];
  }

  return (0, _builder.default).apply(void 0, ["ExportAllDeclaration"].concat(args));
}

function ExportDefaultDeclaration() {
  for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
    args[_key59] = arguments[_key59];
  }

  return (0, _builder.default).apply(void 0, ["ExportDefaultDeclaration"].concat(args));
}

function ExportNamedDeclaration() {
  for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
    args[_key60] = arguments[_key60];
  }

  return (0, _builder.default).apply(void 0, ["ExportNamedDeclaration"].concat(args));
}

function ExportSpecifier() {
  for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
    args[_key61] = arguments[_key61];
  }

  return (0, _builder.default).apply(void 0, ["ExportSpecifier"].concat(args));
}

function ForOfStatement() {
  for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
    args[_key62] = arguments[_key62];
  }

  return (0, _builder.default).apply(void 0, ["ForOfStatement"].concat(args));
}

function ImportDeclaration() {
  for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
    args[_key63] = arguments[_key63];
  }

  return (0, _builder.default).apply(void 0, ["ImportDeclaration"].concat(args));
}

function ImportDefaultSpecifier() {
  for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
    args[_key64] = arguments[_key64];
  }

  return (0, _builder.default).apply(void 0, ["ImportDefaultSpecifier"].concat(args));
}

function ImportNamespaceSpecifier() {
  for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
    args[_key65] = arguments[_key65];
  }

  return (0, _builder.default).apply(void 0, ["ImportNamespaceSpecifier"].concat(args));
}

function ImportSpecifier() {
  for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
    args[_key66] = arguments[_key66];
  }

  return (0, _builder.default).apply(void 0, ["ImportSpecifier"].concat(args));
}

function MetaProperty() {
  for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
    args[_key67] = arguments[_key67];
  }

  return (0, _builder.default).apply(void 0, ["MetaProperty"].concat(args));
}

function ClassMethod() {
  for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
    args[_key68] = arguments[_key68];
  }

  return (0, _builder.default).apply(void 0, ["ClassMethod"].concat(args));
}

function ObjectPattern() {
  for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
    args[_key69] = arguments[_key69];
  }

  return (0, _builder.default).apply(void 0, ["ObjectPattern"].concat(args));
}

function SpreadElement() {
  for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
    args[_key70] = arguments[_key70];
  }

  return (0, _builder.default).apply(void 0, ["SpreadElement"].concat(args));
}

function Super() {
  for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
    args[_key71] = arguments[_key71];
  }

  return (0, _builder.default).apply(void 0, ["Super"].concat(args));
}

function TaggedTemplateExpression() {
  for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
    args[_key72] = arguments[_key72];
  }

  return (0, _builder.default).apply(void 0, ["TaggedTemplateExpression"].concat(args));
}

function TemplateElement() {
  for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
    args[_key73] = arguments[_key73];
  }

  return (0, _builder.default).apply(void 0, ["TemplateElement"].concat(args));
}

function TemplateLiteral() {
  for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
    args[_key74] = arguments[_key74];
  }

  return (0, _builder.default).apply(void 0, ["TemplateLiteral"].concat(args));
}

function YieldExpression() {
  for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
    args[_key75] = arguments[_key75];
  }

  return (0, _builder.default).apply(void 0, ["YieldExpression"].concat(args));
}

function AnyTypeAnnotation() {
  for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
    args[_key76] = arguments[_key76];
  }

  return (0, _builder.default).apply(void 0, ["AnyTypeAnnotation"].concat(args));
}

function ArrayTypeAnnotation() {
  for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {
    args[_key77] = arguments[_key77];
  }

  return (0, _builder.default).apply(void 0, ["ArrayTypeAnnotation"].concat(args));
}

function BooleanTypeAnnotation() {
  for (var _len78 = arguments.length, args = new Array(_len78), _key78 = 0; _key78 < _len78; _key78++) {
    args[_key78] = arguments[_key78];
  }

  return (0, _builder.default).apply(void 0, ["BooleanTypeAnnotation"].concat(args));
}

function BooleanLiteralTypeAnnotation() {
  for (var _len79 = arguments.length, args = new Array(_len79), _key79 = 0; _key79 < _len79; _key79++) {
    args[_key79] = arguments[_key79];
  }

  return (0, _builder.default).apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(args));
}

function NullLiteralTypeAnnotation() {
  for (var _len80 = arguments.length, args = new Array(_len80), _key80 = 0; _key80 < _len80; _key80++) {
    args[_key80] = arguments[_key80];
  }

  return (0, _builder.default).apply(void 0, ["NullLiteralTypeAnnotation"].concat(args));
}

function ClassImplements() {
  for (var _len81 = arguments.length, args = new Array(_len81), _key81 = 0; _key81 < _len81; _key81++) {
    args[_key81] = arguments[_key81];
  }

  return (0, _builder.default).apply(void 0, ["ClassImplements"].concat(args));
}

function DeclareClass() {
  for (var _len82 = arguments.length, args = new Array(_len82), _key82 = 0; _key82 < _len82; _key82++) {
    args[_key82] = arguments[_key82];
  }

  return (0, _builder.default).apply(void 0, ["DeclareClass"].concat(args));
}

function DeclareFunction() {
  for (var _len83 = arguments.length, args = new Array(_len83), _key83 = 0; _key83 < _len83; _key83++) {
    args[_key83] = arguments[_key83];
  }

  return (0, _builder.default).apply(void 0, ["DeclareFunction"].concat(args));
}

function DeclareInterface() {
  for (var _len84 = arguments.length, args = new Array(_len84), _key84 = 0; _key84 < _len84; _key84++) {
    args[_key84] = arguments[_key84];
  }

  return (0, _builder.default).apply(void 0, ["DeclareInterface"].concat(args));
}

function DeclareModule() {
  for (var _len85 = arguments.length, args = new Array(_len85), _key85 = 0; _key85 < _len85; _key85++) {
    args[_key85] = arguments[_key85];
  }

  return (0, _builder.default).apply(void 0, ["DeclareModule"].concat(args));
}

function DeclareModuleExports() {
  for (var _len86 = arguments.length, args = new Array(_len86), _key86 = 0; _key86 < _len86; _key86++) {
    args[_key86] = arguments[_key86];
  }

  return (0, _builder.default).apply(void 0, ["DeclareModuleExports"].concat(args));
}

function DeclareTypeAlias() {
  for (var _len87 = arguments.length, args = new Array(_len87), _key87 = 0; _key87 < _len87; _key87++) {
    args[_key87] = arguments[_key87];
  }

  return (0, _builder.default).apply(void 0, ["DeclareTypeAlias"].concat(args));
}

function DeclareOpaqueType() {
  for (var _len88 = arguments.length, args = new Array(_len88), _key88 = 0; _key88 < _len88; _key88++) {
    args[_key88] = arguments[_key88];
  }

  return (0, _builder.default).apply(void 0, ["DeclareOpaqueType"].concat(args));
}

function DeclareVariable() {
  for (var _len89 = arguments.length, args = new Array(_len89), _key89 = 0; _key89 < _len89; _key89++) {
    args[_key89] = arguments[_key89];
  }

  return (0, _builder.default).apply(void 0, ["DeclareVariable"].concat(args));
}

function DeclareExportDeclaration() {
  for (var _len90 = arguments.length, args = new Array(_len90), _key90 = 0; _key90 < _len90; _key90++) {
    args[_key90] = arguments[_key90];
  }

  return (0, _builder.default).apply(void 0, ["DeclareExportDeclaration"].concat(args));
}

function DeclareExportAllDeclaration() {
  for (var _len91 = arguments.length, args = new Array(_len91), _key91 = 0; _key91 < _len91; _key91++) {
    args[_key91] = arguments[_key91];
  }

  return (0, _builder.default).apply(void 0, ["DeclareExportAllDeclaration"].concat(args));
}

function DeclaredPredicate() {
  for (var _len92 = arguments.length, args = new Array(_len92), _key92 = 0; _key92 < _len92; _key92++) {
    args[_key92] = arguments[_key92];
  }

  return (0, _builder.default).apply(void 0, ["DeclaredPredicate"].concat(args));
}

function ExistsTypeAnnotation() {
  for (var _len93 = arguments.length, args = new Array(_len93), _key93 = 0; _key93 < _len93; _key93++) {
    args[_key93] = arguments[_key93];
  }

  return (0, _builder.default).apply(void 0, ["ExistsTypeAnnotation"].concat(args));
}

function FunctionTypeAnnotation() {
  for (var _len94 = arguments.length, args = new Array(_len94), _key94 = 0; _key94 < _len94; _key94++) {
    args[_key94] = arguments[_key94];
  }

  return (0, _builder.default).apply(void 0, ["FunctionTypeAnnotation"].concat(args));
}

function FunctionTypeParam() {
  for (var _len95 = arguments.length, args = new Array(_len95), _key95 = 0; _key95 < _len95; _key95++) {
    args[_key95] = arguments[_key95];
  }

  return (0, _builder.default).apply(void 0, ["FunctionTypeParam"].concat(args));
}

function GenericTypeAnnotation() {
  for (var _len96 = arguments.length, args = new Array(_len96), _key96 = 0; _key96 < _len96; _key96++) {
    args[_key96] = arguments[_key96];
  }

  return (0, _builder.default).apply(void 0, ["GenericTypeAnnotation"].concat(args));
}

function InferredPredicate() {
  for (var _len97 = arguments.length, args = new Array(_len97), _key97 = 0; _key97 < _len97; _key97++) {
    args[_key97] = arguments[_key97];
  }

  return (0, _builder.default).apply(void 0, ["InferredPredicate"].concat(args));
}

function InterfaceExtends() {
  for (var _len98 = arguments.length, args = new Array(_len98), _key98 = 0; _key98 < _len98; _key98++) {
    args[_key98] = arguments[_key98];
  }

  return (0, _builder.default).apply(void 0, ["InterfaceExtends"].concat(args));
}

function InterfaceDeclaration() {
  for (var _len99 = arguments.length, args = new Array(_len99), _key99 = 0; _key99 < _len99; _key99++) {
    args[_key99] = arguments[_key99];
  }

  return (0, _builder.default).apply(void 0, ["InterfaceDeclaration"].concat(args));
}

function InterfaceTypeAnnotation() {
  for (var _len100 = arguments.length, args = new Array(_len100), _key100 = 0; _key100 < _len100; _key100++) {
    args[_key100] = arguments[_key100];
  }

  return (0, _builder.default).apply(void 0, ["InterfaceTypeAnnotation"].concat(args));
}

function IntersectionTypeAnnotation() {
  for (var _len101 = arguments.length, args = new Array(_len101), _key101 = 0; _key101 < _len101; _key101++) {
    args[_key101] = arguments[_key101];
  }

  return (0, _builder.default).apply(void 0, ["IntersectionTypeAnnotation"].concat(args));
}

function MixedTypeAnnotation() {
  for (var _len102 = arguments.length, args = new Array(_len102), _key102 = 0; _key102 < _len102; _key102++) {
    args[_key102] = arguments[_key102];
  }

  return (0, _builder.default).apply(void 0, ["MixedTypeAnnotation"].concat(args));
}

function EmptyTypeAnnotation() {
  for (var _len103 = arguments.length, args = new Array(_len103), _key103 = 0; _key103 < _len103; _key103++) {
    args[_key103] = arguments[_key103];
  }

  return (0, _builder.default).apply(void 0, ["EmptyTypeAnnotation"].concat(args));
}

function NullableTypeAnnotation() {
  for (var _len104 = arguments.length, args = new Array(_len104), _key104 = 0; _key104 < _len104; _key104++) {
    args[_key104] = arguments[_key104];
  }

  return (0, _builder.default).apply(void 0, ["NullableTypeAnnotation"].concat(args));
}

function NumberLiteralTypeAnnotation() {
  for (var _len105 = arguments.length, args = new Array(_len105), _key105 = 0; _key105 < _len105; _key105++) {
    args[_key105] = arguments[_key105];
  }

  return (0, _builder.default).apply(void 0, ["NumberLiteralTypeAnnotation"].concat(args));
}

function NumberTypeAnnotation() {
  for (var _len106 = arguments.length, args = new Array(_len106), _key106 = 0; _key106 < _len106; _key106++) {
    args[_key106] = arguments[_key106];
  }

  return (0, _builder.default).apply(void 0, ["NumberTypeAnnotation"].concat(args));
}

function ObjectTypeAnnotation() {
  for (var _len107 = arguments.length, args = new Array(_len107), _key107 = 0; _key107 < _len107; _key107++) {
    args[_key107] = arguments[_key107];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeAnnotation"].concat(args));
}

function ObjectTypeInternalSlot() {
  for (var _len108 = arguments.length, args = new Array(_len108), _key108 = 0; _key108 < _len108; _key108++) {
    args[_key108] = arguments[_key108];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeInternalSlot"].concat(args));
}

function ObjectTypeCallProperty() {
  for (var _len109 = arguments.length, args = new Array(_len109), _key109 = 0; _key109 < _len109; _key109++) {
    args[_key109] = arguments[_key109];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeCallProperty"].concat(args));
}

function ObjectTypeIndexer() {
  for (var _len110 = arguments.length, args = new Array(_len110), _key110 = 0; _key110 < _len110; _key110++) {
    args[_key110] = arguments[_key110];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeIndexer"].concat(args));
}

function ObjectTypeProperty() {
  for (var _len111 = arguments.length, args = new Array(_len111), _key111 = 0; _key111 < _len111; _key111++) {
    args[_key111] = arguments[_key111];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeProperty"].concat(args));
}

function ObjectTypeSpreadProperty() {
  for (var _len112 = arguments.length, args = new Array(_len112), _key112 = 0; _key112 < _len112; _key112++) {
    args[_key112] = arguments[_key112];
  }

  return (0, _builder.default).apply(void 0, ["ObjectTypeSpreadProperty"].concat(args));
}

function OpaqueType() {
  for (var _len113 = arguments.length, args = new Array(_len113), _key113 = 0; _key113 < _len113; _key113++) {
    args[_key113] = arguments[_key113];
  }

  return (0, _builder.default).apply(void 0, ["OpaqueType"].concat(args));
}

function QualifiedTypeIdentifier() {
  for (var _len114 = arguments.length, args = new Array(_len114), _key114 = 0; _key114 < _len114; _key114++) {
    args[_key114] = arguments[_key114];
  }

  return (0, _builder.default).apply(void 0, ["QualifiedTypeIdentifier"].concat(args));
}

function StringLiteralTypeAnnotation() {
  for (var _len115 = arguments.length, args = new Array(_len115), _key115 = 0; _key115 < _len115; _key115++) {
    args[_key115] = arguments[_key115];
  }

  return (0, _builder.default).apply(void 0, ["StringLiteralTypeAnnotation"].concat(args));
}

function StringTypeAnnotation() {
  for (var _len116 = arguments.length, args = new Array(_len116), _key116 = 0; _key116 < _len116; _key116++) {
    args[_key116] = arguments[_key116];
  }

  return (0, _builder.default).apply(void 0, ["StringTypeAnnotation"].concat(args));
}

function ThisTypeAnnotation() {
  for (var _len117 = arguments.length, args = new Array(_len117), _key117 = 0; _key117 < _len117; _key117++) {
    args[_key117] = arguments[_key117];
  }

  return (0, _builder.default).apply(void 0, ["ThisTypeAnnotation"].concat(args));
}

function TupleTypeAnnotation() {
  for (var _len118 = arguments.length, args = new Array(_len118), _key118 = 0; _key118 < _len118; _key118++) {
    args[_key118] = arguments[_key118];
  }

  return (0, _builder.default).apply(void 0, ["TupleTypeAnnotation"].concat(args));
}

function TypeofTypeAnnotation() {
  for (var _len119 = arguments.length, args = new Array(_len119), _key119 = 0; _key119 < _len119; _key119++) {
    args[_key119] = arguments[_key119];
  }

  return (0, _builder.default).apply(void 0, ["TypeofTypeAnnotation"].concat(args));
}

function TypeAlias() {
  for (var _len120 = arguments.length, args = new Array(_len120), _key120 = 0; _key120 < _len120; _key120++) {
    args[_key120] = arguments[_key120];
  }

  return (0, _builder.default).apply(void 0, ["TypeAlias"].concat(args));
}

function TypeAnnotation() {
  for (var _len121 = arguments.length, args = new Array(_len121), _key121 = 0; _key121 < _len121; _key121++) {
    args[_key121] = arguments[_key121];
  }

  return (0, _builder.default).apply(void 0, ["TypeAnnotation"].concat(args));
}

function TypeCastExpression() {
  for (var _len122 = arguments.length, args = new Array(_len122), _key122 = 0; _key122 < _len122; _key122++) {
    args[_key122] = arguments[_key122];
  }

  return (0, _builder.default).apply(void 0, ["TypeCastExpression"].concat(args));
}

function TypeParameter() {
  for (var _len123 = arguments.length, args = new Array(_len123), _key123 = 0; _key123 < _len123; _key123++) {
    args[_key123] = arguments[_key123];
  }

  return (0, _builder.default).apply(void 0, ["TypeParameter"].concat(args));
}

function TypeParameterDeclaration() {
  for (var _len124 = arguments.length, args = new Array(_len124), _key124 = 0; _key124 < _len124; _key124++) {
    args[_key124] = arguments[_key124];
  }

  return (0, _builder.default).apply(void 0, ["TypeParameterDeclaration"].concat(args));
}

function TypeParameterInstantiation() {
  for (var _len125 = arguments.length, args = new Array(_len125), _key125 = 0; _key125 < _len125; _key125++) {
    args[_key125] = arguments[_key125];
  }

  return (0, _builder.default).apply(void 0, ["TypeParameterInstantiation"].concat(args));
}

function UnionTypeAnnotation() {
  for (var _len126 = arguments.length, args = new Array(_len126), _key126 = 0; _key126 < _len126; _key126++) {
    args[_key126] = arguments[_key126];
  }

  return (0, _builder.default).apply(void 0, ["UnionTypeAnnotation"].concat(args));
}

function Variance() {
  for (var _len127 = arguments.length, args = new Array(_len127), _key127 = 0; _key127 < _len127; _key127++) {
    args[_key127] = arguments[_key127];
  }

  return (0, _builder.default).apply(void 0, ["Variance"].concat(args));
}

function VoidTypeAnnotation() {
  for (var _len128 = arguments.length, args = new Array(_len128), _key128 = 0; _key128 < _len128; _key128++) {
    args[_key128] = arguments[_key128];
  }

  return (0, _builder.default).apply(void 0, ["VoidTypeAnnotation"].concat(args));
}

function EnumDeclaration() {
  for (var _len129 = arguments.length, args = new Array(_len129), _key129 = 0; _key129 < _len129; _key129++) {
    args[_key129] = arguments[_key129];
  }

  return (0, _builder.default).apply(void 0, ["EnumDeclaration"].concat(args));
}

function EnumBooleanBody() {
  for (var _len130 = arguments.length, args = new Array(_len130), _key130 = 0; _key130 < _len130; _key130++) {
    args[_key130] = arguments[_key130];
  }

  return (0, _builder.default).apply(void 0, ["EnumBooleanBody"].concat(args));
}

function EnumNumberBody() {
  for (var _len131 = arguments.length, args = new Array(_len131), _key131 = 0; _key131 < _len131; _key131++) {
    args[_key131] = arguments[_key131];
  }

  return (0, _builder.default).apply(void 0, ["EnumNumberBody"].concat(args));
}

function EnumStringBody() {
  for (var _len132 = arguments.length, args = new Array(_len132), _key132 = 0; _key132 < _len132; _key132++) {
    args[_key132] = arguments[_key132];
  }

  return (0, _builder.default).apply(void 0, ["EnumStringBody"].concat(args));
}

function EnumSymbolBody() {
  for (var _len133 = arguments.length, args = new Array(_len133), _key133 = 0; _key133 < _len133; _key133++) {
    args[_key133] = arguments[_key133];
  }

  return (0, _builder.default).apply(void 0, ["EnumSymbolBody"].concat(args));
}

function EnumBooleanMember() {
  for (var _len134 = arguments.length, args = new Array(_len134), _key134 = 0; _key134 < _len134; _key134++) {
    args[_key134] = arguments[_key134];
  }

  return (0, _builder.default).apply(void 0, ["EnumBooleanMember"].concat(args));
}

function EnumNumberMember() {
  for (var _len135 = arguments.length, args = new Array(_len135), _key135 = 0; _key135 < _len135; _key135++) {
    args[_key135] = arguments[_key135];
  }

  return (0, _builder.default).apply(void 0, ["EnumNumberMember"].concat(args));
}

function EnumStringMember() {
  for (var _len136 = arguments.length, args = new Array(_len136), _key136 = 0; _key136 < _len136; _key136++) {
    args[_key136] = arguments[_key136];
  }

  return (0, _builder.default).apply(void 0, ["EnumStringMember"].concat(args));
}

function EnumDefaultedMember() {
  for (var _len137 = arguments.length, args = new Array(_len137), _key137 = 0; _key137 < _len137; _key137++) {
    args[_key137] = arguments[_key137];
  }

  return (0, _builder.default).apply(void 0, ["EnumDefaultedMember"].concat(args));
}

function JSXAttribute() {
  for (var _len138 = arguments.length, args = new Array(_len138), _key138 = 0; _key138 < _len138; _key138++) {
    args[_key138] = arguments[_key138];
  }

  return (0, _builder.default).apply(void 0, ["JSXAttribute"].concat(args));
}

function JSXClosingElement() {
  for (var _len139 = arguments.length, args = new Array(_len139), _key139 = 0; _key139 < _len139; _key139++) {
    args[_key139] = arguments[_key139];
  }

  return (0, _builder.default).apply(void 0, ["JSXClosingElement"].concat(args));
}

function JSXElement() {
  for (var _len140 = arguments.length, args = new Array(_len140), _key140 = 0; _key140 < _len140; _key140++) {
    args[_key140] = arguments[_key140];
  }

  return (0, _builder.default).apply(void 0, ["JSXElement"].concat(args));
}

function JSXEmptyExpression() {
  for (var _len141 = arguments.length, args = new Array(_len141), _key141 = 0; _key141 < _len141; _key141++) {
    args[_key141] = arguments[_key141];
  }

  return (0, _builder.default).apply(void 0, ["JSXEmptyExpression"].concat(args));
}

function JSXExpressionContainer() {
  for (var _len142 = arguments.length, args = new Array(_len142), _key142 = 0; _key142 < _len142; _key142++) {
    args[_key142] = arguments[_key142];
  }

  return (0, _builder.default).apply(void 0, ["JSXExpressionContainer"].concat(args));
}

function JSXSpreadChild() {
  for (var _len143 = arguments.length, args = new Array(_len143), _key143 = 0; _key143 < _len143; _key143++) {
    args[_key143] = arguments[_key143];
  }

  return (0, _builder.default).apply(void 0, ["JSXSpreadChild"].concat(args));
}

function JSXIdentifier() {
  for (var _len144 = arguments.length, args = new Array(_len144), _key144 = 0; _key144 < _len144; _key144++) {
    args[_key144] = arguments[_key144];
  }

  return (0, _builder.default).apply(void 0, ["JSXIdentifier"].concat(args));
}

function JSXMemberExpression() {
  for (var _len145 = arguments.length, args = new Array(_len145), _key145 = 0; _key145 < _len145; _key145++) {
    args[_key145] = arguments[_key145];
  }

  return (0, _builder.default).apply(void 0, ["JSXMemberExpression"].concat(args));
}

function JSXNamespacedName() {
  for (var _len146 = arguments.length, args = new Array(_len146), _key146 = 0; _key146 < _len146; _key146++) {
    args[_key146] = arguments[_key146];
  }

  return (0, _builder.default).apply(void 0, ["JSXNamespacedName"].concat(args));
}

function JSXOpeningElement() {
  for (var _len147 = arguments.length, args = new Array(_len147), _key147 = 0; _key147 < _len147; _key147++) {
    args[_key147] = arguments[_key147];
  }

  return (0, _builder.default).apply(void 0, ["JSXOpeningElement"].concat(args));
}

function JSXSpreadAttribute() {
  for (var _len148 = arguments.length, args = new Array(_len148), _key148 = 0; _key148 < _len148; _key148++) {
    args[_key148] = arguments[_key148];
  }

  return (0, _builder.default).apply(void 0, ["JSXSpreadAttribute"].concat(args));
}

function JSXText() {
  for (var _len149 = arguments.length, args = new Array(_len149), _key149 = 0; _key149 < _len149; _key149++) {
    args[_key149] = arguments[_key149];
  }

  return (0, _builder.default).apply(void 0, ["JSXText"].concat(args));
}

function JSXFragment() {
  for (var _len150 = arguments.length, args = new Array(_len150), _key150 = 0; _key150 < _len150; _key150++) {
    args[_key150] = arguments[_key150];
  }

  return (0, _builder.default).apply(void 0, ["JSXFragment"].concat(args));
}

function JSXOpeningFragment() {
  for (var _len151 = arguments.length, args = new Array(_len151), _key151 = 0; _key151 < _len151; _key151++) {
    args[_key151] = arguments[_key151];
  }

  return (0, _builder.default).apply(void 0, ["JSXOpeningFragment"].concat(args));
}

function JSXClosingFragment() {
  for (var _len152 = arguments.length, args = new Array(_len152), _key152 = 0; _key152 < _len152; _key152++) {
    args[_key152] = arguments[_key152];
  }

  return (0, _builder.default).apply(void 0, ["JSXClosingFragment"].concat(args));
}

function Noop() {
  for (var _len153 = arguments.length, args = new Array(_len153), _key153 = 0; _key153 < _len153; _key153++) {
    args[_key153] = arguments[_key153];
  }

  return (0, _builder.default).apply(void 0, ["Noop"].concat(args));
}

function Placeholder() {
  for (var _len154 = arguments.length, args = new Array(_len154), _key154 = 0; _key154 < _len154; _key154++) {
    args[_key154] = arguments[_key154];
  }

  return (0, _builder.default).apply(void 0, ["Placeholder"].concat(args));
}

function V8IntrinsicIdentifier() {
  for (var _len155 = arguments.length, args = new Array(_len155), _key155 = 0; _key155 < _len155; _key155++) {
    args[_key155] = arguments[_key155];
  }

  return (0, _builder.default).apply(void 0, ["V8IntrinsicIdentifier"].concat(args));
}

function ArgumentPlaceholder() {
  for (var _len156 = arguments.length, args = new Array(_len156), _key156 = 0; _key156 < _len156; _key156++) {
    args[_key156] = arguments[_key156];
  }

  return (0, _builder.default).apply(void 0, ["ArgumentPlaceholder"].concat(args));
}

function AwaitExpression() {
  for (var _len157 = arguments.length, args = new Array(_len157), _key157 = 0; _key157 < _len157; _key157++) {
    args[_key157] = arguments[_key157];
  }

  return (0, _builder.default).apply(void 0, ["AwaitExpression"].concat(args));
}

function BindExpression() {
  for (var _len158 = arguments.length, args = new Array(_len158), _key158 = 0; _key158 < _len158; _key158++) {
    args[_key158] = arguments[_key158];
  }

  return (0, _builder.default).apply(void 0, ["BindExpression"].concat(args));
}

function ClassProperty() {
  for (var _len159 = arguments.length, args = new Array(_len159), _key159 = 0; _key159 < _len159; _key159++) {
    args[_key159] = arguments[_key159];
  }

  return (0, _builder.default).apply(void 0, ["ClassProperty"].concat(args));
}

function OptionalMemberExpression() {
  for (var _len160 = arguments.length, args = new Array(_len160), _key160 = 0; _key160 < _len160; _key160++) {
    args[_key160] = arguments[_key160];
  }

  return (0, _builder.default).apply(void 0, ["OptionalMemberExpression"].concat(args));
}

function PipelineTopicExpression() {
  for (var _len161 = arguments.length, args = new Array(_len161), _key161 = 0; _key161 < _len161; _key161++) {
    args[_key161] = arguments[_key161];
  }

  return (0, _builder.default).apply(void 0, ["PipelineTopicExpression"].concat(args));
}

function PipelineBareFunction() {
  for (var _len162 = arguments.length, args = new Array(_len162), _key162 = 0; _key162 < _len162; _key162++) {
    args[_key162] = arguments[_key162];
  }

  return (0, _builder.default).apply(void 0, ["PipelineBareFunction"].concat(args));
}

function PipelinePrimaryTopicReference() {
  for (var _len163 = arguments.length, args = new Array(_len163), _key163 = 0; _key163 < _len163; _key163++) {
    args[_key163] = arguments[_key163];
  }

  return (0, _builder.default).apply(void 0, ["PipelinePrimaryTopicReference"].concat(args));
}

function OptionalCallExpression() {
  for (var _len164 = arguments.length, args = new Array(_len164), _key164 = 0; _key164 < _len164; _key164++) {
    args[_key164] = arguments[_key164];
  }

  return (0, _builder.default).apply(void 0, ["OptionalCallExpression"].concat(args));
}

function ClassPrivateProperty() {
  for (var _len165 = arguments.length, args = new Array(_len165), _key165 = 0; _key165 < _len165; _key165++) {
    args[_key165] = arguments[_key165];
  }

  return (0, _builder.default).apply(void 0, ["ClassPrivateProperty"].concat(args));
}

function ClassPrivateMethod() {
  for (var _len166 = arguments.length, args = new Array(_len166), _key166 = 0; _key166 < _len166; _key166++) {
    args[_key166] = arguments[_key166];
  }

  return (0, _builder.default).apply(void 0, ["ClassPrivateMethod"].concat(args));
}

function Import() {
  for (var _len167 = arguments.length, args = new Array(_len167), _key167 = 0; _key167 < _len167; _key167++) {
    args[_key167] = arguments[_key167];
  }

  return (0, _builder.default).apply(void 0, ["Import"].concat(args));
}

function Decorator() {
  for (var _len168 = arguments.length, args = new Array(_len168), _key168 = 0; _key168 < _len168; _key168++) {
    args[_key168] = arguments[_key168];
  }

  return (0, _builder.default).apply(void 0, ["Decorator"].concat(args));
}

function DoExpression() {
  for (var _len169 = arguments.length, args = new Array(_len169), _key169 = 0; _key169 < _len169; _key169++) {
    args[_key169] = arguments[_key169];
  }

  return (0, _builder.default).apply(void 0, ["DoExpression"].concat(args));
}

function ExportDefaultSpecifier() {
  for (var _len170 = arguments.length, args = new Array(_len170), _key170 = 0; _key170 < _len170; _key170++) {
    args[_key170] = arguments[_key170];
  }

  return (0, _builder.default).apply(void 0, ["ExportDefaultSpecifier"].concat(args));
}

function ExportNamespaceSpecifier() {
  for (var _len171 = arguments.length, args = new Array(_len171), _key171 = 0; _key171 < _len171; _key171++) {
    args[_key171] = arguments[_key171];
  }

  return (0, _builder.default).apply(void 0, ["ExportNamespaceSpecifier"].concat(args));
}

function PrivateName() {
  for (var _len172 = arguments.length, args = new Array(_len172), _key172 = 0; _key172 < _len172; _key172++) {
    args[_key172] = arguments[_key172];
  }

  return (0, _builder.default).apply(void 0, ["PrivateName"].concat(args));
}

function BigIntLiteral() {
  for (var _len173 = arguments.length, args = new Array(_len173), _key173 = 0; _key173 < _len173; _key173++) {
    args[_key173] = arguments[_key173];
  }

  return (0, _builder.default).apply(void 0, ["BigIntLiteral"].concat(args));
}

function TSParameterProperty() {
  for (var _len174 = arguments.length, args = new Array(_len174), _key174 = 0; _key174 < _len174; _key174++) {
    args[_key174] = arguments[_key174];
  }

  return (0, _builder.default).apply(void 0, ["TSParameterProperty"].concat(args));
}

function TSDeclareFunction() {
  for (var _len175 = arguments.length, args = new Array(_len175), _key175 = 0; _key175 < _len175; _key175++) {
    args[_key175] = arguments[_key175];
  }

  return (0, _builder.default).apply(void 0, ["TSDeclareFunction"].concat(args));
}

function TSDeclareMethod() {
  for (var _len176 = arguments.length, args = new Array(_len176), _key176 = 0; _key176 < _len176; _key176++) {
    args[_key176] = arguments[_key176];
  }

  return (0, _builder.default).apply(void 0, ["TSDeclareMethod"].concat(args));
}

function TSQualifiedName() {
  for (var _len177 = arguments.length, args = new Array(_len177), _key177 = 0; _key177 < _len177; _key177++) {
    args[_key177] = arguments[_key177];
  }

  return (0, _builder.default).apply(void 0, ["TSQualifiedName"].concat(args));
}

function TSCallSignatureDeclaration() {
  for (var _len178 = arguments.length, args = new Array(_len178), _key178 = 0; _key178 < _len178; _key178++) {
    args[_key178] = arguments[_key178];
  }

  return (0, _builder.default).apply(void 0, ["TSCallSignatureDeclaration"].concat(args));
}

function TSConstructSignatureDeclaration() {
  for (var _len179 = arguments.length, args = new Array(_len179), _key179 = 0; _key179 < _len179; _key179++) {
    args[_key179] = arguments[_key179];
  }

  return (0, _builder.default).apply(void 0, ["TSConstructSignatureDeclaration"].concat(args));
}

function TSPropertySignature() {
  for (var _len180 = arguments.length, args = new Array(_len180), _key180 = 0; _key180 < _len180; _key180++) {
    args[_key180] = arguments[_key180];
  }

  return (0, _builder.default).apply(void 0, ["TSPropertySignature"].concat(args));
}

function TSMethodSignature() {
  for (var _len181 = arguments.length, args = new Array(_len181), _key181 = 0; _key181 < _len181; _key181++) {
    args[_key181] = arguments[_key181];
  }

  return (0, _builder.default).apply(void 0, ["TSMethodSignature"].concat(args));
}

function TSIndexSignature() {
  for (var _len182 = arguments.length, args = new Array(_len182), _key182 = 0; _key182 < _len182; _key182++) {
    args[_key182] = arguments[_key182];
  }

  return (0, _builder.default).apply(void 0, ["TSIndexSignature"].concat(args));
}

function TSAnyKeyword() {
  for (var _len183 = arguments.length, args = new Array(_len183), _key183 = 0; _key183 < _len183; _key183++) {
    args[_key183] = arguments[_key183];
  }

  return (0, _builder.default).apply(void 0, ["TSAnyKeyword"].concat(args));
}

function TSBooleanKeyword() {
  for (var _len184 = arguments.length, args = new Array(_len184), _key184 = 0; _key184 < _len184; _key184++) {
    args[_key184] = arguments[_key184];
  }

  return (0, _builder.default).apply(void 0, ["TSBooleanKeyword"].concat(args));
}

function TSBigIntKeyword() {
  for (var _len185 = arguments.length, args = new Array(_len185), _key185 = 0; _key185 < _len185; _key185++) {
    args[_key185] = arguments[_key185];
  }

  return (0, _builder.default).apply(void 0, ["TSBigIntKeyword"].concat(args));
}

function TSNeverKeyword() {
  for (var _len186 = arguments.length, args = new Array(_len186), _key186 = 0; _key186 < _len186; _key186++) {
    args[_key186] = arguments[_key186];
  }

  return (0, _builder.default).apply(void 0, ["TSNeverKeyword"].concat(args));
}

function TSNullKeyword() {
  for (var _len187 = arguments.length, args = new Array(_len187), _key187 = 0; _key187 < _len187; _key187++) {
    args[_key187] = arguments[_key187];
  }

  return (0, _builder.default).apply(void 0, ["TSNullKeyword"].concat(args));
}

function TSNumberKeyword() {
  for (var _len188 = arguments.length, args = new Array(_len188), _key188 = 0; _key188 < _len188; _key188++) {
    args[_key188] = arguments[_key188];
  }

  return (0, _builder.default).apply(void 0, ["TSNumberKeyword"].concat(args));
}

function TSObjectKeyword() {
  for (var _len189 = arguments.length, args = new Array(_len189), _key189 = 0; _key189 < _len189; _key189++) {
    args[_key189] = arguments[_key189];
  }

  return (0, _builder.default).apply(void 0, ["TSObjectKeyword"].concat(args));
}

function TSStringKeyword() {
  for (var _len190 = arguments.length, args = new Array(_len190), _key190 = 0; _key190 < _len190; _key190++) {
    args[_key190] = arguments[_key190];
  }

  return (0, _builder.default).apply(void 0, ["TSStringKeyword"].concat(args));
}

function TSSymbolKeyword() {
  for (var _len191 = arguments.length, args = new Array(_len191), _key191 = 0; _key191 < _len191; _key191++) {
    args[_key191] = arguments[_key191];
  }

  return (0, _builder.default).apply(void 0, ["TSSymbolKeyword"].concat(args));
}

function TSUndefinedKeyword() {
  for (var _len192 = arguments.length, args = new Array(_len192), _key192 = 0; _key192 < _len192; _key192++) {
    args[_key192] = arguments[_key192];
  }

  return (0, _builder.default).apply(void 0, ["TSUndefinedKeyword"].concat(args));
}

function TSUnknownKeyword() {
  for (var _len193 = arguments.length, args = new Array(_len193), _key193 = 0; _key193 < _len193; _key193++) {
    args[_key193] = arguments[_key193];
  }

  return (0, _builder.default).apply(void 0, ["TSUnknownKeyword"].concat(args));
}

function TSVoidKeyword() {
  for (var _len194 = arguments.length, args = new Array(_len194), _key194 = 0; _key194 < _len194; _key194++) {
    args[_key194] = arguments[_key194];
  }

  return (0, _builder.default).apply(void 0, ["TSVoidKeyword"].concat(args));
}

function TSThisType() {
  for (var _len195 = arguments.length, args = new Array(_len195), _key195 = 0; _key195 < _len195; _key195++) {
    args[_key195] = arguments[_key195];
  }

  return (0, _builder.default).apply(void 0, ["TSThisType"].concat(args));
}

function TSFunctionType() {
  for (var _len196 = arguments.length, args = new Array(_len196), _key196 = 0; _key196 < _len196; _key196++) {
    args[_key196] = arguments[_key196];
  }

  return (0, _builder.default).apply(void 0, ["TSFunctionType"].concat(args));
}

function TSConstructorType() {
  for (var _len197 = arguments.length, args = new Array(_len197), _key197 = 0; _key197 < _len197; _key197++) {
    args[_key197] = arguments[_key197];
  }

  return (0, _builder.default).apply(void 0, ["TSConstructorType"].concat(args));
}

function TSTypeReference() {
  for (var _len198 = arguments.length, args = new Array(_len198), _key198 = 0; _key198 < _len198; _key198++) {
    args[_key198] = arguments[_key198];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeReference"].concat(args));
}

function TSTypePredicate() {
  for (var _len199 = arguments.length, args = new Array(_len199), _key199 = 0; _key199 < _len199; _key199++) {
    args[_key199] = arguments[_key199];
  }

  return (0, _builder.default).apply(void 0, ["TSTypePredicate"].concat(args));
}

function TSTypeQuery() {
  for (var _len200 = arguments.length, args = new Array(_len200), _key200 = 0; _key200 < _len200; _key200++) {
    args[_key200] = arguments[_key200];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeQuery"].concat(args));
}

function TSTypeLiteral() {
  for (var _len201 = arguments.length, args = new Array(_len201), _key201 = 0; _key201 < _len201; _key201++) {
    args[_key201] = arguments[_key201];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeLiteral"].concat(args));
}

function TSArrayType() {
  for (var _len202 = arguments.length, args = new Array(_len202), _key202 = 0; _key202 < _len202; _key202++) {
    args[_key202] = arguments[_key202];
  }

  return (0, _builder.default).apply(void 0, ["TSArrayType"].concat(args));
}

function TSTupleType() {
  for (var _len203 = arguments.length, args = new Array(_len203), _key203 = 0; _key203 < _len203; _key203++) {
    args[_key203] = arguments[_key203];
  }

  return (0, _builder.default).apply(void 0, ["TSTupleType"].concat(args));
}

function TSOptionalType() {
  for (var _len204 = arguments.length, args = new Array(_len204), _key204 = 0; _key204 < _len204; _key204++) {
    args[_key204] = arguments[_key204];
  }

  return (0, _builder.default).apply(void 0, ["TSOptionalType"].concat(args));
}

function TSRestType() {
  for (var _len205 = arguments.length, args = new Array(_len205), _key205 = 0; _key205 < _len205; _key205++) {
    args[_key205] = arguments[_key205];
  }

  return (0, _builder.default).apply(void 0, ["TSRestType"].concat(args));
}

function TSUnionType() {
  for (var _len206 = arguments.length, args = new Array(_len206), _key206 = 0; _key206 < _len206; _key206++) {
    args[_key206] = arguments[_key206];
  }

  return (0, _builder.default).apply(void 0, ["TSUnionType"].concat(args));
}

function TSIntersectionType() {
  for (var _len207 = arguments.length, args = new Array(_len207), _key207 = 0; _key207 < _len207; _key207++) {
    args[_key207] = arguments[_key207];
  }

  return (0, _builder.default).apply(void 0, ["TSIntersectionType"].concat(args));
}

function TSConditionalType() {
  for (var _len208 = arguments.length, args = new Array(_len208), _key208 = 0; _key208 < _len208; _key208++) {
    args[_key208] = arguments[_key208];
  }

  return (0, _builder.default).apply(void 0, ["TSConditionalType"].concat(args));
}

function TSInferType() {
  for (var _len209 = arguments.length, args = new Array(_len209), _key209 = 0; _key209 < _len209; _key209++) {
    args[_key209] = arguments[_key209];
  }

  return (0, _builder.default).apply(void 0, ["TSInferType"].concat(args));
}

function TSParenthesizedType() {
  for (var _len210 = arguments.length, args = new Array(_len210), _key210 = 0; _key210 < _len210; _key210++) {
    args[_key210] = arguments[_key210];
  }

  return (0, _builder.default).apply(void 0, ["TSParenthesizedType"].concat(args));
}

function TSTypeOperator() {
  for (var _len211 = arguments.length, args = new Array(_len211), _key211 = 0; _key211 < _len211; _key211++) {
    args[_key211] = arguments[_key211];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeOperator"].concat(args));
}

function TSIndexedAccessType() {
  for (var _len212 = arguments.length, args = new Array(_len212), _key212 = 0; _key212 < _len212; _key212++) {
    args[_key212] = arguments[_key212];
  }

  return (0, _builder.default).apply(void 0, ["TSIndexedAccessType"].concat(args));
}

function TSMappedType() {
  for (var _len213 = arguments.length, args = new Array(_len213), _key213 = 0; _key213 < _len213; _key213++) {
    args[_key213] = arguments[_key213];
  }

  return (0, _builder.default).apply(void 0, ["TSMappedType"].concat(args));
}

function TSLiteralType() {
  for (var _len214 = arguments.length, args = new Array(_len214), _key214 = 0; _key214 < _len214; _key214++) {
    args[_key214] = arguments[_key214];
  }

  return (0, _builder.default).apply(void 0, ["TSLiteralType"].concat(args));
}

function TSExpressionWithTypeArguments() {
  for (var _len215 = arguments.length, args = new Array(_len215), _key215 = 0; _key215 < _len215; _key215++) {
    args[_key215] = arguments[_key215];
  }

  return (0, _builder.default).apply(void 0, ["TSExpressionWithTypeArguments"].concat(args));
}

function TSInterfaceDeclaration() {
  for (var _len216 = arguments.length, args = new Array(_len216), _key216 = 0; _key216 < _len216; _key216++) {
    args[_key216] = arguments[_key216];
  }

  return (0, _builder.default).apply(void 0, ["TSInterfaceDeclaration"].concat(args));
}

function TSInterfaceBody() {
  for (var _len217 = arguments.length, args = new Array(_len217), _key217 = 0; _key217 < _len217; _key217++) {
    args[_key217] = arguments[_key217];
  }

  return (0, _builder.default).apply(void 0, ["TSInterfaceBody"].concat(args));
}

function TSTypeAliasDeclaration() {
  for (var _len218 = arguments.length, args = new Array(_len218), _key218 = 0; _key218 < _len218; _key218++) {
    args[_key218] = arguments[_key218];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeAliasDeclaration"].concat(args));
}

function TSAsExpression() {
  for (var _len219 = arguments.length, args = new Array(_len219), _key219 = 0; _key219 < _len219; _key219++) {
    args[_key219] = arguments[_key219];
  }

  return (0, _builder.default).apply(void 0, ["TSAsExpression"].concat(args));
}

function TSTypeAssertion() {
  for (var _len220 = arguments.length, args = new Array(_len220), _key220 = 0; _key220 < _len220; _key220++) {
    args[_key220] = arguments[_key220];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeAssertion"].concat(args));
}

function TSEnumDeclaration() {
  for (var _len221 = arguments.length, args = new Array(_len221), _key221 = 0; _key221 < _len221; _key221++) {
    args[_key221] = arguments[_key221];
  }

  return (0, _builder.default).apply(void 0, ["TSEnumDeclaration"].concat(args));
}

function TSEnumMember() {
  for (var _len222 = arguments.length, args = new Array(_len222), _key222 = 0; _key222 < _len222; _key222++) {
    args[_key222] = arguments[_key222];
  }

  return (0, _builder.default).apply(void 0, ["TSEnumMember"].concat(args));
}

function TSModuleDeclaration() {
  for (var _len223 = arguments.length, args = new Array(_len223), _key223 = 0; _key223 < _len223; _key223++) {
    args[_key223] = arguments[_key223];
  }

  return (0, _builder.default).apply(void 0, ["TSModuleDeclaration"].concat(args));
}

function TSModuleBlock() {
  for (var _len224 = arguments.length, args = new Array(_len224), _key224 = 0; _key224 < _len224; _key224++) {
    args[_key224] = arguments[_key224];
  }

  return (0, _builder.default).apply(void 0, ["TSModuleBlock"].concat(args));
}

function TSImportType() {
  for (var _len225 = arguments.length, args = new Array(_len225), _key225 = 0; _key225 < _len225; _key225++) {
    args[_key225] = arguments[_key225];
  }

  return (0, _builder.default).apply(void 0, ["TSImportType"].concat(args));
}

function TSImportEqualsDeclaration() {
  for (var _len226 = arguments.length, args = new Array(_len226), _key226 = 0; _key226 < _len226; _key226++) {
    args[_key226] = arguments[_key226];
  }

  return (0, _builder.default).apply(void 0, ["TSImportEqualsDeclaration"].concat(args));
}

function TSExternalModuleReference() {
  for (var _len227 = arguments.length, args = new Array(_len227), _key227 = 0; _key227 < _len227; _key227++) {
    args[_key227] = arguments[_key227];
  }

  return (0, _builder.default).apply(void 0, ["TSExternalModuleReference"].concat(args));
}

function TSNonNullExpression() {
  for (var _len228 = arguments.length, args = new Array(_len228), _key228 = 0; _key228 < _len228; _key228++) {
    args[_key228] = arguments[_key228];
  }

  return (0, _builder.default).apply(void 0, ["TSNonNullExpression"].concat(args));
}

function TSExportAssignment() {
  for (var _len229 = arguments.length, args = new Array(_len229), _key229 = 0; _key229 < _len229; _key229++) {
    args[_key229] = arguments[_key229];
  }

  return (0, _builder.default).apply(void 0, ["TSExportAssignment"].concat(args));
}

function TSNamespaceExportDeclaration() {
  for (var _len230 = arguments.length, args = new Array(_len230), _key230 = 0; _key230 < _len230; _key230++) {
    args[_key230] = arguments[_key230];
  }

  return (0, _builder.default).apply(void 0, ["TSNamespaceExportDeclaration"].concat(args));
}

function TSTypeAnnotation() {
  for (var _len231 = arguments.length, args = new Array(_len231), _key231 = 0; _key231 < _len231; _key231++) {
    args[_key231] = arguments[_key231];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeAnnotation"].concat(args));
}

function TSTypeParameterInstantiation() {
  for (var _len232 = arguments.length, args = new Array(_len232), _key232 = 0; _key232 < _len232; _key232++) {
    args[_key232] = arguments[_key232];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeParameterInstantiation"].concat(args));
}

function TSTypeParameterDeclaration() {
  for (var _len233 = arguments.length, args = new Array(_len233), _key233 = 0; _key233 < _len233; _key233++) {
    args[_key233] = arguments[_key233];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeParameterDeclaration"].concat(args));
}

function TSTypeParameter() {
  for (var _len234 = arguments.length, args = new Array(_len234), _key234 = 0; _key234 < _len234; _key234++) {
    args[_key234] = arguments[_key234];
  }

  return (0, _builder.default).apply(void 0, ["TSTypeParameter"].concat(args));
}

function NumberLiteral() {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

  for (var _len235 = arguments.length, args = new Array(_len235), _key235 = 0; _key235 < _len235; _key235++) {
    args[_key235] = arguments[_key235];
  }

  return NumberLiteral.apply(void 0, ["NumberLiteral"].concat(args));
}

function RegexLiteral() {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

  for (var _len236 = arguments.length, args = new Array(_len236), _key236 = 0; _key236 < _len236; _key236++) {
    args[_key236] = arguments[_key236];
  }

  return RegexLiteral.apply(void 0, ["RegexLiteral"].concat(args));
}

function RestProperty() {
  console.trace("The node type RestProperty has been renamed to RestElement");

  for (var _len237 = arguments.length, args = new Array(_len237), _key237 = 0; _key237 < _len237; _key237++) {
    args[_key237] = arguments[_key237];
  }

  return RestProperty.apply(void 0, ["RestProperty"].concat(args));
}

function SpreadProperty() {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");

  for (var _len238 = arguments.length, args = new Array(_len238), _key238 = 0; _key238 < _len238; _key238++) {
    args[_key238] = arguments[_key238];
  }

  return SpreadProperty.apply(void 0, ["SpreadProperty"].concat(args));
}

},{"../builder":203}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildChildren;

var _generated = require("../../validators/generated");

var _cleanJSXElementLiteralChild = _interopRequireDefault(require("../../utils/react/cleanJSXElementLiteralChild"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function buildChildren(node) {
  var elements = [];

  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if ((0, _generated.isJSXText)(child)) {
      (0, _cleanJSXElementLiteralChild.default)(child, elements);
      continue;
    }

    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
    elements.push(child);
  }

  return elements;
}

},{"../../utils/react/cleanJSXElementLiteralChild":254,"../../validators/generated":257}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clone;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function clone(node) {
  return (0, _cloneNode.default)(node, false);
}

},{"./cloneNode":210}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeep;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function cloneDeep(node) {
  return (0, _cloneNode.default)(node);
}

},{"./cloneNode":210}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNode;

var _definitions = require("../definitions");

var has = Function.call.bind(Object.prototype.hasOwnProperty);

function cloneIfNode(obj, deep) {
  if (obj && typeof obj.type === "string" && obj.type !== "CommentLine" && obj.type !== "CommentBlock") {
    return cloneNode(obj, deep);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep) {
  if (Array.isArray(obj)) {
    return obj.map(function (node) {
      return cloneIfNode(node, deep);
    });
  }

  return cloneIfNode(obj, deep);
}

function cloneNode(node) {
  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!node) return node;
  var type = node.type;
  var newNode = {
    type: type
  };

  if (type === "Identifier") {
    newNode.name = node.name;

    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true) : node.typeAnnotation;
    }
  } else if (!has(_definitions.NODE_FIELDS, type)) {
    throw new Error("Unknown node type: \"".concat(type, "\""));
  } else {
    for (var _i = 0, _Object$keys = Object.keys(_definitions.NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
      var field = _Object$keys[_i];

      if (has(node, field)) {
        newNode[field] = deep ? cloneIfNodeOrArray(node[field], true) : node[field];
      }
    }
  }

  if (has(node, "loc")) {
    newNode.loc = node.loc;
  }

  if (has(node, "leadingComments")) {
    newNode.leadingComments = node.leadingComments;
  }

  if (has(node, "innerComments")) {
    newNode.innerComments = node.innerComments;
  }

  if (has(node, "trailingComments")) {
    newNode.trailingComments = node.trailingComments;
  }

  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

},{"../definitions":236}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithoutLoc;

var _clone = _interopRequireDefault(require("./clone"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function cloneWithoutLoc(node) {
  var newNode = (0, _clone.default)(node);
  newNode.loc = null;
  return newNode;
}

},{"./clone":208}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComment;

var _addComments = _interopRequireDefault(require("./addComments"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function addComment(node, type, content, line) {
  return (0, _addComments.default)(node, type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

},{"./addComments":213}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComments;

function addComments(node, type, comments) {
  if (!comments || !node) return node;
  var key = "".concat(type, "Comments");

  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }

  return node;
}

},{}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritInnerComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inheritInnerComments(child, parent) {
  (0, _inherit.default)("innerComments", child, parent);
}

},{"../utils/inherit":253}],215:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritLeadingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inheritLeadingComments(child, parent) {
  (0, _inherit.default)("leadingComments", child, parent);
}

},{"../utils/inherit":253}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritTrailingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inheritTrailingComments(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}

},{"../utils/inherit":253}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritsComments;

var _inheritTrailingComments = _interopRequireDefault(require("./inheritTrailingComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./inheritLeadingComments"));

var _inheritInnerComments = _interopRequireDefault(require("./inheritInnerComments"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inheritsComments(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}

},{"./inheritInnerComments":214,"./inheritLeadingComments":215,"./inheritTrailingComments":216}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComments;

var _constants = require("../constants");

function removeComments(node) {
  _constants.COMMENT_KEYS.forEach(function (key) {
    node[key] = null;
  });

  return node;
}

},{"../constants":220}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

var _definitions = require("../../definitions");

var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
var MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;

},{"../../definitions":236}],220:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
var FLATTENABLE_KEYS = ["body", "expressions"];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
var FOR_INIT_KEYS = ["left", "init"];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
exports.COMMENT_KEYS = COMMENT_KEYS;
var LOGICAL_OPERATORS = ["||", "&&", "??"];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
var UPDATE_OPERATORS = ["++", "--"];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
var BOOLEAN_BINARY_OPERATORS = [].concat(_toConsumableArray(COMPARISON_BINARY_OPERATORS), BOOLEAN_NUMBER_BINARY_OPERATORS);
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, _toConsumableArray(BOOLEAN_BINARY_OPERATORS));
exports.BINARY_OPERATORS = BINARY_OPERATORS;
var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
var STRING_UNARY_OPERATORS = ["typeof"];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
exports.UNARY_OPERATORS = UNARY_OPERATORS;
var INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

},{}],221:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureBlock;

var _toBlock = _interopRequireDefault(require("./toBlock"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function ensureBlock(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body";
  return node[key] = (0, _toBlock.default)(node[key], node);
}

},{"./toBlock":224}],222:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gatherSequenceExpressions;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function gatherSequenceExpressions(nodes, scope, declars) {
  var exprs = [];
  var ensureLastUndefined = true;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var node = _step.value;
      ensureLastUndefined = false;

      if ((0, _generated.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _generated.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _generated.isVariableDeclaration)(node)) {
        if (node.kind !== "var") return;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = node.declarations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var declar = _step2.value;
            var bindings = (0, _getBindingIdentifiers.default)(declar);

            for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
              var key = _Object$keys[_i];
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }

            if (declar.init) {
              exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        ensureLastUndefined = true;
      } else if ((0, _generated.isIfStatement)(node)) {
        var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
      } else if ((0, _generated.isBlockStatement)(node)) {
        var body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _generated.isEmptyStatement)(node)) {
        ensureLastUndefined = true;
      } else {
        return;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return (0, _generated2.sequenceExpression)(exprs);
  }
}

},{"../builders/generated":206,"../clone/cloneNode":210,"../retrievers/getBindingIdentifiers":249,"../validators/generated":257}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBindingIdentifierName;

var _toIdentifier = _interopRequireDefault(require("./toIdentifier"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function toBindingIdentifierName(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

},{"./toIdentifier":227}],224:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBlock;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toBlock(node, parent) {
  if ((0, _generated.isBlockStatement)(node)) {
    return node;
  }

  var blockNodes = [];

  if ((0, _generated.isEmptyStatement)(node)) {
    blockNodes = [];
  } else {
    if (!(0, _generated.isStatement)(node)) {
      if ((0, _generated.isFunction)(parent)) {
        node = (0, _generated2.returnStatement)(node);
      } else {
        node = (0, _generated2.expressionStatement)(node);
      }
    }

    blockNodes = [node];
  }

  return (0, _generated2.blockStatement)(blockNodes);
}

},{"../builders/generated":206,"../validators/generated":257}],225:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toComputedKey;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toComputedKey(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;
  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
  return key;
}

},{"../builders/generated":206,"../validators/generated":257}],226:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toExpression;

var _generated = require("../validators/generated");

function toExpression(node) {
  if ((0, _generated.isExpressionStatement)(node)) {
    node = node.expression;
  }

  if ((0, _generated.isExpression)(node)) {
    return node;
  }

  if ((0, _generated.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated.isFunction)(node)) {
    node.type = "FunctionExpression";
  }

  if (!(0, _generated.isExpression)(node)) {
    throw new Error("cannot turn ".concat(node.type, " to an expression"));
  }

  return node;
}

},{"../validators/generated":257}],227:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toIdentifier;

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function toIdentifier(name) {
  name = name + "";
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!(0, _isValidIdentifier.default)(name)) {
    name = "_".concat(name);
  }

  return name || "_";
}

},{"../validators/isValidIdentifier":271}],228:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toKeyAlias;

var _generated = require("../validators/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

var _removePropertiesDeep = _interopRequireDefault(require("../modifications/removePropertiesDeep"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function toKeyAlias(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;
  var alias;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if ((0, _generated.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
  }

  if (node.computed) {
    alias = "[".concat(alias, "]");
  }

  if (node.static) {
    alias = "static:".concat(alias);
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};

},{"../clone/cloneNode":210,"../modifications/removePropertiesDeep":248,"../validators/generated":257}],229:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toSequenceExpression;

var _gatherSequenceExpressions = _interopRequireDefault(require("./gatherSequenceExpressions"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function toSequenceExpression(nodes, scope) {
  if (!nodes || !nodes.length) return;
  var declars = [];
  var result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
  if (!result) return;

  for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
    var declar = _declars[_i];
    scope.push(declar);
  }

  return result;
}

},{"./gatherSequenceExpressions":222}],230:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toStatement;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toStatement(node, ignore) {
  if ((0, _generated.isStatement)(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType;

  if ((0, _generated.isClass)(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if ((0, _generated.isFunction)(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if ((0, _generated.isAssignmentExpression)(node)) {
    return (0, _generated2.expressionStatement)(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn ".concat(node.type, " to a statement"));
    }
  }

  node.type = newType;
  return node;
}

},{"../builders/generated":206,"../validators/generated":257}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valueToNode;

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _isRegExp = _interopRequireDefault(require("lodash/isRegExp"));

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _generated = require("../builders/generated");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function valueToNode(value) {
  if (value === undefined) {
    return (0, _generated.identifier)("undefined");
  }

  if (value === true || value === false) {
    return (0, _generated.booleanLiteral)(value);
  }

  if (value === null) {
    return (0, _generated.nullLiteral)();
  }

  if (typeof value === "string") {
    return (0, _generated.stringLiteral)(value);
  }

  if (typeof value === "number") {
    var result;

    if (Number.isFinite(value)) {
      result = (0, _generated.numericLiteral)(Math.abs(value));
    } else {
      var numerator;

      if (Number.isNaN(value)) {
        numerator = (0, _generated.numericLiteral)(0);
      } else {
        numerator = (0, _generated.numericLiteral)(1);
      }

      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
    }

    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated.unaryExpression)("-", result);
    }

    return result;
  }

  if ((0, _isRegExp.default)(value)) {
    var pattern = value.source;
    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return (0, _generated.regExpLiteral)(pattern, flags);
  }

  if (Array.isArray(value)) {
    return (0, _generated.arrayExpression)(value.map(valueToNode));
  }

  if ((0, _isPlainObject.default)(value)) {
    var props = [];

    for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var nodeKey = void 0;

      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _generated.identifier)(key);
      } else {
        nodeKey = (0, _generated.stringLiteral)(key);
      }

      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
    }

    return (0, _generated.objectExpression)(props);
  }

  throw new Error("don't know how to turn this value into a node");
}

},{"../builders/generated":206,"../validators/isValidIdentifier":271,"lodash/isPlainObject":1026,"lodash/isRegExp":1027}],232:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _constants = require("../constants");

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

(0, _utils.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: (0, _utils.assertValueType)("string")
    },
    left: {
      validate: (0, _utils.assertNodeType)("LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
(0, _utils.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.BINARY_OPERATORS))
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
(0, _utils.default)("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
(0, _utils.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
(0, _utils.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    },
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
(0, _utils.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
(0, _utils.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("DebuggerStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
(0, _utils.default)("EmptyStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
(0, _utils.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    }
  }
});
(0, _utils.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
var functionCommon = {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  generator: {
    default: false,
    validate: (0, _utils.assertValueType)("boolean")
  },
  async: {
    validate: (0, _utils.assertValueType)("boolean"),
    default: false
  }
};
exports.functionCommon = functionCommon;
var functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
var functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
(0, _utils.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, functionDeclarationCommon, {}, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
});
(0, _utils.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
var patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
  }
};
exports.patternLikeCommon = patternLikeCommon;
(0, _utils.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils.chain)(function (node, key, val) {
        if (!(0, _isValidIdentifier.default)(val)) {}
      }, (0, _utils.assertValueType)("string"))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: (0, _utils.assertValueType)("string"),
      default: ""
    }
  }
});
(0, _utils.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.LOGICAL_OPERATORS))
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        var normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        var computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  }
});
(0, _utils.default)("NewExpression", {
  inherits: "CallExpression"
});
(0, _utils.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)("string")
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
(0, _utils.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
    kind: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("method", "get", "set")),
      default: "method"
    },
    computed: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function () {
        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        var computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
(0, _utils.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function () {
        var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        var computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
});
(0, _utils.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: (0, _utils.assertNodeType)("LVal")
    }
  })
});
(0, _utils.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});
(0, _utils.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  }
});
(0, _utils.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    }
  }
});
(0, _utils.default)("ThisExpression", {
  aliases: ["Expression"]
});
(0, _utils.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.UNARY_OPERATORS))
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
(0, _utils.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.UPDATE_OPERATORS))
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});
(0, _utils.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("var", "let", "const"))
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    }
  }
});
(0, _utils.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("LVal")
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
    }
  }
});
(0, _utils.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

},{"../constants":220,"../validators/isValidIdentifier":271,"./utils":241}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

(0, _utils.default)("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
  })
});
(0, _utils.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("PatternLike")))
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
  })
});
(0, _utils.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, _core.functionCommon, {}, _core.functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    }
  })
});
(0, _utils.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
    }
  }
});
var classCommon = {
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  },
  body: {
    validate: (0, _utils.assertNodeType)("ClassBody")
  },
  superClass: {
    optional: true,
    validate: (0, _utils.assertNodeType)("Expression")
  },
  superTypeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    optional: true
  },
  implements: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
    optional: true
  }
};
(0, _utils.default)("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: Object.assign({}, classCommon, {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: Object.assign({}, classCommon, {
    id: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
    }
  }
});
(0, _utils.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("Declaration"),
      optional: true
    },
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false,
      validate: (0, _utils.assertValueType)("boolean")
    }
  }
});
(0, _utils.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
(0, _utils.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof"),
      optional: true
    }
  }
});
(0, _utils.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
var classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  static: {
    default: false,
    validate: (0, _utils.assertValueType)("boolean")
  },
  computed: {
    default: false,
    validate: (0, _utils.assertValueType)("boolean")
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      var computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        var validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
  }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
var classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, {}, classMethodOrPropertyCommon, {
  kind: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("get", "set", "method", "constructor")),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
(0, _utils.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, _core.functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
});
(0, _utils.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Super", {
  aliases: ["Expression"]
});
(0, _utils.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      })
    },
    tail: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    }
  }
});
(0, _utils.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError("Number of ".concat(node.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(val.length + 1, " quasis but got ").concat(node.quasis.length));
        }
      })
    }
  }
});
(0, _utils.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});

},{"./core":232,"./utils":241}],234:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _es = require("./es2015");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {}
});
(0, _utils.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        var normal = (0, _utils.assertNodeType)("Identifier");
        var computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  }
});
(0, _utils.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
});
(0, _utils.default)("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateProperty", {
  visitor: ["key", "value", "decorators"],
  builder: ["key", "value", "decorators"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("Import", {
  aliases: ["Expression"]
});
(0, _utils.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

},{"./es2015":233,"./utils":241}],235:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var defineInterfaceishType = function defineInterfaceishType(name) {
  var typeParameterType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "TypeParameterDeclaration";
  (0, _utils.default)(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
};

(0, _utils.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("DeclareClass");
(0, _utils.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
  }
});
defineInterfaceishType("DeclareInterface");
(0, _utils.default)("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)("BlockStatement"),
    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
  }
});
(0, _utils.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType")
  }
});
(0, _utils.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, _utils.validateOptionalType)("Flow"),
    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, _utils.validateOptionalType)("StringLiteral"),
    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, _utils.validateType)("StringLiteral"),
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: (0, _utils.validateType)("Flow")
  }
});
(0, _utils.default)("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"]
});
(0, _utils.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: (0, _utils.validateOptionalType)("Identifier"),
    typeAnnotation: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
(0, _utils.default)("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"]
});
(0, _utils.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("InterfaceDeclaration");
(0, _utils.default)("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    body: (0, _utils.validateType)("ObjectTypeAnnotation")
  }
});
(0, _utils.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
  }
});
(0, _utils.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
    exact: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    value: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateOptionalType)("Identifier"),
    key: (0, _utils.validateType)("FlowType"),
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    value: (0, _utils.validateType)("FlowType"),
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType"),
    impltype: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
});
(0, _utils.default)("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
  }
});
(0, _utils.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    default: (0, _utils.validateOptionalType)("FlowType"),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
  }
});
(0, _utils.default)("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
  }
});
(0, _utils.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EnumDeclaration", {
  alises: ["Declaration"],
  visitor: ["id", "body"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
  }
});
(0, _utils.default)("EnumBooleanBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumBooleanMember")
  }
});
(0, _utils.default)("EnumNumberBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumNumberMember")
  }
});
(0, _utils.default)("EnumStringBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"])
  }
});
(0, _utils.default)("EnumSymbolBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")
  }
});
(0, _utils.default)("EnumBooleanMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("BooleanLiteral")
  }
});
(0, _utils.default)("EnumNumberMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("NumericLiteral")
  }
});
(0, _utils.default)("EnumStringMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("EnumDefaultedMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});

},{"./utils":241}],236:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISITOR_KEYS", {
  enumerable: true,
  get: function get() {
    return _utils.VISITOR_KEYS;
  }
});
Object.defineProperty(exports, "ALIAS_KEYS", {
  enumerable: true,
  get: function get() {
    return _utils.ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
  enumerable: true,
  get: function get() {
    return _utils.FLIPPED_ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "NODE_FIELDS", {
  enumerable: true,
  get: function get() {
    return _utils.NODE_FIELDS;
  }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
  enumerable: true,
  get: function get() {
    return _utils.BUILDER_KEYS;
  }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
  enumerable: true,
  get: function get() {
    return _utils.DEPRECATED_KEYS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
  enumerable: true,
  get: function get() {
    return _placeholders.PLACEHOLDERS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
  enumerable: true,
  get: function get() {
    return _placeholders.PLACEHOLDERS_ALIAS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
  enumerable: true,
  get: function get() {
    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
  }
});
exports.TYPES = void 0;

var _toFastProperties = _interopRequireDefault(require("to-fast-properties"));

require("./core");

require("./es2015");

require("./flow");

require("./jsx");

require("./misc");

require("./experimental");

require("./typescript");

var _utils = require("./utils");

var _placeholders = require("./placeholders");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

(0, _toFastProperties.default)(_utils.VISITOR_KEYS);
(0, _toFastProperties.default)(_utils.ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.NODE_FIELDS);
(0, _toFastProperties.default)(_utils.BUILDER_KEYS);
(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
var TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

},{"./core":232,"./es2015":233,"./experimental":234,"./flow":235,"./jsx":237,"./misc":238,"./placeholders":239,"./typescript":240,"./utils":241,"to-fast-properties":1083}],237:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

(0, _utils.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
});
(0, _utils.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    }
  }
});
(0, _utils.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXEmptyExpression", {
  aliases: ["JSX"]
});
(0, _utils.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
});
(0, _utils.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    },
    selfClosing: {
      default: false,
      validate: (0, _utils.assertValueType)("boolean")
    },
    attributes: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"]
});
(0, _utils.default)("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"]
});

},{"./utils":241}],238:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _utils = _interopRequireWildcard(require("./utils"));

var _placeholders = require("./placeholders");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

(0, _utils.default)("Noop", {
  visitor: []
});
(0, _utils.default)("Placeholder", {
  visitor: [],
  builder: ["expectedNode", "name"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    expectedNode: {
      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_placeholders.PLACEHOLDERS))
    }
  }
});
(0, _utils.default)("V8IntrinsicIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});

},{"./placeholders":239,"./utils":241}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;

var _utils = require("./utils");

var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
exports.PLACEHOLDERS = PLACEHOLDERS;
var PLACEHOLDERS_ALIAS = {
  Declaration: ["Statement"],
  Pattern: ["PatternLike", "LVal"]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

for (var _i = 0, _PLACEHOLDERS = PLACEHOLDERS; _i < _PLACEHOLDERS.length; _i++) {
  var type = _PLACEHOLDERS[_i];
  var alias = _utils.ALIAS_KEYS[type];
  if (alias && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}

var PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
  PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
    }

    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
  });
});

},{"./utils":241}],240:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

var _es = require("./es2015");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var bool = (0, _utils.assertValueType)("boolean");
var tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
(0, _utils.default)("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    parameter: {
      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    }
  }
});
(0, _utils.default)("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.functionDeclarationCommon, {}, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, {}, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, _utils.validateType)("TSEntityName"),
    right: (0, _utils.validateType)("Identifier")
  }
});
var signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
var callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
var namedTypeElementCommon = {
  key: (0, _utils.validateType)("Expression"),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool)
};
(0, _utils.default)("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  })
});
(0, _utils.default)("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, signatureDeclarationCommon, {}, namedTypeElementCommon)
});
(0, _utils.default)("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }
});
var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

for (var _i = 0, _tsKeywordTypes = tsKeywordTypes; _i < _tsKeywordTypes.length; _i++) {
  var type = _tsKeywordTypes[_i];
  (0, _utils.default)(type, {
    aliases: ["TSType"],
    visitor: [],
    fields: {}
  });
}

(0, _utils.default)("TSThisType", {
  aliases: ["TSType"],
  visitor: [],
  fields: {}
});
var fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSFunctionType", fnOrCtr);
(0, _utils.default)("TSConstructorType", fnOrCtr);
(0, _utils.default)("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation", "asserts"],
  fields: {
    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    asserts: (0, _utils.validate)(bool)
  }
});
(0, _utils.default)("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
  }
});
(0, _utils.default)("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)("TSType")
  }
});
(0, _utils.default)("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
var unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, _utils.validateArrayOfType)("TSType")
  }
};
(0, _utils.default)("TSUnionType", unionOrIntersection);
(0, _utils.default)("TSIntersectionType", unionOrIntersection);
(0, _utils.default)("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, _utils.validateType)("TSType"),
    extendsType: (0, _utils.validateType)("TSType"),
    trueType: (0, _utils.validateType)("TSType"),
    falseType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, _utils.validateType)("TSTypeParameter")
  }
});
(0, _utils.default)("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, _utils.validateType)("TSType"),
    indexType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
  }
});
(0, _utils.default)("TSLiteralType", {
  aliases: ["TSType"],
  visitor: ["literal"],
  fields: {
    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
  }
});
(0, _utils.default)("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, _utils.validateType)("TSInterfaceBody")
  }
});
(0, _utils.default)("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType"),
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
});
(0, _utils.default)("TSModuleBlock", {
  aliases: ["Scopable", "Block", "BlockParent"],
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  }
});
(0, _utils.default)("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, _utils.validateType)("StringLiteral"),
    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)("Identifier"),
    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
  }
});
(0, _utils.default)("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TSType")
    }
  }
});
(0, _utils.default)("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    }
  }
});
(0, _utils.default)("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    }
  }
});
(0, _utils.default)("TSTypeParameter", {
  builder: ["constraint", "default", "name"],
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    },
    constraint: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    },
    default: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    }
  }
});

},{"./core":232,"./es2015":233,"./utils":241}],241:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.typeIs = typeIs;
exports.validateType = validateType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.validateArrayOfType = validateArrayOfType;
exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.assertShape = assertShape;
exports.chain = chain;
exports.default = defineType;
exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

var _is = _interopRequireDefault(require("../validators/is"));

var _validate = require("../validators/validate");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
var ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
var FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
var NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
var BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
var DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return _typeof(val);
  }
}

function validate(validate) {
  return {
    validate: validate
  };
}

function typeIs(typeName) {
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));
}

function validateType(typeName) {
  return validate(typeIs(typeName));
}

function validateOptional(validate) {
  return {
    validate: validate,
    optional: true
  };
}

function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true
  };
}

function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
}

function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName));
}

function validateArrayOfType(typeName) {
  return validate(arrayOfType(typeName));
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (var i = 0; i < val.length; i++) {
      callback(node, "".concat(key, "[").concat(i, "]"), val[i]);
    }
  }

  validator.each = callback;
  return validator;
}

function assertOneOf() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  function validate(node, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError("Property ".concat(key, " expected value to be one of ").concat(JSON.stringify(values), " but got ").concat(JSON.stringify(val)));
    }
  }

  validate.oneOf = values;
  return validate;
}

function assertNodeType() {
  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    types[_key2] = arguments[_key2];
  }

  function validate(node, key, val) {
    var valid = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var type = _step.value;

        if ((0, _is.default)(type, val)) {
          valid = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!valid) {
      throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " ") + "but instead got ".concat(JSON.stringify(val && val.type)));
    }
  }

  validate.oneOfNodeTypes = types;
  return validate;
}

function assertNodeOrValueType() {
  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    types[_key3] = arguments[_key3];
  }

  function validate(node, key, val) {
    var valid = false;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var type = _step2.value;

        if (getType(val) === type || (0, _is.default)(type, val)) {
          valid = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (!valid) {
      throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " ") + "but instead got ".concat(JSON.stringify(val && val.type)));
    }
  }

  validate.oneOfNodeOrValueTypes = types;
  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    var valid = getType(val) === type;

    if (!valid) {
      throw new TypeError("Property ".concat(key, " expected type of ").concat(type, " but got ").concat(getType(val)));
    }
  }

  validate.type = type;
  return validate;
}

function assertShape(shape) {
  function validate(node, key, val) {
    var errors = [];

    for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
      var property = _Object$keys[_i];

      try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        }

        throw error;
      }
    }

    if (errors.length) {
      throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected to have the following:\n").concat(errors.join("\n")));
    }
  }

  validate.shapeOf = shape;
  return validate;
}

function chain() {
  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    fns[_key4] = arguments[_key4];
  }

  function validate() {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = fns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var fn = _step3.value;
        fn.apply(void 0, arguments);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  validate.chainOf = fns;
  return validate;
}

function defineType(type) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var inherits = opts.inherits && store[opts.inherits] || {};
  var fields = opts.fields || inherits.fields || {};
  var visitor = opts.visitor || inherits.visitor || [];
  var aliases = opts.aliases || inherits.aliases || [];
  var builder = opts.builder || inherits.builder || opts.visitor || [];

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = visitor.concat(builder)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var key = _step4.value;
      fields[key] = fields[key] || {};
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  for (var _i2 = 0, _Object$keys2 = Object.keys(fields); _i2 < _Object$keys2.length; _i2++) {
    var _key5 = _Object$keys2[_i2];
    var field = fields[_key5];

    if (builder.indexOf(_key5) === -1) {
      field.optional = true;
    }

    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = assertValueType(getType(field.default));
    }
  }

  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(function (alias) {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });
  store[type] = opts;
}

var store = {};

},{"../validators/is":258,"../validators/validate":276}],242:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  react: true,
  assertNode: true,
  createTypeAnnotationBasedOnTypeof: true,
  createUnionTypeAnnotation: true,
  cloneNode: true,
  clone: true,
  cloneDeep: true,
  cloneWithoutLoc: true,
  addComment: true,
  addComments: true,
  inheritInnerComments: true,
  inheritLeadingComments: true,
  inheritsComments: true,
  inheritTrailingComments: true,
  removeComments: true,
  ensureBlock: true,
  toBindingIdentifierName: true,
  toBlock: true,
  toComputedKey: true,
  toExpression: true,
  toIdentifier: true,
  toKeyAlias: true,
  toSequenceExpression: true,
  toStatement: true,
  valueToNode: true,
  appendToMemberExpression: true,
  inherits: true,
  prependToMemberExpression: true,
  removeProperties: true,
  removePropertiesDeep: true,
  removeTypeDuplicates: true,
  getBindingIdentifiers: true,
  getOuterBindingIdentifiers: true,
  traverse: true,
  traverseFast: true,
  shallowEqual: true,
  is: true,
  isBinding: true,
  isBlockScoped: true,
  isImmutable: true,
  isLet: true,
  isNode: true,
  isNodesEquivalent: true,
  isPlaceholderType: true,
  isReferenced: true,
  isScope: true,
  isSpecifierDefault: true,
  isType: true,
  isValidES3Identifier: true,
  isValidIdentifier: true,
  isVar: true,
  matchesPattern: true,
  validate: true,
  buildMatchMemberExpression: true
};
Object.defineProperty(exports, "assertNode", {
  enumerable: true,
  get: function get() {
    return _assertNode.default;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function get() {
    return _createTypeAnnotationBasedOnTypeof.default;
  }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _createUnionTypeAnnotation.default;
  }
});
Object.defineProperty(exports, "cloneNode", {
  enumerable: true,
  get: function get() {
    return _cloneNode.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function get() {
    return _clone.default;
  }
});
Object.defineProperty(exports, "cloneDeep", {
  enumerable: true,
  get: function get() {
    return _cloneDeep.default;
  }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
  enumerable: true,
  get: function get() {
    return _cloneWithoutLoc.default;
  }
});
Object.defineProperty(exports, "addComment", {
  enumerable: true,
  get: function get() {
    return _addComment.default;
  }
});
Object.defineProperty(exports, "addComments", {
  enumerable: true,
  get: function get() {
    return _addComments.default;
  }
});
Object.defineProperty(exports, "inheritInnerComments", {
  enumerable: true,
  get: function get() {
    return _inheritInnerComments.default;
  }
});
Object.defineProperty(exports, "inheritLeadingComments", {
  enumerable: true,
  get: function get() {
    return _inheritLeadingComments.default;
  }
});
Object.defineProperty(exports, "inheritsComments", {
  enumerable: true,
  get: function get() {
    return _inheritsComments.default;
  }
});
Object.defineProperty(exports, "inheritTrailingComments", {
  enumerable: true,
  get: function get() {
    return _inheritTrailingComments.default;
  }
});
Object.defineProperty(exports, "removeComments", {
  enumerable: true,
  get: function get() {
    return _removeComments.default;
  }
});
Object.defineProperty(exports, "ensureBlock", {
  enumerable: true,
  get: function get() {
    return _ensureBlock.default;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function get() {
    return _toBindingIdentifierName.default;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function get() {
    return _toBlock.default;
  }
});
Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function get() {
    return _toComputedKey.default;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function get() {
    return _toExpression.default;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function get() {
    return _toIdentifier.default;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function get() {
    return _toKeyAlias.default;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function get() {
    return _toSequenceExpression.default;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function get() {
    return _toStatement.default;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function get() {
    return _valueToNode.default;
  }
});
Object.defineProperty(exports, "appendToMemberExpression", {
  enumerable: true,
  get: function get() {
    return _appendToMemberExpression.default;
  }
});
Object.defineProperty(exports, "inherits", {
  enumerable: true,
  get: function get() {
    return _inherits.default;
  }
});
Object.defineProperty(exports, "prependToMemberExpression", {
  enumerable: true,
  get: function get() {
    return _prependToMemberExpression.default;
  }
});
Object.defineProperty(exports, "removeProperties", {
  enumerable: true,
  get: function get() {
    return _removeProperties.default;
  }
});
Object.defineProperty(exports, "removePropertiesDeep", {
  enumerable: true,
  get: function get() {
    return _removePropertiesDeep.default;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function get() {
    return _removeTypeDuplicates.default;
  }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _getBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _getOuterBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function get() {
    return _traverse.default;
  }
});
Object.defineProperty(exports, "traverseFast", {
  enumerable: true,
  get: function get() {
    return _traverseFast.default;
  }
});
Object.defineProperty(exports, "shallowEqual", {
  enumerable: true,
  get: function get() {
    return _shallowEqual.default;
  }
});
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function get() {
    return _is.default;
  }
});
Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function get() {
    return _isBinding.default;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function get() {
    return _isBlockScoped.default;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function get() {
    return _isImmutable.default;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function get() {
    return _isLet.default;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function get() {
    return _isNode.default;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function get() {
    return _isNodesEquivalent.default;
  }
});
Object.defineProperty(exports, "isPlaceholderType", {
  enumerable: true,
  get: function get() {
    return _isPlaceholderType.default;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function get() {
    return _isReferenced.default;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function get() {
    return _isScope.default;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function get() {
    return _isSpecifierDefault.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function get() {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isValidES3Identifier", {
  enumerable: true,
  get: function get() {
    return _isValidES3Identifier.default;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function get() {
    return _isValidIdentifier.default;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function get() {
    return _isVar.default;
  }
});
Object.defineProperty(exports, "matchesPattern", {
  enumerable: true,
  get: function get() {
    return _matchesPattern.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function get() {
    return _validate.default;
  }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
  enumerable: true,
  get: function get() {
    return _buildMatchMemberExpression.default;
  }
});
exports.react = void 0;

var _isReactComponent = _interopRequireDefault(require("./validators/react/isReactComponent"));

var _isCompatTag = _interopRequireDefault(require("./validators/react/isCompatTag"));

var _buildChildren = _interopRequireDefault(require("./builders/react/buildChildren"));

var _assertNode = _interopRequireDefault(require("./asserts/assertNode"));

var _generated = require("./asserts/generated");

Object.keys(_generated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generated[key];
    }
  });
});

var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(require("./builders/flow/createTypeAnnotationBasedOnTypeof"));

var _createUnionTypeAnnotation = _interopRequireDefault(require("./builders/flow/createUnionTypeAnnotation"));

var _generated2 = require("./builders/generated");

Object.keys(_generated2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generated2[key];
    }
  });
});

var _cloneNode = _interopRequireDefault(require("./clone/cloneNode"));

var _clone = _interopRequireDefault(require("./clone/clone"));

var _cloneDeep = _interopRequireDefault(require("./clone/cloneDeep"));

var _cloneWithoutLoc = _interopRequireDefault(require("./clone/cloneWithoutLoc"));

var _addComment = _interopRequireDefault(require("./comments/addComment"));

var _addComments = _interopRequireDefault(require("./comments/addComments"));

var _inheritInnerComments = _interopRequireDefault(require("./comments/inheritInnerComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./comments/inheritLeadingComments"));

var _inheritsComments = _interopRequireDefault(require("./comments/inheritsComments"));

var _inheritTrailingComments = _interopRequireDefault(require("./comments/inheritTrailingComments"));

var _removeComments = _interopRequireDefault(require("./comments/removeComments"));

var _generated3 = require("./constants/generated");

Object.keys(_generated3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generated3[key];
    }
  });
});

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constants[key];
    }
  });
});

var _ensureBlock = _interopRequireDefault(require("./converters/ensureBlock"));

var _toBindingIdentifierName = _interopRequireDefault(require("./converters/toBindingIdentifierName"));

var _toBlock = _interopRequireDefault(require("./converters/toBlock"));

var _toComputedKey = _interopRequireDefault(require("./converters/toComputedKey"));

var _toExpression = _interopRequireDefault(require("./converters/toExpression"));

var _toIdentifier = _interopRequireDefault(require("./converters/toIdentifier"));

var _toKeyAlias = _interopRequireDefault(require("./converters/toKeyAlias"));

var _toSequenceExpression = _interopRequireDefault(require("./converters/toSequenceExpression"));

var _toStatement = _interopRequireDefault(require("./converters/toStatement"));

var _valueToNode = _interopRequireDefault(require("./converters/valueToNode"));

var _definitions = require("./definitions");

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _definitions[key];
    }
  });
});

var _appendToMemberExpression = _interopRequireDefault(require("./modifications/appendToMemberExpression"));

var _inherits = _interopRequireDefault(require("./modifications/inherits"));

var _prependToMemberExpression = _interopRequireDefault(require("./modifications/prependToMemberExpression"));

var _removeProperties = _interopRequireDefault(require("./modifications/removeProperties"));

var _removePropertiesDeep = _interopRequireDefault(require("./modifications/removePropertiesDeep"));

var _removeTypeDuplicates = _interopRequireDefault(require("./modifications/flow/removeTypeDuplicates"));

var _getBindingIdentifiers = _interopRequireDefault(require("./retrievers/getBindingIdentifiers"));

var _getOuterBindingIdentifiers = _interopRequireDefault(require("./retrievers/getOuterBindingIdentifiers"));

var _traverse = _interopRequireDefault(require("./traverse/traverse"));

var _traverseFast = _interopRequireDefault(require("./traverse/traverseFast"));

var _shallowEqual = _interopRequireDefault(require("./utils/shallowEqual"));

var _is = _interopRequireDefault(require("./validators/is"));

var _isBinding = _interopRequireDefault(require("./validators/isBinding"));

var _isBlockScoped = _interopRequireDefault(require("./validators/isBlockScoped"));

var _isImmutable = _interopRequireDefault(require("./validators/isImmutable"));

var _isLet = _interopRequireDefault(require("./validators/isLet"));

var _isNode = _interopRequireDefault(require("./validators/isNode"));

var _isNodesEquivalent = _interopRequireDefault(require("./validators/isNodesEquivalent"));

var _isPlaceholderType = _interopRequireDefault(require("./validators/isPlaceholderType"));

var _isReferenced = _interopRequireDefault(require("./validators/isReferenced"));

var _isScope = _interopRequireDefault(require("./validators/isScope"));

var _isSpecifierDefault = _interopRequireDefault(require("./validators/isSpecifierDefault"));

var _isType = _interopRequireDefault(require("./validators/isType"));

var _isValidES3Identifier = _interopRequireDefault(require("./validators/isValidES3Identifier"));

var _isValidIdentifier = _interopRequireDefault(require("./validators/isValidIdentifier"));

var _isVar = _interopRequireDefault(require("./validators/isVar"));

var _matchesPattern = _interopRequireDefault(require("./validators/matchesPattern"));

var _validate = _interopRequireDefault(require("./validators/validate"));

var _buildMatchMemberExpression = _interopRequireDefault(require("./validators/buildMatchMemberExpression"));

var _generated4 = require("./validators/generated");

Object.keys(_generated4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generated4[key];
    }
  });
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var react = {
  isReactComponent: _isReactComponent.default,
  isCompatTag: _isCompatTag.default,
  buildChildren: _buildChildren.default
};
exports.react = react;

},{"./asserts/assertNode":201,"./asserts/generated":202,"./builders/flow/createTypeAnnotationBasedOnTypeof":204,"./builders/flow/createUnionTypeAnnotation":205,"./builders/generated":206,"./builders/react/buildChildren":207,"./clone/clone":208,"./clone/cloneDeep":209,"./clone/cloneNode":210,"./clone/cloneWithoutLoc":211,"./comments/addComment":212,"./comments/addComments":213,"./comments/inheritInnerComments":214,"./comments/inheritLeadingComments":215,"./comments/inheritTrailingComments":216,"./comments/inheritsComments":217,"./comments/removeComments":218,"./constants":220,"./constants/generated":219,"./converters/ensureBlock":221,"./converters/toBindingIdentifierName":223,"./converters/toBlock":224,"./converters/toComputedKey":225,"./converters/toExpression":226,"./converters/toIdentifier":227,"./converters/toKeyAlias":228,"./converters/toSequenceExpression":229,"./converters/toStatement":230,"./converters/valueToNode":231,"./definitions":236,"./modifications/appendToMemberExpression":243,"./modifications/flow/removeTypeDuplicates":244,"./modifications/inherits":245,"./modifications/prependToMemberExpression":246,"./modifications/removeProperties":247,"./modifications/removePropertiesDeep":248,"./retrievers/getBindingIdentifiers":249,"./retrievers/getOuterBindingIdentifiers":250,"./traverse/traverse":251,"./traverse/traverseFast":252,"./utils/shallowEqual":255,"./validators/buildMatchMemberExpression":256,"./validators/generated":257,"./validators/is":258,"./validators/isBinding":259,"./validators/isBlockScoped":260,"./validators/isImmutable":261,"./validators/isLet":262,"./validators/isNode":263,"./validators/isNodesEquivalent":264,"./validators/isPlaceholderType":265,"./validators/isReferenced":266,"./validators/isScope":267,"./validators/isSpecifierDefault":268,"./validators/isType":269,"./validators/isValidES3Identifier":270,"./validators/isValidIdentifier":271,"./validators/isVar":272,"./validators/matchesPattern":273,"./validators/react/isCompatTag":274,"./validators/react/isReactComponent":275,"./validators/validate":276}],243:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appendToMemberExpression;

var _generated = require("../builders/generated");

function appendToMemberExpression(member, append) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

},{"../builders/generated":206}],244:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function removeTypeDuplicates(nodes) {
  var generics = {};
  var bases = {};
  var typeGroups = [];
  var types = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      var name = node.id.name;

      if (generics[name]) {
        var existing = generics[name];

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
    var type = _Object$keys[_i];
    types.push(bases[type]);
  }

  for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
    var _name = _Object$keys2[_i2];
    types.push(generics[_name]);
  }

  return types;
}

},{"../../validators/generated":257}],245:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherits;

var _constants = require("../constants");

var _inheritsComments = _interopRequireDefault(require("../comments/inheritsComments"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inherits(child, parent) {
  if (!child || !parent) return child;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _constants.INHERIT_KEYS.optional[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
    var _key = _Object$keys[_i];
    if (_key[0] === "_" && _key !== "__clone") child[_key] = parent[_key];
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _constants.INHERIT_KEYS.force[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _key2 = _step2.value;
      child[_key2] = parent[_key2];
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  (0, _inheritsComments.default)(child, parent);
  return child;
}

},{"../comments/inheritsComments":217,"../constants":220}],246:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prependToMemberExpression;

var _generated = require("../builders/generated");

function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated.memberExpression)(prepend, member.object);
  return member;
}

},{"../builders/generated":206}],247:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeProperties;

var _constants = require("../constants");

var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

var CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (node[key] != null) node[key] = undefined;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
    var _key = _Object$keys[_i];
    if (_key[0] === "_" && node[_key] != null) node[_key] = undefined;
  }

  var symbols = Object.getOwnPropertySymbols(node);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = symbols[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var sym = _step2.value;
      node[sym] = null;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

},{"../constants":220}],248:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removePropertiesDeep;

var _traverseFast = _interopRequireDefault(require("../traverse/traverseFast"));

var _removeProperties = _interopRequireDefault(require("./removeProperties"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function removePropertiesDeep(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}

},{"../traverse/traverseFast":252,"./removeProperties":247}],249:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBindingIdentifiers;

var _generated = require("../validators/generated");

function getBindingIdentifiers(node, duplicates, outerOnly) {
  var search = [].concat(node);
  var ids = Object.create(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;
    var keys = getBindingIdentifiers.keys[id.type];

    if ((0, _generated.isIdentifier)(id)) {
      if (duplicates) {
        var _ids = ids[id.name] = ids[id.name] || [];

        _ids.push(id);
      } else {
        ids[id.name] = id;
      }

      continue;
    }

    if ((0, _generated.isExportDeclaration)(id)) {
      if ((0, _generated.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }

      continue;
    }

    if (outerOnly) {
      if ((0, _generated.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }

      if ((0, _generated.isFunctionExpression)(id)) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

},{"../validators/generated":257}],250:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterBindingIdentifiers;

var _getBindingIdentifiers = _interopRequireDefault(require("./getBindingIdentifiers"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function getOuterBindingIdentifiers(node, duplicates) {
  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

},{"./getBindingIdentifiers":249}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var _definitions = require("../definitions");

function traverse(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = {
      enter: handlers
    };
  }

  var _handlers = handlers,
      enter = _handlers.enter,
      exit = _handlers.exit;
  traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  var keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var i = 0; i < subNode.length; i++) {
          var child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node,
            key: key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node,
          key: key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (exit) exit(node, ancestors, state);
}

},{"../definitions":236}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseFast;

var _definitions = require("../definitions");

function traverseFast(node, enter, opts) {
  if (!node) return;
  var keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = subNode[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _node = _step2.value;
            traverseFast(_node, enter, opts);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

},{"../definitions":236}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherit;

var _uniq = _interopRequireDefault(require("lodash/uniq"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = (0, _uniq.default)([].concat(child[key], parent[key]).filter(Boolean));
  }
}

},{"lodash/uniq":1047}],254:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanJSXElementLiteralChild;

var _generated = require("../../builders/generated");

function cleanJSXElementLiteralChild(child, args) {
  var lines = child.value.split(/\r\n|\n|\r/);
  var lastNonEmptyLine = 0;

  for (var i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  var str = "";

  for (var _i = 0; _i < lines.length; _i++) {
    var line = lines[_i];
    var isFirstLine = _i === 0;
    var isLastLine = _i === lines.length - 1;
    var isLastNonEmptyLine = _i === lastNonEmptyLine;
    var trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push((0, _generated.stringLiteral)(str));
}

},{"../../builders/generated":206}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;

function shallowEqual(actual, expected) {
  var keys = Object.keys(expected);

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

},{}],256:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildMatchMemberExpression;

var _matchesPattern = _interopRequireDefault(require("./matchesPattern"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function buildMatchMemberExpression(match, allowPartial) {
  var parts = match.split(".");
  return function (member) {
    return (0, _matchesPattern.default)(member, parts, allowPartial);
  };
}

},{"./matchesPattern":273}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = isArrayExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBinaryExpression = isBinaryExpression;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isBlockStatement = isBlockStatement;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isExpressionStatement = isExpressionStatement;
exports.isFile = isFile;
exports.isForInStatement = isForInStatement;
exports.isForStatement = isForStatement;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isLabeledStatement = isLabeledStatement;
exports.isStringLiteral = isStringLiteral;
exports.isNumericLiteral = isNumericLiteral;
exports.isNullLiteral = isNullLiteral;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isMemberExpression = isMemberExpression;
exports.isNewExpression = isNewExpression;
exports.isProgram = isProgram;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMethod = isObjectMethod;
exports.isObjectProperty = isObjectProperty;
exports.isRestElement = isRestElement;
exports.isReturnStatement = isReturnStatement;
exports.isSequenceExpression = isSequenceExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isThisExpression = isThisExpression;
exports.isThrowStatement = isThrowStatement;
exports.isTryStatement = isTryStatement;
exports.isUnaryExpression = isUnaryExpression;
exports.isUpdateExpression = isUpdateExpression;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isArrayPattern = isArrayPattern;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportSpecifier = isExportSpecifier;
exports.isForOfStatement = isForOfStatement;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isMetaProperty = isMetaProperty;
exports.isClassMethod = isClassMethod;
exports.isObjectPattern = isObjectPattern;
exports.isSpreadElement = isSpreadElement;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isYieldExpression = isYieldExpression;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isClassImplements = isClassImplements;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXText = isJSXText;
exports.isJSXFragment = isJSXFragment;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isNoop = isNoop;
exports.isPlaceholder = isPlaceholder;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isAwaitExpression = isAwaitExpression;
exports.isBindExpression = isBindExpression;
exports.isClassProperty = isClassProperty;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isImport = isImport;
exports.isDecorator = isDecorator;
exports.isDoExpression = isDoExpression;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isPrivateName = isPrivateName;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSArrayType = isTSArrayType;
exports.isTSTupleType = isTSTupleType;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSRestType = isTSRestType;
exports.isTSUnionType = isTSUnionType;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSInferType = isTSInferType;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSMappedType = isTSMappedType;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSImportType = isTSImportType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isExpression = isExpression;
exports.isBinary = isBinary;
exports.isScopable = isScopable;
exports.isBlockParent = isBlockParent;
exports.isBlock = isBlock;
exports.isStatement = isStatement;
exports.isTerminatorless = isTerminatorless;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isLoop = isLoop;
exports.isWhile = isWhile;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFor = isFor;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionParent = isFunctionParent;
exports.isPureish = isPureish;
exports.isDeclaration = isDeclaration;
exports.isPatternLike = isPatternLike;
exports.isLVal = isLVal;
exports.isTSEntityName = isTSEntityName;
exports.isLiteral = isLiteral;
exports.isImmutable = isImmutable;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isMethod = isMethod;
exports.isObjectMember = isObjectMember;
exports.isProperty = isProperty;
exports.isUnaryLike = isUnaryLike;
exports.isPattern = isPattern;
exports.isClass = isClass;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isFlow = isFlow;
exports.isFlowType = isFlowType;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isEnumBody = isEnumBody;
exports.isEnumMember = isEnumMember;
exports.isJSX = isJSX;
exports.isPrivate = isPrivate;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSType = isTSType;
exports.isNumberLiteral = isNumberLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestProperty = isRestProperty;
exports.isSpreadProperty = isSpreadProperty;

var _shallowEqual = _interopRequireDefault(require("../../utils/shallowEqual"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isArrayExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinaryExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterpreterDirective(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirective(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBreakStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCallExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCatchClause(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditionalExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isContinueStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDebuggerStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoWhileStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFile(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForInStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIdentifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIfStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLabeledStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumericLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegExpLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLogicalExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMemberExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNewExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProgram(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMethod(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isReturnStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSequenceExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchCase(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThrowStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTryStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUpdateExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclarator(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhileStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWithStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentPattern(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayPattern(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForOfStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMetaProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassMethod(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectPattern(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSuper(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isYieldExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassImplements(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareClass(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareFunction(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareInterface(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModule(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareVariable(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInferredPredicate(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceExtends(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOpaqueType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAlias(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeCastExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameter(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariance(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXAttribute(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXIdentifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXText(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXFragment(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNoop(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPlaceholder(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAwaitExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBindExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImport(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecorator(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivateName(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBigIntLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParameterProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSQualifiedName(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSPropertySignature(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMethodSignature(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexSignature(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNullKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSStringKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSThisType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSFunctionType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructorType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeReference(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypePredicate(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeQuery(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSArrayType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTupleType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSOptionalType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSRestType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnionType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIntersectionType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConditionalType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInferType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeOperator(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMappedType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSLiteralType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAsExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleBlock(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExportAssignment(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameter(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpression(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinary(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isScopable(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockParent(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlock(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTerminatorless(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCompletionStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditional(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLoop(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhile(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionWrapper(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFor(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForXStatement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunction(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionParent(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPureish(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPatternLike(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLVal(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEntityName(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLiteral(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImmutable(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUserWhitespacable(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMethod(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProperty(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryLike(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPattern(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClass(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Class" || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleSpecifier(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlow(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowDeclaration(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowPredicate(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBody(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumMember(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSX(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivate(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeElement(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSType(node, opts) {
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  var nodeType = node.type;

  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

},{"../../utils/shallowEqual":255}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = is;

var _shallowEqual = _interopRequireDefault(require("../utils/shallowEqual"));

var _isType = _interopRequireDefault(require("./isType"));

var _isPlaceholderType = _interopRequireDefault(require("./isPlaceholderType"));

var _definitions = require("../definitions");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function is(type, node, opts) {
  if (!node) return false;
  var matches = (0, _isType.default)(node.type, type);

  if (!matches) {
    if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
      return (0, _isPlaceholderType.default)(node.expectedNode, type);
    }

    return false;
  }

  if (typeof opts === "undefined") {
    return true;
  } else {
    return (0, _shallowEqual.default)(node, opts);
  }
}

},{"../definitions":236,"../utils/shallowEqual":255,"./isPlaceholderType":265,"./isType":269}],259:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBinding;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isBinding(node, parent, grandparent) {
  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
    return false;
  }

  var keys = _getBindingIdentifiers.default.keys[parent.type];

  if (keys) {
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = parent[key];

      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

},{"../retrievers/getBindingIdentifiers":249}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBlockScoped;

var _generated = require("./generated");

var _isLet = _interopRequireDefault(require("./isLet"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isBlockScoped(node) {
  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

},{"./generated":257,"./isLet":262}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isImmutable;

var _isType = _interopRequireDefault(require("./isType"));

var _generated = require("./generated");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isImmutable(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;

  if ((0, _generated.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}

},{"./generated":257,"./isType":269}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLet;

var _generated = require("./generated");

var _constants = require("../constants");

function isLet(node) {
  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

},{"../constants":220,"./generated":257}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNode;

var _definitions = require("../definitions");

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

},{"../definitions":236}],264:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNodesEquivalent;

var _definitions = require("../definitions");

function isNodesEquivalent(a, b) {
  if (_typeof(a) !== "object" || _typeof(b) !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  var fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  var visitorKeys = _definitions.VISITOR_KEYS[a.type];

  for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
    var field = _fields[_i];

    if (_typeof(a[field]) !== _typeof(b[field])) {
      return false;
    }

    if (a[field] == null && b[field] == null) {
      continue;
    } else if (a[field] == null || b[field] == null) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }

      if (a[field].length !== b[field].length) {
        return false;
      }

      for (var i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }

      continue;
    }

    if (_typeof(a[field]) === "object" && (!visitorKeys || !visitorKeys.includes(field))) {
      for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];

        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }

      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}

},{"../definitions":236}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPlaceholderType;

var _definitions = require("../definitions");

function isPlaceholderType(placeholderType, targetType) {
  if (placeholderType === targetType) return true;
  var aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];

  if (aliases) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var alias = _step.value;
        if (targetType === alias) return true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return false;
}

},{"../definitions":236}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isReferenced;

function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }

      return parent.object === node;

    case "VariableDeclarator":
      return parent.init === node;

    case "ArrowFunctionExpression":
      return parent.body === node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }

      return parent.local === node;

    case "PrivateName":
      return false;

    case "ObjectProperty":
    case "ClassProperty":
    case "ClassPrivateProperty":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }

      if (parent.value === node) {
        return !grandparent || grandparent.type !== "ObjectPattern";
      }

      return true;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return false;

    case "RestElement":
      return false;

    case "BreakStatement":
    case "ContinueStatement":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "JSXAttribute":
      return false;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;

    case "MetaProperty":
      return false;

    case "ObjectTypeProperty":
      return parent.key !== node;

    case "TSEnumMember":
      return parent.id !== node;

    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }

      return true;
  }

  return true;
}

},{}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScope;

var _generated = require("./generated");

function isScope(node, parent) {
  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
    body: node
  })) {
    return false;
  }

  return (0, _generated.isScopable)(node);
}

},{"./generated":257}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isSpecifierDefault;

var _generated = require("./generated");

function isSpecifierDefault(specifier) {
  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
    name: "default"
  });
}

},{"./generated":257}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isType;

var _definitions = require("../definitions");

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;
  if (_definitions.ALIAS_KEYS[targetType]) return false;
  var aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

  if (aliases) {
    if (aliases[0] === nodeType) return true;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var alias = _step.value;
        if (nodeType === alias) return true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return false;
}

},{"../definitions":236}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidES3Identifier;

var _isValidIdentifier = _interopRequireDefault(require("./isValidIdentifier"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

},{"./isValidIdentifier":271}],271:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidIdentifier;

var _esutils = _interopRequireDefault(require("esutils"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isValidIdentifier(name) {
  if (typeof name !== "string" || _esutils.default.keyword.isReservedWordES6(name, true)) {
    return false;
  } else if (name === "await") {
    return false;
  } else {
    return _esutils.default.keyword.isIdentifierNameES6(name);
  }
}

},{"esutils":836}],272:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isVar;

var _generated = require("./generated");

var _constants = require("../constants");

function isVar(node) {
  return (0, _generated.isVariableDeclaration)(node, {
    kind: "var"
  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

},{"../constants":220,"./generated":257}],273:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesPattern;

var _generated = require("./generated");

function matchesPattern(member, match, allowPartial) {
  if (!(0, _generated.isMemberExpression)(member)) return false;
  var parts = Array.isArray(match) ? match : match.split(".");
  var nodes = [];
  var node;

  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
    nodes.push(node.property);
  }

  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;

  for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    var _node = nodes[j];
    var value = void 0;

    if ((0, _generated.isIdentifier)(_node)) {
      value = _node.name;
    } else if ((0, _generated.isStringLiteral)(_node)) {
      value = _node.value;
    } else {
      return false;
    }

    if (parts[i] !== value) return false;
  }

  return true;
}

},{"./generated":257}],274:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCompatTag;

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}

},{}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _buildMatchMemberExpression = _interopRequireDefault(require("../buildMatchMemberExpression"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

},{"../buildMatchMemberExpression":256}],276:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;
exports.validateField = validateField;

var _definitions = require("../definitions");

function validate(node, key, val) {
  if (!node) return;
  var fields = _definitions.NODE_FIELDS[node.type];
  if (!fields) return;
  var field = fields[key];
  validateField(node, key, val, field);
}

function validateField(node, key, val, field) {
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

},{"../definitions":236}],277:[function(require,module,exports){
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var colorConvert = require('color-convert');

var wrapAnsi16 = function wrapAnsi16(fn, offset) {
  return function () {
    var code = fn.apply(colorConvert, arguments);
    return "\x1B[".concat(code + offset, "m");
  };
};

var wrapAnsi256 = function wrapAnsi256(fn, offset) {
  return function () {
    var code = fn.apply(colorConvert, arguments);
    return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
  };
};

var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
  return function () {
    var rgb = fn.apply(colorConvert, arguments);
    return "\x1B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
  };
};

function assembleStyles() {
  var codes = new Map();
  var styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      // Bright color
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }; // Fix humans

  styles.color.grey = styles.color.gray;

  for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
    var groupName = _Object$keys[_i];
    var group = styles[groupName];

    for (var _i3 = 0, _Object$keys3 = Object.keys(group); _i3 < _Object$keys3.length; _i3++) {
      var styleName = _Object$keys3[_i3];
      var style = group[styleName];
      styles[styleName] = {
        open: "\x1B[".concat(style[0], "m"),
        close: "\x1B[".concat(style[1], "m")
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
  }

  var ansi2ansi = function ansi2ansi(n) {
    return n;
  };

  var rgb2rgb = function rgb2rgb(r, g, b) {
    return [r, g, b];
  };

  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = {
    ansi: wrapAnsi16(ansi2ansi, 0)
  };
  styles.color.ansi256 = {
    ansi256: wrapAnsi256(ansi2ansi, 0)
  };
  styles.color.ansi16m = {
    rgb: wrapAnsi16m(rgb2rgb, 0)
  };
  styles.bgColor.ansi = {
    ansi: wrapAnsi16(ansi2ansi, 10)
  };
  styles.bgColor.ansi256 = {
    ansi256: wrapAnsi256(ansi2ansi, 10)
  };
  styles.bgColor.ansi16m = {
    rgb: wrapAnsi16m(rgb2rgb, 10)
  };

  for (var _i2 = 0, _Object$keys2 = Object.keys(colorConvert); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];

    if (_typeof(colorConvert[key]) !== 'object') {
      continue;
    }

    var suite = colorConvert[key];

    if (key === 'ansi16') {
      key = 'ansi';
    }

    if ('ansi16' in suite) {
      styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
      styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
    }

    if ('ansi256' in suite) {
      styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
      styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
    }

    if ('rgb' in suite) {
      styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
      styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
    }
  }

  return styles;
} // Make the export immutable


Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});

},{"color-convert":299}],278:[function(require,module,exports){
(function (global){
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var objectAssign = require('object-assign'); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }

  return !!(b != null && b._isBuffer);
} // based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


var util = require('util/');

var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;

var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


var assert = module.exports = ok; // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}; // assert.AssertionError instanceof Error


util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}

assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
}; // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
}; // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || _typeof(actual) !== 'object') && (expected === null || _typeof(expected) !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
}; // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
}; // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
}; // Expose a strict only variant of assert


function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":1051,"util/":281}],279:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],280:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function isBuffer(arg) {
  return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],281:[function(require,module,exports){
(function (process,global){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":280,"_process":1054,"inherits":279}],282:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImportSource = getImportSource;
exports.createDynamicImportTransform = createDynamicImportTransform;

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function getImportSource(t, callNode) {
  var importArguments = callNode.arguments;

  var _importArguments = _slicedToArray(importArguments, 1),
      importPath = _importArguments[0];

  var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

  if (isString) {
    t.removeComments(importPath);
    return importPath;
  }

  return t.templateLiteral([t.templateElement({
    raw: '',
    cooked: ''
  }), t.templateElement({
    raw: '',
    cooked: ''
  }, true)], importArguments);
}

function createDynamicImportTransform(_ref) {
  var template = _ref.template,
      t = _ref.types;
  var buildImport = template('Promise.resolve().then(() => MODULE)');
  return function (context, path) {
    var requireCall = t.callExpression(t.identifier('require'), [getImportSource(t, path.parent)]);
    var _context$opts$noInter = context.opts.noInterop,
        noInterop = _context$opts$noInter === undefined ? false : _context$opts$noInter;
    var MODULE = noInterop === true ? requireCall : t.callExpression(context.addHelper('interopRequireWildcard'), [requireCall]);
    var newImport = buildImport({
      MODULE: MODULE
    });
    path.parentPath.replaceWith(newImport);
  };
}

},{}],283:[function(require,module,exports){
"use strict";

// Re-export lib/utils, so that consumers can import
// babel-plugin-dynamic-import-node/utils instead of
// babel-plugin-dynamic-import-node/lib/utils
// eslint-disable-next-line import/no-unresolved
module.exports = require('./lib/utils');

},{"./lib/utils":282}],284:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],285:[function(require,module,exports){
"use strict";

},{}],286:[function(require,module,exports){
"use strict";

var BrowserslistError = require('./error');

function noop() {}

module.exports = {
  loadQueries: function loadQueries() {
    throw new BrowserslistError('Sharable configs are not supported in client-side build of Browserslist');
  },
  getStat: function getStat(opts) {
    return opts.stats;
  },
  loadConfig: function loadConfig(opts) {
    if (opts.config) {
      throw new BrowserslistError('Browserslist config are not supported in client-side build');
    }
  },
  loadCountry: function loadCountry() {
    throw new BrowserslistError('Country statistics is not supported ' + 'in client-side build of Browserslist');
  },
  currentNode: function currentNode(resolve, context) {
    return resolve(['maintained node versions'], context)[0];
  },
  parseConfig: noop,
  readConfig: noop,
  findConfig: noop,
  clearCaches: noop,
  oldDataWarning: noop
};

},{"./error":287}],287:[function(require,module,exports){
"use strict";

function BrowserslistError(message) {
  this.name = 'BrowserslistError';
  this.message = message;
  this.browserslist = true;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, BrowserslistError);
  }
}

BrowserslistError.prototype = Error.prototype;
module.exports = BrowserslistError;

},{}],288:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var jsReleases = require('node-releases/data/processed/envs.json');

var agents = require('caniuse-lite/dist/unpacker/agents').agents;

var jsEOL = require('node-releases/data/release-schedule/release-schedule.json');

var path = require('path');

var e2c = require('electron-to-chromium/versions');

var BrowserslistError = require('./error');

var env = require('./node'); // Will load browser.js in webpack


var FLOAT_RANGE = /^\d+(\.\d+)?(-\d+(\.\d+)?)*$/;
var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
var QUERY_OR = 1;
var QUERY_AND = 2;

function isVersionsMatch(versionA, versionB) {
  return (versionA + '.').indexOf(versionB + '.') === 0;
}

function isEolReleased(name) {
  var version = name.slice(1);
  return jsReleases.some(function (i) {
    return isVersionsMatch(i.version, version);
  });
}

function normalize(versions) {
  return versions.filter(function (version) {
    return typeof version === 'string';
  });
}

function normalizeElectron(version) {
  var versionToUse = version;

  if (version.split('.').length === 3) {
    versionToUse = version.split('.').slice(0, -1).join('.');
  }

  return versionToUse;
}

function nameMapper(name) {
  return function mapName(version) {
    return name + ' ' + version;
  };
}

function getMajor(version) {
  return parseInt(version.split('.')[0]);
}

function getMajorVersions(released, number) {
  if (released.length === 0) return [];
  var minimum = getMajor(released[released.length - 1]) - parseInt(number) + 1;
  var selected = [];

  for (var i = released.length - 1; i >= 0; i--) {
    if (minimum > getMajor(released[i])) break;
    selected.unshift(released[i]);
  }

  return selected;
}

function uniq(array) {
  var filtered = [];

  for (var i = 0; i < array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
  }

  return filtered;
} // Helpers


function fillUsage(result, name, data) {
  for (var i in data) {
    result[name + ' ' + i] = data[i];
  }
}

function generateFilter(sign, version) {
  version = parseFloat(version);

  if (sign === '>') {
    return function (v) {
      return parseFloat(v) > version;
    };
  } else if (sign === '>=') {
    return function (v) {
      return parseFloat(v) >= version;
    };
  } else if (sign === '<') {
    return function (v) {
      return parseFloat(v) < version;
    };
  } else {
    return function (v) {
      return parseFloat(v) <= version;
    };
  }
}

function generateSemverFilter(sign, version) {
  version = version.split('.').map(parseSimpleInt);
  version[1] = version[1] || 0;
  version[2] = version[2] || 0;

  if (sign === '>') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(v, version) > 0;
    };
  } else if (sign === '>=') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(v, version) >= 0;
    };
  } else if (sign === '<') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(version, v) > 0;
    };
  } else {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(version, v) >= 0;
    };
  }
}

function parseSimpleInt(x) {
  return parseInt(x);
}

function compare(a, b) {
  if (a < b) return -1;
  if (a > b) return +1;
  return 0;
}

function compareSemver(a, b) {
  return compare(a[0], b[0]) || compare(a[1], b[1]) || compare(a[2], b[2]);
}

function resolveVersion(data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version;
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version];
  } else {
    return false;
  }
}

function normalizeVersion(data, version, context) {
  var resolved = resolveVersion(data, version);

  if (!resolved && context.mobileToDesktop && browserslist.desktopNames[data.name]) {
    var alias = checkName(browserslist.desktopNames[data.name]);
    resolved = resolveVersion(alias, version);
  }

  if (resolved) {
    return resolved;
  } else if (data.versions.length === 1) {
    return data.versions[0];
  } else {
    return false;
  }
}

function filterByYear(since) {
  since = since / 1000;
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name);
    if (!data) return selected;
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      return data.releaseDate[v] >= since;
    });
    return selected.concat(versions.map(nameMapper(data.name)));
  }, []);
}

function byName(name) {
  name = name.toLowerCase();
  name = browserslist.aliases[name] || name;
  return browserslist.data[name];
}

function checkName(name) {
  var data = byName(name);
  if (!data) throw new BrowserslistError('Unknown browser ' + name);
  return data;
}

function unknownQuery(query) {
  return new BrowserslistError('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
}

function filterAndroid(list, versions) {
  var released = browserslist.data.android.released;
  var firstEvergreen = 37;
  var last = released[released.length - 1];
  var diff = last - firstEvergreen - versions; // First Android Evergreen

  if (diff > 0) {
    return list.slice(-1);
  } else {
    return list.slice(diff - 1);
  }
}
/**
 * Resolves queries into a browser list.
 * @param {string|string[]} queries Queries to combine.
 * Either an array of queries or a long string of queries.
 * @param {object} [context] Optional arguments to
 * the select function in `queries`.
 * @returns {string[]} A list of browsers
 */


function resolve(queries, context) {
  if (Array.isArray(queries)) {
    queries = flatten(queries.map(parse));
  } else {
    queries = parse(queries);
  }

  return queries.reduce(function (result, query, index) {
    var selection = query.queryString;
    var isExclude = selection.indexOf('not ') === 0;

    if (isExclude) {
      if (index === 0) {
        throw new BrowserslistError('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
      }

      selection = selection.slice(4);
    }

    for (var i = 0; i < QUERIES.length; i++) {
      var type = QUERIES[i];
      var match = selection.match(type.regexp);

      if (match) {
        var args = [context].concat(match.slice(1));
        var array = type.select.apply(browserslist, args).map(function (j) {
          var parts = j.split(' ');

          if (parts[1] === '0') {
            return parts[0] + ' ' + byName(parts[0]).versions[0];
          } else {
            return j;
          }
        });

        switch (query.type) {
          case QUERY_AND:
            if (isExclude) {
              return result.filter(function (j) {
                return array.indexOf(j) === -1;
              });
            } else {
              return result.filter(function (j) {
                return array.indexOf(j) !== -1;
              });
            }

          case QUERY_OR:
          default:
            if (isExclude) {
              var filter = {};
              array.forEach(function (j) {
                filter[j] = true;
              });
              return result.filter(function (j) {
                return !filter[j];
              });
            }

            return result.concat(array);
        }
      }
    }

    throw unknownQuery(selection);
  }, []);
}

var cache = {};
/**
 * Return array of browsers by selection queries.
 *
 * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.
 * @param {object} [opts] Options.
 * @param {string} [opts.path="."] Path to processed file.
 *                                 It will be used to find config files.
 * @param {string} [opts.env="production"] Processing environment.
 *                                         It will be used to take right
 *                                         queries from config file.
 * @param {string} [opts.config] Path to config file with queries.
 * @param {object} [opts.stats] Custom browser usage statistics
 *                              for "> 1% in my stats" query.
 * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown
 *                                                     version in direct query.
 * @param {boolean} [opts.dangerousExtend] Disable security checks
 *                                         for extend query.
 * @param {boolean} [opts.mobileToDesktop] Alias mobile browsers to the desktop
 *                                         version when Can I Use doesn't have
 *                                         data about the specified version.
 * @returns {string[]} Array with browser names in Can I Use.
 *
 * @example
 * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']
 */

function browserslist(queries, opts) {
  if (typeof opts === 'undefined') opts = {};

  if (typeof opts.path === 'undefined') {
    opts.path = path.resolve ? path.resolve('.') : '.';
  }

  if (typeof queries === 'undefined' || queries === null) {
    var config = browserslist.loadConfig(opts);

    if (config) {
      queries = config;
    } else {
      queries = browserslist.defaults;
    }
  }

  if (!(typeof queries === 'string' || Array.isArray(queries))) {
    throw new BrowserslistError('Browser queries must be an array or string. Got ' + _typeof(queries) + '.');
  }

  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend,
    mobileToDesktop: opts.mobileToDesktop
  };
  env.oldDataWarning(browserslist.data);
  var stats = env.getStat(opts, browserslist.data);

  if (stats) {
    context.customUsage = {};

    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser]);
    }
  }

  var cacheKey = JSON.stringify([queries, context]);
  if (cache[cacheKey]) return cache[cacheKey];
  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
    name1 = name1.split(' ');
    name2 = name2.split(' ');

    if (name1[0] === name2[0]) {
      if (FLOAT_RANGE.test(name1[1]) && FLOAT_RANGE.test(name2[1])) {
        return parseFloat(name2[1]) - parseFloat(name1[1]);
      } else {
        return compare(name2[1], name1[1]);
      }
    } else {
      return compare(name1[0], name2[0]);
    }
  });

  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
    cache[cacheKey] = result;
  }

  return result;
}

function parse(queries) {
  var qs = [];

  do {
    queries = doMatch(queries, qs);
  } while (queries);

  return qs;
}

function doMatch(string, qs) {
  var or = /^(?:,\s*|\s+OR\s+)(.*)/i;
  var and = /^\s+AND\s+(.*)/i;
  return find(string, function (parsed, n, max) {
    if (and.test(parsed)) {
      qs.unshift({
        type: QUERY_AND,
        queryString: parsed.match(and)[1]
      });
      return true;
    } else if (or.test(parsed)) {
      qs.unshift({
        type: QUERY_OR,
        queryString: parsed.match(or)[1]
      });
      return true;
    } else if (n === max) {
      qs.unshift({
        type: QUERY_OR,
        queryString: parsed.trim()
      });
      return true;
    }

    return false;
  });
}

function find(string, predicate) {
  for (var n = 1, max = string.length; n <= max; n++) {
    var parsed = string.substr(-n, n);

    if (predicate(parsed, n, max)) {
      return string.slice(0, -n);
    }
  }

  return '';
}

function flatten(array) {
  if (!Array.isArray(array)) return [array];
  return array.reduce(function (a, b) {
    return a.concat(flatten(b));
  }, []);
} // Will be filled by Can I Use data below


browserslist.data = {};
browserslist.usage = {
  global: {},
  custom: null
}; // Default browsers query

browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead']; // Browser names aliases

browserslist.aliases = {
  fx: 'firefox',
  ff: 'firefox',
  ios: 'ios_saf',
  explorer: 'ie',
  blackberry: 'bb',
  explorermobile: 'ie_mob',
  operamini: 'op_mini',
  operamobile: 'op_mob',
  chromeandroid: 'and_chr',
  firefoxandroid: 'and_ff',
  ucandroid: 'and_uc',
  qqandroid: 'and_qq'
}; // Can I Use only provides a few versions for some browsers (e.g. and_chr).
// Fallback to a similar browser for unknown versions

browserslist.desktopNames = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  op_mob: 'opera'
}; // Aliases to work with joined versions like `ios_saf 7.0-7.1`

browserslist.versionAliases = {};
browserslist.clearCaches = env.clearCaches;
browserslist.parseConfig = env.parseConfig;
browserslist.readConfig = env.readConfig;
browserslist.findConfig = env.findConfig;
browserslist.loadConfig = env.loadConfig;
/**
 * Return browsers market coverage.
 *
 * @param {string[]} browsers Browsers names in Can I Use.
 * @param {string|object} [stats="global"] Which statistics should be used.
 *                                         Country code or custom statistics.
 *                                         Pass `"my stats"` to load statistics
 *                                         from Browserslist files.
 *
 * @return {number} Total market coverage for all selected browsers.
 *
 * @example
 * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1
 */

browserslist.coverage = function (browsers, stats) {
  var data;

  if (typeof stats === 'undefined') {
    data = browserslist.usage.global;
  } else if (stats === 'my stats') {
    var opts = {};
    opts.path = path.resolve ? path.resolve('.') : '.';
    var customStats = env.getStat(opts);

    if (!customStats) {
      throw new BrowserslistError('Custom usage statistics was not provided');
    }

    data = {};

    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser]);
    }
  } else if (typeof stats === 'string') {
    if (stats.length > 2) {
      stats = stats.toLowerCase();
    } else {
      stats = stats.toUpperCase();
    }

    env.loadCountry(browserslist.usage, stats);
    data = browserslist.usage[stats];
  } else {
    if ('dataByBrowser' in stats) {
      stats = stats.dataByBrowser;
    }

    data = {};

    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + ' ' + version] = stats[name][version];
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i];

    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, ' 0')];
    }

    return all + (usage || 0);
  }, 0);
};

var QUERIES = [{
  regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
  select: function select(context, versions) {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name);
      if (!data) return selected;
      var list = getMajorVersions(data.released, versions);
      list = list.map(nameMapper(data.name));
      if (data.name === 'android') list = filterAndroid(list, versions);
      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^last\s+(\d+)\s+versions?$/i,
  select: function select(context, versions) {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name);
      if (!data) return selected;
      var list = data.released.slice(-versions);
      list = list.map(nameMapper(data.name));
      if (data.name === 'android') list = filterAndroid(list, versions);
      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
  select: function select(context, versions) {
    var validVersions = getMajorVersions(Object.keys(e2c).reverse(), versions);
    return validVersions.map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
  select: function select(context, versions, name) {
    var data = checkName(name);
    var validVersions = getMajorVersions(data.released, versions);
    var list = validVersions.map(nameMapper(data.name));
    if (data.name === 'android') list = filterAndroid(list, versions);
    return list;
  }
}, {
  regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
  select: function select(context, versions) {
    return Object.keys(e2c).reverse().slice(-versions).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
  select: function select(context, versions, name) {
    var data = checkName(name);
    var list = data.released.slice(-versions).map(nameMapper(data.name));
    if (data.name === 'android') list = filterAndroid(list, versions);
    return list;
  }
}, {
  regexp: /^unreleased\s+versions$/i,
  select: function select() {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name);
      if (!data) return selected;
      var list = data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1;
      });
      list = list.map(nameMapper(data.name));
      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^unreleased\s+electron\s+versions?$/i,
  select: function select() {
    return [];
  }
}, {
  regexp: /^unreleased\s+(\w+)\s+versions?$/i,
  select: function select(context, name) {
    var data = checkName(name);
    return data.versions.filter(function (v) {
      return data.released.indexOf(v) === -1;
    }).map(nameMapper(data.name));
  }
}, {
  regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
  select: function select(context, years) {
    return filterByYear(Date.now() - YEAR * years);
  }
}, {
  regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
  select: function select(context, year, month, date) {
    year = parseInt(year);
    month = parseInt(month || '01') - 1;
    date = parseInt(date || '01');
    return filterByYear(Date.UTC(year, month, date, 0, 0, 0));
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
  select: function select(context, sign, popularity) {
    popularity = parseFloat(popularity);
    var usage = browserslist.usage.global;
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
  select: function select(context, sign, popularity) {
    popularity = parseFloat(popularity);

    if (!context.customUsage) {
      throw new BrowserslistError('Custom usage statistics was not provided');
    }

    var usage = context.customUsage;
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
  select: function select(context, sign, popularity, place) {
    popularity = parseFloat(popularity);

    if (place.length === 2) {
      place = place.toUpperCase();
    } else {
      place = place.toLowerCase();
    }

    env.loadCountry(browserslist.usage, place);
    var usage = browserslist.usage[place];
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
  select: function select(context, coverage, statMode) {
    coverage = parseFloat(coverage);
    var usage = browserslist.usage.global;

    if (statMode) {
      if (statMode.match(/^\s+in\s+my\s+stats$/)) {
        if (!context.customUsage) {
          throw new BrowserslistError('Custom usage statistics was not provided');
        }

        usage = context.customUsage;
      } else {
        var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
        var place = match[1];

        if (place.length === 2) {
          place = place.toUpperCase();
        } else {
          place = place.toLowerCase();
        }

        env.loadCountry(browserslist.usage, place);
        usage = browserslist.usage[place];
      }
    }

    var versions = Object.keys(usage).sort(function (a, b) {
      return usage[b] - usage[a];
    });
    var coveraged = 0;
    var result = [];
    var version;

    for (var i = 0; i <= versions.length; i++) {
      version = versions[i];
      if (usage[version] === 0) break;
      coveraged += usage[version];
      result.push(version);
      if (coveraged >= coverage) break;
    }

    return result;
  }
}, {
  regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
  select: function select(context, from, to) {
    var fromToUse = normalizeElectron(from);
    var toToUse = normalizeElectron(to);

    if (!e2c[fromToUse]) {
      throw new BrowserslistError('Unknown version ' + from + ' of electron');
    }

    if (!e2c[toToUse]) {
      throw new BrowserslistError('Unknown version ' + to + ' of electron');
    }

    from = parseFloat(from);
    to = parseFloat(to);
    return Object.keys(e2c).filter(function (i) {
      var parsed = parseFloat(i);
      return parsed >= from && parsed <= to;
    }).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
  select: function select(context, name, from, to) {
    var data = checkName(name);
    from = parseFloat(normalizeVersion(data, from, context) || from);
    to = parseFloat(normalizeVersion(data, to, context) || to);

    function filter(v) {
      var parsed = parseFloat(v);
      return parsed >= from && parsed <= to;
    }

    return data.released.filter(filter).map(nameMapper(data.name));
  }
}, {
  regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
  select: function select(context, sign, version) {
    var versionToUse = normalizeElectron(version);
    return Object.keys(e2c).filter(generateFilter(sign, versionToUse)).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
  select: function select(context, sign, version) {
    var nodeVersions = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    }).map(function (i) {
      return i.version;
    });
    return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
      return 'node ' + v;
    });
  }
}, {
  regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
  select: function select(context, name, sign, version) {
    var data = checkName(name);
    var alias = browserslist.versionAliases[data.name][version];

    if (alias) {
      version = alias;
    }

    return data.released.filter(generateFilter(sign, version)).map(function (v) {
      return data.name + ' ' + v;
    });
  }
}, {
  regexp: /^(firefox|ff|fx)\s+esr$/i,
  select: function select() {
    return ['firefox 68'];
  }
}, {
  regexp: /(operamini|op_mini)\s+all/i,
  select: function select() {
    return ['op_mini all'];
  }
}, {
  regexp: /^electron\s+([\d.]+)$/i,
  select: function select(context, version) {
    var versionToUse = normalizeElectron(version);
    var chrome = e2c[versionToUse];

    if (!chrome) {
      throw new BrowserslistError('Unknown version ' + version + ' of electron');
    }

    return ['chrome ' + chrome];
  }
}, {
  regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
  select: function select(context, version) {
    var nodeReleases = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    });
    var matched = nodeReleases.filter(function (i) {
      return isVersionsMatch(i.version, version);
    });

    if (matched.length === 0) {
      if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new BrowserslistError('Unknown version ' + version + ' of Node.js');
      }
    }

    return ['node ' + matched[matched.length - 1].version];
  }
}, {
  regexp: /^current\s+node$/i,
  select: function select(context) {
    return [env.currentNode(resolve, context)];
  }
}, {
  regexp: /^maintained\s+node\s+versions$/i,
  select: function select(context) {
    var now = Date.now();
    var queries = Object.keys(jsEOL).filter(function (key) {
      return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
    }).map(function (key) {
      return 'node ' + key.slice(1);
    });
    return resolve(queries, context);
  }
}, {
  regexp: /^phantomjs\s+1.9$/i,
  select: function select() {
    return ['safari 5'];
  }
}, {
  regexp: /^phantomjs\s+2.1$/i,
  select: function select() {
    return ['safari 6'];
  }
}, {
  regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
  select: function select(context, name, version) {
    if (/^tp$/i.test(version)) version = 'TP';
    var data = checkName(name);
    var alias = normalizeVersion(data, version, context);

    if (alias) {
      version = alias;
    } else {
      if (version.indexOf('.') === -1) {
        alias = version + '.0';
      } else {
        alias = version.replace(/\.0$/, '');
      }

      alias = normalizeVersion(data, alias, context);

      if (alias) {
        version = alias;
      } else if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new BrowserslistError('Unknown version ' + version + ' of ' + name);
      }
    }

    return [data.name + ' ' + version];
  }
}, {
  regexp: /^extends (.+)$/i,
  select: function select(context, name) {
    return resolve(env.loadQueries(context, name), context);
  }
}, {
  regexp: /^defaults$/i,
  select: function select() {
    return browserslist(browserslist.defaults);
  }
}, {
  regexp: /^dead$/i,
  select: function select(context) {
    var dead = ['ie <= 10', 'ie_mob <= 10', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
    return resolve(dead, context);
  }
}, {
  regexp: /^(\w+)$/i,
  select: function select(context, name) {
    if (byName(name)) {
      throw new BrowserslistError('Specify versions in Browserslist query for browser ' + name);
    } else {
      throw unknownQuery(name);
    }
  }
}]; // Get and convert Can I Use data

(function () {
  for (var name in agents) {
    var browser = agents[name];
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    };
    fillUsage(browserslist.usage.global, name, browser.usage_global);
    browserslist.versionAliases[name] = {};

    for (var i = 0; i < browser.versions.length; i++) {
      var full = browser.versions[i];
      if (!full) continue;

      if (full.indexOf('-') !== -1) {
        var interval = full.split('-');

        for (var j = 0; j < interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full;
        }
      }
    }
  }
})();

module.exports = browserslist;

}).call(this,require('_process'))
},{"./error":287,"./node":286,"_process":1054,"caniuse-lite/dist/unpacker/agents":293,"electron-to-chromium/versions":831,"node-releases/data/processed/envs.json":1049,"node-releases/data/release-schedule/release-schedule.json":1050,"path":285}],289:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var base64 = require('base64-js');

var ieee754 = require('ieee754');

var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
} // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }

  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
} // Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219


var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);

  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;

    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }

  return table;
}();

}).call(this,require("buffer").Buffer)
},{"base64-js":284,"buffer":289,"ieee754":839}],290:[function(require,module,exports){
"use strict";

module.exports = {
  A: {
    A: {
      H: 0.0138389,
      D: 0.00922596,
      G: 0.156841,
      E: 0.0415168,
      A: 0.0415168,
      B: 2.03894,
      mB: 0.009298
    },
    B: "ms",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mB", "H", "D", "G", "E", "A", "B", "", "", ""],
    E: "IE",
    F: {
      mB: 962323200,
      H: 998870400,
      D: 1161129600,
      G: 1237420800,
      E: 1300060800,
      A: 1346716800,
      B: 1381968000
    }
  },
  B: {
    A: {
      C: 0.013383,
      L: 0.013383,
      q: 0.026766,
      M: 0.026766,
      O: 0.057993,
      I: 0.517476,
      J: 1.45429,
      K: 0
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "q", "M", "O", "I", "J", "K", "", ""],
    E: "Edge",
    F: {
      C: 1438128000,
      L: 1447286400,
      q: 1470096000,
      M: 1491868800,
      O: 1508198400,
      I: 1525046400,
      J: 1542067200,
      K: null
    },
    D: {
      C: "ms",
      L: "ms",
      q: "ms",
      M: "ms",
      O: "ms",
      I: "ms",
      J: "ms"
    }
  },
  C: {
    A: {
      "0": 0.026766,
      "1": 0.013383,
      "2": 0.008922,
      "3": 0.160596,
      "4": 0.013383,
      "5": 0.004879,
      "6": 0.75837,
      "8": 0.004707,
      "9": 0.013383,
      jB: 0.004827,
      AB: 0.00487,
      F: 0.00974,
      H: 0.020136,
      D: 0.005725,
      G: 0.004525,
      E: 0.00533,
      A: 0.004283,
      B: 0.005029,
      C: 0.004471,
      L: 0.004486,
      q: 0.00453,
      M: 0.004465,
      O: 0.004417,
      I: 0.008922,
      J: 0.004393,
      P: 0.004443,
      Q: 0.004283,
      R: 0.004465,
      S: 0.004393,
      T: 0.004525,
      U: 0.008786,
      V: 0.004461,
      W: 0.004317,
      X: 0.004393,
      Y: 0.004418,
      Z: 0.008834,
      a: 0.004461,
      b: 0.008922,
      c: 0.004471,
      d: 0.008922,
      f: 0.022305,
      g: 0.004465,
      h: 0.004783,
      i: 0.008922,
      j: 0.004783,
      k: 0.00487,
      l: 0.005029,
      m: 0.0047,
      n: 0.013383,
      o: 0.008922,
      p: 0.017844,
      N: 0.004525,
      r: 0.026766,
      s: 0.040149,
      t: 0.004461,
      u: 0.013383,
      v: 0.008922,
      w: 0.156135,
      x: 0.004461,
      y: 0.013383,
      z: 0.013383,
      LB: 0.013383,
      BB: 0.017844,
      CB: 0.022305,
      DB: 0.04461,
      EB: 0.057993,
      FB: 0.053532,
      HB: 2.50262,
      IB: 0.066915,
      JB: 0,
      KB: 0,
      dB: 0.008786,
      cB: 0.00487
    },
    B: "moz",
    C: ["", "", "", "", "jB", "AB", "dB", "cB", "F", "5", "H", "D", "G", "E", "A", "B", "C", "L", "q", "M", "O", "I", "J", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "8", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "N", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "LB", "3", "9", "4", "BB", "CB", "DB", "EB", "FB", "6", "HB", "IB", "JB", "KB", ""],
    E: "Firefox",
    F: {
      "0": 1506556800,
      "1": 1510617600,
      "2": 1516665600,
      "3": 1525824000,
      "4": 1536105600,
      "5": 1308614400,
      "6": 1562630400,
      "8": 1417392000,
      "9": 1529971200,
      jB: 1161648000,
      AB: 1213660800,
      dB: 1246320000,
      cB: 1264032000,
      F: 1300752000,
      H: 1313452800,
      D: 1317081600,
      G: 1317081600,
      E: 1320710400,
      A: 1324339200,
      B: 1327968000,
      C: 1331596800,
      L: 1335225600,
      q: 1338854400,
      M: 1342483200,
      O: 1346112000,
      I: 1349740800,
      J: 1353628800,
      P: 1357603200,
      Q: 1361232000,
      R: 1364860800,
      S: 1368489600,
      T: 1372118400,
      U: 1375747200,
      V: 1379376000,
      W: 1386633600,
      X: 1391472000,
      Y: 1395100800,
      Z: 1398729600,
      a: 1402358400,
      b: 1405987200,
      c: 1409616000,
      d: 1413244800,
      f: 1421107200,
      g: 1424736000,
      h: 1428278400,
      i: 1431475200,
      j: 1435881600,
      k: 1439251200,
      l: 1442880000,
      m: 1446508800,
      n: 1450137600,
      o: 1453852800,
      p: 1457395200,
      N: 1461628800,
      r: 1465257600,
      s: 1470096000,
      t: 1474329600,
      u: 1479168000,
      v: 1485216000,
      w: 1488844800,
      x: 1492560000,
      y: 1497312000,
      z: 1502150400,
      LB: 1520985600,
      BB: 1540252800,
      CB: 1544486400,
      DB: 1548720000,
      EB: 1552953600,
      FB: 1558396800,
      HB: 1567468800,
      IB: 1571788800,
      JB: null,
      KB: null
    }
  },
  D: {
    A: {
      "0": 0.035688,
      "1": 0.066915,
      "2": 0.040149,
      "3": 0.035688,
      "4": 0.035688,
      "5": 0.004879,
      "6": 0.066915,
      "8": 0.008922,
      "9": 0.298887,
      F: 0.004706,
      H: 0.004879,
      D: 0.005591,
      G: 0.005591,
      E: 0.005591,
      A: 0.004534,
      B: 0.004461,
      C: 0.010424,
      L: 0.004461,
      q: 0.004706,
      M: 0.015087,
      O: 0.004393,
      I: 0.004393,
      J: 0.008652,
      P: 0.004418,
      Q: 0.004393,
      R: 0.004317,
      S: 0.004465,
      T: 0.008786,
      U: 0.008922,
      V: 0.004461,
      W: 0.004461,
      X: 0.004326,
      Y: 0.0047,
      Z: 0.004461,
      a: 0.00893,
      b: 0.013383,
      c: 0.004465,
      d: 0.017844,
      f: 0.008922,
      g: 0.013383,
      h: 0.004461,
      i: 0.022305,
      j: 0.004465,
      k: 0.031227,
      l: 0.022305,
      m: 0.004461,
      n: 0.022305,
      o: 0.004465,
      p: 0.008922,
      N: 0.008922,
      r: 0.013383,
      s: 0.040149,
      t: 0.410412,
      u: 0.008922,
      v: 0.013383,
      w: 0.008922,
      x: 0.022305,
      y: 0.035688,
      z: 0.049071,
      LB: 0.022305,
      BB: 0.347958,
      CB: 0.026766,
      DB: 0.075837,
      EB: 0.049071,
      FB: 0.098142,
      HB: 0.17844,
      IB: 0.147213,
      JB: 0.200745,
      KB: 0.272121,
      bB: 0.285504,
      WB: 0.40149,
      QB: 0.691455,
      K: 18.8879,
      pB: 6.31678,
      RB: 0.04461,
      SB: 0.013383,
      TB: 0,
      UB: 0
    },
    B: "webkit",
    C: ["F", "5", "H", "D", "G", "E", "A", "B", "C", "L", "q", "M", "O", "I", "J", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "8", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "N", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "LB", "3", "9", "4", "BB", "CB", "DB", "EB", "FB", "6", "HB", "IB", "JB", "KB", "bB", "WB", "QB", "K", "pB", "RB", "SB", "TB", "UB"],
    E: "Chrome",
    F: {
      "0": 1485302400,
      "1": 1489017600,
      "2": 1492560000,
      "3": 1500940800,
      "4": 1508198400,
      "5": 1274745600,
      "6": 1532390400,
      "8": 1397001600,
      "9": 1504569600,
      F: 1264377600,
      H: 1283385600,
      D: 1287619200,
      G: 1291248000,
      E: 1296777600,
      A: 1299542400,
      B: 1303862400,
      C: 1307404800,
      L: 1312243200,
      q: 1316131200,
      M: 1316131200,
      O: 1319500800,
      I: 1323734400,
      J: 1328659200,
      P: 1332892800,
      Q: 1337040000,
      R: 1340668800,
      S: 1343692800,
      T: 1348531200,
      U: 1352246400,
      V: 1357862400,
      W: 1361404800,
      X: 1364428800,
      Y: 1369094400,
      Z: 1374105600,
      a: 1376956800,
      b: 1384214400,
      c: 1389657600,
      d: 1392940800,
      f: 1400544000,
      g: 1405468800,
      h: 1409011200,
      i: 1412640000,
      j: 1416268800,
      k: 1421798400,
      l: 1425513600,
      m: 1429401600,
      n: 1432080000,
      o: 1437523200,
      p: 1441152000,
      N: 1444780800,
      r: 1449014400,
      s: 1453248000,
      t: 1456963200,
      u: 1460592000,
      v: 1464134400,
      w: 1469059200,
      x: 1472601600,
      y: 1476230400,
      z: 1480550400,
      LB: 1496707200,
      BB: 1512518400,
      CB: 1516752000,
      DB: 1520294400,
      EB: 1523923200,
      FB: 1527552000,
      HB: 1536019200,
      IB: 1539648000,
      JB: 1543968000,
      KB: 1548720000,
      bB: 1552348800,
      WB: 1555977600,
      QB: 1559606400,
      K: 1564444800,
      pB: 1568073600,
      RB: 1571702400,
      SB: null,
      TB: null,
      UB: null
    }
  },
  E: {
    A: {
      "5": 0.004461,
      "7": 1.47659,
      F: 0,
      H: 0.004349,
      D: 0.004465,
      G: 0.031227,
      E: 0.017844,
      A: 0.022305,
      B: 0.04461,
      C: 0.214128,
      L: 0.321192,
      VB: 0,
      OB: 0.008692,
      XB: 0.771753,
      YB: 0.00456,
      ZB: 0.004283,
      aB: 0.035688,
      NB: 0.111525,
      e: 0.218589,
      eB: 0
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "VB", "OB", "F", "5", "XB", "H", "YB", "D", "ZB", "G", "E", "aB", "A", "NB", "B", "e", "C", "7", "L", "eB", "", ""],
    E: "Safari",
    F: {
      "5": 1275868800,
      "7": 1553472000,
      VB: 1205798400,
      OB: 1226534400,
      F: 1244419200,
      XB: 1311120000,
      H: 1343174400,
      YB: 1382400000,
      D: 1382400000,
      ZB: 1410998400,
      G: 1413417600,
      E: 1443657600,
      aB: 1458518400,
      A: 1474329600,
      NB: 1490572800,
      B: 1505779200,
      e: 1522281600,
      C: 1537142400,
      L: 1568851200,
      eB: null
    }
  },
  F: {
    A: {
      "0": 0.004461,
      "1": 0.008922,
      "2": 0.008922,
      "3": 0.008922,
      "4": 0.120447,
      "7": 0.008922,
      "8": 0.009758,
      E: 0.0082,
      B: 0.016581,
      C: 0.004317,
      M: 0.00685,
      O: 0.00685,
      I: 0.00685,
      J: 0.005014,
      P: 0.006015,
      Q: 0.004879,
      R: 0.006597,
      S: 0.006597,
      T: 0.013434,
      U: 0.006702,
      V: 0.006015,
      W: 0.005595,
      X: 0.004393,
      Y: 0.008652,
      Z: 0.004879,
      a: 0.004879,
      b: 0.004461,
      c: 0.005152,
      d: 0.005014,
      f: 0.004879,
      g: 0.013383,
      h: 0.004283,
      i: 0.004367,
      j: 0.004534,
      k: 0.004367,
      l: 0.004227,
      m: 0.004418,
      n: 0.008922,
      o: 0.004227,
      p: 0.004725,
      N: 0.004417,
      r: 0.008942,
      s: 0.004707,
      t: 0.004827,
      u: 0.004707,
      v: 0.004707,
      w: 0.004326,
      x: 0.008922,
      y: 0.014349,
      z: 0.004725,
      fB: 0.00685,
      gB: 0,
      hB: 0.008392,
      iB: 0.004706,
      e: 0.006229,
      MB: 0.004879,
      kB: 0.008786
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "fB", "gB", "hB", "iB", "B", "e", "MB", "kB", "C", "7", "M", "O", "I", "J", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "8", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "N", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "", "", ""],
    E: "Opera",
    F: {
      "0": 1537833600,
      "1": 1543363200,
      "2": 1548201600,
      "3": 1554768000,
      "4": 1561593600,
      "7": 1352073600,
      "8": 1449100800,
      E: 1150761600,
      fB: 1223424000,
      gB: 1251763200,
      hB: 1267488000,
      iB: 1277942400,
      B: 1292457600,
      e: 1302566400,
      MB: 1309219200,
      kB: 1323129600,
      C: 1323129600,
      M: 1372723200,
      O: 1377561600,
      I: 1381104000,
      J: 1386288000,
      P: 1390867200,
      Q: 1393891200,
      R: 1399334400,
      S: 1401753600,
      T: 1405987200,
      U: 1409616000,
      V: 1413331200,
      W: 1417132800,
      X: 1422316800,
      Y: 1425945600,
      Z: 1430179200,
      a: 1433808000,
      b: 1438646400,
      c: 1442448000,
      d: 1445904000,
      f: 1454371200,
      g: 1457308800,
      h: 1462320000,
      i: 1465344000,
      j: 1470096000,
      k: 1474329600,
      l: 1477267200,
      m: 1481587200,
      n: 1486425600,
      o: 1490054400,
      p: 1494374400,
      N: 1498003200,
      r: 1502236800,
      s: 1506470400,
      t: 1510099200,
      u: 1515024000,
      v: 1517961600,
      w: 1521676800,
      x: 1525910400,
      y: 1530144000,
      z: 1534982400
    },
    D: {
      "7": "o",
      E: "o",
      B: "o",
      C: "o",
      fB: "o",
      gB: "o",
      hB: "o",
      iB: "o",
      e: "o",
      MB: "o",
      kB: "o"
    }
  },
  G: {
    A: {
      G: 0,
      OB: 0.0045567,
      lB: 0.00227835,
      GB: 0,
      nB: 0.00797423,
      oB: 0,
      PB: 0.00911341,
      qB: 0.0170876,
      rB: 0.019366,
      sB: 0.140119,
      tB: 0.0672114,
      uB: 0.169737,
      vB: 0.184546,
      wB: 0.333779,
      xB: 0.560475,
      yB: 9.06898,
      zB: 0.797423
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OB", "lB", "GB", "nB", "oB", "PB", "G", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "", "", ""],
    E: "iOS Safari",
    F: {
      OB: 1270252800,
      lB: 1283904000,
      GB: 1299628800,
      nB: 1331078400,
      oB: 1359331200,
      PB: 1394409600,
      G: 1410912000,
      qB: 1413763200,
      rB: 1442361600,
      sB: 1458518400,
      tB: 1473724800,
      uB: 1490572800,
      vB: 1505779200,
      wB: 1522281600,
      xB: 1537142400,
      yB: 1553472000,
      zB: 1568851200
    }
  },
  H: {
    A: {
      "0B": 1.42636
    },
    B: "o",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0B", "", "", ""],
    E: "Opera Mini",
    F: {
      "0B": 1426464000
    }
  },
  I: {
    A: {
      AB: 0.00223765,
      F: 0.0124669,
      K: 0,
      "1B": 0,
      "2B": 0.0035163,
      "3B": 0.00191798,
      "4B": 0.0284501,
      GB: 0.168143,
      "5B": 0,
      "6B": 0.10453
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "1B", "2B", "3B", "AB", "F", "4B", "GB", "5B", "6B", "K", "", "", ""],
    E: "Android Browser",
    F: {
      "1B": 1256515200,
      "2B": 1274313600,
      "3B": 1291593600,
      AB: 1298332800,
      F: 1318896000,
      "4B": 1341792000,
      GB: 1374624000,
      "5B": 1386547200,
      "6B": 1401667200,
      K: 1566777600
    }
  },
  J: {
    A: {
      D: 0,
      A: 0.011078
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""],
    E: "Blackberry Browser",
    F: {
      D: 1325376000,
      A: 1359504000
    }
  },
  K: {
    A: {
      "7": 0,
      A: 0,
      B: 0,
      C: 0,
      N: 0.0111391,
      e: 0,
      MB: 0
    },
    B: "o",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "e", "MB", "C", "7", "N", "", "", ""],
    E: "Opera Mobile",
    F: {
      "7": 1349740800,
      A: 1287100800,
      B: 1300752000,
      e: 1314835200,
      MB: 1318291200,
      C: 1330300800,
      N: 1474588800
    },
    D: {
      N: "webkit"
    }
  },
  L: {
    A: {
      K: 35.6387
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "K", "", "", ""],
    E: "Chrome for Android",
    F: {
      K: 1564531200
    }
  },
  M: {
    A: {
      "6": 0.193865
    },
    B: "moz",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "6", "", "", ""],
    E: "Firefox for Android",
    F: {
      "6": 1567468800
    }
  },
  N: {
    A: {
      A: 0.0115934,
      B: 0.066468
    },
    B: "ms",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
    E: "IE Mobile",
    F: {
      A: 1340150400,
      B: 1353456000
    }
  },
  O: {
    A: {
      "7B": 3.19046
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7B", "", "", ""],
    E: "UC Browser for Android",
    F: {
      "7B": 1471392000
    },
    D: {
      "7B": "webkit"
    }
  },
  P: {
    A: {
      F: 0.460988,
      "8B": 0.031431,
      "9B": 0.041908,
      AC: 0.157155,
      BC: 0.073339,
      CC: 1.65537,
      NB: 1.15247
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "8B", "9B", "AC", "BC", "CC", "NB", "", "", ""],
    E: "Samsung Internet",
    F: {
      F: 1461024000,
      "8B": 1481846400,
      "9B": 1509408000,
      AC: 1528329600,
      BC: 1546128000,
      CC: 1554163200,
      NB: 1567900800
    }
  },
  Q: {
    A: {
      DC: 0.238177
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "DC", "", "", ""],
    E: "QQ Browser",
    F: {
      DC: 1483228800
    }
  },
  R: {
    A: {
      EC: 0
    },
    B: "webkit",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "", ""],
    E: "Baidu Browser",
    F: {
      EC: 1491004800
    }
  },
  S: {
    A: {
      FC: 0.210482
    },
    B: "moz",
    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "FC", "", "", ""],
    E: "KaiOS Browser",
    F: {
      FC: 1527811200
    }
  }
};

},{}],291:[function(require,module,exports){
"use strict";

module.exports = {
  "0": "56",
  "1": "57",
  "2": "58",
  "3": "60",
  "4": "62",
  "5": "5",
  "6": "68",
  "7": "12.1",
  "8": "34",
  "9": "61",
  A: "10",
  B: "11",
  C: "12",
  D: "7",
  E: "9",
  F: "4",
  G: "8",
  H: "6",
  I: "17",
  J: "18",
  K: "76",
  L: "13",
  M: "15",
  N: "46",
  O: "16",
  P: "19",
  Q: "20",
  R: "21",
  S: "22",
  T: "23",
  U: "24",
  V: "25",
  W: "26",
  X: "27",
  Y: "28",
  Z: "29",
  a: "30",
  b: "31",
  c: "32",
  d: "33",
  e: "11.1",
  f: "35",
  g: "36",
  h: "37",
  i: "38",
  j: "39",
  k: "40",
  l: "41",
  m: "42",
  n: "43",
  o: "44",
  p: "45",
  q: "14",
  r: "47",
  s: "48",
  t: "49",
  u: "50",
  v: "51",
  w: "52",
  x: "53",
  y: "54",
  z: "55",
  AB: "3",
  BB: "63",
  CB: "64",
  DB: "65",
  EB: "66",
  FB: "67",
  GB: "4.2-4.3",
  HB: "69",
  IB: "70",
  JB: "71",
  KB: "72",
  LB: "59",
  MB: "11.5",
  NB: "10.1",
  OB: "3.2",
  PB: "7.0-7.1",
  QB: "75",
  RB: "78",
  SB: "79",
  TB: "80",
  UB: "81",
  VB: "3.1",
  WB: "74",
  XB: "5.1",
  YB: "6.1",
  ZB: "7.1",
  aB: "9.1",
  bB: "73",
  cB: "3.6",
  dB: "3.5",
  eB: "TP",
  fB: "9.5-9.6",
  gB: "10.0-10.1",
  hB: "10.5",
  iB: "10.6",
  jB: "2",
  kB: "11.6",
  lB: "4.0-4.1",
  mB: "5.5",
  nB: "5.0-5.1",
  oB: "6.0-6.1",
  pB: "77",
  qB: "8.1-8.4",
  rB: "9.0-9.2",
  sB: "9.3",
  tB: "10.0-10.2",
  uB: "10.3",
  vB: "11.0-11.2",
  wB: "11.3-11.4",
  xB: "12.0-12.1",
  yB: "12.2-12.4",
  zB: "13.0-13.1",
  "0B": "all",
  "1B": "2.1",
  "2B": "2.2",
  "3B": "2.3",
  "4B": "4.1",
  "5B": "4.4",
  "6B": "4.4.3-4.4.4",
  "7B": "12.12",
  "8B": "5.0-5.4",
  "9B": "6.2-6.4",
  AC: "7.2-7.4",
  BC: "8.2",
  CC: "9.2",
  DC: "1.2",
  EC: "7.12",
  FC: "2.5"
};

},{}],292:[function(require,module,exports){
"use strict";

module.exports = {
  A: "ie",
  B: "edge",
  C: "firefox",
  D: "chrome",
  E: "safari",
  F: "opera",
  G: "ios_saf",
  H: "op_mini",
  I: "android",
  J: "bb",
  K: "op_mob",
  L: "and_chr",
  M: "and_ff",
  N: "ie_mob",
  O: "and_uc",
  P: "samsung",
  Q: "and_qq",
  R: "baidu",
  S: "kaios"
};

},{}],293:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.agents = undefined;

var _browsers = require('./browsers');

var _browserVersions = require('./browserVersions');

var agentsData = require('../../data/agents');

function unpackBrowserVersions(versionsData) {
  return Object.keys(versionsData).reduce(function (usage, version) {
    usage[_browserVersions.browserVersions[version]] = versionsData[version];
    return usage;
  }, {});
}

var agents = exports.agents = Object.keys(agentsData).reduce(function (map, key) {
  var versionsData = agentsData[key];
  map[_browsers.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
    if (entry === 'A') {
      data.usage_global = unpackBrowserVersions(versionsData[entry]);
    } else if (entry === 'C') {
      data.versions = versionsData[entry].reduce(function (list, version) {
        if (version === '') {
          list.push(null);
        } else {
          list.push(_browserVersions.browserVersions[version]);
        }

        return list;
      }, []);
    } else if (entry === 'D') {
      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
    } else if (entry === 'E') {
      data.browser = versionsData[entry];
    } else if (entry === 'F') {
      data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
        map[_browserVersions.browserVersions[key]] = versionsData[entry][key];
        return map;
      }, {});
    } else {
      // entry is B
      data.prefix = versionsData[entry];
    }

    return data;
  }, {});
  return map;
}, {});

},{"../../data/agents":290,"./browserVersions":294,"./browsers":295}],294:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browserVersions = exports.browserVersions = require('../../data/browserVersions');

},{"../../data/browserVersions":291}],295:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var browsers = exports.browsers = require('../../data/browsers');

},{"../../data/browsers":292}],296:[function(require,module,exports){
(function (process){
'use strict';

var escapeStringRegexp = require('escape-string-regexp');

var ansiStyles = require('ansi-styles');

var stdoutColor = require('supports-color').stdout;

var template = require('./templates.js');

var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm'); // `supportsColor.level`  `ansiStyles.color[name]` mapping

var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // `color-convert` models to exclude from the Chalk API due to conflicts and such

var skipModels = new Set(['gray']);
var styles = Object.create(null);

function applyOptions(obj, options) {
  options = options || {}; // Detect level if not set manually

  var scLevel = stdoutColor ? stdoutColor.level : 0;
  obj.level = options.level === undefined ? scLevel : options.level;
  obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
  // We check for this.template here since calling `chalk.constructor()`
  // by itself will have a `this` of a previously constructed chalk object
  if (!this || !(this instanceof Chalk) || this.template) {
    var chalk = {};
    applyOptions(chalk, options);

    chalk.template = function () {
      var args = [].slice.call(arguments);
      return chalkTag.apply(null, [chalk.template].concat(args));
    };

    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = Chalk;
    return chalk.template;
  }

  applyOptions(this, options);
} // Use bright blue on Windows as the normal blue color is illegible


if (isSimpleWindowsTerm) {
  ansiStyles.blue.open = "\x1B[94m";
}

var _loop = function _loop() {
  var key = _Object$keys[_i];
  ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
  styles[key] = {
    get: function get() {
      var codes = ansiStyles[key];
      return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
    }
  };
};

for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
  _loop();
}

styles.visible = {
  get: function get() {
    return build.call(this, this._styles || [], true, 'visible');
  }
};
ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

var _loop2 = function _loop2() {
  var model = _Object$keys2[_i2];

  if (skipModels.has(model)) {
    return "continue";
  }

  styles[model] = {
    get: function get() {
      var level = this.level;
      return function () {
        var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
        var codes = {
          open: open,
          close: ansiStyles.color.close,
          closeRe: ansiStyles.color.closeRe
        };
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
      };
    }
  };
};

for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
  var _ret = _loop2();

  if (_ret === "continue") continue;
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

var _loop3 = function _loop3() {
  var model = _Object$keys3[_i3];

  if (skipModels.has(model)) {
    return "continue";
  }

  var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get: function get() {
      var level = this.level;
      return function () {
        var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
        var codes = {
          open: open,
          close: ansiStyles.bgColor.close,
          closeRe: ansiStyles.bgColor.closeRe
        };
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
      };
    }
  };
};

for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
  var _ret2 = _loop3();

  if (_ret2 === "continue") continue;
}

var proto = Object.defineProperties(function () {}, styles);

function build(_styles, _empty, key) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };

  builder._styles = _styles;
  builder._empty = _empty;
  var self = this;
  Object.defineProperty(builder, 'level', {
    enumerable: true,
    get: function get() {
      return self.level;
    },
    set: function set(level) {
      self.level = level;
    }
  });
  Object.defineProperty(builder, 'enabled', {
    enumerable: true,
    get: function get() {
      return self.enabled;
    },
    set: function set(enabled) {
      self.enabled = enabled;
    }
  }); // See below for fix regarding invisible grey/dim combination on Windows

  builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // `__proto__` is used because we must return a function, but there is
  // no way to create a function with a different prototype

  builder.__proto__ = proto; // eslint-disable-line no-proto

  return builder;
}

function applyStyle() {
  // Support varags, but simply cast to string in case there's only one arg
  var args = arguments;
  var argsLen = args.length;
  var str = String(arguments[0]);

  if (argsLen === 0) {
    return '';
  }

  if (argsLen > 1) {
    // Don't slice `arguments`, it prevents V8 optimizations
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!this.enabled || this.level <= 0 || !str) {
    return this._empty ? '' : str;
  } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
  // see https://github.com/chalk/chalk/issues/58
  // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.


  var originalDim = ansiStyles.dim.open;

  if (isSimpleWindowsTerm && this.hasGrey) {
    ansiStyles.dim.open = '';
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = this._styles.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var code = _step.value;
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen
      // after next line to fix a bleed issue on macOS
      // https://github.com/chalk/chalk/pull/92

      str = str.replace(/\r?\n/g, "".concat(code.close, "$&").concat(code.open));
    } // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  ansiStyles.dim.open = originalDim;
  return str;
}

function chalkTag(chalk, strings) {
  if (!Array.isArray(strings)) {
    // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return [].slice.call(arguments, 1).join(' ');
  }

  var args = [].slice.call(arguments, 2);
  var parts = [strings.raw[0]];

  for (var i = 1; i < strings.length; i++) {
    parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
    parts.push(String(strings.raw[i]));
  }

  return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);
module.exports = Chalk(); // eslint-disable-line new-cap

module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript

}).call(this,require('_process'))
},{"./templates.js":297,"_process":1054,"ansi-styles":277,"escape-string-regexp":832,"supports-color":1082}],297:[function(require,module,exports){
'use strict';

var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

function unescape(c) {
  if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }

  return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
  var results = [];
  var chunks = args.trim().split(/\s*,\s*/g);
  var matches;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunk = _step.value;

      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
          return escape ? unescape(escape) : chr;
        }));
      } else {
        throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return results;
}

function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  var results = [];
  var matches;

  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    var name = matches[1];

    if (matches[2]) {
      var args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }

  return results;
}

function buildStyle(chalk, styles) {
  var enabled = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = styles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var layer = _step2.value;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = layer.styles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var style = _step3.value;
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var current = chalk;

  for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
    var styleName = _Object$keys[_i];

    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error("Unknown Chalk style: ".concat(styleName));
      }

      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName]);
      } else {
        current = current[styleName];
      }
    }
  }

  return current;
}

module.exports = function (chalk, tmp) {
  var styles = [];
  var chunks = [];
  var chunk = []; // eslint-disable-next-line max-params

  tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
    if (escapeChar) {
      chunk.push(unescape(escapeChar));
    } else if (style) {
      var str = chunk.join('');
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
      styles.push({
        inverse: inverse,
        styles: parseStyle(style)
      });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error('Found extraneous } in Chalk template literal');
      }

      chunks.push(buildStyle(chalk, styles)(chunk.join('')));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(''));

  if (styles.length > 0) {
    var errMsg = "Chalk template literal is missing ".concat(styles.length, " closing bracket").concat(styles.length === 1 ? '' : 's', " (`}`)");
    throw new Error(errMsg);
  }

  return chunks.join('');
};

},{}],298:[function(require,module,exports){
"use strict";

/* MIT license */
var cssKeywords = require('color-name'); // NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)


var reverseKeywords = {};

for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}

var convert = module.exports = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
}; // hide .channels and .labels properties

for (var model in convert) {
  if (convert.hasOwnProperty(model)) {
    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }

    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }

    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }

    var channels = convert[model].channels;
    var labels = convert[model].labels;
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
      value: labels
    });
  }
}

convert.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h;
  var s;
  var l;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff = v - Math.min(r, g, b);

  var diffc = function diffc(c) {
    return (v - c) / 6 / diff + 1 / 2;
  };

  if (diff === 0) {
    h = s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }

    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }

  return [h * 360, s * 100, v * 100];
};

convert.rgb.hwb = function (rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert.rgb.hsl(rgb)[0];
  var w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */


function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}

convert.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb];

  if (reversed) {
    return reversed;
  }

  var currentClosestDistance = Infinity;
  var currentClosestKeyword;

  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword]; // Compute comparative distance

      var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }

  return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
  return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255; // assume sRGB

  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
  var xyz = convert.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;

  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  t1 = 2 * l - t2;
  rgb = [0, 0, 0];

  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    }

    if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return rgb;
};

convert.hsl.hsv = function (hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
};

convert.hsv.hsl = function (hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


convert.hwb.rgb = function (hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i;
  var v;
  var f;
  var n; // wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }

  n = wh + f * (v - wh); // linear interpolation

  var r;
  var g;
  var b;

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }

  return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r;
  var g;
  var b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};

convert.lab.xyz = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};

convert.lab.lch = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c;
  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};

convert.lch.lab = function (lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var a;
  var b;
  var hr;
  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

  value = Math.round(value / 50);

  if (value === 0) {
    return 30;
  }

  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

  if (value === 2) {
    ansi += 60;
  }

  return ansi;
};

convert.hsv.ansi16 = function (args) {
  // optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2]; // we use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.

  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }

    if (r > 248) {
      return 231;
    }

    return Math.round((r - 8) / 247 * 24) + 232;
  }

  var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};

convert.ansi16.rgb = function (args) {
  var color = args % 10; // handle greyscale

  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }

    color = color / 10.5 * 255;
    return [color, color, color];
  }

  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = (color >> 1 & 1) * mult * 255;
  var b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};

convert.ansi256.rgb = function (args) {
  // handle greyscale
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }

  args -= 16;
  var rem;
  var r = Math.floor(args / 36) / 5 * 255;
  var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r, g, b];
};

convert.rgb.hex = function (args) {
  var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

  if (!match) {
    return [0, 0, 0];
  }

  var colorString = match[0];

  if (match[0].length === 3) {
    colorString = colorString.split('').map(function (char) {
      return char + char;
    }).join('');
  }

  var integer = parseInt(colorString, 16);
  var r = integer >> 16 & 0xFF;
  var g = integer >> 8 & 0xFF;
  var b = integer & 0xFF;
  return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max = Math.max(Math.max(r, g), b);
  var min = Math.min(Math.min(r, g), b);
  var chroma = max - min;
  var grayscale;
  var hue;

  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }

  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma + 4;
  }

  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;

  if (l < 0.5) {
    c = 2.0 * s * l;
  } else {
    c = 2.0 * s * (1.0 - l);
  }

  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }

  return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;

  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }

  return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;

  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }

  var pure = [0, 0, 0];
  var hi = h % 1 * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;

    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;

    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;

    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;

    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;

    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }

  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  var f = 0;

  if (v > 0.0) {
    f = c / v;
  }

  return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1.0 - c) + 0.5 * c;
  var s = 0;

  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }

  return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;

  if (c < 1) {
    g = (v - c) / (1 - c);
  }

  return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};

convert.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};

convert.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
  return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
  var val = Math.round(gray[0] / 100 * 255) & 0xFF;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};

},{"color-name":301}],299:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var conversions = require('./conversions');

var route = require('./route');

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    return fn(args);
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    var result = fn(args); // we're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (_typeof(result) === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
module.exports = convert;

},{"./conversions":298,"./route":300}],300:[function(require,module,exports){
"use strict";

var conversions = require('./conversions');
/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/


function buildGraph() {
  var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel]; // unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

module.exports = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);

  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];

    if (node.parent === null) {
      // no possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};

},{"./conversions":298}],301:[function(require,module,exports){
'use strict';

module.exports = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

},{}],302:[function(require,module,exports){
'use strict';

var fs = require('fs');

var path = require('path');

var SafeBuffer = require('safe-buffer');

Object.defineProperty(exports, 'commentRegex', {
  get: function getCommentRegex() {
    return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
  }
});
Object.defineProperty(exports, 'mapFileCommentRegex', {
  get: function getMapFileCommentRegex() {
    // Matches sourceMappingURL in either // or /* comment styles.
    return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
  }
});

function decodeBase64(base64) {
  return SafeBuffer.Buffer.from(base64, 'base64').toString();
}

function stripComment(sm) {
  return sm.split(',').pop();
}

function readFromFileMap(sm, dir) {
  // NOTE: this will only work on the server since it attempts to read the map file
  var r = exports.mapFileCommentRegex.exec(sm); // for some odd reason //# .. captures in 1 and /* .. */ in 2

  var filename = r[1] || r[2];
  var filepath = path.resolve(dir, filename);

  try {
    return fs.readFileSync(filepath, 'utf8');
  } catch (e) {
    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
  }
}

function Converter(sm, opts) {
  opts = opts || {};
  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
  if (opts.hasComment) sm = stripComment(sm);
  if (opts.isEncoded) sm = decodeBase64(sm);
  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
  this.sourcemap = sm;
}

Converter.prototype.toJSON = function (space) {
  return JSON.stringify(this.sourcemap, null, space);
};

Converter.prototype.toBase64 = function () {
  var json = this.toJSON();
  return SafeBuffer.Buffer.from(json, 'utf8').toString('base64');
};

Converter.prototype.toComment = function (options) {
  var base64 = this.toBase64();
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
}; // returns copy instead of original


Converter.prototype.toObject = function () {
  return JSON.parse(this.toJSON());
};

Converter.prototype.addProperty = function (key, value) {
  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
  return this.setProperty(key, value);
};

Converter.prototype.setProperty = function (key, value) {
  this.sourcemap[key] = value;
  return this;
};

Converter.prototype.getProperty = function (key) {
  return this.sourcemap[key];
};

exports.fromObject = function (obj) {
  return new Converter(obj);
};

exports.fromJSON = function (json) {
  return new Converter(json, {
    isJSON: true
  });
};

exports.fromBase64 = function (base64) {
  return new Converter(base64, {
    isEncoded: true
  });
};

exports.fromComment = function (comment) {
  comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
  return new Converter(comment, {
    isEncoded: true,
    hasComment: true
  });
};

exports.fromMapFileComment = function (comment, dir) {
  return new Converter(comment, {
    commentFileDir: dir,
    isFileComment: true,
    isJSON: true
  });
}; // Finds last sourcemap comment in file or returns null if none was found


exports.fromSource = function (content) {
  var m = content.match(exports.commentRegex);
  return m ? exports.fromComment(m.pop()) : null;
}; // Finds last sourcemap comment in file or returns null if none was found


exports.fromMapFileSource = function (content, dir) {
  var m = content.match(exports.mapFileCommentRegex);
  return m ? exports.fromMapFileComment(m.pop(), dir) : null;
};

exports.removeComments = function (src) {
  return src.replace(exports.commentRegex, '');
};

exports.removeMapFileComments = function (src) {
  return src.replace(exports.mapFileCommentRegex, '');
};

exports.generateMapFileComment = function (file, options) {
  var data = 'sourceMappingURL=' + file;
  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
};

},{"fs":285,"path":1052,"safe-buffer":1069}],303:[function(require,module,exports){
module.exports={
  "es.symbol": {
    "edge": "15",
    "chrome": "49",
    "firefox": "51",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.symbol.description": {
    "chrome": "70",
    "firefox": "63",
    "safari": "12.1",
    "edge": "74",
    "opera": "57",
    "node": "11.0",
    "samsung": "10.2",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.symbol.async-iterator": {
    "chrome": "63",
    "firefox": "55",
    "safari": "12.0",
    "edge": "74",
    "opera": "50",
    "node": "10.0",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "12.0"
  },
  "es.symbol.has-instance": {
    "edge": "15",
    "chrome": "50",
    "firefox": "49",
    "safari": "10.0",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.symbol.is-concat-spreadable": {
    "edge": "15",
    "chrome": "48",
    "firefox": "48",
    "safari": "10.0",
    "opera": "35",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.symbol.iterator": {
    "edge": "13",
    "chrome": "39",
    "firefox": "36",
    "safari": "9.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.symbol.match": {
    "chrome": "50",
    "firefox": "40",
    "safari": "10.0",
    "edge": "74",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.symbol.match-all": {
    "chrome": "73",
    "firefox": "67",
    "safari": "13",
    "edge": "74",
    "opera": "60",
    "node": "12.0",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.symbol.replace": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10.0",
    "edge": "74",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.symbol.search": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10.0",
    "edge": "74",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.symbol.species": {
    "edge": "13",
    "chrome": "51",
    "firefox": "41",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.symbol.split": {
    "chrome": "50",
    "firefox": "49",
    "safari": "10.0",
    "edge": "74",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.symbol.to-primitive": {
    "edge": "15",
    "chrome": "47",
    "firefox": "44",
    "safari": "10.0",
    "opera": "34",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.36",
    "ios": "10.0"
  },
  "es.symbol.to-string-tag": {
    "edge": "15",
    "chrome": "49",
    "firefox": "51",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.symbol.unscopables": {
    "edge": "13",
    "chrome": "39",
    "firefox": "48",
    "safari": "9.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.concat": {
    "edge": "15",
    "chrome": "51",
    "firefox": "48",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.copy-within": {
    "edge": "13",
    "chrome": "45",
    "firefox": "48",
    "safari": "9.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "9.0"
  },
  "es.array.every": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.fill": {
    "edge": "13",
    "chrome": "45",
    "firefox": "4",
    "safari": "9.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "9.0"
  },
  "es.array.filter": {
    "edge": "13",
    "chrome": "51",
    "firefox": "48",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.find": {
    "edge": "13",
    "chrome": "45",
    "firefox": "48",
    "safari": "9.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "9.0"
  },
  "es.array.find-index": {
    "edge": "13",
    "chrome": "45",
    "firefox": "48",
    "safari": "9.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "9.0"
  },
  "es.array.flat": {
    "chrome": "69",
    "firefox": "62",
    "safari": "12.0",
    "edge": "74",
    "opera": "56",
    "node": "11.0",
    "samsung": "10.2",
    "electron": "4.0",
    "ios": "12.0"
  },
  "es.array.flat-map": {
    "chrome": "69",
    "firefox": "62",
    "safari": "12.0",
    "edge": "74",
    "opera": "56",
    "node": "11.0",
    "samsung": "10.2",
    "electron": "4.0",
    "ios": "12.0"
  },
  "es.array.for-each": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.from": {
    "edge": "15",
    "chrome": "51",
    "firefox": "53",
    "safari": "9.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "9.0"
  },
  "es.array.includes": {
    "edge": "14",
    "chrome": "53",
    "firefox": "48",
    "safari": "10.0",
    "opera": "40",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "10.0"
  },
  "es.array.index-of": {
    "ie": "9",
    "chrome": "51",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "9.0"
  },
  "es.array.is-array": {
    "ie": "9",
    "chrome": "5",
    "opera": "10.50",
    "android": "4.0",
    "firefox": "4",
    "safari": "4.0",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "6.0",
    "phantom": "1.9"
  },
  "es.array.iterator": {
    "edge": "15",
    "chrome": "66",
    "firefox": "60",
    "safari": "10.0",
    "opera": "53",
    "node": "10.0",
    "samsung": "9.2",
    "electron": "3.0",
    "ios": "10.0"
  },
  "es.array.join": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.last-index-of": {
    "ie": "9",
    "chrome": "51",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "9.0"
  },
  "es.array.map": {
    "edge": "13",
    "chrome": "51",
    "firefox": "48",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.of": {
    "edge": "13",
    "chrome": "45",
    "firefox": "25",
    "safari": "9.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "9.0"
  },
  "es.array.reduce": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.reduce-right": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.reverse": {
    "ie": "8",
    "chrome": "26",
    "firefox": "4",
    "safari": "12.0.2",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "13.0"
  },
  "es.array.slice": {
    "edge": "13",
    "chrome": "51",
    "firefox": "48",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.some": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array.sort": {
    "ie": "9",
    "chrome": "63",
    "firefox": "4",
    "safari": "12.0",
    "edge": "12",
    "opera": "50",
    "node": "10.0",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "12.0"
  },
  "es.array.species": {
    "edge": "13",
    "chrome": "51",
    "firefox": "48",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.splice": {
    "edge": "13",
    "chrome": "51",
    "firefox": "49",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.array.unscopables.flat": {
    "firefox": "67",
    "chrome": "73",
    "safari": "13",
    "edge": "74",
    "opera": "60",
    "node": "12.0",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.array.unscopables.flat-map": {
    "firefox": "67",
    "chrome": "73",
    "safari": "13",
    "edge": "74",
    "opera": "60",
    "node": "12.0",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.array-buffer.constructor": {
    "edge": "14",
    "chrome": "26",
    "firefox": "44",
    "safari": "12.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "12.0"
  },
  "es.array-buffer.is-view": {
    "ie": "11",
    "chrome": "32",
    "firefox": "29",
    "safari": "8.0",
    "edge": "12",
    "opera": "19",
    "node": "4.0",
    "samsung": "2.1",
    "android": "4.4.3",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.array-buffer.slice": {
    "ie": "11",
    "chrome": "31",
    "firefox": "46",
    "safari": "12.1",
    "edge": "12",
    "opera": "18",
    "node": "4.0",
    "samsung": "2.1",
    "android": "4.4.3",
    "electron": "0.20",
    "ios": "13.0"
  },
  "es.data-view": {
    "ie": "10",
    "chrome": "26",
    "firefox": "15",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.date.now": {
    "ie": "9",
    "chrome": "5",
    "opera": "10.50",
    "android": "4.0",
    "firefox": "2",
    "safari": "4.0",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "6.0",
    "phantom": "1.9"
  },
  "es.date.to-iso-string": {
    "ie": "9",
    "chrome": "26",
    "firefox": "7",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.date.to-json": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "10.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "10.0"
  },
  "es.date.to-primitive": {
    "edge": "15",
    "chrome": "47",
    "firefox": "44",
    "safari": "10.0",
    "opera": "34",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.36",
    "ios": "10.0"
  },
  "es.date.to-string": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.function.bind": {
    "ie": "9",
    "chrome": "7",
    "opera": "12",
    "android": "4.0",
    "firefox": "4",
    "safari": "5.1",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "6.0",
    "phantom": "2.0"
  },
  "es.function.has-instance": {
    "edge": "15",
    "chrome": "51",
    "firefox": "50",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.function.name": {
    "edge": "14",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.global-this": {
    "chrome": "71",
    "firefox": "65",
    "safari": "12.1",
    "edge": "74",
    "opera": "58",
    "node": "12.0",
    "samsung": "10.2",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.json.stringify": {
    "chrome": "72",
    "firefox": "64",
    "safari": "12.1",
    "edge": "74",
    "opera": "59",
    "node": "12.0",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.json.to-string-tag": {
    "edge": "15",
    "chrome": "50",
    "firefox": "51",
    "safari": "10.0",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.map": {
    "edge": "15",
    "chrome": "51",
    "firefox": "53",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.math.acosh": {
    "edge": "13",
    "chrome": "54",
    "firefox": "25",
    "safari": "8.0",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "9.0"
  },
  "es.math.asinh": {
    "edge": "13",
    "chrome": "38",
    "firefox": "25",
    "safari": "8.0",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.atanh": {
    "edge": "13",
    "chrome": "38",
    "firefox": "25",
    "safari": "8.0",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.cbrt": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.clz32": {
    "edge": "12",
    "chrome": "38",
    "firefox": "31",
    "safari": "9.0",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.cosh": {
    "edge": "13",
    "chrome": "39",
    "firefox": "25",
    "safari": "8.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.expm1": {
    "edge": "13",
    "chrome": "39",
    "firefox": "46",
    "safari": "8.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.fround": {
    "edge": "12",
    "chrome": "38",
    "firefox": "26",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.hypot": {
    "edge": "12",
    "chrome": "78",
    "firefox": "27",
    "safari": "7.1",
    "opera": "65",
    "node": "13.0",
    "electron": "7.0",
    "ios": "8.0"
  },
  "es.math.imul": {
    "edge": "13",
    "chrome": "28",
    "firefox": "20",
    "safari": "9.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.log10": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.log1p": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.log2": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.sign": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "9.0",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.sinh": {
    "edge": "13",
    "chrome": "39",
    "firefox": "25",
    "safari": "8.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.math.tanh": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.math.to-string-tag": {
    "edge": "15",
    "chrome": "50",
    "firefox": "51",
    "safari": "10.0",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.math.trunc": {
    "edge": "12",
    "chrome": "38",
    "firefox": "25",
    "safari": "7.1",
    "opera": "25",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "8.0"
  },
  "es.number.constructor": {
    "edge": "13",
    "chrome": "41",
    "firefox": "46",
    "safari": "9.0",
    "opera": "28",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.number.epsilon": {
    "edge": "12",
    "chrome": "34",
    "firefox": "25",
    "safari": "9.0",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.is-finite": {
    "edge": "12",
    "chrome": "19",
    "android": "4.1",
    "firefox": "16",
    "safari": "9.0",
    "opera": "15",
    "node": "0.12",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.is-integer": {
    "edge": "12",
    "chrome": "34",
    "firefox": "16",
    "safari": "9.0",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.is-nan": {
    "edge": "12",
    "chrome": "19",
    "android": "4.1",
    "firefox": "15",
    "safari": "9.0",
    "opera": "15",
    "node": "0.12",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.is-safe-integer": {
    "edge": "12",
    "chrome": "34",
    "firefox": "32",
    "safari": "9.0",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.max-safe-integer": {
    "edge": "12",
    "chrome": "34",
    "firefox": "31",
    "safari": "9.0",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.min-safe-integer": {
    "edge": "12",
    "chrome": "34",
    "firefox": "31",
    "safari": "9.0",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.parse-float": {
    "edge": "13",
    "chrome": "35",
    "firefox": "39",
    "safari": "11.0",
    "opera": "22",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "11.0"
  },
  "es.number.parse-int": {
    "edge": "13",
    "chrome": "35",
    "firefox": "39",
    "safari": "9.0",
    "opera": "22",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.to-fixed": {
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "74",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.number.to-precision": {
    "ie": "8",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.object.assign": {
    "edge": "13",
    "chrome": "49",
    "firefox": "36",
    "safari": "9.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "9.0"
  },
  "es.object.create": {
    "ie": "9",
    "chrome": "5",
    "opera": "12",
    "android": "4.0",
    "firefox": "4",
    "safari": "4.0",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "6.0",
    "phantom": "1.9"
  },
  "es.object.define-getter": {
    "edge": "16",
    "chrome": "62",
    "firefox": "48",
    "safari": "8.0",
    "opera": "49",
    "node": "8.10",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "9.0"
  },
  "es.object.define-properties": {
    "ie": "9",
    "chrome": "5",
    "opera": "12",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.object.define-property": {
    "ie": "9",
    "chrome": "5",
    "opera": "12",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "node": "0.10",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.object.define-setter": {
    "edge": "16",
    "chrome": "62",
    "firefox": "48",
    "safari": "8.0",
    "opera": "49",
    "node": "8.10",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "9.0"
  },
  "es.object.entries": {
    "edge": "14",
    "chrome": "54",
    "firefox": "47",
    "safari": "10.1",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "10.3"
  },
  "es.object.freeze": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.from-entries": {
    "chrome": "73",
    "firefox": "63",
    "safari": "12.1",
    "edge": "74",
    "opera": "60",
    "node": "12.0",
    "electron": "5.0",
    "ios": "13.0"
  },
  "es.object.get-own-property-descriptor": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.get-own-property-descriptors": {
    "edge": "15",
    "chrome": "54",
    "firefox": "50",
    "safari": "10.0",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "10.0"
  },
  "es.object.get-own-property-names": {
    "edge": "13",
    "chrome": "40",
    "firefox": "34",
    "safari": "9.0",
    "opera": "27",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.object.get-prototype-of": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.is": {
    "edge": "12",
    "chrome": "19",
    "android": "4.1",
    "firefox": "22",
    "safari": "9.0",
    "opera": "15",
    "node": "0.12",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.object.is-extensible": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.is-frozen": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.is-sealed": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.keys": {
    "edge": "13",
    "chrome": "40",
    "firefox": "35",
    "safari": "9.0",
    "opera": "27",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.object.lookup-getter": {
    "edge": "16",
    "chrome": "62",
    "firefox": "48",
    "safari": "8.0",
    "opera": "49",
    "node": "8.10",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "9.0"
  },
  "es.object.lookup-setter": {
    "edge": "16",
    "chrome": "62",
    "firefox": "48",
    "safari": "8.0",
    "opera": "49",
    "node": "8.10",
    "samsung": "8.2",
    "electron": "3.0",
    "ios": "9.0"
  },
  "es.object.prevent-extensions": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.seal": {
    "edge": "13",
    "chrome": "44",
    "firefox": "35",
    "safari": "9.0",
    "opera": "31",
    "node": "4.0",
    "samsung": "4.0",
    "electron": "0.30",
    "ios": "9.0"
  },
  "es.object.set-prototype-of": {
    "ie": "11",
    "chrome": "34",
    "firefox": "31",
    "safari": "9.0",
    "edge": "12",
    "opera": "21",
    "node": "4.0",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.object.to-string": {
    "edge": "15",
    "chrome": "49",
    "firefox": "51",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.object.values": {
    "edge": "14",
    "chrome": "54",
    "firefox": "47",
    "safari": "10.1",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "10.3"
  },
  "es.parse-float": {
    "ie": "8",
    "chrome": "35",
    "firefox": "8",
    "safari": "8.0",
    "edge": "12",
    "opera": "22",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.parse-int": {
    "ie": "9",
    "chrome": "35",
    "firefox": "21",
    "safari": "8.0",
    "edge": "12",
    "opera": "22",
    "node": "4.0",
    "samsung": "3.0",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.promise": {
    "chrome": "67",
    "firefox": "69",
    "safari": "11.0",
    "edge": "74",
    "opera": "54",
    "node": "10.4",
    "samsung": "9.2",
    "electron": "4.0",
    "ios": "11.0"
  },
  "es.promise.all-settled": {
    "chrome": "76",
    "firefox": "71",
    "safari": "13",
    "edge": "76",
    "opera": "63",
    "node": "12.9",
    "electron": "6.0",
    "ios": "13.0"
  },
  "es.promise.finally": {
    "chrome": "67",
    "firefox": "69",
    "safari": "12.0",
    "edge": "74",
    "opera": "54",
    "node": "10.4",
    "samsung": "9.2",
    "electron": "4.0",
    "ios": "12.0"
  },
  "es.reflect.apply": {
    "edge": "15",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.construct": {
    "edge": "15",
    "chrome": "49",
    "firefox": "44",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.define-property": {
    "edge": "13",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.delete-property": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.get": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.get-own-property-descriptor": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.get-prototype-of": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.has": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.is-extensible": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.own-keys": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.prevent-extensions": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.set": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.reflect.set-prototype-of": {
    "edge": "12",
    "chrome": "49",
    "firefox": "42",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.regexp.constructor": {
    "safari": "10.0",
    "chrome": "51",
    "firefox": "49",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.regexp.exec": {
    "ie": "9",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "edge": "12",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.regexp.flags": {
    "chrome": "49",
    "firefox": "37",
    "safari": "9.0",
    "edge": "74",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "9.0"
  },
  "es.regexp.to-string": {
    "chrome": "50",
    "firefox": "46",
    "safari": "10.0",
    "edge": "74",
    "opera": "37",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "1.1",
    "ios": "10.0"
  },
  "es.set": {
    "edge": "15",
    "chrome": "51",
    "firefox": "53",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.code-point-at": {
    "edge": "13",
    "chrome": "41",
    "firefox": "29",
    "safari": "9.0",
    "opera": "28",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.string.ends-with": {
    "chrome": "51",
    "firefox": "40",
    "safari": "10.0",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.from-code-point": {
    "edge": "13",
    "chrome": "41",
    "firefox": "29",
    "safari": "9.0",
    "opera": "28",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.string.includes": {
    "chrome": "51",
    "firefox": "40",
    "safari": "10.0",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.iterator": {
    "edge": "13",
    "chrome": "39",
    "firefox": "36",
    "safari": "9.0",
    "opera": "26",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.match": {
    "chrome": "51",
    "firefox": "49",
    "safari": "10.0",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.match-all": {
    "chrome": "80",
    "edge": "80",
    "opera": "67"
  },
  "es.string.pad-end": {
    "edge": "15",
    "chrome": "57",
    "firefox": "48",
    "safari": "11.0",
    "opera": "44",
    "node": "8.0",
    "samsung": "7.2",
    "electron": "1.7",
    "ios": "11.0"
  },
  "es.string.pad-start": {
    "edge": "15",
    "chrome": "57",
    "firefox": "48",
    "safari": "11.0",
    "opera": "44",
    "node": "8.0",
    "samsung": "7.2",
    "electron": "1.7",
    "ios": "11.0"
  },
  "es.string.raw": {
    "edge": "13",
    "chrome": "41",
    "firefox": "34",
    "safari": "9.0",
    "opera": "28",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.string.repeat": {
    "edge": "13",
    "chrome": "41",
    "firefox": "24",
    "safari": "9.0",
    "opera": "28",
    "node": "4.0",
    "samsung": "3.4",
    "electron": "0.21",
    "ios": "9.0"
  },
  "es.string.replace": {
    "chrome": "64",
    "edge": "74",
    "opera": "51",
    "node": "10.0",
    "samsung": "9.2",
    "electron": "3.0"
  },
  "es.string.search": {
    "safari": "10.0",
    "firefox": "49",
    "chrome": "51",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.split": {
    "safari": "10.0",
    "firefox": "49",
    "chrome": "54",
    "edge": "74",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4",
    "ios": "10.0"
  },
  "es.string.starts-with": {
    "safari": "10.0",
    "chrome": "51",
    "firefox": "40",
    "edge": "74",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.string.trim": {
    "edge": "15",
    "chrome": "59",
    "firefox": "52",
    "safari": "12.1",
    "opera": "46",
    "node": "8.3",
    "samsung": "7.2",
    "electron": "1.8",
    "ios": "13.0"
  },
  "es.string.trim-end": {
    "chrome": "66",
    "firefox": "61",
    "safari": "12.1",
    "edge": "74",
    "opera": "53",
    "node": "10.0",
    "samsung": "9.2",
    "electron": "3.0",
    "ios": "13.0"
  },
  "es.string.trim-start": {
    "chrome": "66",
    "firefox": "61",
    "safari": "12.0",
    "edge": "74",
    "opera": "53",
    "node": "10.0",
    "samsung": "9.2",
    "electron": "3.0",
    "ios": "12.0"
  },
  "es.string.anchor": {
    "edge": "13",
    "chrome": "26",
    "firefox": "17",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.big": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.blink": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.bold": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.fixed": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.fontcolor": {
    "edge": "13",
    "chrome": "26",
    "firefox": "17",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.fontsize": {
    "edge": "13",
    "chrome": "26",
    "firefox": "17",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.italics": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.link": {
    "edge": "13",
    "chrome": "26",
    "firefox": "17",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.small": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.strike": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.sub": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.string.sup": {
    "edge": "13",
    "chrome": "26",
    "firefox": "4",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.typed-array.float32-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.float64-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.int8-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.int16-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.int32-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.uint8-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.uint8-clamped-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.uint16-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.uint32-array": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.copy-within": {
    "edge": "13",
    "chrome": "45",
    "firefox": "34",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.every": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.fill": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.filter": {
    "edge": "13",
    "chrome": "45",
    "firefox": "38",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.find": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.find-index": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.for-each": {
    "edge": "13",
    "chrome": "45",
    "firefox": "38",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.from": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.includes": {
    "edge": "14",
    "chrome": "49",
    "firefox": "43",
    "safari": "10.0",
    "opera": "36",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.37",
    "ios": "10.0"
  },
  "es.typed-array.index-of": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.iterator": {
    "edge": "13",
    "chrome": "47",
    "firefox": "37",
    "safari": "10.0",
    "opera": "34",
    "node": "6.0",
    "samsung": "5.0",
    "electron": "0.36",
    "ios": "10.0"
  },
  "es.typed-array.join": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.last-index-of": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.map": {
    "edge": "13",
    "chrome": "45",
    "firefox": "38",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.of": {
    "edge": "15",
    "chrome": "54",
    "firefox": "55",
    "opera": "41",
    "node": "7.0",
    "samsung": "6.2",
    "electron": "1.4"
  },
  "es.typed-array.reduce": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.reduce-right": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.reverse": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.set": {
    "edge": "13",
    "chrome": "26",
    "firefox": "15",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.typed-array.slice": {
    "edge": "13",
    "chrome": "45",
    "firefox": "38",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.some": {
    "edge": "13",
    "chrome": "45",
    "firefox": "37",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.sort": {
    "edge": "13",
    "chrome": "45",
    "firefox": "46",
    "safari": "10.0",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.subarray": {
    "edge": "13",
    "chrome": "26",
    "firefox": "15",
    "safari": "8.0",
    "opera": "16",
    "node": "0.12",
    "samsung": "2.1",
    "android": "4.4",
    "electron": "0.20",
    "ios": "9.0"
  },
  "es.typed-array.to-locale-string": {
    "chrome": "45",
    "firefox": "51",
    "safari": "10.0",
    "edge": "74",
    "opera": "32",
    "node": "4.0",
    "samsung": "5.0",
    "electron": "0.31",
    "ios": "10.0"
  },
  "es.typed-array.to-string": {
    "edge": "13",
    "chrome": "51",
    "firefox": "51",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.weak-map": {
    "edge": "15",
    "chrome": "51",
    "firefox": "53",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "es.weak-set": {
    "edge": "15",
    "chrome": "51",
    "firefox": "53",
    "safari": "10.0",
    "opera": "38",
    "node": "6.5",
    "samsung": "5.0",
    "electron": "1.2",
    "ios": "10.0"
  },
  "esnext.aggregate-error": {},
  "esnext.array.is-template-object": {},
  "esnext.array.last-index": {},
  "esnext.array.last-item": {},
  "esnext.async-iterator.constructor": {},
  "esnext.async-iterator.as-indexed-pairs": {},
  "esnext.async-iterator.drop": {},
  "esnext.async-iterator.every": {},
  "esnext.async-iterator.filter": {},
  "esnext.async-iterator.find": {},
  "esnext.async-iterator.flat-map": {},
  "esnext.async-iterator.for-each": {},
  "esnext.async-iterator.from": {},
  "esnext.async-iterator.map": {},
  "esnext.async-iterator.reduce": {},
  "esnext.async-iterator.some": {},
  "esnext.async-iterator.take": {},
  "esnext.async-iterator.to-array": {},
  "esnext.composite-key": {},
  "esnext.composite-symbol": {},
  "esnext.global-this": {
    "chrome": "71",
    "firefox": "65",
    "safari": "12.1",
    "edge": "74",
    "opera": "58",
    "node": "12.0",
    "samsung": "10.2",
    "electron": "5.0",
    "ios": "13.0"
  },
  "esnext.iterator.constructor": {},
  "esnext.iterator.as-indexed-pairs": {},
  "esnext.iterator.drop": {},
  "esnext.iterator.every": {},
  "esnext.iterator.filter": {},
  "esnext.iterator.find": {},
  "esnext.iterator.flat-map": {},
  "esnext.iterator.for-each": {},
  "esnext.iterator.from": {},
  "esnext.iterator.map": {},
  "esnext.iterator.reduce": {},
  "esnext.iterator.some": {},
  "esnext.iterator.take": {},
  "esnext.iterator.to-array": {},
  "esnext.map.delete-all": {},
  "esnext.map.every": {},
  "esnext.map.filter": {},
  "esnext.map.find": {},
  "esnext.map.find-key": {},
  "esnext.map.from": {},
  "esnext.map.group-by": {},
  "esnext.map.includes": {},
  "esnext.map.key-by": {},
  "esnext.map.key-of": {},
  "esnext.map.map-keys": {},
  "esnext.map.map-values": {},
  "esnext.map.merge": {},
  "esnext.map.of": {},
  "esnext.map.reduce": {},
  "esnext.map.some": {},
  "esnext.map.update": {},
  "esnext.map.update-or-insert": {},
  "esnext.map.upsert": {},
  "esnext.math.clamp": {},
  "esnext.math.deg-per-rad": {},
  "esnext.math.degrees": {},
  "esnext.math.fscale": {},
  "esnext.math.iaddh": {},
  "esnext.math.imulh": {},
  "esnext.math.isubh": {},
  "esnext.math.rad-per-deg": {},
  "esnext.math.radians": {},
  "esnext.math.scale": {},
  "esnext.math.seeded-prng": {},
  "esnext.math.signbit": {},
  "esnext.math.umulh": {},
  "esnext.number.from-string": {},
  "esnext.observable": {},
  "esnext.promise.all-settled": {
    "chrome": "76",
    "firefox": "71",
    "safari": "13",
    "edge": "76",
    "opera": "63",
    "node": "12.9",
    "electron": "6.0",
    "ios": "13.0"
  },
  "esnext.promise.any": {},
  "esnext.promise.try": {},
  "esnext.reflect.define-metadata": {},
  "esnext.reflect.delete-metadata": {},
  "esnext.reflect.get-metadata": {},
  "esnext.reflect.get-metadata-keys": {},
  "esnext.reflect.get-own-metadata": {},
  "esnext.reflect.get-own-metadata-keys": {},
  "esnext.reflect.has-metadata": {},
  "esnext.reflect.has-own-metadata": {},
  "esnext.reflect.metadata": {},
  "esnext.set.add-all": {},
  "esnext.set.delete-all": {},
  "esnext.set.difference": {},
  "esnext.set.every": {},
  "esnext.set.filter": {},
  "esnext.set.find": {},
  "esnext.set.from": {},
  "esnext.set.intersection": {},
  "esnext.set.is-disjoint-from": {},
  "esnext.set.is-subset-of": {},
  "esnext.set.is-superset-of": {},
  "esnext.set.join": {},
  "esnext.set.map": {},
  "esnext.set.of": {},
  "esnext.set.reduce": {},
  "esnext.set.some": {},
  "esnext.set.symmetric-difference": {},
  "esnext.set.union": {},
  "esnext.string.at": {},
  "esnext.string.code-points": {},
  "esnext.string.match-all": {
    "chrome": "80",
    "edge": "80",
    "opera": "67"
  },
  "esnext.string.replace-all": {
    "firefox": "72"
  },
  "esnext.symbol.async-dispose": {},
  "esnext.symbol.dispose": {},
  "esnext.symbol.observable": {},
  "esnext.symbol.pattern-match": {},
  "esnext.symbol.replace-all": {},
  "esnext.weak-map.delete-all": {},
  "esnext.weak-map.from": {},
  "esnext.weak-map.of": {},
  "esnext.weak-map.upsert": {},
  "esnext.weak-set.add-all": {},
  "esnext.weak-set.delete-all": {},
  "esnext.weak-set.from": {},
  "esnext.weak-set.of": {},
  "web.dom-collections.for-each": {
    "edge": "16",
    "chrome": "58",
    "node": "0.10",
    "firefox": "50",
    "safari": "10.0",
    "opera": "45",
    "samsung": "7.2",
    "electron": "1.7",
    "ios": "10.0"
  },
  "web.dom-collections.iterator": {
    "chrome": "66",
    "node": "0.10",
    "firefox": "60",
    "edge": "74",
    "opera": "53",
    "samsung": "9.2",
    "electron": "3.0"
  },
  "web.immediate": {
    "ie": "10",
    "node": "0.10"
  },
  "web.queue-microtask": {
    "chrome": "71",
    "node": "12.0",
    "firefox": "69",
    "safari": "12.1",
    "edge": "74",
    "opera": "58",
    "samsung": "10.2",
    "electron": "5.0",
    "ios": "13.0"
  },
  "web.timers": {
    "ie": "10",
    "chrome": "1",
    "opera": "7",
    "node": "0.10",
    "android": "1.5",
    "firefox": "1",
    "safari": "1.0",
    "edge": "12",
    "samsung": "2.1",
    "electron": "0.20",
    "ios": "6.0",
    "phantom": "1.9"
  },
  "web.url": {
    "chrome": "67",
    "node": "10.0",
    "firefox": "57",
    "edge": "74",
    "opera": "54",
    "samsung": "9.2",
    "electron": "4.0"
  },
  "web.url.to-json": {
    "chrome": "71",
    "node": "10.0",
    "firefox": "57",
    "edge": "74",
    "opera": "58",
    "samsung": "10.2",
    "electron": "5.0"
  },
  "web.url-search-params": {
    "chrome": "67",
    "node": "10.0",
    "firefox": "57",
    "edge": "74",
    "opera": "54",
    "samsung": "9.2",
    "electron": "4.0"
  }
}
},{}],304:[function(require,module,exports){
module.exports={
  "core-js": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/es/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
  "core-js/es/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/es/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
  "core-js/es/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
  "core-js/es/array/concat": [
    "es.array.concat"
  ],
  "core-js/es/array/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/es/array/entries": [
    "es.array.iterator"
  ],
  "core-js/es/array/every": [
    "es.array.every"
  ],
  "core-js/es/array/fill": [
    "es.array.fill"
  ],
  "core-js/es/array/filter": [
    "es.array.filter"
  ],
  "core-js/es/array/find-index": [
    "es.array.find-index"
  ],
  "core-js/es/array/find": [
    "es.array.find"
  ],
  "core-js/es/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/es/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/es/array/for-each": [
    "es.array.for-each"
  ],
  "core-js/es/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
  "core-js/es/array/includes": [
    "es.array.includes"
  ],
  "core-js/es/array/index-of": [
    "es.array.index-of"
  ],
  "core-js/es/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator"
  ],
  "core-js/es/array/is-array": [
    "es.array.is-array"
  ],
  "core-js/es/array/iterator": [
    "es.array.iterator"
  ],
  "core-js/es/array/join": [
    "es.array.join"
  ],
  "core-js/es/array/keys": [
    "es.array.iterator"
  ],
  "core-js/es/array/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/es/array/map": [
    "es.array.map"
  ],
  "core-js/es/array/of": [
    "es.array.of"
  ],
  "core-js/es/array/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/es/array/reduce": [
    "es.array.reduce"
  ],
  "core-js/es/array/reverse": [
    "es.array.reverse"
  ],
  "core-js/es/array/slice": [
    "es.array.slice"
  ],
  "core-js/es/array/some": [
    "es.array.some"
  ],
  "core-js/es/array/sort": [
    "es.array.sort"
  ],
  "core-js/es/array/splice": [
    "es.array.splice"
  ],
  "core-js/es/array/values": [
    "es.array.iterator"
  ],
  "core-js/es/array/virtual/concat": [
    "es.array.concat"
  ],
  "core-js/es/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/es/array/virtual/entries": [
    "es.array.iterator"
  ],
  "core-js/es/array/virtual/every": [
    "es.array.every"
  ],
  "core-js/es/array/virtual/fill": [
    "es.array.fill"
  ],
  "core-js/es/array/virtual/filter": [
    "es.array.filter"
  ],
  "core-js/es/array/virtual/find-index": [
    "es.array.find-index"
  ],
  "core-js/es/array/virtual/find": [
    "es.array.find"
  ],
  "core-js/es/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/es/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/es/array/virtual/for-each": [
    "es.array.for-each"
  ],
  "core-js/es/array/virtual/includes": [
    "es.array.includes"
  ],
  "core-js/es/array/virtual/index-of": [
    "es.array.index-of"
  ],
  "core-js/es/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
  "core-js/es/array/virtual/iterator": [
    "es.array.iterator"
  ],
  "core-js/es/array/virtual/join": [
    "es.array.join"
  ],
  "core-js/es/array/virtual/keys": [
    "es.array.iterator"
  ],
  "core-js/es/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/es/array/virtual/map": [
    "es.array.map"
  ],
  "core-js/es/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/es/array/virtual/reduce": [
    "es.array.reduce"
  ],
  "core-js/es/array/virtual/reverse": [
    "es.array.reverse"
  ],
  "core-js/es/array/virtual/slice": [
    "es.array.slice"
  ],
  "core-js/es/array/virtual/some": [
    "es.array.some"
  ],
  "core-js/es/array/virtual/sort": [
    "es.array.sort"
  ],
  "core-js/es/array/virtual/splice": [
    "es.array.splice"
  ],
  "core-js/es/array/virtual/values": [
    "es.array.iterator"
  ],
  "core-js/es/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/es/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/es/date/now": [
    "es.date.now"
  ],
  "core-js/es/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
  "core-js/es/date/to-json": [
    "es.date.to-json"
  ],
  "core-js/es/date/to-primitive": [
    "es.date.to-primitive"
  ],
  "core-js/es/date/to-string": [
    "es.date.to-string"
  ],
  "core-js/es/function/bind": [
    "es.function.bind"
  ],
  "core-js/es/function/has-instance": [
    "es.function.has-instance"
  ],
  "core-js/es/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
  "core-js/es/function/name": [
    "es.function.name"
  ],
  "core-js/es/function/virtual/bind": [
    "es.function.bind"
  ],
  "core-js/es/function/virtual": [
    "es.function.bind"
  ],
  "core-js/es/global-this": [
    "es.global-this"
  ],
  "core-js/es": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set"
  ],
  "core-js/es/instance/bind": [
    "es.function.bind"
  ],
  "core-js/es/instance/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/es/instance/concat": [
    "es.array.concat"
  ],
  "core-js/es/instance/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/es/instance/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/es/instance/entries": [
    "es.array.iterator"
  ],
  "core-js/es/instance/every": [
    "es.array.every"
  ],
  "core-js/es/instance/fill": [
    "es.array.fill"
  ],
  "core-js/es/instance/filter": [
    "es.array.filter"
  ],
  "core-js/es/instance/find-index": [
    "es.array.find-index"
  ],
  "core-js/es/instance/find": [
    "es.array.find"
  ],
  "core-js/es/instance/flags": [
    "es.regexp.flags"
  ],
  "core-js/es/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/es/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/es/instance/for-each": [
    "es.array.for-each"
  ],
  "core-js/es/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
  "core-js/es/instance/index-of": [
    "es.array.index-of"
  ],
  "core-js/es/instance/keys": [
    "es.array.iterator"
  ],
  "core-js/es/instance/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/es/instance/map": [
    "es.array.map"
  ],
  "core-js/es/instance/match-all": [
    "es.string.match-all"
  ],
  "core-js/es/instance/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/es/instance/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/es/instance/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/es/instance/reduce": [
    "es.array.reduce"
  ],
  "core-js/es/instance/repeat": [
    "es.string.repeat"
  ],
  "core-js/es/instance/reverse": [
    "es.array.reverse"
  ],
  "core-js/es/instance/slice": [
    "es.array.slice"
  ],
  "core-js/es/instance/some": [
    "es.array.some"
  ],
  "core-js/es/instance/sort": [
    "es.array.sort"
  ],
  "core-js/es/instance/splice": [
    "es.array.splice"
  ],
  "core-js/es/instance/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/es/instance/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/es/instance/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/es/instance/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/es/instance/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/es/instance/trim": [
    "es.string.trim"
  ],
  "core-js/es/instance/values": [
    "es.array.iterator"
  ],
  "core-js/es/json": [
    "es.json.to-string-tag"
  ],
  "core-js/es/json/stringify": [
    "es.json.stringify"
  ],
  "core-js/es/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
  "core-js/es/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/es/math/acosh": [
    "es.math.acosh"
  ],
  "core-js/es/math/asinh": [
    "es.math.asinh"
  ],
  "core-js/es/math/atanh": [
    "es.math.atanh"
  ],
  "core-js/es/math/cbrt": [
    "es.math.cbrt"
  ],
  "core-js/es/math/clz32": [
    "es.math.clz32"
  ],
  "core-js/es/math/cosh": [
    "es.math.cosh"
  ],
  "core-js/es/math/expm1": [
    "es.math.expm1"
  ],
  "core-js/es/math/fround": [
    "es.math.fround"
  ],
  "core-js/es/math/hypot": [
    "es.math.hypot"
  ],
  "core-js/es/math/imul": [
    "es.math.imul"
  ],
  "core-js/es/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
  "core-js/es/math/log10": [
    "es.math.log10"
  ],
  "core-js/es/math/log1p": [
    "es.math.log1p"
  ],
  "core-js/es/math/log2": [
    "es.math.log2"
  ],
  "core-js/es/math/sign": [
    "es.math.sign"
  ],
  "core-js/es/math/sinh": [
    "es.math.sinh"
  ],
  "core-js/es/math/tanh": [
    "es.math.tanh"
  ],
  "core-js/es/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
  "core-js/es/math/trunc": [
    "es.math.trunc"
  ],
  "core-js/es/number/constructor": [
    "es.number.constructor"
  ],
  "core-js/es/number/epsilon": [
    "es.number.epsilon"
  ],
  "core-js/es/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/es/number/is-finite": [
    "es.number.is-finite"
  ],
  "core-js/es/number/is-integer": [
    "es.number.is-integer"
  ],
  "core-js/es/number/is-nan": [
    "es.number.is-nan"
  ],
  "core-js/es/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
  "core-js/es/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
  "core-js/es/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
  "core-js/es/number/parse-float": [
    "es.number.parse-float"
  ],
  "core-js/es/number/parse-int": [
    "es.number.parse-int"
  ],
  "core-js/es/number/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/es/number/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/es/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/es/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/es/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/es/object/assign": [
    "es.object.assign"
  ],
  "core-js/es/object/create": [
    "es.object.create"
  ],
  "core-js/es/object/define-getter": [
    "es.object.define-getter"
  ],
  "core-js/es/object/define-properties": [
    "es.object.define-properties"
  ],
  "core-js/es/object/define-property": [
    "es.object.define-property"
  ],
  "core-js/es/object/define-setter": [
    "es.object.define-setter"
  ],
  "core-js/es/object/entries": [
    "es.object.entries"
  ],
  "core-js/es/object/freeze": [
    "es.object.freeze"
  ],
  "core-js/es/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
  "core-js/es/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
  "core-js/es/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
  "core-js/es/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
  "core-js/es/object/get-own-property-symbols": [
    "es.symbol"
  ],
  "core-js/es/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
  "core-js/es/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values"
  ],
  "core-js/es/object/is-extensible": [
    "es.object.is-extensible"
  ],
  "core-js/es/object/is-frozen": [
    "es.object.is-frozen"
  ],
  "core-js/es/object/is-sealed": [
    "es.object.is-sealed"
  ],
  "core-js/es/object/is": [
    "es.object.is"
  ],
  "core-js/es/object/keys": [
    "es.object.keys"
  ],
  "core-js/es/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
  "core-js/es/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
  "core-js/es/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
  "core-js/es/object/seal": [
    "es.object.seal"
  ],
  "core-js/es/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
  "core-js/es/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/es/object/values": [
    "es.object.values"
  ],
  "core-js/es/parse-float": [
    "es.parse-float"
  ],
  "core-js/es/parse-int": [
    "es.parse-int"
  ],
  "core-js/es/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled"
  ],
  "core-js/es/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
  "core-js/es/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/es/reflect/apply": [
    "es.reflect.apply"
  ],
  "core-js/es/reflect/construct": [
    "es.reflect.construct"
  ],
  "core-js/es/reflect/define-property": [
    "es.reflect.define-property"
  ],
  "core-js/es/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
  "core-js/es/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
  "core-js/es/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
  "core-js/es/reflect/get": [
    "es.reflect.get"
  ],
  "core-js/es/reflect/has": [
    "es.reflect.has"
  ],
  "core-js/es/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of"
  ],
  "core-js/es/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
  "core-js/es/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
  "core-js/es/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
  "core-js/es/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
  "core-js/es/reflect/set": [
    "es.reflect.set"
  ],
  "core-js/es/regexp/constructor": [
    "es.regexp.constructor"
  ],
  "core-js/es/regexp/flags": [
    "es.regexp.flags"
  ],
  "core-js/es/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/es/regexp/match": [
    "es.string.match"
  ],
  "core-js/es/regexp/replace": [
    "es.string.replace"
  ],
  "core-js/es/regexp/search": [
    "es.string.search"
  ],
  "core-js/es/regexp/split": [
    "es.string.split"
  ],
  "core-js/es/regexp/to-string": [
    "es.regexp.to-string"
  ],
  "core-js/es/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/es/string/anchor": [
    "es.string.anchor"
  ],
  "core-js/es/string/big": [
    "es.string.big"
  ],
  "core-js/es/string/blink": [
    "es.string.blink"
  ],
  "core-js/es/string/bold": [
    "es.string.bold"
  ],
  "core-js/es/string/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/es/string/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/es/string/fixed": [
    "es.string.fixed"
  ],
  "core-js/es/string/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/es/string/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/es/string/from-code-point": [
    "es.string.from-code-point"
  ],
  "core-js/es/string/includes": [
    "es.string.includes"
  ],
  "core-js/es/string": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/es/string/italics": [
    "es.string.italics"
  ],
  "core-js/es/string/iterator": [
    "es.string.iterator"
  ],
  "core-js/es/string/link": [
    "es.string.link"
  ],
  "core-js/es/string/match-all": [
    "es.string.match-all"
  ],
  "core-js/es/string/match": [
    "es.string.match"
  ],
  "core-js/es/string/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/es/string/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/es/string/raw": [
    "es.string.raw"
  ],
  "core-js/es/string/repeat": [
    "es.string.repeat"
  ],
  "core-js/es/string/replace": [
    "es.string.replace"
  ],
  "core-js/es/string/search": [
    "es.string.search"
  ],
  "core-js/es/string/small": [
    "es.string.small"
  ],
  "core-js/es/string/split": [
    "es.string.split"
  ],
  "core-js/es/string/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/es/string/strike": [
    "es.string.strike"
  ],
  "core-js/es/string/sub": [
    "es.string.sub"
  ],
  "core-js/es/string/sup": [
    "es.string.sup"
  ],
  "core-js/es/string/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/es/string/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/es/string/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/es/string/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/es/string/trim": [
    "es.string.trim"
  ],
  "core-js/es/string/virtual/anchor": [
    "es.string.anchor"
  ],
  "core-js/es/string/virtual/big": [
    "es.string.big"
  ],
  "core-js/es/string/virtual/blink": [
    "es.string.blink"
  ],
  "core-js/es/string/virtual/bold": [
    "es.string.bold"
  ],
  "core-js/es/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/es/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/es/string/virtual/fixed": [
    "es.string.fixed"
  ],
  "core-js/es/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/es/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/es/string/virtual/includes": [
    "es.string.includes"
  ],
  "core-js/es/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/es/string/virtual/italics": [
    "es.string.italics"
  ],
  "core-js/es/string/virtual/iterator": [
    "es.string.iterator"
  ],
  "core-js/es/string/virtual/link": [
    "es.string.link"
  ],
  "core-js/es/string/virtual/match-all": [
    "es.string.match-all"
  ],
  "core-js/es/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/es/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/es/string/virtual/repeat": [
    "es.string.repeat"
  ],
  "core-js/es/string/virtual/small": [
    "es.string.small"
  ],
  "core-js/es/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/es/string/virtual/strike": [
    "es.string.strike"
  ],
  "core-js/es/string/virtual/sub": [
    "es.string.sub"
  ],
  "core-js/es/string/virtual/sup": [
    "es.string.sup"
  ],
  "core-js/es/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/es/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/es/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/es/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/es/string/virtual/trim": [
    "es.string.trim"
  ],
  "core-js/es/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
  "core-js/es/symbol/description": [
    "es.symbol.description"
  ],
  "core-js/es/symbol/for": [
    "es.symbol"
  ],
  "core-js/es/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
  "core-js/es/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/es/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
  "core-js/es/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/es/symbol/key-for": [
    "es.symbol"
  ],
  "core-js/es/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
  "core-js/es/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
  "core-js/es/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
  "core-js/es/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
  "core-js/es/symbol/species": [
    "es.symbol.species"
  ],
  "core-js/es/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
  "core-js/es/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
  "core-js/es/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/es/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
  "core-js/es/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
  "core-js/es/typed-array/entries": [
    "es.typed-array.iterator"
  ],
  "core-js/es/typed-array/every": [
    "es.typed-array.every"
  ],
  "core-js/es/typed-array/fill": [
    "es.typed-array.fill"
  ],
  "core-js/es/typed-array/filter": [
    "es.typed-array.filter"
  ],
  "core-js/es/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
  "core-js/es/typed-array/find": [
    "es.typed-array.find"
  ],
  "core-js/es/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
  "core-js/es/typed-array/from": [
    "es.typed-array.from"
  ],
  "core-js/es/typed-array/includes": [
    "es.typed-array.includes"
  ],
  "core-js/es/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
  "core-js/es/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
  "core-js/es/typed-array/join": [
    "es.typed-array.join"
  ],
  "core-js/es/typed-array/keys": [
    "es.typed-array.iterator"
  ],
  "core-js/es/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
  "core-js/es/typed-array/map": [
    "es.typed-array.map"
  ],
  "core-js/es/typed-array/methods": [
    "es.object.to-string",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/of": [
    "es.typed-array.of"
  ],
  "core-js/es/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
  "core-js/es/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
  "core-js/es/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
  "core-js/es/typed-array/set": [
    "es.typed-array.set"
  ],
  "core-js/es/typed-array/slice": [
    "es.typed-array.slice"
  ],
  "core-js/es/typed-array/some": [
    "es.typed-array.some"
  ],
  "core-js/es/typed-array/sort": [
    "es.typed-array.sort"
  ],
  "core-js/es/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
  "core-js/es/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
  "core-js/es/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/es/typed-array/values": [
    "es.typed-array.iterator"
  ],
  "core-js/es/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
  "core-js/es/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
  "core-js/features/aggregate-error": [
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
  "core-js/features/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
  "core-js/features/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/features/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
  "core-js/features/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
  "core-js/features/array/concat": [
    "es.array.concat"
  ],
  "core-js/features/array/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/features/array/entries": [
    "es.array.iterator"
  ],
  "core-js/features/array/every": [
    "es.array.every"
  ],
  "core-js/features/array/fill": [
    "es.array.fill"
  ],
  "core-js/features/array/filter": [
    "es.array.filter"
  ],
  "core-js/features/array/find-index": [
    "es.array.find-index"
  ],
  "core-js/features/array/find": [
    "es.array.find"
  ],
  "core-js/features/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/features/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/features/array/for-each": [
    "es.array.for-each"
  ],
  "core-js/features/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
  "core-js/features/array/includes": [
    "es.array.includes"
  ],
  "core-js/features/array/index-of": [
    "es.array.index-of"
  ],
  "core-js/features/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item"
  ],
  "core-js/features/array/is-array": [
    "es.array.is-array"
  ],
  "core-js/features/array/is-template-object": [
    "esnext.array.is-template-object"
  ],
  "core-js/features/array/iterator": [
    "es.array.iterator"
  ],
  "core-js/features/array/join": [
    "es.array.join"
  ],
  "core-js/features/array/keys": [
    "es.array.iterator"
  ],
  "core-js/features/array/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/features/array/last-index": [
    "esnext.array.last-index"
  ],
  "core-js/features/array/last-item": [
    "esnext.array.last-item"
  ],
  "core-js/features/array/map": [
    "es.array.map"
  ],
  "core-js/features/array/of": [
    "es.array.of"
  ],
  "core-js/features/array/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/features/array/reduce": [
    "es.array.reduce"
  ],
  "core-js/features/array/reverse": [
    "es.array.reverse"
  ],
  "core-js/features/array/slice": [
    "es.array.slice"
  ],
  "core-js/features/array/some": [
    "es.array.some"
  ],
  "core-js/features/array/sort": [
    "es.array.sort"
  ],
  "core-js/features/array/splice": [
    "es.array.splice"
  ],
  "core-js/features/array/values": [
    "es.array.iterator"
  ],
  "core-js/features/array/virtual/concat": [
    "es.array.concat"
  ],
  "core-js/features/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/features/array/virtual/entries": [
    "es.array.iterator"
  ],
  "core-js/features/array/virtual/every": [
    "es.array.every"
  ],
  "core-js/features/array/virtual/fill": [
    "es.array.fill"
  ],
  "core-js/features/array/virtual/filter": [
    "es.array.filter"
  ],
  "core-js/features/array/virtual/find-index": [
    "es.array.find-index"
  ],
  "core-js/features/array/virtual/find": [
    "es.array.find"
  ],
  "core-js/features/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/features/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/features/array/virtual/for-each": [
    "es.array.for-each"
  ],
  "core-js/features/array/virtual/includes": [
    "es.array.includes"
  ],
  "core-js/features/array/virtual/index-of": [
    "es.array.index-of"
  ],
  "core-js/features/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
  "core-js/features/array/virtual/iterator": [
    "es.array.iterator"
  ],
  "core-js/features/array/virtual/join": [
    "es.array.join"
  ],
  "core-js/features/array/virtual/keys": [
    "es.array.iterator"
  ],
  "core-js/features/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/features/array/virtual/map": [
    "es.array.map"
  ],
  "core-js/features/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/features/array/virtual/reduce": [
    "es.array.reduce"
  ],
  "core-js/features/array/virtual/reverse": [
    "es.array.reverse"
  ],
  "core-js/features/array/virtual/slice": [
    "es.array.slice"
  ],
  "core-js/features/array/virtual/some": [
    "es.array.some"
  ],
  "core-js/features/array/virtual/sort": [
    "es.array.sort"
  ],
  "core-js/features/array/virtual/splice": [
    "es.array.splice"
  ],
  "core-js/features/array/virtual/values": [
    "es.array.iterator"
  ],
  "core-js/features/async-iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/drop": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/every": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.every",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/filter": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.filter",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/find": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.find",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/flat-map": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.flat-map",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/for-each": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/from": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/map": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.map",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/reduce": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.reduce",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/some": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.some",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/take": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.take",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/to-array": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/clear-immediate": [
    "web.immediate"
  ],
  "core-js/features/composite-key": [
    "esnext.composite-key"
  ],
  "core-js/features/composite-symbol": [
    "es.symbol",
    "esnext.composite-symbol"
  ],
  "core-js/features/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/features/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/features/date/now": [
    "es.date.now"
  ],
  "core-js/features/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
  "core-js/features/date/to-json": [
    "es.date.to-json"
  ],
  "core-js/features/date/to-primitive": [
    "es.date.to-primitive"
  ],
  "core-js/features/date/to-string": [
    "es.date.to-string"
  ],
  "core-js/features/dom-collections/for-each": [
    "web.dom-collections.for-each"
  ],
  "core-js/features/dom-collections": [
    "es.array.iterator",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/features/dom-collections/iterator": [
    "web.dom-collections.iterator"
  ],
  "core-js/features/function/bind": [
    "es.function.bind"
  ],
  "core-js/features/function/has-instance": [
    "es.function.has-instance"
  ],
  "core-js/features/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
  "core-js/features/function/name": [
    "es.function.name"
  ],
  "core-js/features/function/virtual/bind": [
    "es.function.bind"
  ],
  "core-js/features/function/virtual": [
    "es.function.bind"
  ],
  "core-js/features/get-iterator-method": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/get-iterator": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/global-this": [
    "es.global-this",
    "esnext.global-this"
  ],
  "core-js/features": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/features/instance/at": [
    "esnext.string.at"
  ],
  "core-js/features/instance/bind": [
    "es.function.bind"
  ],
  "core-js/features/instance/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/features/instance/code-points": [
    "esnext.string.code-points"
  ],
  "core-js/features/instance/concat": [
    "es.array.concat"
  ],
  "core-js/features/instance/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/features/instance/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/features/instance/entries": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/instance/every": [
    "es.array.every"
  ],
  "core-js/features/instance/fill": [
    "es.array.fill"
  ],
  "core-js/features/instance/filter": [
    "es.array.filter"
  ],
  "core-js/features/instance/find-index": [
    "es.array.find-index"
  ],
  "core-js/features/instance/find": [
    "es.array.find"
  ],
  "core-js/features/instance/flags": [
    "es.regexp.flags"
  ],
  "core-js/features/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/features/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/features/instance/for-each": [
    "es.array.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/features/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
  "core-js/features/instance/index-of": [
    "es.array.index-of"
  ],
  "core-js/features/instance/keys": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/instance/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/features/instance/map": [
    "es.array.map"
  ],
  "core-js/features/instance/match-all": [
    "es.string.match-all"
  ],
  "core-js/features/instance/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/features/instance/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/features/instance/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/features/instance/reduce": [
    "es.array.reduce"
  ],
  "core-js/features/instance/repeat": [
    "es.string.repeat"
  ],
  "core-js/features/instance/replace-all": [
    "esnext.string.replace-all"
  ],
  "core-js/features/instance/reverse": [
    "es.array.reverse"
  ],
  "core-js/features/instance/slice": [
    "es.array.slice"
  ],
  "core-js/features/instance/some": [
    "es.array.some"
  ],
  "core-js/features/instance/sort": [
    "es.array.sort"
  ],
  "core-js/features/instance/splice": [
    "es.array.splice"
  ],
  "core-js/features/instance/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/features/instance/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/features/instance/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/features/instance/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/features/instance/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/features/instance/trim": [
    "es.string.trim"
  ],
  "core-js/features/instance/values": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/is-iterable": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/drop": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.drop",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/every": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.every",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/filter": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.filter",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/find": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.find",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/flat-map": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.flat-map",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/for-each": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/from": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/map": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.map",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/reduce": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.reduce",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/some": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.some",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/take": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.take",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/to-array": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/json": [
    "es.json.to-string-tag"
  ],
  "core-js/features/json/stringify": [
    "es.json.stringify"
  ],
  "core-js/features/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
  "core-js/features/map/delete-all": [
    "es.map",
    "esnext.map.delete-all"
  ],
  "core-js/features/map/every": [
    "es.map",
    "esnext.map.every"
  ],
  "core-js/features/map/filter": [
    "es.map",
    "esnext.map.filter"
  ],
  "core-js/features/map/find-key": [
    "es.map",
    "esnext.map.find-key"
  ],
  "core-js/features/map/find": [
    "es.map",
    "esnext.map.find"
  ],
  "core-js/features/map/from": [
    "es.map",
    "es.string.iterator",
    "esnext.map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/map/group-by": [
    "es.map",
    "esnext.map.group-by"
  ],
  "core-js/features/map/includes": [
    "es.map",
    "esnext.map.includes"
  ],
  "core-js/features/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/features/map/key-by": [
    "es.map",
    "esnext.map.key-by"
  ],
  "core-js/features/map/key-of": [
    "es.map",
    "esnext.map.key-of"
  ],
  "core-js/features/map/map-keys": [
    "es.map",
    "esnext.map.map-keys"
  ],
  "core-js/features/map/map-values": [
    "es.map",
    "esnext.map.map-values"
  ],
  "core-js/features/map/merge": [
    "es.map",
    "esnext.map.merge"
  ],
  "core-js/features/map/of": [
    "es.map",
    "es.string.iterator",
    "esnext.map.of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/map/reduce": [
    "es.map",
    "esnext.map.reduce"
  ],
  "core-js/features/map/some": [
    "es.map",
    "esnext.map.some"
  ],
  "core-js/features/map/update-or-insert": [
    "es.map",
    "esnext.map.update-or-insert"
  ],
  "core-js/features/map/update": [
    "es.map",
    "esnext.map.update"
  ],
  "core-js/features/map/upsert": [
    "es.map",
    "esnext.map.upsert"
  ],
  "core-js/features/math/acosh": [
    "es.math.acosh"
  ],
  "core-js/features/math/asinh": [
    "es.math.asinh"
  ],
  "core-js/features/math/atanh": [
    "es.math.atanh"
  ],
  "core-js/features/math/cbrt": [
    "es.math.cbrt"
  ],
  "core-js/features/math/clamp": [
    "esnext.math.clamp"
  ],
  "core-js/features/math/clz32": [
    "es.math.clz32"
  ],
  "core-js/features/math/cosh": [
    "es.math.cosh"
  ],
  "core-js/features/math/deg-per-rad": [
    "esnext.math.deg-per-rad"
  ],
  "core-js/features/math/degrees": [
    "esnext.math.degrees"
  ],
  "core-js/features/math/expm1": [
    "es.math.expm1"
  ],
  "core-js/features/math/fround": [
    "es.math.fround"
  ],
  "core-js/features/math/fscale": [
    "esnext.math.fscale"
  ],
  "core-js/features/math/hypot": [
    "es.math.hypot"
  ],
  "core-js/features/math/iaddh": [
    "esnext.math.iaddh"
  ],
  "core-js/features/math/imul": [
    "es.math.imul"
  ],
  "core-js/features/math/imulh": [
    "esnext.math.imulh"
  ],
  "core-js/features/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh"
  ],
  "core-js/features/math/isubh": [
    "esnext.math.isubh"
  ],
  "core-js/features/math/log10": [
    "es.math.log10"
  ],
  "core-js/features/math/log1p": [
    "es.math.log1p"
  ],
  "core-js/features/math/log2": [
    "es.math.log2"
  ],
  "core-js/features/math/rad-per-deg": [
    "esnext.math.rad-per-deg"
  ],
  "core-js/features/math/radians": [
    "esnext.math.radians"
  ],
  "core-js/features/math/scale": [
    "esnext.math.scale"
  ],
  "core-js/features/math/seeded-prng": [
    "esnext.math.seeded-prng"
  ],
  "core-js/features/math/sign": [
    "es.math.sign"
  ],
  "core-js/features/math/signbit": [
    "esnext.math.signbit"
  ],
  "core-js/features/math/sinh": [
    "es.math.sinh"
  ],
  "core-js/features/math/tanh": [
    "es.math.tanh"
  ],
  "core-js/features/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
  "core-js/features/math/trunc": [
    "es.math.trunc"
  ],
  "core-js/features/math/umulh": [
    "esnext.math.umulh"
  ],
  "core-js/features/number/constructor": [
    "es.number.constructor"
  ],
  "core-js/features/number/epsilon": [
    "es.number.epsilon"
  ],
  "core-js/features/number/from-string": [
    "esnext.number.from-string"
  ],
  "core-js/features/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "esnext.number.from-string"
  ],
  "core-js/features/number/is-finite": [
    "es.number.is-finite"
  ],
  "core-js/features/number/is-integer": [
    "es.number.is-integer"
  ],
  "core-js/features/number/is-nan": [
    "es.number.is-nan"
  ],
  "core-js/features/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
  "core-js/features/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
  "core-js/features/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
  "core-js/features/number/parse-float": [
    "es.number.parse-float"
  ],
  "core-js/features/number/parse-int": [
    "es.number.parse-int"
  ],
  "core-js/features/number/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/features/number/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/features/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/features/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/features/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/features/object/assign": [
    "es.object.assign"
  ],
  "core-js/features/object/create": [
    "es.object.create"
  ],
  "core-js/features/object/define-getter": [
    "es.object.define-getter"
  ],
  "core-js/features/object/define-properties": [
    "es.object.define-properties"
  ],
  "core-js/features/object/define-property": [
    "es.object.define-property"
  ],
  "core-js/features/object/define-setter": [
    "es.object.define-setter"
  ],
  "core-js/features/object/entries": [
    "es.object.entries"
  ],
  "core-js/features/object/freeze": [
    "es.object.freeze"
  ],
  "core-js/features/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
  "core-js/features/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
  "core-js/features/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
  "core-js/features/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
  "core-js/features/object/get-own-property-symbols": [
    "es.symbol"
  ],
  "core-js/features/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
  "core-js/features/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values"
  ],
  "core-js/features/object/is-extensible": [
    "es.object.is-extensible"
  ],
  "core-js/features/object/is-frozen": [
    "es.object.is-frozen"
  ],
  "core-js/features/object/is-sealed": [
    "es.object.is-sealed"
  ],
  "core-js/features/object/is": [
    "es.object.is"
  ],
  "core-js/features/object/keys": [
    "es.object.keys"
  ],
  "core-js/features/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
  "core-js/features/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
  "core-js/features/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
  "core-js/features/object/seal": [
    "es.object.seal"
  ],
  "core-js/features/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
  "core-js/features/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/features/object/values": [
    "es.object.values"
  ],
  "core-js/features/observable": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.observable",
    "esnext.symbol.observable",
    "web.dom-collections.iterator"
  ],
  "core-js/features/parse-float": [
    "es.parse-float"
  ],
  "core-js/features/parse-int": [
    "es.parse-int"
  ],
  "core-js/features/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled",
    "esnext.promise.all-settled"
  ],
  "core-js/features/promise/any": [
    "es.promise",
    "esnext.aggregate-error",
    "esnext.promise.any"
  ],
  "core-js/features/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
  "core-js/features/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "web.dom-collections.iterator"
  ],
  "core-js/features/promise/try": [
    "es.promise",
    "esnext.promise.try"
  ],
  "core-js/features/queue-microtask": [
    "web.queue-microtask"
  ],
  "core-js/features/reflect/apply": [
    "es.reflect.apply"
  ],
  "core-js/features/reflect/construct": [
    "es.reflect.construct"
  ],
  "core-js/features/reflect/define-metadata": [
    "esnext.reflect.define-metadata"
  ],
  "core-js/features/reflect/define-property": [
    "es.reflect.define-property"
  ],
  "core-js/features/reflect/delete-metadata": [
    "esnext.reflect.delete-metadata"
  ],
  "core-js/features/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
  "core-js/features/reflect/get-metadata-keys": [
    "esnext.reflect.get-metadata-keys"
  ],
  "core-js/features/reflect/get-metadata": [
    "esnext.reflect.get-metadata"
  ],
  "core-js/features/reflect/get-own-metadata-keys": [
    "esnext.reflect.get-own-metadata-keys"
  ],
  "core-js/features/reflect/get-own-metadata": [
    "esnext.reflect.get-own-metadata"
  ],
  "core-js/features/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
  "core-js/features/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
  "core-js/features/reflect/get": [
    "es.reflect.get"
  ],
  "core-js/features/reflect/has-metadata": [
    "esnext.reflect.has-metadata"
  ],
  "core-js/features/reflect/has-own-metadata": [
    "esnext.reflect.has-own-metadata"
  ],
  "core-js/features/reflect/has": [
    "es.reflect.has"
  ],
  "core-js/features/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
  "core-js/features/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
  "core-js/features/reflect/metadata": [
    "esnext.reflect.metadata"
  ],
  "core-js/features/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
  "core-js/features/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
  "core-js/features/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
  "core-js/features/reflect/set": [
    "es.reflect.set"
  ],
  "core-js/features/regexp/constructor": [
    "es.regexp.constructor"
  ],
  "core-js/features/regexp/flags": [
    "es.regexp.flags"
  ],
  "core-js/features/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/features/regexp/match": [
    "es.string.match"
  ],
  "core-js/features/regexp/replace": [
    "es.string.replace"
  ],
  "core-js/features/regexp/search": [
    "es.string.search"
  ],
  "core-js/features/regexp/split": [
    "es.string.split"
  ],
  "core-js/features/regexp/to-string": [
    "es.regexp.to-string"
  ],
  "core-js/features/set-immediate": [
    "web.immediate"
  ],
  "core-js/features/set-interval": [
    "web.timers"
  ],
  "core-js/features/set-timeout": [
    "web.timers"
  ],
  "core-js/features/set/add-all": [
    "es.set",
    "esnext.set.add-all"
  ],
  "core-js/features/set/delete-all": [
    "es.set",
    "esnext.set.delete-all"
  ],
  "core-js/features/set/difference": [
    "es.set",
    "es.string.iterator",
    "esnext.set.difference",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/every": [
    "es.set",
    "esnext.set.every"
  ],
  "core-js/features/set/filter": [
    "es.set",
    "esnext.set.filter"
  ],
  "core-js/features/set/find": [
    "es.set",
    "esnext.set.find"
  ],
  "core-js/features/set/from": [
    "es.set",
    "es.string.iterator",
    "esnext.set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/intersection": [
    "es.set",
    "esnext.set.intersection"
  ],
  "core-js/features/set/is-disjoint-from": [
    "es.set",
    "esnext.set.is-disjoint-from"
  ],
  "core-js/features/set/is-subset-of": [
    "es.set",
    "es.string.iterator",
    "esnext.set.is-subset-of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/is-superset-of": [
    "es.set",
    "esnext.set.is-superset-of"
  ],
  "core-js/features/set/join": [
    "es.set",
    "esnext.set.join"
  ],
  "core-js/features/set/map": [
    "es.set",
    "esnext.set.map"
  ],
  "core-js/features/set/of": [
    "es.set",
    "es.string.iterator",
    "esnext.set.of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/reduce": [
    "es.set",
    "esnext.set.reduce"
  ],
  "core-js/features/set/some": [
    "es.set",
    "esnext.set.some"
  ],
  "core-js/features/set/symmetric-difference": [
    "es.set",
    "es.string.iterator",
    "esnext.set.symmetric-difference",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/union": [
    "es.set",
    "es.string.iterator",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/features/string/anchor": [
    "es.string.anchor"
  ],
  "core-js/features/string/at": [
    "esnext.string.at"
  ],
  "core-js/features/string/big": [
    "es.string.big"
  ],
  "core-js/features/string/blink": [
    "es.string.blink"
  ],
  "core-js/features/string/bold": [
    "es.string.bold"
  ],
  "core-js/features/string/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/features/string/code-points": [
    "esnext.string.code-points"
  ],
  "core-js/features/string/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/features/string/fixed": [
    "es.string.fixed"
  ],
  "core-js/features/string/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/features/string/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/features/string/from-code-point": [
    "es.string.from-code-point"
  ],
  "core-js/features/string/includes": [
    "es.string.includes"
  ],
  "core-js/features/string": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.match-all",
    "esnext.string.replace-all"
  ],
  "core-js/features/string/italics": [
    "es.string.italics"
  ],
  "core-js/features/string/iterator": [
    "es.string.iterator"
  ],
  "core-js/features/string/link": [
    "es.string.link"
  ],
  "core-js/features/string/match-all": [
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/features/string/match": [
    "es.string.match"
  ],
  "core-js/features/string/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/features/string/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/features/string/raw": [
    "es.string.raw"
  ],
  "core-js/features/string/repeat": [
    "es.string.repeat"
  ],
  "core-js/features/string/replace-all": [
    "esnext.string.replace-all"
  ],
  "core-js/features/string/replace": [
    "es.string.replace"
  ],
  "core-js/features/string/search": [
    "es.string.search"
  ],
  "core-js/features/string/small": [
    "es.string.small"
  ],
  "core-js/features/string/split": [
    "es.string.split"
  ],
  "core-js/features/string/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/features/string/strike": [
    "es.string.strike"
  ],
  "core-js/features/string/sub": [
    "es.string.sub"
  ],
  "core-js/features/string/sup": [
    "es.string.sup"
  ],
  "core-js/features/string/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/features/string/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/features/string/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/features/string/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/features/string/trim": [
    "es.string.trim"
  ],
  "core-js/features/string/virtual/anchor": [
    "es.string.anchor"
  ],
  "core-js/features/string/virtual/at": [
    "esnext.string.at"
  ],
  "core-js/features/string/virtual/big": [
    "es.string.big"
  ],
  "core-js/features/string/virtual/blink": [
    "es.string.blink"
  ],
  "core-js/features/string/virtual/bold": [
    "es.string.bold"
  ],
  "core-js/features/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/features/string/virtual/code-points": [
    "esnext.string.code-points"
  ],
  "core-js/features/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/features/string/virtual/fixed": [
    "es.string.fixed"
  ],
  "core-js/features/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/features/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/features/string/virtual/includes": [
    "es.string.includes"
  ],
  "core-js/features/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.match-all",
    "esnext.string.replace-all"
  ],
  "core-js/features/string/virtual/italics": [
    "es.string.italics"
  ],
  "core-js/features/string/virtual/iterator": [
    "es.string.iterator"
  ],
  "core-js/features/string/virtual/link": [
    "es.string.link"
  ],
  "core-js/features/string/virtual/match-all": [
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/features/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/features/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/features/string/virtual/repeat": [
    "es.string.repeat"
  ],
  "core-js/features/string/virtual/replace-all": [
    "esnext.string.replace-all"
  ],
  "core-js/features/string/virtual/small": [
    "es.string.small"
  ],
  "core-js/features/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/features/string/virtual/strike": [
    "es.string.strike"
  ],
  "core-js/features/string/virtual/sub": [
    "es.string.sub"
  ],
  "core-js/features/string/virtual/sup": [
    "es.string.sup"
  ],
  "core-js/features/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/features/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/features/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/features/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/features/string/virtual/trim": [
    "es.string.trim"
  ],
  "core-js/features/symbol/async-dispose": [
    "esnext.symbol.async-dispose"
  ],
  "core-js/features/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
  "core-js/features/symbol/description": [
    "es.symbol.description"
  ],
  "core-js/features/symbol/dispose": [
    "esnext.symbol.dispose"
  ],
  "core-js/features/symbol/for": [
    "es.symbol"
  ],
  "core-js/features/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
  "core-js/features/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all"
  ],
  "core-js/features/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
  "core-js/features/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/symbol/key-for": [
    "es.symbol"
  ],
  "core-js/features/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
  "core-js/features/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
  "core-js/features/symbol/observable": [
    "esnext.symbol.observable"
  ],
  "core-js/features/symbol/pattern-match": [
    "esnext.symbol.pattern-match"
  ],
  "core-js/features/symbol/replace-all": [
    "esnext.symbol.replace-all"
  ],
  "core-js/features/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
  "core-js/features/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
  "core-js/features/symbol/species": [
    "es.symbol.species"
  ],
  "core-js/features/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
  "core-js/features/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
  "core-js/features/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/features/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
  "core-js/features/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
  "core-js/features/typed-array/entries": [
    "es.typed-array.iterator"
  ],
  "core-js/features/typed-array/every": [
    "es.typed-array.every"
  ],
  "core-js/features/typed-array/fill": [
    "es.typed-array.fill"
  ],
  "core-js/features/typed-array/filter": [
    "es.typed-array.filter"
  ],
  "core-js/features/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
  "core-js/features/typed-array/find": [
    "es.typed-array.find"
  ],
  "core-js/features/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
  "core-js/features/typed-array/from": [
    "es.typed-array.from"
  ],
  "core-js/features/typed-array/includes": [
    "es.typed-array.includes"
  ],
  "core-js/features/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
  "core-js/features/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
  "core-js/features/typed-array/join": [
    "es.typed-array.join"
  ],
  "core-js/features/typed-array/keys": [
    "es.typed-array.iterator"
  ],
  "core-js/features/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
  "core-js/features/typed-array/map": [
    "es.typed-array.map"
  ],
  "core-js/features/typed-array/of": [
    "es.typed-array.of"
  ],
  "core-js/features/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
  "core-js/features/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
  "core-js/features/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
  "core-js/features/typed-array/set": [
    "es.typed-array.set"
  ],
  "core-js/features/typed-array/slice": [
    "es.typed-array.slice"
  ],
  "core-js/features/typed-array/some": [
    "es.typed-array.some"
  ],
  "core-js/features/typed-array/sort": [
    "es.typed-array.sort"
  ],
  "core-js/features/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
  "core-js/features/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
  "core-js/features/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/features/typed-array/values": [
    "es.typed-array.iterator"
  ],
  "core-js/features/url-search-params": [
    "web.url-search-params"
  ],
  "core-js/features/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/features/url/to-json": [
    "web.url.to-json"
  ],
  "core-js/features/weak-map/delete-all": [
    "es.weak-map",
    "esnext.weak-map.delete-all"
  ],
  "core-js/features/weak-map/from": [
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-map/of": [
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-map/upsert": [
    "es.weak-map",
    "esnext.weak-map.upsert"
  ],
  "core-js/features/weak-set/add-all": [
    "es.weak-set",
    "esnext.weak-set.add-all"
  ],
  "core-js/features/weak-set/delete-all": [
    "es.weak-set",
    "esnext.weak-set.delete-all"
  ],
  "core-js/features/weak-set/from": [
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-set/of": [
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
  "core-js/proposals/array-is-template-object": [
    "esnext.array.is-template-object"
  ],
  "core-js/proposals/array-last": [
    "esnext.array.last-index",
    "esnext.array.last-item"
  ],
  "core-js/proposals/collection-methods": [
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.weak-map.delete-all",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all"
  ],
  "core-js/proposals/collection-of-from": [
    "esnext.map.from",
    "esnext.map.of",
    "esnext.set.from",
    "esnext.set.of",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
  "core-js/proposals/efficient-64-bit-arithmetic": [
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.umulh"
  ],
  "core-js/proposals/global-this": [
    "esnext.global-this"
  ],
  "core-js/proposals": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/proposals/iterator-helpers": [
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array"
  ],
  "core-js/proposals/keys-composition": [
    "esnext.composite-key",
    "esnext.composite-symbol"
  ],
  "core-js/proposals/map-update-or-insert": [
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
  "core-js/proposals/map-upsert": [
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
  "core-js/proposals/math-extensions": [
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale"
  ],
  "core-js/proposals/math-signbit": [
    "esnext.math.signbit"
  ],
  "core-js/proposals/number-from-string": [
    "esnext.number.from-string"
  ],
  "core-js/proposals/observable": [
    "esnext.observable",
    "esnext.symbol.observable"
  ],
  "core-js/proposals/pattern-matching": [
    "esnext.symbol.pattern-match"
  ],
  "core-js/proposals/promise-all-settled": [
    "esnext.promise.all-settled"
  ],
  "core-js/proposals/promise-any": [
    "esnext.aggregate-error",
    "esnext.promise.any"
  ],
  "core-js/proposals/promise-try": [
    "esnext.promise.try"
  ],
  "core-js/proposals/reflect-metadata": [
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
  "core-js/proposals/seeded-random": [
    "esnext.math.seeded-prng"
  ],
  "core-js/proposals/set-methods": [
    "esnext.set.difference",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference",
    "esnext.set.union"
  ],
  "core-js/proposals/string-at": [
    "esnext.string.at"
  ],
  "core-js/proposals/string-code-points": [
    "esnext.string.code-points"
  ],
  "core-js/proposals/string-match-all": [
    "esnext.string.match-all"
  ],
  "core-js/proposals/string-replace-all": [
    "esnext.string.replace-all",
    "esnext.symbol.replace-all"
  ],
  "core-js/proposals/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/proposals/using-statement": [
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose"
  ],
  "core-js/stable/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
  "core-js/stable/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/stable/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
  "core-js/stable/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
  "core-js/stable/array/concat": [
    "es.array.concat"
  ],
  "core-js/stable/array/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/stable/array/entries": [
    "es.array.iterator"
  ],
  "core-js/stable/array/every": [
    "es.array.every"
  ],
  "core-js/stable/array/fill": [
    "es.array.fill"
  ],
  "core-js/stable/array/filter": [
    "es.array.filter"
  ],
  "core-js/stable/array/find-index": [
    "es.array.find-index"
  ],
  "core-js/stable/array/find": [
    "es.array.find"
  ],
  "core-js/stable/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/stable/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/stable/array/for-each": [
    "es.array.for-each"
  ],
  "core-js/stable/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
  "core-js/stable/array/includes": [
    "es.array.includes"
  ],
  "core-js/stable/array/index-of": [
    "es.array.index-of"
  ],
  "core-js/stable/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator"
  ],
  "core-js/stable/array/is-array": [
    "es.array.is-array"
  ],
  "core-js/stable/array/iterator": [
    "es.array.iterator"
  ],
  "core-js/stable/array/join": [
    "es.array.join"
  ],
  "core-js/stable/array/keys": [
    "es.array.iterator"
  ],
  "core-js/stable/array/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/stable/array/map": [
    "es.array.map"
  ],
  "core-js/stable/array/of": [
    "es.array.of"
  ],
  "core-js/stable/array/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/stable/array/reduce": [
    "es.array.reduce"
  ],
  "core-js/stable/array/reverse": [
    "es.array.reverse"
  ],
  "core-js/stable/array/slice": [
    "es.array.slice"
  ],
  "core-js/stable/array/some": [
    "es.array.some"
  ],
  "core-js/stable/array/sort": [
    "es.array.sort"
  ],
  "core-js/stable/array/splice": [
    "es.array.splice"
  ],
  "core-js/stable/array/values": [
    "es.array.iterator"
  ],
  "core-js/stable/array/virtual/concat": [
    "es.array.concat"
  ],
  "core-js/stable/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/stable/array/virtual/entries": [
    "es.array.iterator"
  ],
  "core-js/stable/array/virtual/every": [
    "es.array.every"
  ],
  "core-js/stable/array/virtual/fill": [
    "es.array.fill"
  ],
  "core-js/stable/array/virtual/filter": [
    "es.array.filter"
  ],
  "core-js/stable/array/virtual/find-index": [
    "es.array.find-index"
  ],
  "core-js/stable/array/virtual/find": [
    "es.array.find"
  ],
  "core-js/stable/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/stable/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/stable/array/virtual/for-each": [
    "es.array.for-each"
  ],
  "core-js/stable/array/virtual/includes": [
    "es.array.includes"
  ],
  "core-js/stable/array/virtual/index-of": [
    "es.array.index-of"
  ],
  "core-js/stable/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
  "core-js/stable/array/virtual/iterator": [
    "es.array.iterator"
  ],
  "core-js/stable/array/virtual/join": [
    "es.array.join"
  ],
  "core-js/stable/array/virtual/keys": [
    "es.array.iterator"
  ],
  "core-js/stable/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/stable/array/virtual/map": [
    "es.array.map"
  ],
  "core-js/stable/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/stable/array/virtual/reduce": [
    "es.array.reduce"
  ],
  "core-js/stable/array/virtual/reverse": [
    "es.array.reverse"
  ],
  "core-js/stable/array/virtual/slice": [
    "es.array.slice"
  ],
  "core-js/stable/array/virtual/some": [
    "es.array.some"
  ],
  "core-js/stable/array/virtual/sort": [
    "es.array.sort"
  ],
  "core-js/stable/array/virtual/splice": [
    "es.array.splice"
  ],
  "core-js/stable/array/virtual/values": [
    "es.array.iterator"
  ],
  "core-js/stable/clear-immediate": [
    "web.immediate"
  ],
  "core-js/stable/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/stable/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/stable/date/now": [
    "es.date.now"
  ],
  "core-js/stable/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
  "core-js/stable/date/to-json": [
    "es.date.to-json"
  ],
  "core-js/stable/date/to-primitive": [
    "es.date.to-primitive"
  ],
  "core-js/stable/date/to-string": [
    "es.date.to-string"
  ],
  "core-js/stable/dom-collections/for-each": [
    "web.dom-collections.for-each"
  ],
  "core-js/stable/dom-collections": [
    "es.array.iterator",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/dom-collections/iterator": [
    "web.dom-collections.iterator"
  ],
  "core-js/stable/function/bind": [
    "es.function.bind"
  ],
  "core-js/stable/function/has-instance": [
    "es.function.has-instance"
  ],
  "core-js/stable/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
  "core-js/stable/function/name": [
    "es.function.name"
  ],
  "core-js/stable/function/virtual/bind": [
    "es.function.bind"
  ],
  "core-js/stable/function/virtual": [
    "es.function.bind"
  ],
  "core-js/stable/global-this": [
    "es.global-this"
  ],
  "core-js/stable": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/stable/instance/bind": [
    "es.function.bind"
  ],
  "core-js/stable/instance/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/stable/instance/concat": [
    "es.array.concat"
  ],
  "core-js/stable/instance/copy-within": [
    "es.array.copy-within"
  ],
  "core-js/stable/instance/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/stable/instance/entries": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/instance/every": [
    "es.array.every"
  ],
  "core-js/stable/instance/fill": [
    "es.array.fill"
  ],
  "core-js/stable/instance/filter": [
    "es.array.filter"
  ],
  "core-js/stable/instance/find-index": [
    "es.array.find-index"
  ],
  "core-js/stable/instance/find": [
    "es.array.find"
  ],
  "core-js/stable/instance/flags": [
    "es.regexp.flags"
  ],
  "core-js/stable/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
  "core-js/stable/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
  "core-js/stable/instance/for-each": [
    "es.array.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
  "core-js/stable/instance/index-of": [
    "es.array.index-of"
  ],
  "core-js/stable/instance/keys": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/instance/last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/stable/instance/map": [
    "es.array.map"
  ],
  "core-js/stable/instance/match-all": [
    "es.string.match-all"
  ],
  "core-js/stable/instance/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/stable/instance/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/stable/instance/reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/stable/instance/reduce": [
    "es.array.reduce"
  ],
  "core-js/stable/instance/repeat": [
    "es.string.repeat"
  ],
  "core-js/stable/instance/reverse": [
    "es.array.reverse"
  ],
  "core-js/stable/instance/slice": [
    "es.array.slice"
  ],
  "core-js/stable/instance/some": [
    "es.array.some"
  ],
  "core-js/stable/instance/sort": [
    "es.array.sort"
  ],
  "core-js/stable/instance/splice": [
    "es.array.splice"
  ],
  "core-js/stable/instance/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/stable/instance/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/stable/instance/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/stable/instance/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/stable/instance/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/stable/instance/trim": [
    "es.string.trim"
  ],
  "core-js/stable/instance/values": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/json": [
    "es.json.to-string-tag"
  ],
  "core-js/stable/json/stringify": [
    "es.json.stringify"
  ],
  "core-js/stable/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
  "core-js/stable/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/math/acosh": [
    "es.math.acosh"
  ],
  "core-js/stable/math/asinh": [
    "es.math.asinh"
  ],
  "core-js/stable/math/atanh": [
    "es.math.atanh"
  ],
  "core-js/stable/math/cbrt": [
    "es.math.cbrt"
  ],
  "core-js/stable/math/clz32": [
    "es.math.clz32"
  ],
  "core-js/stable/math/cosh": [
    "es.math.cosh"
  ],
  "core-js/stable/math/expm1": [
    "es.math.expm1"
  ],
  "core-js/stable/math/fround": [
    "es.math.fround"
  ],
  "core-js/stable/math/hypot": [
    "es.math.hypot"
  ],
  "core-js/stable/math/imul": [
    "es.math.imul"
  ],
  "core-js/stable/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
  "core-js/stable/math/log10": [
    "es.math.log10"
  ],
  "core-js/stable/math/log1p": [
    "es.math.log1p"
  ],
  "core-js/stable/math/log2": [
    "es.math.log2"
  ],
  "core-js/stable/math/sign": [
    "es.math.sign"
  ],
  "core-js/stable/math/sinh": [
    "es.math.sinh"
  ],
  "core-js/stable/math/tanh": [
    "es.math.tanh"
  ],
  "core-js/stable/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
  "core-js/stable/math/trunc": [
    "es.math.trunc"
  ],
  "core-js/stable/number/constructor": [
    "es.number.constructor"
  ],
  "core-js/stable/number/epsilon": [
    "es.number.epsilon"
  ],
  "core-js/stable/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/stable/number/is-finite": [
    "es.number.is-finite"
  ],
  "core-js/stable/number/is-integer": [
    "es.number.is-integer"
  ],
  "core-js/stable/number/is-nan": [
    "es.number.is-nan"
  ],
  "core-js/stable/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
  "core-js/stable/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
  "core-js/stable/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
  "core-js/stable/number/parse-float": [
    "es.number.parse-float"
  ],
  "core-js/stable/number/parse-int": [
    "es.number.parse-int"
  ],
  "core-js/stable/number/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/stable/number/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/stable/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/stable/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/stable/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
  "core-js/stable/object/assign": [
    "es.object.assign"
  ],
  "core-js/stable/object/create": [
    "es.object.create"
  ],
  "core-js/stable/object/define-getter": [
    "es.object.define-getter"
  ],
  "core-js/stable/object/define-properties": [
    "es.object.define-properties"
  ],
  "core-js/stable/object/define-property": [
    "es.object.define-property"
  ],
  "core-js/stable/object/define-setter": [
    "es.object.define-setter"
  ],
  "core-js/stable/object/entries": [
    "es.object.entries"
  ],
  "core-js/stable/object/freeze": [
    "es.object.freeze"
  ],
  "core-js/stable/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
  "core-js/stable/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
  "core-js/stable/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
  "core-js/stable/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
  "core-js/stable/object/get-own-property-symbols": [
    "es.symbol"
  ],
  "core-js/stable/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
  "core-js/stable/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values"
  ],
  "core-js/stable/object/is-extensible": [
    "es.object.is-extensible"
  ],
  "core-js/stable/object/is-frozen": [
    "es.object.is-frozen"
  ],
  "core-js/stable/object/is-sealed": [
    "es.object.is-sealed"
  ],
  "core-js/stable/object/is": [
    "es.object.is"
  ],
  "core-js/stable/object/keys": [
    "es.object.keys"
  ],
  "core-js/stable/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
  "core-js/stable/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
  "core-js/stable/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
  "core-js/stable/object/seal": [
    "es.object.seal"
  ],
  "core-js/stable/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
  "core-js/stable/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/stable/object/values": [
    "es.object.values"
  ],
  "core-js/stable/parse-float": [
    "es.parse-float"
  ],
  "core-js/stable/parse-int": [
    "es.parse-int"
  ],
  "core-js/stable/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled"
  ],
  "core-js/stable/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
  "core-js/stable/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/queue-microtask": [
    "web.queue-microtask"
  ],
  "core-js/stable/reflect/apply": [
    "es.reflect.apply"
  ],
  "core-js/stable/reflect/construct": [
    "es.reflect.construct"
  ],
  "core-js/stable/reflect/define-property": [
    "es.reflect.define-property"
  ],
  "core-js/stable/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
  "core-js/stable/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
  "core-js/stable/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
  "core-js/stable/reflect/get": [
    "es.reflect.get"
  ],
  "core-js/stable/reflect/has": [
    "es.reflect.has"
  ],
  "core-js/stable/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of"
  ],
  "core-js/stable/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
  "core-js/stable/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
  "core-js/stable/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
  "core-js/stable/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
  "core-js/stable/reflect/set": [
    "es.reflect.set"
  ],
  "core-js/stable/regexp/constructor": [
    "es.regexp.constructor"
  ],
  "core-js/stable/regexp/flags": [
    "es.regexp.flags"
  ],
  "core-js/stable/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/stable/regexp/match": [
    "es.string.match"
  ],
  "core-js/stable/regexp/replace": [
    "es.string.replace"
  ],
  "core-js/stable/regexp/search": [
    "es.string.search"
  ],
  "core-js/stable/regexp/split": [
    "es.string.split"
  ],
  "core-js/stable/regexp/to-string": [
    "es.regexp.to-string"
  ],
  "core-js/stable/set-immediate": [
    "web.immediate"
  ],
  "core-js/stable/set-interval": [
    "web.timers"
  ],
  "core-js/stable/set-timeout": [
    "web.timers"
  ],
  "core-js/stable/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/string/anchor": [
    "es.string.anchor"
  ],
  "core-js/stable/string/big": [
    "es.string.big"
  ],
  "core-js/stable/string/blink": [
    "es.string.blink"
  ],
  "core-js/stable/string/bold": [
    "es.string.bold"
  ],
  "core-js/stable/string/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/stable/string/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/stable/string/fixed": [
    "es.string.fixed"
  ],
  "core-js/stable/string/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/stable/string/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/stable/string/from-code-point": [
    "es.string.from-code-point"
  ],
  "core-js/stable/string/includes": [
    "es.string.includes"
  ],
  "core-js/stable/string": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/stable/string/italics": [
    "es.string.italics"
  ],
  "core-js/stable/string/iterator": [
    "es.string.iterator"
  ],
  "core-js/stable/string/link": [
    "es.string.link"
  ],
  "core-js/stable/string/match-all": [
    "es.string.match-all"
  ],
  "core-js/stable/string/match": [
    "es.string.match"
  ],
  "core-js/stable/string/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/stable/string/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/stable/string/raw": [
    "es.string.raw"
  ],
  "core-js/stable/string/repeat": [
    "es.string.repeat"
  ],
  "core-js/stable/string/replace": [
    "es.string.replace"
  ],
  "core-js/stable/string/search": [
    "es.string.search"
  ],
  "core-js/stable/string/small": [
    "es.string.small"
  ],
  "core-js/stable/string/split": [
    "es.string.split"
  ],
  "core-js/stable/string/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/stable/string/strike": [
    "es.string.strike"
  ],
  "core-js/stable/string/sub": [
    "es.string.sub"
  ],
  "core-js/stable/string/sup": [
    "es.string.sup"
  ],
  "core-js/stable/string/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/stable/string/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/stable/string/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/stable/string/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/stable/string/trim": [
    "es.string.trim"
  ],
  "core-js/stable/string/virtual/anchor": [
    "es.string.anchor"
  ],
  "core-js/stable/string/virtual/big": [
    "es.string.big"
  ],
  "core-js/stable/string/virtual/blink": [
    "es.string.blink"
  ],
  "core-js/stable/string/virtual/bold": [
    "es.string.bold"
  ],
  "core-js/stable/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/stable/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
  "core-js/stable/string/virtual/fixed": [
    "es.string.fixed"
  ],
  "core-js/stable/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/stable/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
  "core-js/stable/string/virtual/includes": [
    "es.string.includes"
  ],
  "core-js/stable/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/stable/string/virtual/italics": [
    "es.string.italics"
  ],
  "core-js/stable/string/virtual/iterator": [
    "es.string.iterator"
  ],
  "core-js/stable/string/virtual/link": [
    "es.string.link"
  ],
  "core-js/stable/string/virtual/match-all": [
    "es.string.match-all"
  ],
  "core-js/stable/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
  "core-js/stable/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
  "core-js/stable/string/virtual/repeat": [
    "es.string.repeat"
  ],
  "core-js/stable/string/virtual/small": [
    "es.string.small"
  ],
  "core-js/stable/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
  "core-js/stable/string/virtual/strike": [
    "es.string.strike"
  ],
  "core-js/stable/string/virtual/sub": [
    "es.string.sub"
  ],
  "core-js/stable/string/virtual/sup": [
    "es.string.sup"
  ],
  "core-js/stable/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
  "core-js/stable/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
  "core-js/stable/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
  "core-js/stable/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
  "core-js/stable/string/virtual/trim": [
    "es.string.trim"
  ],
  "core-js/stable/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
  "core-js/stable/symbol/description": [
    "es.symbol.description"
  ],
  "core-js/stable/symbol/for": [
    "es.symbol"
  ],
  "core-js/stable/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
  "core-js/stable/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/stable/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
  "core-js/stable/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/symbol/key-for": [
    "es.symbol"
  ],
  "core-js/stable/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
  "core-js/stable/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
  "core-js/stable/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
  "core-js/stable/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
  "core-js/stable/symbol/species": [
    "es.symbol.species"
  ],
  "core-js/stable/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
  "core-js/stable/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
  "core-js/stable/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
  "core-js/stable/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
  "core-js/stable/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
  "core-js/stable/typed-array/entries": [
    "es.typed-array.iterator"
  ],
  "core-js/stable/typed-array/every": [
    "es.typed-array.every"
  ],
  "core-js/stable/typed-array/fill": [
    "es.typed-array.fill"
  ],
  "core-js/stable/typed-array/filter": [
    "es.typed-array.filter"
  ],
  "core-js/stable/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
  "core-js/stable/typed-array/find": [
    "es.typed-array.find"
  ],
  "core-js/stable/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
  "core-js/stable/typed-array/from": [
    "es.typed-array.from"
  ],
  "core-js/stable/typed-array/includes": [
    "es.typed-array.includes"
  ],
  "core-js/stable/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
  "core-js/stable/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
  "core-js/stable/typed-array/join": [
    "es.typed-array.join"
  ],
  "core-js/stable/typed-array/keys": [
    "es.typed-array.iterator"
  ],
  "core-js/stable/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
  "core-js/stable/typed-array/map": [
    "es.typed-array.map"
  ],
  "core-js/stable/typed-array/of": [
    "es.typed-array.of"
  ],
  "core-js/stable/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
  "core-js/stable/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
  "core-js/stable/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
  "core-js/stable/typed-array/set": [
    "es.typed-array.set"
  ],
  "core-js/stable/typed-array/slice": [
    "es.typed-array.slice"
  ],
  "core-js/stable/typed-array/some": [
    "es.typed-array.some"
  ],
  "core-js/stable/typed-array/sort": [
    "es.typed-array.sort"
  ],
  "core-js/stable/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
  "core-js/stable/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
  "core-js/stable/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
  "core-js/stable/typed-array/values": [
    "es.typed-array.iterator"
  ],
  "core-js/stable/url-search-params": [
    "web.url-search-params"
  ],
  "core-js/stable/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/stable/url/to-json": [
    "web.url.to-json"
  ],
  "core-js/stable/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
  "core-js/stage/0": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/stage/1": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
  "core-js/stage/2": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.set.difference",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.replace-all",
    "esnext.weak-map.upsert"
  ],
  "core-js/stage/3": [
    "esnext.aggregate-error",
    "esnext.global-this",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.replace-all"
  ],
  "core-js/stage/4": [
    "esnext.global-this",
    "esnext.promise.all-settled",
    "esnext.string.match-all"
  ],
  "core-js/stage": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/stage/pre": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/web/dom-collections": [
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/web/immediate": [
    "web.immediate"
  ],
  "core-js/web": [
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/web/queue-microtask": [
    "web.queue-microtask"
  ],
  "core-js/web/timers": [
    "web.timers"
  ],
  "core-js/web/url-search-params": [
    "web.url-search-params"
  ],
  "core-js/web/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "core-js/modules/es.array-buffer.constructor": [
    "es.array-buffer.constructor"
  ],
  "core-js/modules/es.array-buffer.is-view": [
    "es.array-buffer.is-view"
  ],
  "core-js/modules/es.array-buffer.slice": [
    "es.array-buffer.slice"
  ],
  "core-js/modules/es.array.concat": [
    "es.array.concat"
  ],
  "core-js/modules/es.array.copy-within": [
    "es.array.copy-within"
  ],
  "core-js/modules/es.array.every": [
    "es.array.every"
  ],
  "core-js/modules/es.array.fill": [
    "es.array.fill"
  ],
  "core-js/modules/es.array.filter": [
    "es.array.filter"
  ],
  "core-js/modules/es.array.find-index": [
    "es.array.find-index"
  ],
  "core-js/modules/es.array.find": [
    "es.array.find"
  ],
  "core-js/modules/es.array.flat-map": [
    "es.array.flat-map"
  ],
  "core-js/modules/es.array.flat": [
    "es.array.flat"
  ],
  "core-js/modules/es.array.for-each": [
    "es.array.for-each"
  ],
  "core-js/modules/es.array.from": [
    "es.array.from"
  ],
  "core-js/modules/es.array.includes": [
    "es.array.includes"
  ],
  "core-js/modules/es.array.index-of": [
    "es.array.index-of"
  ],
  "core-js/modules/es.array.is-array": [
    "es.array.is-array"
  ],
  "core-js/modules/es.array.iterator": [
    "es.array.iterator"
  ],
  "core-js/modules/es.array.join": [
    "es.array.join"
  ],
  "core-js/modules/es.array.last-index-of": [
    "es.array.last-index-of"
  ],
  "core-js/modules/es.array.map": [
    "es.array.map"
  ],
  "core-js/modules/es.array.of": [
    "es.array.of"
  ],
  "core-js/modules/es.array.reduce-right": [
    "es.array.reduce-right"
  ],
  "core-js/modules/es.array.reduce": [
    "es.array.reduce"
  ],
  "core-js/modules/es.array.reverse": [
    "es.array.reverse"
  ],
  "core-js/modules/es.array.slice": [
    "es.array.slice"
  ],
  "core-js/modules/es.array.some": [
    "es.array.some"
  ],
  "core-js/modules/es.array.sort": [
    "es.array.sort"
  ],
  "core-js/modules/es.array.species": [
    "es.array.species"
  ],
  "core-js/modules/es.array.splice": [
    "es.array.splice"
  ],
  "core-js/modules/es.array.unscopables.flat-map": [
    "es.array.unscopables.flat-map"
  ],
  "core-js/modules/es.array.unscopables.flat": [
    "es.array.unscopables.flat"
  ],
  "core-js/modules/es.data-view": [
    "es.data-view"
  ],
  "core-js/modules/es.date.now": [
    "es.date.now"
  ],
  "core-js/modules/es.date.to-iso-string": [
    "es.date.to-iso-string"
  ],
  "core-js/modules/es.date.to-json": [
    "es.date.to-json"
  ],
  "core-js/modules/es.date.to-primitive": [
    "es.date.to-primitive"
  ],
  "core-js/modules/es.date.to-string": [
    "es.date.to-string"
  ],
  "core-js/modules/es.function.bind": [
    "es.function.bind"
  ],
  "core-js/modules/es.function.has-instance": [
    "es.function.has-instance"
  ],
  "core-js/modules/es.function.name": [
    "es.function.name"
  ],
  "core-js/modules/es.global-this": [
    "es.global-this"
  ],
  "core-js/modules/es.json.stringify": [
    "es.json.stringify"
  ],
  "core-js/modules/es.json.to-string-tag": [
    "es.json.to-string-tag"
  ],
  "core-js/modules/es.map": [
    "es.map"
  ],
  "core-js/modules/es.math.acosh": [
    "es.math.acosh"
  ],
  "core-js/modules/es.math.asinh": [
    "es.math.asinh"
  ],
  "core-js/modules/es.math.atanh": [
    "es.math.atanh"
  ],
  "core-js/modules/es.math.cbrt": [
    "es.math.cbrt"
  ],
  "core-js/modules/es.math.clz32": [
    "es.math.clz32"
  ],
  "core-js/modules/es.math.cosh": [
    "es.math.cosh"
  ],
  "core-js/modules/es.math.expm1": [
    "es.math.expm1"
  ],
  "core-js/modules/es.math.fround": [
    "es.math.fround"
  ],
  "core-js/modules/es.math.hypot": [
    "es.math.hypot"
  ],
  "core-js/modules/es.math.imul": [
    "es.math.imul"
  ],
  "core-js/modules/es.math.log10": [
    "es.math.log10"
  ],
  "core-js/modules/es.math.log1p": [
    "es.math.log1p"
  ],
  "core-js/modules/es.math.log2": [
    "es.math.log2"
  ],
  "core-js/modules/es.math.sign": [
    "es.math.sign"
  ],
  "core-js/modules/es.math.sinh": [
    "es.math.sinh"
  ],
  "core-js/modules/es.math.tanh": [
    "es.math.tanh"
  ],
  "core-js/modules/es.math.to-string-tag": [
    "es.math.to-string-tag"
  ],
  "core-js/modules/es.math.trunc": [
    "es.math.trunc"
  ],
  "core-js/modules/es.number.constructor": [
    "es.number.constructor"
  ],
  "core-js/modules/es.number.epsilon": [
    "es.number.epsilon"
  ],
  "core-js/modules/es.number.is-finite": [
    "es.number.is-finite"
  ],
  "core-js/modules/es.number.is-integer": [
    "es.number.is-integer"
  ],
  "core-js/modules/es.number.is-nan": [
    "es.number.is-nan"
  ],
  "core-js/modules/es.number.is-safe-integer": [
    "es.number.is-safe-integer"
  ],
  "core-js/modules/es.number.max-safe-integer": [
    "es.number.max-safe-integer"
  ],
  "core-js/modules/es.number.min-safe-integer": [
    "es.number.min-safe-integer"
  ],
  "core-js/modules/es.number.parse-float": [
    "es.number.parse-float"
  ],
  "core-js/modules/es.number.parse-int": [
    "es.number.parse-int"
  ],
  "core-js/modules/es.number.to-fixed": [
    "es.number.to-fixed"
  ],
  "core-js/modules/es.number.to-precision": [
    "es.number.to-precision"
  ],
  "core-js/modules/es.object.assign": [
    "es.object.assign"
  ],
  "core-js/modules/es.object.create": [
    "es.object.create"
  ],
  "core-js/modules/es.object.define-getter": [
    "es.object.define-getter"
  ],
  "core-js/modules/es.object.define-properties": [
    "es.object.define-properties"
  ],
  "core-js/modules/es.object.define-property": [
    "es.object.define-property"
  ],
  "core-js/modules/es.object.define-setter": [
    "es.object.define-setter"
  ],
  "core-js/modules/es.object.entries": [
    "es.object.entries"
  ],
  "core-js/modules/es.object.freeze": [
    "es.object.freeze"
  ],
  "core-js/modules/es.object.from-entries": [
    "es.object.from-entries"
  ],
  "core-js/modules/es.object.get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
  "core-js/modules/es.object.get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
  "core-js/modules/es.object.get-own-property-names": [
    "es.object.get-own-property-names"
  ],
  "core-js/modules/es.object.get-prototype-of": [
    "es.object.get-prototype-of"
  ],
  "core-js/modules/es.object.is-extensible": [
    "es.object.is-extensible"
  ],
  "core-js/modules/es.object.is-frozen": [
    "es.object.is-frozen"
  ],
  "core-js/modules/es.object.is-sealed": [
    "es.object.is-sealed"
  ],
  "core-js/modules/es.object.is": [
    "es.object.is"
  ],
  "core-js/modules/es.object.keys": [
    "es.object.keys"
  ],
  "core-js/modules/es.object.lookup-getter": [
    "es.object.lookup-getter"
  ],
  "core-js/modules/es.object.lookup-setter": [
    "es.object.lookup-setter"
  ],
  "core-js/modules/es.object.prevent-extensions": [
    "es.object.prevent-extensions"
  ],
  "core-js/modules/es.object.seal": [
    "es.object.seal"
  ],
  "core-js/modules/es.object.set-prototype-of": [
    "es.object.set-prototype-of"
  ],
  "core-js/modules/es.object.to-string": [
    "es.object.to-string"
  ],
  "core-js/modules/es.object.values": [
    "es.object.values"
  ],
  "core-js/modules/es.parse-float": [
    "es.parse-float"
  ],
  "core-js/modules/es.parse-int": [
    "es.parse-int"
  ],
  "core-js/modules/es.promise.all-settled": [
    "es.promise.all-settled"
  ],
  "core-js/modules/es.promise.finally": [
    "es.promise.finally"
  ],
  "core-js/modules/es.promise": [
    "es.promise"
  ],
  "core-js/modules/es.reflect.apply": [
    "es.reflect.apply"
  ],
  "core-js/modules/es.reflect.construct": [
    "es.reflect.construct"
  ],
  "core-js/modules/es.reflect.define-property": [
    "es.reflect.define-property"
  ],
  "core-js/modules/es.reflect.delete-property": [
    "es.reflect.delete-property"
  ],
  "core-js/modules/es.reflect.get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
  "core-js/modules/es.reflect.get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
  "core-js/modules/es.reflect.get": [
    "es.reflect.get"
  ],
  "core-js/modules/es.reflect.has": [
    "es.reflect.has"
  ],
  "core-js/modules/es.reflect.is-extensible": [
    "es.reflect.is-extensible"
  ],
  "core-js/modules/es.reflect.own-keys": [
    "es.reflect.own-keys"
  ],
  "core-js/modules/es.reflect.prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
  "core-js/modules/es.reflect.set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
  "core-js/modules/es.reflect.set": [
    "es.reflect.set"
  ],
  "core-js/modules/es.regexp.constructor": [
    "es.regexp.constructor"
  ],
  "core-js/modules/es.regexp.exec": [
    "es.regexp.exec"
  ],
  "core-js/modules/es.regexp.flags": [
    "es.regexp.flags"
  ],
  "core-js/modules/es.regexp.to-string": [
    "es.regexp.to-string"
  ],
  "core-js/modules/es.set": [
    "es.set"
  ],
  "core-js/modules/es.string.anchor": [
    "es.string.anchor"
  ],
  "core-js/modules/es.string.big": [
    "es.string.big"
  ],
  "core-js/modules/es.string.blink": [
    "es.string.blink"
  ],
  "core-js/modules/es.string.bold": [
    "es.string.bold"
  ],
  "core-js/modules/es.string.code-point-at": [
    "es.string.code-point-at"
  ],
  "core-js/modules/es.string.ends-with": [
    "es.string.ends-with"
  ],
  "core-js/modules/es.string.fixed": [
    "es.string.fixed"
  ],
  "core-js/modules/es.string.fontcolor": [
    "es.string.fontcolor"
  ],
  "core-js/modules/es.string.fontsize": [
    "es.string.fontsize"
  ],
  "core-js/modules/es.string.from-code-point": [
    "es.string.from-code-point"
  ],
  "core-js/modules/es.string.includes": [
    "es.string.includes"
  ],
  "core-js/modules/es.string.italics": [
    "es.string.italics"
  ],
  "core-js/modules/es.string.iterator": [
    "es.string.iterator"
  ],
  "core-js/modules/es.string.link": [
    "es.string.link"
  ],
  "core-js/modules/es.string.match-all": [
    "es.string.match-all"
  ],
  "core-js/modules/es.string.match": [
    "es.string.match"
  ],
  "core-js/modules/es.string.pad-end": [
    "es.string.pad-end"
  ],
  "core-js/modules/es.string.pad-start": [
    "es.string.pad-start"
  ],
  "core-js/modules/es.string.raw": [
    "es.string.raw"
  ],
  "core-js/modules/es.string.repeat": [
    "es.string.repeat"
  ],
  "core-js/modules/es.string.replace": [
    "es.string.replace"
  ],
  "core-js/modules/es.string.search": [
    "es.string.search"
  ],
  "core-js/modules/es.string.small": [
    "es.string.small"
  ],
  "core-js/modules/es.string.split": [
    "es.string.split"
  ],
  "core-js/modules/es.string.starts-with": [
    "es.string.starts-with"
  ],
  "core-js/modules/es.string.strike": [
    "es.string.strike"
  ],
  "core-js/modules/es.string.sub": [
    "es.string.sub"
  ],
  "core-js/modules/es.string.sup": [
    "es.string.sup"
  ],
  "core-js/modules/es.string.trim-end": [
    "es.string.trim-end"
  ],
  "core-js/modules/es.string.trim-start": [
    "es.string.trim-start"
  ],
  "core-js/modules/es.string.trim": [
    "es.string.trim"
  ],
  "core-js/modules/es.symbol.async-iterator": [
    "es.symbol.async-iterator"
  ],
  "core-js/modules/es.symbol.description": [
    "es.symbol.description"
  ],
  "core-js/modules/es.symbol.has-instance": [
    "es.symbol.has-instance"
  ],
  "core-js/modules/es.symbol.is-concat-spreadable": [
    "es.symbol.is-concat-spreadable"
  ],
  "core-js/modules/es.symbol.iterator": [
    "es.symbol.iterator"
  ],
  "core-js/modules/es.symbol": [
    "es.symbol"
  ],
  "core-js/modules/es.symbol.match-all": [
    "es.symbol.match-all"
  ],
  "core-js/modules/es.symbol.match": [
    "es.symbol.match"
  ],
  "core-js/modules/es.symbol.replace": [
    "es.symbol.replace"
  ],
  "core-js/modules/es.symbol.search": [
    "es.symbol.search"
  ],
  "core-js/modules/es.symbol.species": [
    "es.symbol.species"
  ],
  "core-js/modules/es.symbol.split": [
    "es.symbol.split"
  ],
  "core-js/modules/es.symbol.to-primitive": [
    "es.symbol.to-primitive"
  ],
  "core-js/modules/es.symbol.to-string-tag": [
    "es.symbol.to-string-tag"
  ],
  "core-js/modules/es.symbol.unscopables": [
    "es.symbol.unscopables"
  ],
  "core-js/modules/es.typed-array.copy-within": [
    "es.typed-array.copy-within"
  ],
  "core-js/modules/es.typed-array.every": [
    "es.typed-array.every"
  ],
  "core-js/modules/es.typed-array.fill": [
    "es.typed-array.fill"
  ],
  "core-js/modules/es.typed-array.filter": [
    "es.typed-array.filter"
  ],
  "core-js/modules/es.typed-array.find-index": [
    "es.typed-array.find-index"
  ],
  "core-js/modules/es.typed-array.find": [
    "es.typed-array.find"
  ],
  "core-js/modules/es.typed-array.float32-array": [
    "es.typed-array.float32-array"
  ],
  "core-js/modules/es.typed-array.float64-array": [
    "es.typed-array.float64-array"
  ],
  "core-js/modules/es.typed-array.for-each": [
    "es.typed-array.for-each"
  ],
  "core-js/modules/es.typed-array.from": [
    "es.typed-array.from"
  ],
  "core-js/modules/es.typed-array.includes": [
    "es.typed-array.includes"
  ],
  "core-js/modules/es.typed-array.index-of": [
    "es.typed-array.index-of"
  ],
  "core-js/modules/es.typed-array.int16-array": [
    "es.typed-array.int16-array"
  ],
  "core-js/modules/es.typed-array.int32-array": [
    "es.typed-array.int32-array"
  ],
  "core-js/modules/es.typed-array.int8-array": [
    "es.typed-array.int8-array"
  ],
  "core-js/modules/es.typed-array.iterator": [
    "es.typed-array.iterator"
  ],
  "core-js/modules/es.typed-array.join": [
    "es.typed-array.join"
  ],
  "core-js/modules/es.typed-array.last-index-of": [
    "es.typed-array.last-index-of"
  ],
  "core-js/modules/es.typed-array.map": [
    "es.typed-array.map"
  ],
  "core-js/modules/es.typed-array.of": [
    "es.typed-array.of"
  ],
  "core-js/modules/es.typed-array.reduce-right": [
    "es.typed-array.reduce-right"
  ],
  "core-js/modules/es.typed-array.reduce": [
    "es.typed-array.reduce"
  ],
  "core-js/modules/es.typed-array.reverse": [
    "es.typed-array.reverse"
  ],
  "core-js/modules/es.typed-array.set": [
    "es.typed-array.set"
  ],
  "core-js/modules/es.typed-array.slice": [
    "es.typed-array.slice"
  ],
  "core-js/modules/es.typed-array.some": [
    "es.typed-array.some"
  ],
  "core-js/modules/es.typed-array.sort": [
    "es.typed-array.sort"
  ],
  "core-js/modules/es.typed-array.subarray": [
    "es.typed-array.subarray"
  ],
  "core-js/modules/es.typed-array.to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
  "core-js/modules/es.typed-array.to-string": [
    "es.typed-array.to-string"
  ],
  "core-js/modules/es.typed-array.uint16-array": [
    "es.typed-array.uint16-array"
  ],
  "core-js/modules/es.typed-array.uint32-array": [
    "es.typed-array.uint32-array"
  ],
  "core-js/modules/es.typed-array.uint8-array": [
    "es.typed-array.uint8-array"
  ],
  "core-js/modules/es.typed-array.uint8-clamped-array": [
    "es.typed-array.uint8-clamped-array"
  ],
  "core-js/modules/es.weak-map": [
    "es.weak-map"
  ],
  "core-js/modules/es.weak-set": [
    "es.weak-set"
  ],
  "core-js/modules/esnext.aggregate-error": [
    "esnext.aggregate-error"
  ],
  "core-js/modules/esnext.array.is-template-object": [
    "esnext.array.is-template-object"
  ],
  "core-js/modules/esnext.array.last-index": [
    "esnext.array.last-index"
  ],
  "core-js/modules/esnext.array.last-item": [
    "esnext.array.last-item"
  ],
  "core-js/modules/esnext.async-iterator.as-indexed-pairs": [
    "esnext.async-iterator.as-indexed-pairs"
  ],
  "core-js/modules/esnext.async-iterator.constructor": [
    "esnext.async-iterator.constructor"
  ],
  "core-js/modules/esnext.async-iterator.drop": [
    "esnext.async-iterator.drop"
  ],
  "core-js/modules/esnext.async-iterator.every": [
    "esnext.async-iterator.every"
  ],
  "core-js/modules/esnext.async-iterator.filter": [
    "esnext.async-iterator.filter"
  ],
  "core-js/modules/esnext.async-iterator.find": [
    "esnext.async-iterator.find"
  ],
  "core-js/modules/esnext.async-iterator.flat-map": [
    "esnext.async-iterator.flat-map"
  ],
  "core-js/modules/esnext.async-iterator.for-each": [
    "esnext.async-iterator.for-each"
  ],
  "core-js/modules/esnext.async-iterator.from": [
    "esnext.async-iterator.from"
  ],
  "core-js/modules/esnext.async-iterator.map": [
    "esnext.async-iterator.map"
  ],
  "core-js/modules/esnext.async-iterator.reduce": [
    "esnext.async-iterator.reduce"
  ],
  "core-js/modules/esnext.async-iterator.some": [
    "esnext.async-iterator.some"
  ],
  "core-js/modules/esnext.async-iterator.take": [
    "esnext.async-iterator.take"
  ],
  "core-js/modules/esnext.async-iterator.to-array": [
    "esnext.async-iterator.to-array"
  ],
  "core-js/modules/esnext.composite-key": [
    "esnext.composite-key"
  ],
  "core-js/modules/esnext.composite-symbol": [
    "esnext.composite-symbol"
  ],
  "core-js/modules/esnext.global-this": [
    "esnext.global-this"
  ],
  "core-js/modules/esnext.iterator.as-indexed-pairs": [
    "esnext.iterator.as-indexed-pairs"
  ],
  "core-js/modules/esnext.iterator.constructor": [
    "esnext.iterator.constructor"
  ],
  "core-js/modules/esnext.iterator.drop": [
    "esnext.iterator.drop"
  ],
  "core-js/modules/esnext.iterator.every": [
    "esnext.iterator.every"
  ],
  "core-js/modules/esnext.iterator.filter": [
    "esnext.iterator.filter"
  ],
  "core-js/modules/esnext.iterator.find": [
    "esnext.iterator.find"
  ],
  "core-js/modules/esnext.iterator.flat-map": [
    "esnext.iterator.flat-map"
  ],
  "core-js/modules/esnext.iterator.for-each": [
    "esnext.iterator.for-each"
  ],
  "core-js/modules/esnext.iterator.from": [
    "esnext.iterator.from"
  ],
  "core-js/modules/esnext.iterator.map": [
    "esnext.iterator.map"
  ],
  "core-js/modules/esnext.iterator.reduce": [
    "esnext.iterator.reduce"
  ],
  "core-js/modules/esnext.iterator.some": [
    "esnext.iterator.some"
  ],
  "core-js/modules/esnext.iterator.take": [
    "esnext.iterator.take"
  ],
  "core-js/modules/esnext.iterator.to-array": [
    "esnext.iterator.to-array"
  ],
  "core-js/modules/esnext.map.delete-all": [
    "esnext.map.delete-all"
  ],
  "core-js/modules/esnext.map.every": [
    "esnext.map.every"
  ],
  "core-js/modules/esnext.map.filter": [
    "esnext.map.filter"
  ],
  "core-js/modules/esnext.map.find-key": [
    "esnext.map.find-key"
  ],
  "core-js/modules/esnext.map.find": [
    "esnext.map.find"
  ],
  "core-js/modules/esnext.map.from": [
    "esnext.map.from"
  ],
  "core-js/modules/esnext.map.group-by": [
    "esnext.map.group-by"
  ],
  "core-js/modules/esnext.map.includes": [
    "esnext.map.includes"
  ],
  "core-js/modules/esnext.map.key-by": [
    "esnext.map.key-by"
  ],
  "core-js/modules/esnext.map.key-of": [
    "esnext.map.key-of"
  ],
  "core-js/modules/esnext.map.map-keys": [
    "esnext.map.map-keys"
  ],
  "core-js/modules/esnext.map.map-values": [
    "esnext.map.map-values"
  ],
  "core-js/modules/esnext.map.merge": [
    "esnext.map.merge"
  ],
  "core-js/modules/esnext.map.of": [
    "esnext.map.of"
  ],
  "core-js/modules/esnext.map.reduce": [
    "esnext.map.reduce"
  ],
  "core-js/modules/esnext.map.some": [
    "esnext.map.some"
  ],
  "core-js/modules/esnext.map.update-or-insert": [
    "esnext.map.update-or-insert"
  ],
  "core-js/modules/esnext.map.update": [
    "esnext.map.update"
  ],
  "core-js/modules/esnext.map.upsert": [
    "esnext.map.upsert"
  ],
  "core-js/modules/esnext.math.clamp": [
    "esnext.math.clamp"
  ],
  "core-js/modules/esnext.math.deg-per-rad": [
    "esnext.math.deg-per-rad"
  ],
  "core-js/modules/esnext.math.degrees": [
    "esnext.math.degrees"
  ],
  "core-js/modules/esnext.math.fscale": [
    "esnext.math.fscale"
  ],
  "core-js/modules/esnext.math.iaddh": [
    "esnext.math.iaddh"
  ],
  "core-js/modules/esnext.math.imulh": [
    "esnext.math.imulh"
  ],
  "core-js/modules/esnext.math.isubh": [
    "esnext.math.isubh"
  ],
  "core-js/modules/esnext.math.rad-per-deg": [
    "esnext.math.rad-per-deg"
  ],
  "core-js/modules/esnext.math.radians": [
    "esnext.math.radians"
  ],
  "core-js/modules/esnext.math.scale": [
    "esnext.math.scale"
  ],
  "core-js/modules/esnext.math.seeded-prng": [
    "esnext.math.seeded-prng"
  ],
  "core-js/modules/esnext.math.signbit": [
    "esnext.math.signbit"
  ],
  "core-js/modules/esnext.math.umulh": [
    "esnext.math.umulh"
  ],
  "core-js/modules/esnext.number.from-string": [
    "esnext.number.from-string"
  ],
  "core-js/modules/esnext.observable": [
    "esnext.observable"
  ],
  "core-js/modules/esnext.promise.all-settled": [
    "esnext.promise.all-settled"
  ],
  "core-js/modules/esnext.promise.any": [
    "esnext.promise.any"
  ],
  "core-js/modules/esnext.promise.try": [
    "esnext.promise.try"
  ],
  "core-js/modules/esnext.reflect.define-metadata": [
    "esnext.reflect.define-metadata"
  ],
  "core-js/modules/esnext.reflect.delete-metadata": [
    "esnext.reflect.delete-metadata"
  ],
  "core-js/modules/esnext.reflect.get-metadata-keys": [
    "esnext.reflect.get-metadata-keys"
  ],
  "core-js/modules/esnext.reflect.get-metadata": [
    "esnext.reflect.get-metadata"
  ],
  "core-js/modules/esnext.reflect.get-own-metadata-keys": [
    "esnext.reflect.get-own-metadata-keys"
  ],
  "core-js/modules/esnext.reflect.get-own-metadata": [
    "esnext.reflect.get-own-metadata"
  ],
  "core-js/modules/esnext.reflect.has-metadata": [
    "esnext.reflect.has-metadata"
  ],
  "core-js/modules/esnext.reflect.has-own-metadata": [
    "esnext.reflect.has-own-metadata"
  ],
  "core-js/modules/esnext.reflect.metadata": [
    "esnext.reflect.metadata"
  ],
  "core-js/modules/esnext.set.add-all": [
    "esnext.set.add-all"
  ],
  "core-js/modules/esnext.set.delete-all": [
    "esnext.set.delete-all"
  ],
  "core-js/modules/esnext.set.difference": [
    "esnext.set.difference"
  ],
  "core-js/modules/esnext.set.every": [
    "esnext.set.every"
  ],
  "core-js/modules/esnext.set.filter": [
    "esnext.set.filter"
  ],
  "core-js/modules/esnext.set.find": [
    "esnext.set.find"
  ],
  "core-js/modules/esnext.set.from": [
    "esnext.set.from"
  ],
  "core-js/modules/esnext.set.intersection": [
    "esnext.set.intersection"
  ],
  "core-js/modules/esnext.set.is-disjoint-from": [
    "esnext.set.is-disjoint-from"
  ],
  "core-js/modules/esnext.set.is-subset-of": [
    "esnext.set.is-subset-of"
  ],
  "core-js/modules/esnext.set.is-superset-of": [
    "esnext.set.is-superset-of"
  ],
  "core-js/modules/esnext.set.join": [
    "esnext.set.join"
  ],
  "core-js/modules/esnext.set.map": [
    "esnext.set.map"
  ],
  "core-js/modules/esnext.set.of": [
    "esnext.set.of"
  ],
  "core-js/modules/esnext.set.reduce": [
    "esnext.set.reduce"
  ],
  "core-js/modules/esnext.set.some": [
    "esnext.set.some"
  ],
  "core-js/modules/esnext.set.symmetric-difference": [
    "esnext.set.symmetric-difference"
  ],
  "core-js/modules/esnext.set.union": [
    "esnext.set.union"
  ],
  "core-js/modules/esnext.string.at": [
    "esnext.string.at"
  ],
  "core-js/modules/esnext.string.code-points": [
    "esnext.string.code-points"
  ],
  "core-js/modules/esnext.string.match-all": [
    "esnext.string.match-all"
  ],
  "core-js/modules/esnext.string.replace-all": [
    "esnext.string.replace-all"
  ],
  "core-js/modules/esnext.symbol.async-dispose": [
    "esnext.symbol.async-dispose"
  ],
  "core-js/modules/esnext.symbol.dispose": [
    "esnext.symbol.dispose"
  ],
  "core-js/modules/esnext.symbol.observable": [
    "esnext.symbol.observable"
  ],
  "core-js/modules/esnext.symbol.pattern-match": [
    "esnext.symbol.pattern-match"
  ],
  "core-js/modules/esnext.symbol.replace-all": [
    "esnext.symbol.replace-all"
  ],
  "core-js/modules/esnext.weak-map.delete-all": [
    "esnext.weak-map.delete-all"
  ],
  "core-js/modules/esnext.weak-map.from": [
    "esnext.weak-map.from"
  ],
  "core-js/modules/esnext.weak-map.of": [
    "esnext.weak-map.of"
  ],
  "core-js/modules/esnext.weak-map.upsert": [
    "esnext.weak-map.upsert"
  ],
  "core-js/modules/esnext.weak-set.add-all": [
    "esnext.weak-set.add-all"
  ],
  "core-js/modules/esnext.weak-set.delete-all": [
    "esnext.weak-set.delete-all"
  ],
  "core-js/modules/esnext.weak-set.from": [
    "esnext.weak-set.from"
  ],
  "core-js/modules/esnext.weak-set.of": [
    "esnext.weak-set.of"
  ],
  "core-js/modules/web.dom-collections.for-each": [
    "web.dom-collections.for-each"
  ],
  "core-js/modules/web.dom-collections.iterator": [
    "web.dom-collections.iterator"
  ],
  "core-js/modules/web.immediate": [
    "web.immediate"
  ],
  "core-js/modules/web.queue-microtask": [
    "web.queue-microtask"
  ],
  "core-js/modules/web.timers": [
    "web.timers"
  ],
  "core-js/modules/web.url-search-params": [
    "web.url-search-params"
  ],
  "core-js/modules/web.url": [
    "web.url"
  ],
  "core-js/modules/web.url.to-json": [
    "web.url.to-json"
  ]
}
},{}],305:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _require = require('semver'),
    coerce = _require.coerce,
    lte = _require.lte;

var modulesByVersions = require('./modules-by-versions');

module.exports = function (raw) {
  var corejs = coerce(String(raw));

  if (corejs.major !== 3) {
    throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
  }

  var result = [];

  for (var _i = 0, _Object$keys = Object.keys(modulesByVersions); _i < _Object$keys.length; _i++) {
    var version = _Object$keys[_i];

    if (lte(coerce(version), corejs)) {
      result.push.apply(result, _toConsumableArray(modulesByVersions[version]));
    }
  }

  return result;
};

},{"./modules-by-versions":306,"semver":307}],306:[function(require,module,exports){
module.exports={
  "3.0": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  "3.1": [
    "es.string.match-all",
    "es.symbol.match-all",
    "esnext.symbol.replace-all"
  ],
  "3.2": [
    "es.promise.all-settled",
    "esnext.array.is-template-object",
    "esnext.map.update-or-insert",
    "esnext.symbol.async-dispose"
  ],
  "3.3": [
    "es.global-this",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
  "3.4": [
    "es.json.stringify"
  ]
}
},{}],307:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function debug() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function debug() {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var t = exports.tokens = {};
var R = 0;

function tok(n) {
  t[n] = R++;
} // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


tok('NUMERICIDENTIFIER');
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
tok('NUMERICIDENTIFIERLOOSE');
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER');
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION');
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
tok('MAINVERSIONLOOSE');
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER');
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
tok('PRERELEASEIDENTIFIERLOOSE');
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE');
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
tok('PRERELEASELOOSE');
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER');
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD');
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL');
tok('FULLPLAIN');
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

tok('LOOSEPLAIN');
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
tok('LOOSE');
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
tok('GTLT');
src[t.GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

tok('XRANGEIDENTIFIERLOOSE');
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
tok('XRANGEIDENTIFIER');
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
tok('XRANGEPLAIN');
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGEPLAINLOOSE');
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGE');
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
tok('XRANGELOOSE');
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

tok('COERCE');
src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
tok('COERCERTL');
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.
// Meaning is "reasonably at or greater than"

tok('LONETILDE');
src[t.LONETILDE] = '(?:~>?)';
tok('TILDETRIM');
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
tok('TILDE');
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
tok('TILDELOOSE');
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

tok('LONECARET');
src[t.LONECARET] = '(?:\\^)';
tok('CARETTRIM');
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
var caretTrimReplace = '$1^';
tok('CARET');
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
tok('CARETLOOSE');
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

tok('COMPARATORLOOSE');
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
tok('COMPARATOR');
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

tok('COMPARATORTRIM');
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

tok('HYPHENRANGE');
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
tok('HYPHENRANGELOOSE');
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

tok('STAR');
src[t.STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
};

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  var i = 0;

  do {
    var a = this.build[i];
    var b = other.build[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.compareBuild = compareBuild;

function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a === b;

    case '!==':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1] !== undefined ? m[1] : '';

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY || version === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    if (this.value === '') {
      return true;
    }

    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true;
    }

    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
      return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // take a set of comparators and determine whether there
// exists a version which can satisfy it


function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
} // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr;
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[t.STAR], '');
} // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
}

}).call(this,require('_process'))
},{"_process":1054}],308:[function(require,module,exports){
require('../modules/es.symbol');
require('../modules/es.symbol.async-iterator');
require('../modules/es.symbol.description');
require('../modules/es.symbol.has-instance');
require('../modules/es.symbol.is-concat-spreadable');
require('../modules/es.symbol.iterator');
require('../modules/es.symbol.match');
require('../modules/es.symbol.match-all');
require('../modules/es.symbol.replace');
require('../modules/es.symbol.search');
require('../modules/es.symbol.species');
require('../modules/es.symbol.split');
require('../modules/es.symbol.to-primitive');
require('../modules/es.symbol.to-string-tag');
require('../modules/es.symbol.unscopables');
require('../modules/es.object.assign');
require('../modules/es.object.create');
require('../modules/es.object.define-property');
require('../modules/es.object.define-properties');
require('../modules/es.object.entries');
require('../modules/es.object.freeze');
require('../modules/es.object.from-entries');
require('../modules/es.object.get-own-property-descriptor');
require('../modules/es.object.get-own-property-descriptors');
require('../modules/es.object.get-own-property-names');
require('../modules/es.object.get-prototype-of');
require('../modules/es.object.is');
require('../modules/es.object.is-extensible');
require('../modules/es.object.is-frozen');
require('../modules/es.object.is-sealed');
require('../modules/es.object.keys');
require('../modules/es.object.prevent-extensions');
require('../modules/es.object.seal');
require('../modules/es.object.set-prototype-of');
require('../modules/es.object.values');
require('../modules/es.object.to-string');
require('../modules/es.object.define-getter');
require('../modules/es.object.define-setter');
require('../modules/es.object.lookup-getter');
require('../modules/es.object.lookup-setter');
require('../modules/es.function.bind');
require('../modules/es.function.name');
require('../modules/es.function.has-instance');
require('../modules/es.global-this');
require('../modules/es.array.from');
require('../modules/es.array.is-array');
require('../modules/es.array.of');
require('../modules/es.array.concat');
require('../modules/es.array.copy-within');
require('../modules/es.array.every');
require('../modules/es.array.fill');
require('../modules/es.array.filter');
require('../modules/es.array.find');
require('../modules/es.array.find-index');
require('../modules/es.array.flat');
require('../modules/es.array.flat-map');
require('../modules/es.array.for-each');
require('../modules/es.array.includes');
require('../modules/es.array.index-of');
require('../modules/es.array.join');
require('../modules/es.array.last-index-of');
require('../modules/es.array.map');
require('../modules/es.array.reduce');
require('../modules/es.array.reduce-right');
require('../modules/es.array.reverse');
require('../modules/es.array.slice');
require('../modules/es.array.some');
require('../modules/es.array.sort');
require('../modules/es.array.splice');
require('../modules/es.array.species');
require('../modules/es.array.unscopables.flat');
require('../modules/es.array.unscopables.flat-map');
require('../modules/es.array.iterator');
require('../modules/es.string.from-code-point');
require('../modules/es.string.raw');
require('../modules/es.string.code-point-at');
require('../modules/es.string.ends-with');
require('../modules/es.string.includes');
require('../modules/es.string.match');
require('../modules/es.string.match-all');
require('../modules/es.string.pad-end');
require('../modules/es.string.pad-start');
require('../modules/es.string.repeat');
require('../modules/es.string.replace');
require('../modules/es.string.search');
require('../modules/es.string.split');
require('../modules/es.string.starts-with');
require('../modules/es.string.trim');
require('../modules/es.string.trim-start');
require('../modules/es.string.trim-end');
require('../modules/es.string.iterator');
require('../modules/es.string.anchor');
require('../modules/es.string.big');
require('../modules/es.string.blink');
require('../modules/es.string.bold');
require('../modules/es.string.fixed');
require('../modules/es.string.fontcolor');
require('../modules/es.string.fontsize');
require('../modules/es.string.italics');
require('../modules/es.string.link');
require('../modules/es.string.small');
require('../modules/es.string.strike');
require('../modules/es.string.sub');
require('../modules/es.string.sup');
require('../modules/es.regexp.constructor');
require('../modules/es.regexp.exec');
require('../modules/es.regexp.flags');
require('../modules/es.regexp.to-string');
require('../modules/es.parse-int');
require('../modules/es.parse-float');
require('../modules/es.number.constructor');
require('../modules/es.number.epsilon');
require('../modules/es.number.is-finite');
require('../modules/es.number.is-integer');
require('../modules/es.number.is-nan');
require('../modules/es.number.is-safe-integer');
require('../modules/es.number.max-safe-integer');
require('../modules/es.number.min-safe-integer');
require('../modules/es.number.parse-float');
require('../modules/es.number.parse-int');
require('../modules/es.number.to-fixed');
require('../modules/es.number.to-precision');
require('../modules/es.math.acosh');
require('../modules/es.math.asinh');
require('../modules/es.math.atanh');
require('../modules/es.math.cbrt');
require('../modules/es.math.clz32');
require('../modules/es.math.cosh');
require('../modules/es.math.expm1');
require('../modules/es.math.fround');
require('../modules/es.math.hypot');
require('../modules/es.math.imul');
require('../modules/es.math.log10');
require('../modules/es.math.log1p');
require('../modules/es.math.log2');
require('../modules/es.math.sign');
require('../modules/es.math.sinh');
require('../modules/es.math.tanh');
require('../modules/es.math.to-string-tag');
require('../modules/es.math.trunc');
require('../modules/es.date.now');
require('../modules/es.date.to-json');
require('../modules/es.date.to-iso-string');
require('../modules/es.date.to-string');
require('../modules/es.date.to-primitive');
require('../modules/es.json.to-string-tag');
require('../modules/es.promise');
require('../modules/es.promise.all-settled');
require('../modules/es.promise.finally');
require('../modules/es.map');
require('../modules/es.set');
require('../modules/es.weak-map');
require('../modules/es.weak-set');
require('../modules/es.array-buffer.constructor');
require('../modules/es.array-buffer.is-view');
require('../modules/es.array-buffer.slice');
require('../modules/es.data-view');
require('../modules/es.typed-array.int8-array');
require('../modules/es.typed-array.uint8-array');
require('../modules/es.typed-array.uint8-clamped-array');
require('../modules/es.typed-array.int16-array');
require('../modules/es.typed-array.uint16-array');
require('../modules/es.typed-array.int32-array');
require('../modules/es.typed-array.uint32-array');
require('../modules/es.typed-array.float32-array');
require('../modules/es.typed-array.float64-array');
require('../modules/es.typed-array.from');
require('../modules/es.typed-array.of');
require('../modules/es.typed-array.copy-within');
require('../modules/es.typed-array.every');
require('../modules/es.typed-array.fill');
require('../modules/es.typed-array.filter');
require('../modules/es.typed-array.find');
require('../modules/es.typed-array.find-index');
require('../modules/es.typed-array.for-each');
require('../modules/es.typed-array.includes');
require('../modules/es.typed-array.index-of');
require('../modules/es.typed-array.iterator');
require('../modules/es.typed-array.join');
require('../modules/es.typed-array.last-index-of');
require('../modules/es.typed-array.map');
require('../modules/es.typed-array.reduce');
require('../modules/es.typed-array.reduce-right');
require('../modules/es.typed-array.reverse');
require('../modules/es.typed-array.set');
require('../modules/es.typed-array.slice');
require('../modules/es.typed-array.some');
require('../modules/es.typed-array.sort');
require('../modules/es.typed-array.subarray');
require('../modules/es.typed-array.to-locale-string');
require('../modules/es.typed-array.to-string');
require('../modules/es.reflect.apply');
require('../modules/es.reflect.construct');
require('../modules/es.reflect.define-property');
require('../modules/es.reflect.delete-property');
require('../modules/es.reflect.get');
require('../modules/es.reflect.get-own-property-descriptor');
require('../modules/es.reflect.get-prototype-of');
require('../modules/es.reflect.has');
require('../modules/es.reflect.is-extensible');
require('../modules/es.reflect.own-keys');
require('../modules/es.reflect.prevent-extensions');
require('../modules/es.reflect.set');
require('../modules/es.reflect.set-prototype-of');

module.exports = require('../internals/path');

},{"../internals/path":430,"../modules/es.array-buffer.constructor":476,"../modules/es.array-buffer.is-view":477,"../modules/es.array-buffer.slice":478,"../modules/es.array.concat":479,"../modules/es.array.copy-within":480,"../modules/es.array.every":481,"../modules/es.array.fill":482,"../modules/es.array.filter":483,"../modules/es.array.find":485,"../modules/es.array.find-index":484,"../modules/es.array.flat":487,"../modules/es.array.flat-map":486,"../modules/es.array.for-each":488,"../modules/es.array.from":489,"../modules/es.array.includes":490,"../modules/es.array.index-of":491,"../modules/es.array.is-array":492,"../modules/es.array.iterator":493,"../modules/es.array.join":494,"../modules/es.array.last-index-of":495,"../modules/es.array.map":496,"../modules/es.array.of":497,"../modules/es.array.reduce":499,"../modules/es.array.reduce-right":498,"../modules/es.array.reverse":500,"../modules/es.array.slice":501,"../modules/es.array.some":502,"../modules/es.array.sort":503,"../modules/es.array.species":504,"../modules/es.array.splice":505,"../modules/es.array.unscopables.flat":507,"../modules/es.array.unscopables.flat-map":506,"../modules/es.data-view":508,"../modules/es.date.now":509,"../modules/es.date.to-iso-string":510,"../modules/es.date.to-json":511,"../modules/es.date.to-primitive":512,"../modules/es.date.to-string":513,"../modules/es.function.bind":514,"../modules/es.function.has-instance":515,"../modules/es.function.name":516,"../modules/es.global-this":517,"../modules/es.json.to-string-tag":518,"../modules/es.map":519,"../modules/es.math.acosh":520,"../modules/es.math.asinh":521,"../modules/es.math.atanh":522,"../modules/es.math.cbrt":523,"../modules/es.math.clz32":524,"../modules/es.math.cosh":525,"../modules/es.math.expm1":526,"../modules/es.math.fround":527,"../modules/es.math.hypot":528,"../modules/es.math.imul":529,"../modules/es.math.log10":530,"../modules/es.math.log1p":531,"../modules/es.math.log2":532,"../modules/es.math.sign":533,"../modules/es.math.sinh":534,"../modules/es.math.tanh":535,"../modules/es.math.to-string-tag":536,"../modules/es.math.trunc":537,"../modules/es.number.constructor":538,"../modules/es.number.epsilon":539,"../modules/es.number.is-finite":540,"../modules/es.number.is-integer":541,"../modules/es.number.is-nan":542,"../modules/es.number.is-safe-integer":543,"../modules/es.number.max-safe-integer":544,"../modules/es.number.min-safe-integer":545,"../modules/es.number.parse-float":546,"../modules/es.number.parse-int":547,"../modules/es.number.to-fixed":548,"../modules/es.number.to-precision":549,"../modules/es.object.assign":550,"../modules/es.object.create":551,"../modules/es.object.define-getter":552,"../modules/es.object.define-properties":553,"../modules/es.object.define-property":554,"../modules/es.object.define-setter":555,"../modules/es.object.entries":556,"../modules/es.object.freeze":557,"../modules/es.object.from-entries":558,"../modules/es.object.get-own-property-descriptor":559,"../modules/es.object.get-own-property-descriptors":560,"../modules/es.object.get-own-property-names":561,"../modules/es.object.get-prototype-of":562,"../modules/es.object.is":566,"../modules/es.object.is-extensible":563,"../modules/es.object.is-frozen":564,"../modules/es.object.is-sealed":565,"../modules/es.object.keys":567,"../modules/es.object.lookup-getter":568,"../modules/es.object.lookup-setter":569,"../modules/es.object.prevent-extensions":570,"../modules/es.object.seal":571,"../modules/es.object.set-prototype-of":572,"../modules/es.object.to-string":573,"../modules/es.object.values":574,"../modules/es.parse-float":575,"../modules/es.parse-int":576,"../modules/es.promise":579,"../modules/es.promise.all-settled":577,"../modules/es.promise.finally":578,"../modules/es.reflect.apply":580,"../modules/es.reflect.construct":581,"../modules/es.reflect.define-property":582,"../modules/es.reflect.delete-property":583,"../modules/es.reflect.get":586,"../modules/es.reflect.get-own-property-descriptor":584,"../modules/es.reflect.get-prototype-of":585,"../modules/es.reflect.has":587,"../modules/es.reflect.is-extensible":588,"../modules/es.reflect.own-keys":589,"../modules/es.reflect.prevent-extensions":590,"../modules/es.reflect.set":592,"../modules/es.reflect.set-prototype-of":591,"../modules/es.regexp.constructor":593,"../modules/es.regexp.exec":594,"../modules/es.regexp.flags":595,"../modules/es.regexp.to-string":596,"../modules/es.set":597,"../modules/es.string.anchor":598,"../modules/es.string.big":599,"../modules/es.string.blink":600,"../modules/es.string.bold":601,"../modules/es.string.code-point-at":602,"../modules/es.string.ends-with":603,"../modules/es.string.fixed":604,"../modules/es.string.fontcolor":605,"../modules/es.string.fontsize":606,"../modules/es.string.from-code-point":607,"../modules/es.string.includes":608,"../modules/es.string.italics":609,"../modules/es.string.iterator":610,"../modules/es.string.link":611,"../modules/es.string.match":613,"../modules/es.string.match-all":612,"../modules/es.string.pad-end":614,"../modules/es.string.pad-start":615,"../modules/es.string.raw":616,"../modules/es.string.repeat":617,"../modules/es.string.replace":618,"../modules/es.string.search":619,"../modules/es.string.small":620,"../modules/es.string.split":621,"../modules/es.string.starts-with":622,"../modules/es.string.strike":623,"../modules/es.string.sub":624,"../modules/es.string.sup":625,"../modules/es.string.trim":628,"../modules/es.string.trim-end":626,"../modules/es.string.trim-start":627,"../modules/es.symbol":634,"../modules/es.symbol.async-iterator":629,"../modules/es.symbol.description":630,"../modules/es.symbol.has-instance":631,"../modules/es.symbol.is-concat-spreadable":632,"../modules/es.symbol.iterator":633,"../modules/es.symbol.match":636,"../modules/es.symbol.match-all":635,"../modules/es.symbol.replace":637,"../modules/es.symbol.search":638,"../modules/es.symbol.species":639,"../modules/es.symbol.split":640,"../modules/es.symbol.to-primitive":641,"../modules/es.symbol.to-string-tag":642,"../modules/es.symbol.unscopables":643,"../modules/es.typed-array.copy-within":644,"../modules/es.typed-array.every":645,"../modules/es.typed-array.fill":646,"../modules/es.typed-array.filter":647,"../modules/es.typed-array.find":649,"../modules/es.typed-array.find-index":648,"../modules/es.typed-array.float32-array":650,"../modules/es.typed-array.float64-array":651,"../modules/es.typed-array.for-each":652,"../modules/es.typed-array.from":653,"../modules/es.typed-array.includes":654,"../modules/es.typed-array.index-of":655,"../modules/es.typed-array.int16-array":656,"../modules/es.typed-array.int32-array":657,"../modules/es.typed-array.int8-array":658,"../modules/es.typed-array.iterator":659,"../modules/es.typed-array.join":660,"../modules/es.typed-array.last-index-of":661,"../modules/es.typed-array.map":662,"../modules/es.typed-array.of":663,"../modules/es.typed-array.reduce":665,"../modules/es.typed-array.reduce-right":664,"../modules/es.typed-array.reverse":666,"../modules/es.typed-array.set":667,"../modules/es.typed-array.slice":668,"../modules/es.typed-array.some":669,"../modules/es.typed-array.sort":670,"../modules/es.typed-array.subarray":671,"../modules/es.typed-array.to-locale-string":672,"../modules/es.typed-array.to-string":673,"../modules/es.typed-array.uint16-array":674,"../modules/es.typed-array.uint32-array":675,"../modules/es.typed-array.uint8-array":676,"../modules/es.typed-array.uint8-clamped-array":677,"../modules/es.weak-map":678,"../modules/es.weak-set":679}],309:[function(require,module,exports){
require('./es');
require('./proposals');
require('./web');

module.exports = require('./internals/path');

},{"./es":308,"./internals/path":430,"./proposals":802,"./web":830}],310:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};

},{}],311:[function(require,module,exports){
var isObject = require('../internals/is-object');

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};

},{"../internals/is-object":392}],312:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, create(null));
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

},{"../internals/create-non-enumerable-property":350,"../internals/object-create":413,"../internals/well-known-symbol":473}],313:[function(require,module,exports){
'use strict';
var charAt = require('../internals/string-multibyte').charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};

},{"../internals/string-multibyte":451}],314:[function(require,module,exports){
module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};

},{}],315:[function(require,module,exports){
var isObject = require('../internals/is-object');

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

},{"../internals/is-object":392}],316:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var classof = require('../internals/classof');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var defineProperty = require('../internals/object-define-property').f;
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var uid = require('../internals/uid');

var DataView = global.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && DataView);
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportProto = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportStatic = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

// WebKit bug - the same parent prototype for typed arrays and data view
if (NATIVE_ARRAY_BUFFER && setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
  setPrototypeOf(DataViewPrototype, ObjectPrototype);
}

module.exports = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportProto: exportProto,
  exportStatic: exportStatic,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

},{"../internals/classof":334,"../internals/create-non-enumerable-property":350,"../internals/descriptors":357,"../internals/global":377,"../internals/has":378,"../internals/is-object":392,"../internals/object-define-property":415,"../internals/object-get-prototype-of":420,"../internals/object-set-prototype-of":424,"../internals/redefine":435,"../internals/uid":469,"../internals/well-known-symbol":473}],317:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var fails = require('../internals/fails');
var anInstance = require('../internals/an-instance');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var defineProperty = require('../internals/object-define-property').f;
var arrayFill = require('../internals/array-fill');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpackIEEE754 = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

},{"../internals/an-instance":314,"../internals/array-buffer-view-core":316,"../internals/array-fill":319,"../internals/create-non-enumerable-property":350,"../internals/descriptors":357,"../internals/fails":362,"../internals/global":377,"../internals/internal-state":386,"../internals/object-define-property":415,"../internals/object-get-own-property-names":418,"../internals/redefine-all":434,"../internals/set-to-string-tag":445,"../internals/to-index":458,"../internals/to-integer":460,"../internals/to-length":461}],318:[function(require,module,exports){
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"../internals/to-absolute-index":457,"../internals/to-length":461,"../internals/to-object":462}],319:[function(require,module,exports){
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"../internals/to-absolute-index":457,"../internals/to-length":461,"../internals/to-object":462}],320:[function(require,module,exports){
'use strict';
var $forEach = require('../internals/array-iteration').forEach;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = sloppyArrayMethod('forEach') ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

},{"../internals/array-iteration":323,"../internals/sloppy-array-method":449}],321:[function(require,module,exports){
'use strict';
var bind = require('../internals/bind-context');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var getIteratorMethod = require('../internals/get-iterator-method');

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var index = 0;
  var iteratorMethod = getIteratorMethod(O);
  var length, result, step, iterator, next;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      createProperty(result, index, mapping
        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
        : step.value
      );
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
    }
  }
  result.length = index;
  return result;
};

},{"../internals/bind-context":330,"../internals/call-with-safe-iteration-closing":331,"../internals/create-property":352,"../internals/get-iterator-method":373,"../internals/is-array-iterator-method":387,"../internals/to-length":461,"../internals/to-object":462}],322:[function(require,module,exports){
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

},{"../internals/to-absolute-index":457,"../internals/to-indexed-object":459,"../internals/to-length":461}],323:[function(require,module,exports){
var bind = require('../internals/bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var arraySpeciesCreate = require('../internals/array-species-create');

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};

},{"../internals/array-species-create":327,"../internals/bind-context":330,"../internals/indexed-object":383,"../internals/to-length":461,"../internals/to-object":462}],324:[function(require,module,exports){
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var sloppyArrayMethod = require('../internals/sloppy-array-method');

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('lastIndexOf');

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = (NEGATIVE_ZERO || SLOPPY_METHOD) ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;

},{"../internals/sloppy-array-method":449,"../internals/to-indexed-object":459,"../internals/to-integer":460,"../internals/to-length":461}],325:[function(require,module,exports){
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/v8-version');

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

},{"../internals/fails":362,"../internals/v8-version":471,"../internals/well-known-symbol":473}],326:[function(require,module,exports){
var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
var toLength = require('../internals/to-length');

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

},{"../internals/a-function":310,"../internals/indexed-object":383,"../internals/to-length":461,"../internals/to-object":462}],327:[function(require,module,exports){
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

},{"../internals/is-array":388,"../internals/is-object":392,"../internals/well-known-symbol":473}],328:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var getBuiltIn = require('../internals/get-built-in');

var Promise = getBuiltIn('Promise');
var push = [].push;

var createMethod = function (TYPE) {
  var IS_TO_ARRAY = TYPE == 0;
  var IS_FOR_EACH = TYPE == 1;
  var IS_EVERY = TYPE == 2;
  var IS_SOME = TYPE == 3;
  return function (iterator, fn) {
    anObject(iterator);
    var next = aFunction(iterator.next);
    var array = IS_TO_ARRAY ? [] : undefined;
    if (!IS_TO_ARRAY) aFunction(fn);

    return new Promise(function (resolve, reject) {
      var loop = function () {
        try {
          Promise.resolve(anObject(next.call(iterator))).then(function (step) {
            try {
              if (anObject(step).done) {
                resolve(IS_TO_ARRAY ? array : IS_SOME ? false : IS_EVERY || undefined);
              } else {
                var value = step.value;
                if (IS_TO_ARRAY) {
                  push.call(array, value);
                  loop();
                } else {
                  Promise.resolve(fn(value)).then(function (result) {
                    if (IS_FOR_EACH) {
                      loop();
                    } else if (IS_EVERY) {
                      result ? loop() : resolve(false);
                    } else {
                      result ? resolve(IS_SOME || value) : loop();
                    }
                  }, reject);
                }
              }
            } catch (err) { reject(err); }
          }, reject);
        } catch (error) { reject(error); }
      };

      loop();
    });
  };
};

module.exports = {
  toArray: createMethod(0),
  forEach: createMethod(1),
  every: createMethod(2),
  some: createMethod(3),
  find: createMethod(4)
};

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/get-built-in":372}],329:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared-store');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var has = require('../internals/has');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
var AsyncIterator = global.AsyncIterator;
var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
var AsyncIteratorPrototype, prototype;

if (!IS_PURE) {
  if (PassedAsyncIteratorPrototype) {
    AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
  } else if (typeof AsyncIterator == 'function') {
    AsyncIteratorPrototype = AsyncIterator.prototype;
  } else if (shared[USE_FUNCTION_CONSTRUCTOR] || global[USE_FUNCTION_CONSTRUCTOR]) {
    try {
      // eslint-disable-next-line no-new-func
      prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function('return async function*(){}()')())));
      if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
    } catch (error) { /* empty */ }
  }
}

if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};

if (!has(AsyncIteratorPrototype, ASYNC_ITERATOR)) {
  createNonEnumerableProperty(AsyncIteratorPrototype, ASYNC_ITERATOR, function () {
    return this;
  });
}

module.exports = AsyncIteratorPrototype;

},{"../internals/create-non-enumerable-property":350,"../internals/global":377,"../internals/has":378,"../internals/is-pure":393,"../internals/object-get-prototype-of":420,"../internals/shared-store":447,"../internals/well-known-symbol":473}],330:[function(require,module,exports){
var aFunction = require('../internals/a-function');

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"../internals/a-function":310}],331:[function(require,module,exports){
var anObject = require('../internals/an-object');

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

},{"../internals/an-object":315}],332:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":473}],333:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],334:[function(require,module,exports){
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

},{"../internals/classof-raw":333,"../internals/well-known-symbol":473}],335:[function(require,module,exports){
'use strict';
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');

// https://github.com/tc39/collection-methods
module.exports = function (/* ...elements */) {
  var set = anObject(this);
  var adder = aFunction(set.add);
  for (var k = 0, len = arguments.length; k < len; k++) {
    adder.call(set, arguments[k]);
  }
  return set;
};

},{"../internals/a-function":310,"../internals/an-object":315}],336:[function(require,module,exports){
'use strict';
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');

// https://github.com/tc39/collection-methods
module.exports = function (/* ...elements */) {
  var collection = anObject(this);
  var remover = aFunction(collection['delete']);
  var allDeleted = true;
  var wasDeleted;
  for (var k = 0, len = arguments.length; k < len; k++) {
    wasDeleted = remover.call(collection, arguments[k]);
    allDeleted = allDeleted && wasDeleted;
  }
  return !!allDeleted;
};

},{"../internals/a-function":310,"../internals/an-object":315}],337:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var iterate = require('../internals/iterate');

module.exports = function from(source /* , mapFn, thisArg */) {
  var length = arguments.length;
  var mapFn = length > 1 ? arguments[1] : undefined;
  var mapping, A, n, boundFunction;
  aFunction(this);
  mapping = mapFn !== undefined;
  if (mapping) aFunction(mapFn);
  if (source == undefined) return new this();
  A = [];
  if (mapping) {
    n = 0;
    boundFunction = bind(mapFn, length > 2 ? arguments[2] : undefined, 2);
    iterate(source, function (nextItem) {
      A.push(boundFunction(nextItem, n++));
    });
  } else {
    iterate(source, A.push, A);
  }
  return new this(A);
};

},{"../internals/a-function":310,"../internals/bind-context":330,"../internals/iterate":395}],338:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
module.exports = function of() {
  var length = arguments.length;
  var A = new Array(length);
  while (length--) A[length] = arguments[length];
  return new this(A);
};

},{}],339:[function(require,module,exports){
'use strict';
var defineProperty = require('../internals/object-define-property').f;
var create = require('../internals/object-create');
var redefineAll = require('../internals/redefine-all');
var bind = require('../internals/bind-context');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var defineIterator = require('../internals/define-iterator');
var setSpecies = require('../internals/set-species');
var DESCRIPTORS = require('../internals/descriptors');
var fastKey = require('../internals/internal-metadata').fastKey;
var InternalStateModule = require('../internals/internal-state');

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};

},{"../internals/an-instance":314,"../internals/bind-context":330,"../internals/define-iterator":355,"../internals/descriptors":357,"../internals/internal-metadata":385,"../internals/internal-state":386,"../internals/iterate":395,"../internals/object-create":413,"../internals/object-define-property":415,"../internals/redefine-all":434,"../internals/set-species":444}],340:[function(require,module,exports){
'use strict';
var redefineAll = require('../internals/redefine-all');
var getWeakData = require('../internals/internal-metadata').getWeakData;
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var ArrayIterationModule = require('../internals/array-iteration');
var $has = require('../internals/has');
var InternalStateModule = require('../internals/internal-state');

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return C;
  }
};

},{"../internals/an-instance":314,"../internals/an-object":315,"../internals/array-iteration":323,"../internals/has":378,"../internals/internal-metadata":385,"../internals/internal-state":386,"../internals/is-object":392,"../internals/iterate":395,"../internals/redefine-all":434}],341:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var InternalMetadataModule = require('../internals/internal-metadata');
var iterate = require('../internals/iterate');
var anInstance = require('../internals/an-instance');
var isObject = require('../internals/is-object');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var setToStringTag = require('../internals/set-to-string-tag');
var inheritIfRequired = require('../internals/inherit-if-required');

module.exports = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var ADDER = IS_MAP ? 'set' : 'add';
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};

},{"../internals/an-instance":314,"../internals/check-correctness-of-iteration":332,"../internals/export":361,"../internals/fails":362,"../internals/global":377,"../internals/inherit-if-required":384,"../internals/internal-metadata":385,"../internals/is-forced":389,"../internals/is-object":392,"../internals/iterate":395,"../internals/redefine":435,"../internals/set-to-string-tag":445}],342:[function(require,module,exports){
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var Map = require('../modules/es.map');
var WeakMap = require('../modules/es.weak-map');
var create = require('../internals/object-create');
var isObject = require('../internals/is-object');

var Node = function () {
  // keys
  this.object = null;
  this.symbol = null;
  // child nodes
  this.primitives = null;
  this.objectsByIndex = create(null);
};

Node.prototype.get = function (key, initializer) {
  return this[key] || (this[key] = initializer());
};

Node.prototype.next = function (i, it, IS_OBJECT) {
  var store = IS_OBJECT
    ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap())
    : this.primitives || (this.primitives = new Map());
  var entry = store.get(it);
  if (!entry) store.set(it, entry = new Node());
  return entry;
};

var root = new Node();

module.exports = function () {
  var active = root;
  var length = arguments.length;
  var i, it;
  // for prevent leaking, start from objects
  for (i = 0; i < length; i++) {
    if (isObject(it = arguments[i])) active = active.next(i, it, true);
  }
  if (this === Object && active === root) throw TypeError('Composite keys must contain a non-primitive component');
  for (i = 0; i < length; i++) {
    if (!isObject(it = arguments[i])) active = active.next(i, it, false);
  } return active;
};

},{"../internals/is-object":392,"../internals/object-create":413,"../modules/es.map":519,"../modules/es.weak-map":678}],343:[function(require,module,exports){
var has = require('../internals/has');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

},{"../internals/has":378,"../internals/object-define-property":415,"../internals/object-get-own-property-descriptor":416,"../internals/own-keys":427}],344:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};

},{"../internals/well-known-symbol":473}],345:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":362}],346:[function(require,module,exports){
'use strict';
var path = require('../internals/path');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');
var getBuiltIn = require('../internals/get-built-in');

var Promise = getBuiltIn('Promise');

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.get;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $return = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$return = iterator['return'];
  return $$return === undefined
    ? Promise.resolve({ done: true, value: value })
    : anObject($$return.call(iterator, value));
};

var $throw = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$throw = iterator['throw'];
  return $$throw === undefined
    ? Promise.reject(value)
    : $$throw.call(iterator, value);
};

module.exports = function (nextHandler, IS_ITERATOR) {
  var AsyncIteratorProxy = function AsyncIterator(state) {
    state.next = aFunction(state.iterator.next);
    state.done = false;
    setInternalState(this, state);
  };

  AsyncIteratorProxy.prototype = redefineAll(create(path.AsyncIterator.prototype), {
    next: function next(arg) {
      var state = getInternalState(this);
      if (state.done) return Promise.resolve({ done: true, value: undefined });
      try {
        return Promise.resolve(anObject(nextHandler.call(state, arg, Promise)));
      } catch (error) {
        return Promise.reject(error);
      }
    },
    'return': $return,
    'throw': $throw
  });

  if (!IS_ITERATOR) {
    createNonEnumerableProperty(AsyncIteratorProxy.prototype, TO_STRING_TAG, 'Generator');
  }

  return AsyncIteratorProxy;
};

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-non-enumerable-property":350,"../internals/get-built-in":372,"../internals/internal-state":386,"../internals/object-create":413,"../internals/path":430,"../internals/redefine-all":434,"../internals/well-known-symbol":473}],347:[function(require,module,exports){
var requireObjectCoercible = require('../internals/require-object-coercible');

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

},{"../internals/require-object-coercible":440}],348:[function(require,module,exports){
'use strict';
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

},{"../internals/create-property-descriptor":351,"../internals/iterators":397,"../internals/iterators-core":396,"../internals/object-create":413,"../internals/set-to-string-tag":445}],349:[function(require,module,exports){
'use strict';
var path = require('../internals/path');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.get;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $return = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$return = iterator['return'];
  return $$return === undefined ? { done: true, value: value } : anObject($$return.call(iterator, value));
};

var $throw = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$throw = iterator['throw'];
  if ($$throw === undefined) throw value;
  return $$throw.call(iterator, value);
};

module.exports = function (nextHandler, IS_ITERATOR) {
  var IteratorProxy = function Iterator(state) {
    state.next = aFunction(state.iterator.next);
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = redefineAll(create(path.Iterator.prototype), {
    next: function next() {
      var state = getInternalState(this);
      var result = state.done ? undefined : nextHandler.apply(state, arguments);
      return { done: state.done, value: result };
    },
    'return': $return,
    'throw': $throw
  });

  if (!IS_ITERATOR) {
    createNonEnumerableProperty(IteratorProxy.prototype, TO_STRING_TAG, 'Generator');
  }

  return IteratorProxy;
};

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-non-enumerable-property":350,"../internals/internal-state":386,"../internals/object-create":413,"../internals/path":430,"../internals/redefine-all":434,"../internals/well-known-symbol":473}],350:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"../internals/create-property-descriptor":351,"../internals/descriptors":357,"../internals/object-define-property":415}],351:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],352:[function(require,module,exports){
'use strict';
var toPrimitive = require('../internals/to-primitive');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

},{"../internals/create-property-descriptor":351,"../internals/object-define-property":415,"../internals/to-primitive":465}],353:[function(require,module,exports){
'use strict';
var fails = require('../internals/fails');
var padStart = require('../internals/string-pad').start;

var abs = Math.abs;
var DatePrototype = Date.prototype;
var getTime = DatePrototype.getTime;
var nativeDateToISOString = DatePrototype.toISOString;

// `Date.prototype.toISOString` method implementation
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
module.exports = (fails(function () {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  nativeDateToISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = date.getUTCFullYear();
  var milliseconds = date.getUTCMilliseconds();
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) +
    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +
    '-' + padStart(date.getUTCDate(), 2, 0) +
    'T' + padStart(date.getUTCHours(), 2, 0) +
    ':' + padStart(date.getUTCMinutes(), 2, 0) +
    ':' + padStart(date.getUTCSeconds(), 2, 0) +
    '.' + padStart(milliseconds, 3, 0) +
    'Z';
} : nativeDateToISOString;

},{"../internals/fails":362,"../internals/string-pad":452}],354:[function(require,module,exports){
'use strict';
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');

module.exports = function (hint) {
  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
    throw TypeError('Incorrect hint');
  } return toPrimitive(anObject(this), hint !== 'number');
};

},{"../internals/an-object":315,"../internals/to-primitive":465}],355:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

},{"../internals/create-iterator-constructor":348,"../internals/create-non-enumerable-property":350,"../internals/export":361,"../internals/is-pure":393,"../internals/iterators":397,"../internals/iterators-core":396,"../internals/object-get-prototype-of":420,"../internals/object-set-prototype-of":424,"../internals/redefine":435,"../internals/set-to-string-tag":445,"../internals/well-known-symbol":473}],356:[function(require,module,exports){
var path = require('../internals/path');
var has = require('../internals/has');
var wrappedWellKnownSymbolModule = require('../internals/wrapped-well-known-symbol');
var defineProperty = require('../internals/object-define-property').f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

},{"../internals/has":378,"../internals/object-define-property":415,"../internals/path":430,"../internals/wrapped-well-known-symbol":475}],357:[function(require,module,exports){
var fails = require('../internals/fails');

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"../internals/fails":362}],358:[function(require,module,exports){
var global = require('../internals/global');
var isObject = require('../internals/is-object');

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

},{"../internals/global":377,"../internals/is-object":392}],359:[function(require,module,exports){
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

},{}],360:[function(require,module,exports){
// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

},{}],361:[function(require,module,exports){
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

},{"../internals/copy-constructor-properties":343,"../internals/create-non-enumerable-property":350,"../internals/global":377,"../internals/is-forced":389,"../internals/object-get-own-property-descriptor":416,"../internals/redefine":435,"../internals/set-global":443}],362:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

},{}],363:[function(require,module,exports){
'use strict';
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var regexpExec = require('../internals/regexp-exec');

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  }
};

},{"../internals/create-non-enumerable-property":350,"../internals/fails":362,"../internals/redefine":435,"../internals/regexp-exec":438,"../internals/well-known-symbol":473}],364:[function(require,module,exports){
'use strict';
var isArray = require('../internals/is-array');
var toLength = require('../internals/to-length');
var bind = require('../internals/bind-context');

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;

},{"../internals/bind-context":330,"../internals/is-array":388,"../internals/to-length":461}],365:[function(require,module,exports){
'use strict';
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var fails = require('../internals/fails');

// Forced replacement object prototype accessors methods
module.exports = IS_PURE || !fails(function () {
  var key = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, key, function () { /* empty */ });
  delete global[key];
});

},{"../internals/fails":362,"../internals/global":377,"../internals/is-pure":393}],366:[function(require,module,exports){
var fails = require('../internals/fails');

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};

},{"../internals/fails":362}],367:[function(require,module,exports){
var fails = require('../internals/fails');
var whitespaces = require('../internals/whitespaces');

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

},{"../internals/fails":362,"../internals/whitespaces":474}],368:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

},{"../internals/fails":362}],369:[function(require,module,exports){
'use strict';
var aFunction = require('../internals/a-function');
var isObject = require('../internals/is-object');

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

},{"../internals/a-function":310,"../internals/is-object":392}],370:[function(require,module,exports){
var shared = require('../internals/shared');

module.exports = shared('native-function-to-string', Function.toString);

},{"../internals/shared":448}],371:[function(require,module,exports){
var getIteratorMethod = require('../internals/get-iterator-method');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');

module.exports = function (it) {
  var method = it[ASYNC_ITERATOR];
  return method === undefined ? getIteratorMethod(it) : method;
};

},{"../internals/get-iterator-method":373,"../internals/well-known-symbol":473}],372:[function(require,module,exports){
var path = require('../internals/path');
var global = require('../internals/global');

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"../internals/global":377,"../internals/path":430}],373:[function(require,module,exports){
var classof = require('../internals/classof');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"../internals/classof":334,"../internals/iterators":397,"../internals/well-known-symbol":473}],374:[function(require,module,exports){
var anObject = require('../internals/an-object');
var getIteratorMethod = require('../internals/get-iterator-method');

module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};

},{"../internals/an-object":315,"../internals/get-iterator-method":373}],375:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var getIterator = require('../internals/get-iterator');

module.exports = IS_PURE ? getIterator : function (it) {
  // eslint-disable-next-line no-undef
  return Map.prototype.entries.call(it);
};

},{"../internals/get-iterator":374,"../internals/is-pure":393}],376:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var getIterator = require('../internals/get-iterator');

module.exports = IS_PURE ? getIterator : function (it) {
  // eslint-disable-next-line no-undef
  return Set.prototype.values.call(it);
};

},{"../internals/get-iterator":374,"../internals/is-pure":393}],377:[function(require,module,exports){
(function (global){
var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],378:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],379:[function(require,module,exports){
module.exports = {};

},{}],380:[function(require,module,exports){
var global = require('../internals/global');

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

},{"../internals/global":377}],381:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":372}],382:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

},{"../internals/descriptors":357,"../internals/document-create-element":358,"../internals/fails":362}],383:[function(require,module,exports){
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

},{"../internals/classof-raw":333,"../internals/fails":362}],384:[function(require,module,exports){
var isObject = require('../internals/is-object');
var setPrototypeOf = require('../internals/object-set-prototype-of');

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};

},{"../internals/is-object":392,"../internals/object-set-prototype-of":424}],385:[function(require,module,exports){
var hiddenKeys = require('../internals/hidden-keys');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var defineProperty = require('../internals/object-define-property').f;
var uid = require('../internals/uid');
var FREEZING = require('../internals/freezing');

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;

},{"../internals/freezing":368,"../internals/has":378,"../internals/hidden-keys":379,"../internals/is-object":392,"../internals/object-define-property":415,"../internals/uid":469}],386:[function(require,module,exports){
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var objectHas = require('../internals/has');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

},{"../internals/create-non-enumerable-property":350,"../internals/global":377,"../internals/has":378,"../internals/hidden-keys":379,"../internals/is-object":392,"../internals/native-weak-map":408,"../internals/shared-key":446}],387:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/iterators":397,"../internals/well-known-symbol":473}],388:[function(require,module,exports){
var classof = require('../internals/classof-raw');

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

},{"../internals/classof-raw":333}],389:[function(require,module,exports){
var fails = require('../internals/fails');

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;

},{"../internals/fails":362}],390:[function(require,module,exports){
var isObject = require('../internals/is-object');

var floor = Math.floor;

// `Number.isInteger` method implementation
// https://tc39.github.io/ecma262/#sec-number.isinteger
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"../internals/is-object":392}],391:[function(require,module,exports){
var userAgent = require('../internals/user-agent');

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

},{"../internals/user-agent":470}],392:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],393:[function(require,module,exports){
module.exports = false;

},{}],394:[function(require,module,exports){
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/classof-raw":333,"../internals/is-object":392,"../internals/well-known-symbol":473}],395:[function(require,module,exports){
var anObject = require('../internals/an-object');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var bind = require('../internals/bind-context');
var getIteratorMethod = require('../internals/get-iterator-method');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/call-with-safe-iteration-closing":331,"../internals/get-iterator-method":373,"../internals/is-array-iterator-method":387,"../internals/to-length":461}],396:[function(require,module,exports){
'use strict';
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/create-non-enumerable-property":350,"../internals/has":378,"../internals/is-pure":393,"../internals/object-get-prototype-of":420,"../internals/well-known-symbol":473}],397:[function(require,module,exports){
arguments[4][379][0].apply(exports,arguments)
},{"dup":379}],398:[function(require,module,exports){
'use strict';
var anObject = require('../internals/an-object');

// `Map.prototype.upsert` method
// https://github.com/thumbsupep/proposal-upsert
module.exports = function upsert(key, updateFn /* , insertFn */) {
  var map = anObject(this);
  var insertFn = arguments.length > 2 ? arguments[2] : undefined;
  var value;
  if (typeof updateFn != 'function' && typeof insertFn != 'function') {
    throw TypeError('At least one callback required');
  }
  if (map.has(key)) {
    value = map.get(key);
    if (typeof updateFn == 'function') {
      value = updateFn(value);
      map.set(key, value);
    }
  } else if (typeof insertFn == 'function') {
    value = insertFn();
    map.set(key, value);
  } return value;
};

},{"../internals/an-object":315}],399:[function(require,module,exports){
var nativeExpm1 = Math.expm1;
var exp = Math.exp;

// `Math.expm1` method implementation
// https://tc39.github.io/ecma262/#sec-math.expm1
module.exports = (!nativeExpm1
  // Old FF bug
  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || nativeExpm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
} : nativeExpm1;

},{}],400:[function(require,module,exports){
var sign = require('../internals/math-sign');

var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

// `Math.fround` method implementation
// https://tc39.github.io/ecma262/#sec-math.fround
module.exports = Math.fround || function fround(x) {
  var $abs = abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"../internals/math-sign":403}],401:[function(require,module,exports){
var log = Math.log;

// `Math.log1p` method implementation
// https://tc39.github.io/ecma262/#sec-math.log1p
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
};

},{}],402:[function(require,module,exports){
// `Math.scale` method implementation
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      /* eslint-disable no-self-compare */
      || x != x
      || inLow != inLow
      || inHigh != inHigh
      || outLow != outLow
      || outHigh != outHigh
      /* eslint-enable no-self-compare */
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],403:[function(require,module,exports){
// `Math.sign` method implementation
// https://tc39.github.io/ecma262/#sec-math.sign
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],404:[function(require,module,exports){
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var classof = require('../internals/classof-raw');
var macrotask = require('../internals/task').set;
var IS_IOS = require('../internals/is-ios');

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};

},{"../internals/classof-raw":333,"../internals/global":377,"../internals/is-ios":391,"../internals/object-get-own-property-descriptor":416,"../internals/task":455}],405:[function(require,module,exports){
var global = require('../internals/global');

module.exports = global.Promise;

},{"../internals/global":377}],406:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

},{"../internals/fails":362}],407:[function(require,module,exports){
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});

},{"../internals/fails":362,"../internals/is-pure":393,"../internals/well-known-symbol":473}],408:[function(require,module,exports){
var global = require('../internals/global');
var nativeFunctionToString = require('../internals/function-to-string');

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));

},{"../internals/function-to-string":370,"../internals/global":377}],409:[function(require,module,exports){
'use strict';
var aFunction = require('../internals/a-function');

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"../internals/a-function":310}],410:[function(require,module,exports){
var isRegExp = require('../internals/is-regexp');

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};

},{"../internals/is-regexp":394}],411:[function(require,module,exports){
var global = require('../internals/global');

var globalIsFinite = global.isFinite;

// `Number.isFinite` method
// https://tc39.github.io/ecma262/#sec-number.isfinite
module.exports = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

},{"../internals/global":377}],412:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');

var nativeAssign = Object.assign;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !nativeAssign || fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;

},{"../internals/descriptors":357,"../internals/fails":362,"../internals/indexed-object":383,"../internals/object-get-own-property-symbols":419,"../internals/object-keys":422,"../internals/object-property-is-enumerable":423,"../internals/to-object":462}],413:[function(require,module,exports){
var anObject = require('../internals/an-object');
var defineProperties = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');
var IE_PROTO = sharedKey('IE_PROTO');

var PROTOTYPE = 'prototype';
var Empty = function () { /* empty */ };

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
  return createDict();
};

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

hiddenKeys[IE_PROTO] = true;

},{"../internals/an-object":315,"../internals/document-create-element":358,"../internals/enum-bug-keys":360,"../internals/hidden-keys":379,"../internals/html":381,"../internals/object-define-properties":414,"../internals/shared-key":446}],414:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var objectKeys = require('../internals/object-keys');

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};

},{"../internals/an-object":315,"../internals/descriptors":357,"../internals/object-define-property":415,"../internals/object-keys":422}],415:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"../internals/an-object":315,"../internals/descriptors":357,"../internals/ie8-dom-define":382,"../internals/to-primitive":465}],416:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

},{"../internals/create-property-descriptor":351,"../internals/descriptors":357,"../internals/has":378,"../internals/ie8-dom-define":382,"../internals/object-property-is-enumerable":423,"../internals/to-indexed-object":459,"../internals/to-primitive":465}],417:[function(require,module,exports){
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names').f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};

},{"../internals/object-get-own-property-names":418,"../internals/to-indexed-object":459}],418:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/enum-bug-keys":360,"../internals/object-keys-internal":421}],419:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],420:[function(require,module,exports){
var has = require('../internals/has');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};

},{"../internals/correct-prototype-getter":345,"../internals/has":378,"../internals/shared-key":446,"../internals/to-object":462}],421:[function(require,module,exports){
var has = require('../internals/has');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

},{"../internals/array-includes":322,"../internals/has":378,"../internals/hidden-keys":379,"../internals/to-indexed-object":459}],422:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/enum-bug-keys":360,"../internals/object-keys-internal":421}],423:[function(require,module,exports){
'use strict';
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

},{}],424:[function(require,module,exports){
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

},{"../internals/a-possible-prototype":311,"../internals/an-object":315}],425:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var objectKeys = require('../internals/object-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};

},{"../internals/descriptors":357,"../internals/object-keys":422,"../internals/object-property-is-enumerable":423,"../internals/to-indexed-object":459}],426:[function(require,module,exports){
'use strict';
var classof = require('../internals/classof');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;

},{"../internals/classof":334,"../internals/well-known-symbol":473}],427:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

},{"../internals/an-object":315,"../internals/get-built-in":372,"../internals/object-get-own-property-names":418,"../internals/object-get-own-property-symbols":419}],428:[function(require,module,exports){
var global = require('../internals/global');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');

var nativeParseFloat = global.parseFloat;
var FORCED = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat;

},{"../internals/global":377,"../internals/string-trim":454,"../internals/whitespaces":474}],429:[function(require,module,exports){
var global = require('../internals/global');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');

var nativeParseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return nativeParseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
} : nativeParseInt;

},{"../internals/global":377,"../internals/string-trim":454,"../internals/whitespaces":474}],430:[function(require,module,exports){
module.exports = require('../internals/global');

},{"../internals/global":377}],431:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

},{}],432:[function(require,module,exports){
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"../internals/an-object":315,"../internals/is-object":392,"../internals/new-promise-capability":409}],433:[function(require,module,exports){
'use strict';
// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for (var k = base; /* no condition */; k += base) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};

},{}],434:[function(require,module,exports){
var redefine = require('../internals/redefine');

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

},{"../internals/redefine":435}],435:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var setGlobal = require('../internals/set-global');
var nativeFunctionToString = require('../internals/function-to-string');
var InternalStateModule = require('../internals/internal-state');

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(nativeFunctionToString).split('toString');

shared('inspectSource', function (it) {
  return nativeFunctionToString.call(it);
});

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
});

},{"../internals/create-non-enumerable-property":350,"../internals/function-to-string":370,"../internals/global":377,"../internals/has":378,"../internals/internal-state":386,"../internals/set-global":443,"../internals/shared":448}],436:[function(require,module,exports){
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var Map = require('../modules/es.map');
var WeakMap = require('../modules/es.weak-map');
var shared = require('../internals/shared');

var metadata = shared('metadata');
var store = metadata.store || (metadata.store = new WeakMap());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};

var toMetadataKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

module.exports = {
  store: store,
  getMap: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  toKey: toMetadataKey
};

},{"../internals/shared":448,"../modules/es.map":519,"../modules/es.weak-map":678}],437:[function(require,module,exports){
var classof = require('./classof-raw');
var regexpExec = require('./regexp-exec');

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};


},{"./classof-raw":333,"./regexp-exec":438}],438:[function(require,module,exports){
'use strict';
var regexpFlags = require('./regexp-flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./regexp-flags":439}],439:[function(require,module,exports){
'use strict';
var anObject = require('../internals/an-object');

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"../internals/an-object":315}],440:[function(require,module,exports){
// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

},{}],441:[function(require,module,exports){
// `SameValueZero` abstract operation
// https://tc39.github.io/ecma262/#sec-samevaluezero
module.exports = function (x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y || x != x && y != y;
};

},{}],442:[function(require,module,exports){
// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],443:[function(require,module,exports){
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};

},{"../internals/create-non-enumerable-property":350,"../internals/global":377}],444:[function(require,module,exports){
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var definePropertyModule = require('../internals/object-define-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

},{"../internals/descriptors":357,"../internals/get-built-in":372,"../internals/object-define-property":415,"../internals/well-known-symbol":473}],445:[function(require,module,exports){
var defineProperty = require('../internals/object-define-property').f;
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};

},{"../internals/has":378,"../internals/object-define-property":415,"../internals/well-known-symbol":473}],446:[function(require,module,exports){
var shared = require('../internals/shared');
var uid = require('../internals/uid');

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":448,"../internals/uid":469}],447:[function(require,module,exports){
var global = require('../internals/global');
var setGlobal = require('../internals/set-global');

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;

},{"../internals/global":377,"../internals/set-global":443}],448:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.4.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

},{"../internals/is-pure":393,"../internals/shared-store":447}],449:[function(require,module,exports){
'use strict';
var fails = require('../internals/fails');

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};

},{"../internals/fails":362}],450:[function(require,module,exports){
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/well-known-symbol":473}],451:[function(require,module,exports){
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

},{"../internals/require-object-coercible":440,"../internals/to-integer":460}],452:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('../internals/to-length');
var repeat = require('../internals/string-repeat');
var requireObjectCoercible = require('../internals/require-object-coercible');

var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};

},{"../internals/require-object-coercible":440,"../internals/string-repeat":453,"../internals/to-length":461}],453:[function(require,module,exports){
'use strict';
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

},{"../internals/require-object-coercible":440,"../internals/to-integer":460}],454:[function(require,module,exports){
var requireObjectCoercible = require('../internals/require-object-coercible');
var whitespaces = require('../internals/whitespaces');

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

},{"../internals/require-object-coercible":440,"../internals/whitespaces":474}],455:[function(require,module,exports){
var global = require('../internals/global');
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');
var bind = require('../internals/bind-context');
var html = require('../internals/html');
var createElement = require('../internals/document-create-element');
var IS_IOS = require('../internals/is-ios');

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};

},{"../internals/bind-context":330,"../internals/classof-raw":333,"../internals/document-create-element":358,"../internals/fails":362,"../internals/global":377,"../internals/html":381,"../internals/is-ios":391}],456:[function(require,module,exports){
var classof = require('../internals/classof-raw');

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};

},{"../internals/classof-raw":333}],457:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer":460}],458:[function(require,module,exports){
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

},{"../internals/to-integer":460,"../internals/to-length":461}],459:[function(require,module,exports){
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":383,"../internals/require-object-coercible":440}],460:[function(require,module,exports){
var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

},{}],461:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer":460}],462:[function(require,module,exports){
var requireObjectCoercible = require('../internals/require-object-coercible');

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

},{"../internals/require-object-coercible":440}],463:[function(require,module,exports){
var toPositiveInteger = require('../internals/to-positive-integer');

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

},{"../internals/to-positive-integer":464}],464:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

},{"../internals/to-integer":460}],465:[function(require,module,exports){
var isObject = require('../internals/is-object');

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"../internals/is-object":392}],466:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-arrays-constructors-requires-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayBufferModule = require('../internals/array-buffer');
var anInstance = require('../internals/an-instance');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var toOffset = require('../internals/to-offset');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var classof = require('../internals/classof');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var typedArrayFrom = require('../internals/typed-array-from');
var forEach = require('../internals/array-iteration').forEach;
var setSpecies = require('../internals/set-species');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var InternalStateModule = require('../internals/internal-state');
var inheritIfRequired = require('../internals/inherit-if-required');

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };

},{"../internals/an-instance":314,"../internals/array-buffer":317,"../internals/array-buffer-view-core":316,"../internals/array-iteration":323,"../internals/classof":334,"../internals/create-non-enumerable-property":350,"../internals/create-property-descriptor":351,"../internals/descriptors":357,"../internals/export":361,"../internals/global":377,"../internals/has":378,"../internals/inherit-if-required":384,"../internals/internal-state":386,"../internals/is-object":392,"../internals/object-create":413,"../internals/object-define-property":415,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-own-property-names":418,"../internals/object-set-prototype-of":424,"../internals/set-species":444,"../internals/to-index":458,"../internals/to-length":461,"../internals/to-offset":463,"../internals/to-primitive":465,"../internals/typed-array-from":467,"../internals/typed-arrays-constructors-requires-wrappers":468}],467:[function(require,module,exports){
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var getIteratorMethod = require('../internals/get-iterator-method');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var bind = require('../internals/bind-context');
var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};

},{"../internals/array-buffer-view-core":316,"../internals/bind-context":330,"../internals/get-iterator-method":373,"../internals/is-array-iterator-method":387,"../internals/to-length":461,"../internals/to-object":462}],468:[function(require,module,exports){
/* eslint-disable no-new */
var global = require('../internals/global');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});

},{"../internals/array-buffer-view-core":316,"../internals/check-correctness-of-iteration":332,"../internals/fails":362,"../internals/global":377}],469:[function(require,module,exports){
var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

},{}],470:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":372}],471:[function(require,module,exports){
var global = require('../internals/global');
var userAgent = require('../internals/user-agent');

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

},{"../internals/global":377,"../internals/user-agent":470}],472:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/280
var userAgent = require('../internals/user-agent');

// eslint-disable-next-line unicorn/no-unsafe-regex
module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

},{"../internals/user-agent":470}],473:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');

var Symbol = global.Symbol;
var store = shared('wks');

module.exports = function (name) {
  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]
    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

},{"../internals/global":377,"../internals/native-symbol":406,"../internals/shared":448,"../internals/uid":469}],474:[function(require,module,exports){
// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],475:[function(require,module,exports){
exports.f = require('../internals/well-known-symbol');

},{"../internals/well-known-symbol":473}],476:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var arrayBufferModule = require('../internals/array-buffer');
var setSpecies = require('../internals/set-species');

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
$({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

setSpecies(ARRAY_BUFFER);

},{"../internals/array-buffer":317,"../internals/export":361,"../internals/global":377,"../internals/set-species":444}],477:[function(require,module,exports){
var $ = require('../internals/export');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

// `ArrayBuffer.isView` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
$({ target: 'ArrayBuffer', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
  isView: ArrayBufferViewCore.isView
});

},{"../internals/array-buffer-view-core":316,"../internals/export":361}],478:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var ArrayBufferModule = require('../internals/array-buffer');
var anObject = require('../internals/an-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var speciesConstructor = require('../internals/species-constructor');

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});

},{"../internals/an-object":315,"../internals/array-buffer":317,"../internals/export":361,"../internals/fails":362,"../internals/species-constructor":450,"../internals/to-absolute-index":457,"../internals/to-length":461}],479:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var arraySpeciesCreate = require('../internals/array-species-create');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/v8-version');

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

},{"../internals/array-method-has-species-support":325,"../internals/array-species-create":327,"../internals/create-property":352,"../internals/export":361,"../internals/fails":362,"../internals/is-array":388,"../internals/is-object":392,"../internals/to-length":461,"../internals/to-object":462,"../internals/v8-version":471,"../internals/well-known-symbol":473}],480:[function(require,module,exports){
var $ = require('../internals/export');
var copyWithin = require('../internals/array-copy-within');
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
$({ target: 'Array', proto: true }, {
  copyWithin: copyWithin
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');

},{"../internals/add-to-unscopables":312,"../internals/array-copy-within":318,"../internals/export":361}],481:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $every = require('../internals/array-iteration').every;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('every') }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":323,"../internals/export":361,"../internals/sloppy-array-method":449}],482:[function(require,module,exports){
var $ = require('../internals/export');
var fill = require('../internals/array-fill');
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

},{"../internals/add-to-unscopables":312,"../internals/array-fill":319,"../internals/export":361}],483:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $filter = require('../internals/array-iteration').filter;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('filter') }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":323,"../internals/array-method-has-species-support":325,"../internals/export":361}],484:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $findIndex = require('../internals/array-iteration').findIndex;
var addToUnscopables = require('../internals/add-to-unscopables');

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

},{"../internals/add-to-unscopables":312,"../internals/array-iteration":323,"../internals/export":361}],485:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $find = require('../internals/array-iteration').find;
var addToUnscopables = require('../internals/add-to-unscopables');

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

},{"../internals/add-to-unscopables":312,"../internals/array-iteration":323,"../internals/export":361}],486:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var aFunction = require('../internals/a-function');
var arraySpeciesCreate = require('../internals/array-species-create');

// `Array.prototype.flatMap` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

},{"../internals/a-function":310,"../internals/array-species-create":327,"../internals/export":361,"../internals/flatten-into-array":364,"../internals/to-length":461,"../internals/to-object":462}],487:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var toInteger = require('../internals/to-integer');
var arraySpeciesCreate = require('../internals/array-species-create');

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

},{"../internals/array-species-create":327,"../internals/export":361,"../internals/flatten-into-array":364,"../internals/to-integer":460,"../internals/to-length":461,"../internals/to-object":462}],488:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var forEach = require('../internals/array-for-each');

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});

},{"../internals/array-for-each":320,"../internals/export":361}],489:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});

},{"../internals/array-from":321,"../internals/check-correctness-of-iteration":332,"../internals/export":361}],490:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/add-to-unscopables":312,"../internals/array-includes":322,"../internals/export":361}],491:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $indexOf = require('../internals/array-includes').indexOf;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-includes":322,"../internals/export":361,"../internals/sloppy-array-method":449}],492:[function(require,module,exports){
var $ = require('../internals/export');
var isArray = require('../internals/is-array');

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});

},{"../internals/export":361,"../internals/is-array":388}],493:[function(require,module,exports){
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"../internals/add-to-unscopables":312,"../internals/define-iterator":355,"../internals/internal-state":386,"../internals/iterators":397,"../internals/to-indexed-object":459}],494:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IndexedObject = require('../internals/indexed-object');
var toIndexedObject = require('../internals/to-indexed-object');
var sloppyArrayMethod = require('../internals/sloppy-array-method');

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var SLOPPY_METHOD = sloppyArrayMethod('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

},{"../internals/export":361,"../internals/indexed-object":383,"../internals/sloppy-array-method":449,"../internals/to-indexed-object":459}],495:[function(require,module,exports){
var $ = require('../internals/export');
var lastIndexOf = require('../internals/array-last-index-of');

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
$({ target: 'Array', proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf
});

},{"../internals/array-last-index-of":324,"../internals/export":361}],496:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $map = require('../internals/array-iteration').map;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('map') }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":323,"../internals/array-method-has-species-support":325,"../internals/export":361}],497:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var createProperty = require('../internals/create-property');

var ISNT_GENERIC = fails(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
});

// `Array.of` method
// https://tc39.github.io/ecma262/#sec-array.of
// WebKit Array.of isn't generic
$({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
  of: function of(/* ...args */) {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
    result.length = argumentsLength;
    return result;
  }
});

},{"../internals/create-property":352,"../internals/export":361,"../internals/fails":362}],498:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $reduceRight = require('../internals/array-reduce').right;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

// `Array.prototype.reduceRight` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduceRight') }, {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-reduce":326,"../internals/export":361,"../internals/sloppy-array-method":449}],499:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $reduce = require('../internals/array-reduce').left;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduce') }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-reduce":326,"../internals/export":361,"../internals/sloppy-array-method":449}],500:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var isArray = require('../internals/is-array');

var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});

},{"../internals/export":361,"../internals/is-array":388}],501:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var toIndexedObject = require('../internals/to-indexed-object');
var createProperty = require('../internals/create-property');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('slice') }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});

},{"../internals/array-method-has-species-support":325,"../internals/create-property":352,"../internals/export":361,"../internals/is-array":388,"../internals/is-object":392,"../internals/to-absolute-index":457,"../internals/to-indexed-object":459,"../internals/to-length":461,"../internals/well-known-symbol":473}],502:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $some = require('../internals/array-iteration').some;
var sloppyArrayMethod = require('../internals/sloppy-array-method');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('some') }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":323,"../internals/export":361,"../internals/sloppy-array-method":449}],503:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var fails = require('../internals/fails');
var sloppyArrayMethod = require('../internals/sloppy-array-method');

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var SLOPPY_METHOD = sloppyArrayMethod('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});

},{"../internals/a-function":310,"../internals/export":361,"../internals/fails":362,"../internals/sloppy-array-method":449,"../internals/to-object":462}],504:[function(require,module,exports){
var setSpecies = require('../internals/set-species');

// `Array[@@species]` getter
// https://tc39.github.io/ecma262/#sec-get-array-@@species
setSpecies('Array');

},{"../internals/set-species":444}],505:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toObject = require('../internals/to-object');
var arraySpeciesCreate = require('../internals/array-species-create');
var createProperty = require('../internals/create-property');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('splice') }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

},{"../internals/array-method-has-species-support":325,"../internals/array-species-create":327,"../internals/create-property":352,"../internals/export":361,"../internals/to-absolute-index":457,"../internals/to-integer":460,"../internals/to-length":461,"../internals/to-object":462}],506:[function(require,module,exports){
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');

addToUnscopables('flatMap');

},{"../internals/add-to-unscopables":312}],507:[function(require,module,exports){
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');

addToUnscopables('flat');

},{"../internals/add-to-unscopables":312}],508:[function(require,module,exports){
var $ = require('../internals/export');
var ArrayBufferModule = require('../internals/array-buffer');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER;

// `DataView` constructor
// https://tc39.github.io/ecma262/#sec-dataview-constructor
$({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: ArrayBufferModule.DataView
});

},{"../internals/array-buffer":317,"../internals/array-buffer-view-core":316,"../internals/export":361}],509:[function(require,module,exports){
var $ = require('../internals/export');

// `Date.now` method
// https://tc39.github.io/ecma262/#sec-date.now
$({ target: 'Date', stat: true }, {
  now: function now() {
    return new Date().getTime();
  }
});

},{"../internals/export":361}],510:[function(require,module,exports){
var $ = require('../internals/export');
var toISOString = require('../internals/date-to-iso-string');

// `Date.prototype.toISOString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
$({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== toISOString }, {
  toISOString: toISOString
});

},{"../internals/date-to-iso-string":353,"../internals/export":361}],511:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var toPrimitive = require('../internals/to-primitive');

var FORCED = fails(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
});

// `Date.prototype.toJSON` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tojson
$({ target: 'Date', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/to-object":462,"../internals/to-primitive":465}],512:[function(require,module,exports){
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var dateToPrimitive = require('../internals/date-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
if (!(TO_PRIMITIVE in DatePrototype)) {
  createNonEnumerableProperty(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}

},{"../internals/create-non-enumerable-property":350,"../internals/date-to-primitive":354,"../internals/well-known-symbol":473}],513:[function(require,module,exports){
var redefine = require('../internals/redefine');

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;

// `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

},{"../internals/redefine":435}],514:[function(require,module,exports){
var $ = require('../internals/export');
var bind = require('../internals/function-bind');

// `Function.prototype.bind` method
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
$({ target: 'Function', proto: true }, {
  bind: bind
});

},{"../internals/export":361,"../internals/function-bind":369}],515:[function(require,module,exports){
'use strict';
var isObject = require('../internals/is-object');
var definePropertyModule = require('../internals/object-define-property');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');

var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype;

// `Function.prototype[@@hasInstance]` method
// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
if (!(HAS_INSTANCE in FunctionPrototype)) {
  definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
    return false;
  } });
}

},{"../internals/is-object":392,"../internals/object-define-property":415,"../internals/object-get-prototype-of":420,"../internals/well-known-symbol":473}],516:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var defineProperty = require('../internals/object-define-property').f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

},{"../internals/descriptors":357,"../internals/object-define-property":415}],517:[function(require,module,exports){
var $ = require('../internals/export');
var global = require('../internals/global');

// `globalThis` object
// https://github.com/tc39/proposal-global
$({ global: true }, {
  globalThis: global
});

},{"../internals/export":361,"../internals/global":377}],518:[function(require,module,exports){
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);

},{"../internals/global":377,"../internals/set-to-string-tag":445}],519:[function(require,module,exports){
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
module.exports = collection('Map', function (get) {
  return function Map() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong, true);

},{"../internals/collection":341,"../internals/collection-strong":339}],520:[function(require,module,exports){
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');

var nativeAcosh = Math.acosh;
var log = Math.log;
var sqrt = Math.sqrt;
var LN2 = Math.LN2;

var FORCED = !nativeAcosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  || nativeAcosh(Infinity) != Infinity;

// `Math.acosh` method
// https://tc39.github.io/ecma262/#sec-math.acosh
$({ target: 'Math', stat: true, forced: FORCED }, {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? log(x) + LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"../internals/export":361,"../internals/math-log1p":401}],521:[function(require,module,exports){
var $ = require('../internals/export');

var nativeAsinh = Math.asinh;
var log = Math.log;
var sqrt = Math.sqrt;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}

// `Math.asinh` method
// https://tc39.github.io/ecma262/#sec-math.asinh
// Tor Browser bug: Math.asinh(0) -> -0
$({ target: 'Math', stat: true, forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0) }, {
  asinh: asinh
});

},{"../internals/export":361}],522:[function(require,module,exports){
var $ = require('../internals/export');

var nativeAtanh = Math.atanh;
var log = Math.log;

// `Math.atanh` method
// https://tc39.github.io/ecma262/#sec-math.atanh
// Tor Browser bug: Math.atanh(-0) -> 0
$({ target: 'Math', stat: true, forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0) }, {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  }
});

},{"../internals/export":361}],523:[function(require,module,exports){
var $ = require('../internals/export');
var sign = require('../internals/math-sign');

var abs = Math.abs;
var pow = Math.pow;

// `Math.cbrt` method
// https://tc39.github.io/ecma262/#sec-math.cbrt
$({ target: 'Math', stat: true }, {
  cbrt: function cbrt(x) {
    return sign(x = +x) * pow(abs(x), 1 / 3);
  }
});

},{"../internals/export":361,"../internals/math-sign":403}],524:[function(require,module,exports){
var $ = require('../internals/export');

var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E;

// `Math.clz32` method
// https://tc39.github.io/ecma262/#sec-math.clz32
$({ target: 'Math', stat: true }, {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
  }
});

},{"../internals/export":361}],525:[function(require,module,exports){
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');

var nativeCosh = Math.cosh;
var abs = Math.abs;
var E = Math.E;

// `Math.cosh` method
// https://tc39.github.io/ecma262/#sec-math.cosh
$({ target: 'Math', stat: true, forced: !nativeCosh || nativeCosh(710) === Infinity }, {
  cosh: function cosh(x) {
    var t = expm1(abs(x) - 1) + 1;
    return (t + 1 / (t * E * E)) * (E / 2);
  }
});

},{"../internals/export":361,"../internals/math-expm1":399}],526:[function(require,module,exports){
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');

// `Math.expm1` method
// https://tc39.github.io/ecma262/#sec-math.expm1
$({ target: 'Math', stat: true, forced: expm1 != Math.expm1 }, { expm1: expm1 });

},{"../internals/export":361,"../internals/math-expm1":399}],527:[function(require,module,exports){
var $ = require('../internals/export');
var fround = require('../internals/math-fround');

// `Math.fround` method
// https://tc39.github.io/ecma262/#sec-math.fround
$({ target: 'Math', stat: true }, { fround: fround });

},{"../internals/export":361,"../internals/math-fround":400}],528:[function(require,module,exports){
var $ = require('../internals/export');

var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt;

// Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546
var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;

// `Math.hypot` method
// https://tc39.github.io/ecma262/#sec-math.hypot
$({ target: 'Math', stat: true, forced: BUGGY }, {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});

},{"../internals/export":361}],529:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');

var nativeImul = Math.imul;

var FORCED = fails(function () {
  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
});

// `Math.imul` method
// https://tc39.github.io/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity
$({ target: 'Math', stat: true, forced: FORCED }, {
  imul: function imul(x, y) {
    var UINT16 = 0xFFFF;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"../internals/export":361,"../internals/fails":362}],530:[function(require,module,exports){
var $ = require('../internals/export');

var log = Math.log;
var LOG10E = Math.LOG10E;

// `Math.log10` method
// https://tc39.github.io/ecma262/#sec-math.log10
$({ target: 'Math', stat: true }, {
  log10: function log10(x) {
    return log(x) * LOG10E;
  }
});

},{"../internals/export":361}],531:[function(require,module,exports){
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');

// `Math.log1p` method
// https://tc39.github.io/ecma262/#sec-math.log1p
$({ target: 'Math', stat: true }, { log1p: log1p });

},{"../internals/export":361,"../internals/math-log1p":401}],532:[function(require,module,exports){
var $ = require('../internals/export');

var log = Math.log;
var LN2 = Math.LN2;

// `Math.log2` method
// https://tc39.github.io/ecma262/#sec-math.log2
$({ target: 'Math', stat: true }, {
  log2: function log2(x) {
    return log(x) / LN2;
  }
});

},{"../internals/export":361}],533:[function(require,module,exports){
var $ = require('../internals/export');
var sign = require('../internals/math-sign');

// `Math.sign` method
// https://tc39.github.io/ecma262/#sec-math.sign
$({ target: 'Math', stat: true }, {
  sign: sign
});

},{"../internals/export":361,"../internals/math-sign":403}],534:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var expm1 = require('../internals/math-expm1');

var abs = Math.abs;
var exp = Math.exp;
var E = Math.E;

var FORCED = fails(function () {
  return Math.sinh(-2e-17) != -2e-17;
});

// `Math.sinh` method
// https://tc39.github.io/ecma262/#sec-math.sinh
// V8 near Chromium 38 has a problem with very small numbers
$({ target: 'Math', stat: true, forced: FORCED }, {
  sinh: function sinh(x) {
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/math-expm1":399}],535:[function(require,module,exports){
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');

var exp = Math.exp;

// `Math.tanh` method
// https://tc39.github.io/ecma262/#sec-math.tanh
$({ target: 'Math', stat: true }, {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"../internals/export":361,"../internals/math-expm1":399}],536:[function(require,module,exports){
var setToStringTag = require('../internals/set-to-string-tag');

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);

},{"../internals/set-to-string-tag":445}],537:[function(require,module,exports){
var $ = require('../internals/export');

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.github.io/ecma262/#sec-math.trunc
$({ target: 'Math', stat: true }, {
  trunc: function trunc(it) {
    return (it > 0 ? floor : ceil)(it);
  }
});

},{"../internals/export":361}],538:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var has = require('../internals/has');
var classof = require('../internals/classof-raw');
var inheritIfRequired = require('../internals/inherit-if-required');
var toPrimitive = require('../internals/to-primitive');
var fails = require('../internals/fails');
var create = require('../internals/object-create');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var defineProperty = require('../internals/object-define-property').f;
var trim = require('../internals/string-trim').trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}

},{"../internals/classof-raw":333,"../internals/descriptors":357,"../internals/fails":362,"../internals/global":377,"../internals/has":378,"../internals/inherit-if-required":384,"../internals/is-forced":389,"../internals/object-create":413,"../internals/object-define-property":415,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-own-property-names":418,"../internals/redefine":435,"../internals/string-trim":454,"../internals/to-primitive":465}],539:[function(require,module,exports){
var $ = require('../internals/export');

// `Number.EPSILON` constant
// https://tc39.github.io/ecma262/#sec-number.epsilon
$({ target: 'Number', stat: true }, {
  EPSILON: Math.pow(2, -52)
});

},{"../internals/export":361}],540:[function(require,module,exports){
var $ = require('../internals/export');
var numberIsFinite = require('../internals/number-is-finite');

// `Number.isFinite` method
// https://tc39.github.io/ecma262/#sec-number.isfinite
$({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

},{"../internals/export":361,"../internals/number-is-finite":411}],541:[function(require,module,exports){
var $ = require('../internals/export');
var isInteger = require('../internals/is-integer');

// `Number.isInteger` method
// https://tc39.github.io/ecma262/#sec-number.isinteger
$({ target: 'Number', stat: true }, {
  isInteger: isInteger
});

},{"../internals/export":361,"../internals/is-integer":390}],542:[function(require,module,exports){
var $ = require('../internals/export');

// `Number.isNaN` method
// https://tc39.github.io/ecma262/#sec-number.isnan
$({ target: 'Number', stat: true }, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"../internals/export":361}],543:[function(require,module,exports){
var $ = require('../internals/export');
var isInteger = require('../internals/is-integer');

var abs = Math.abs;

// `Number.isSafeInteger` method
// https://tc39.github.io/ecma262/#sec-number.issafeinteger
$({ target: 'Number', stat: true }, {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
  }
});

},{"../internals/export":361,"../internals/is-integer":390}],544:[function(require,module,exports){
var $ = require('../internals/export');

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
$({ target: 'Number', stat: true }, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});

},{"../internals/export":361}],545:[function(require,module,exports){
var $ = require('../internals/export');

// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
$({ target: 'Number', stat: true }, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});

},{"../internals/export":361}],546:[function(require,module,exports){
var $ = require('../internals/export');
var parseFloat = require('../internals/parse-float');

// `Number.parseFloat` method
// https://tc39.github.io/ecma262/#sec-number.parseFloat
$({ target: 'Number', stat: true, forced: Number.parseFloat != parseFloat }, {
  parseFloat: parseFloat
});

},{"../internals/export":361,"../internals/parse-float":428}],547:[function(require,module,exports){
var $ = require('../internals/export');
var parseInt = require('../internals/parse-int');

// `Number.parseInt` method
// https://tc39.github.io/ecma262/#sec-number.parseint
$({ target: 'Number', stat: true, forced: Number.parseInt != parseInt }, {
  parseInt: parseInt
});

},{"../internals/export":361,"../internals/parse-int":429}],548:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toInteger = require('../internals/to-integer');
var thisNumberValue = require('../internals/this-number-value');
var repeat = require('../internals/string-repeat');
var fails = require('../internals/fails');

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/string-repeat":453,"../internals/this-number-value":456,"../internals/to-integer":460}],549:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var thisNumberValue = require('../internals/this-number-value');

var nativeToPrecision = 1.0.toPrecision;

var FORCED = fails(function () {
  // IE7-
  return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToPrecision.call({});
});

// `Number.prototype.toPrecision` method
// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision
$({ target: 'Number', proto: true, forced: FORCED }, {
  toPrecision: function toPrecision(precision) {
    return precision === undefined
      ? nativeToPrecision.call(thisNumberValue(this))
      : nativeToPrecision.call(thisNumberValue(this), precision);
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/this-number-value":456}],550:[function(require,module,exports){
var $ = require('../internals/export');
var assign = require('../internals/object-assign');

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});

},{"../internals/export":361,"../internals/object-assign":412}],551:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var create = require('../internals/object-create');

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});

},{"../internals/descriptors":357,"../internals/export":361,"../internals/object-create":413}],552:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/forced-object-prototype-accessors-methods');
var toObject = require('../internals/to-object');
var aFunction = require('../internals/a-function');
var definePropertyModule = require('../internals/object-define-property');

// `Object.prototype.__defineGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineGetter__: function __defineGetter__(P, getter) {
      definePropertyModule.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
    }
  });
}

},{"../internals/a-function":310,"../internals/descriptors":357,"../internals/export":361,"../internals/forced-object-prototype-accessors-methods":365,"../internals/object-define-property":415,"../internals/to-object":462}],553:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var defineProperties = require('../internals/object-define-properties');

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties
});

},{"../internals/descriptors":357,"../internals/export":361,"../internals/object-define-properties":414}],554:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModile = require('../internals/object-define-property');

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperty: objectDefinePropertyModile.f
});

},{"../internals/descriptors":357,"../internals/export":361,"../internals/object-define-property":415}],555:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/forced-object-prototype-accessors-methods');
var toObject = require('../internals/to-object');
var aFunction = require('../internals/a-function');
var definePropertyModule = require('../internals/object-define-property');

// `Object.prototype.__defineSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineSetter__: function __defineSetter__(P, setter) {
      definePropertyModule.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
    }
  });
}

},{"../internals/a-function":310,"../internals/descriptors":357,"../internals/export":361,"../internals/forced-object-prototype-accessors-methods":365,"../internals/object-define-property":415,"../internals/to-object":462}],556:[function(require,module,exports){
var $ = require('../internals/export');
var $entries = require('../internals/object-to-array').entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});

},{"../internals/export":361,"../internals/object-to-array":425}],557:[function(require,module,exports){
var $ = require('../internals/export');
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

// `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/freezing":368,"../internals/internal-metadata":385,"../internals/is-object":392}],558:[function(require,module,exports){
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var createProperty = require('../internals/create-property');

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, undefined, true);
    return obj;
  }
});

},{"../internals/create-property":352,"../internals/export":361,"../internals/iterate":395}],559:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var DESCRIPTORS = require('../internals/descriptors');

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});

},{"../internals/descriptors":357,"../internals/export":361,"../internals/fails":362,"../internals/object-get-own-property-descriptor":416,"../internals/to-indexed-object":459}],560:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var ownKeys = require('../internals/own-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var createProperty = require('../internals/create-property');

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});

},{"../internals/create-property":352,"../internals/descriptors":357,"../internals/export":361,"../internals/object-get-own-property-descriptor":416,"../internals/own-keys":427,"../internals/to-indexed-object":459}],561:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names-external').f;

var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});

},{"../internals/export":361,"../internals/fails":362,"../internals/object-get-own-property-names-external":417}],562:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var nativeGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});


},{"../internals/correct-prototype-getter":345,"../internals/export":361,"../internals/fails":362,"../internals/object-get-prototype-of":420,"../internals/to-object":462}],563:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');

var nativeIsExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsExtensible(1); });

// `Object.isExtensible` method
// https://tc39.github.io/ecma262/#sec-object.isextensible
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isExtensible: function isExtensible(it) {
    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/is-object":392}],564:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsFrozen(1); });

// `Object.isFrozen` method
// https://tc39.github.io/ecma262/#sec-object.isfrozen
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/is-object":392}],565:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');

var nativeIsSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsSealed(1); });

// `Object.isSealed` method
// https://tc39.github.io/ecma262/#sec-object.issealed
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isSealed: function isSealed(it) {
    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/is-object":392}],566:[function(require,module,exports){
var $ = require('../internals/export');
var is = require('../internals/same-value');

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
$({ target: 'Object', stat: true }, {
  is: is
});

},{"../internals/export":361,"../internals/same-value":442}],567:[function(require,module,exports){
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var nativeKeys = require('../internals/object-keys');
var fails = require('../internals/fails');

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/object-keys":422,"../internals/to-object":462}],568:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/forced-object-prototype-accessors-methods');
var toObject = require('../internals/to-object');
var toPrimitive = require('../internals/to-primitive');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;

// `Object.prototype.__lookupGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupGetter__: function __lookupGetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
      } while (O = getPrototypeOf(O));
    }
  });
}

},{"../internals/descriptors":357,"../internals/export":361,"../internals/forced-object-prototype-accessors-methods":365,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-prototype-of":420,"../internals/to-object":462,"../internals/to-primitive":465}],569:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/forced-object-prototype-accessors-methods');
var toObject = require('../internals/to-object');
var toPrimitive = require('../internals/to-primitive');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;

// `Object.prototype.__lookupSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupSetter__: function __lookupSetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
      } while (O = getPrototypeOf(O));
    }
  });
}

},{"../internals/descriptors":357,"../internals/export":361,"../internals/forced-object-prototype-accessors-methods":365,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-prototype-of":420,"../internals/to-object":462,"../internals/to-primitive":465}],570:[function(require,module,exports){
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');

var nativePreventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () { nativePreventExtensions(1); });

// `Object.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-object.preventextensions
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(it) {
    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/freezing":368,"../internals/internal-metadata":385,"../internals/is-object":392}],571:[function(require,module,exports){
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');

var nativeSeal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function () { nativeSeal(1); });

// `Object.seal` method
// https://tc39.github.io/ecma262/#sec-object.seal
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  seal: function seal(it) {
    return nativeSeal && isObject(it) ? nativeSeal(onFreeze(it)) : it;
  }
});

},{"../internals/export":361,"../internals/fails":362,"../internals/freezing":368,"../internals/internal-metadata":385,"../internals/is-object":392}],572:[function(require,module,exports){
var $ = require('../internals/export');
var setPrototypeOf = require('../internals/object-set-prototype-of');

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});

},{"../internals/export":361,"../internals/object-set-prototype-of":424}],573:[function(require,module,exports){
var redefine = require('../internals/redefine');
var toString = require('../internals/object-to-string');

var ObjectPrototype = Object.prototype;

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (toString !== ObjectPrototype.toString) {
  redefine(ObjectPrototype, 'toString', toString, { unsafe: true });
}

},{"../internals/object-to-string":426,"../internals/redefine":435}],574:[function(require,module,exports){
var $ = require('../internals/export');
var $values = require('../internals/object-to-array').values;

// `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});

},{"../internals/export":361,"../internals/object-to-array":425}],575:[function(require,module,exports){
var $ = require('../internals/export');
var parseFloatImplementation = require('../internals/parse-float');

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
$({ global: true, forced: parseFloat != parseFloatImplementation }, {
  parseFloat: parseFloatImplementation
});

},{"../internals/export":361,"../internals/parse-float":428}],576:[function(require,module,exports){
var $ = require('../internals/export');
var parseIntImplementation = require('../internals/parse-int');

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
$({ global: true, forced: parseInt != parseIntImplementation }, {
  parseInt: parseIntImplementation
});

},{"../internals/export":361,"../internals/parse-int":429}],577:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');

// `Promise.allSettled` method
// https://github.com/tc39/proposal-promise-allSettled
$({ target: 'Promise', stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (e) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: e };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":310,"../internals/export":361,"../internals/iterate":395,"../internals/new-promise-capability":409,"../internals/perform":431}],578:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromise = require('../internals/native-promise-constructor');
var getBuiltIn = require('../internals/get-built-in');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var redefine = require('../internals/redefine');

// `Promise.prototype.finally` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// patch native Promise.prototype for native async functions
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

},{"../internals/export":361,"../internals/get-built-in":372,"../internals/is-pure":393,"../internals/native-promise-constructor":405,"../internals/promise-resolve":432,"../internals/redefine":435,"../internals/species-constructor":450}],579:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var NativePromise = require('../internals/native-promise-constructor');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var shared = require('../internals/shared');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var isObject = require('../internals/is-object');
var aFunction = require('../internals/a-function');
var anInstance = require('../internals/an-instance');
var classof = require('../internals/classof-raw');
var iterate = require('../internals/iterate');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var promiseResolve = require('../internals/promise-resolve');
var hostReportErrors = require('../internals/host-report-errors');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var InternalStateModule = require('../internals/internal-state');
var isForced = require('../internals/is-forced');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/v8-version');

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var inspectSource = shared('inspectSource');
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (V8_VERSION === 66) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  if (!GLOBAL_CORE_JS_PROMISE && !IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":310,"../internals/an-instance":314,"../internals/check-correctness-of-iteration":332,"../internals/classof-raw":333,"../internals/export":361,"../internals/get-built-in":372,"../internals/global":377,"../internals/host-report-errors":380,"../internals/internal-state":386,"../internals/is-forced":389,"../internals/is-object":392,"../internals/is-pure":393,"../internals/iterate":395,"../internals/microtask":404,"../internals/native-promise-constructor":405,"../internals/new-promise-capability":409,"../internals/perform":431,"../internals/promise-resolve":432,"../internals/redefine":435,"../internals/redefine-all":434,"../internals/set-species":444,"../internals/set-to-string-tag":445,"../internals/shared":448,"../internals/species-constructor":450,"../internals/task":455,"../internals/v8-version":471,"../internals/well-known-symbol":473}],580:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var fails = require('../internals/fails');

var nativeApply = getBuiltIn('Reflect', 'apply');
var functionApply = Function.apply;

// MS Edge argumentsList argument is optional
var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
  nativeApply(function () { /* empty */ });
});

// `Reflect.apply` method
// https://tc39.github.io/ecma262/#sec-reflect.apply
$({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
  apply: function apply(target, thisArgument, argumentsList) {
    aFunction(target);
    anObject(argumentsList);
    return nativeApply
      ? nativeApply(target, thisArgument, argumentsList)
      : functionApply.call(target, thisArgument, argumentsList);
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/fails":362,"../internals/get-built-in":372}],581:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var bind = require('../internals/function-bind');
var fails = require('../internals/fails');

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/fails":362,"../internals/function-bind":369,"../internals/get-built-in":372,"../internals/is-object":392,"../internals/object-create":413}],582:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');
var definePropertyModule = require('../internals/object-define-property');
var fails = require('../internals/fails');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
var ERROR_INSTEAD_OF_FALSE = fails(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
});

// `Reflect.defineProperty` method
// https://tc39.github.io/ecma262/#sec-reflect.defineproperty
$({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    var key = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      definePropertyModule.f(target, key, attributes);
      return true;
    } catch (error) {
      return false;
    }
  }
});

},{"../internals/an-object":315,"../internals/descriptors":357,"../internals/export":361,"../internals/fails":362,"../internals/object-define-property":415,"../internals/to-primitive":465}],583:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;

// `Reflect.deleteProperty` method
// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty
$({ target: 'Reflect', stat: true }, {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/object-get-own-property-descriptor":416}],584:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');

// `Reflect.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
$({ target: 'Reflect', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  }
});

},{"../internals/an-object":315,"../internals/descriptors":357,"../internals/export":361,"../internals/object-get-own-property-descriptor":416}],585:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var objectGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

// `Reflect.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
$({ target: 'Reflect', stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(target) {
    return objectGetPrototypeOf(anObject(target));
  }
});

},{"../internals/an-object":315,"../internals/correct-prototype-getter":345,"../internals/export":361,"../internals/object-get-prototype-of":420}],586:[function(require,module,exports){
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var has = require('../internals/has');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');

// `Reflect.get` method
// https://tc39.github.io/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/has":378,"../internals/is-object":392,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-prototype-of":420}],587:[function(require,module,exports){
var $ = require('../internals/export');

// `Reflect.has` method
// https://tc39.github.io/ecma262/#sec-reflect.has
$({ target: 'Reflect', stat: true }, {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"../internals/export":361}],588:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');

var objectIsExtensible = Object.isExtensible;

// `Reflect.isExtensible` method
// https://tc39.github.io/ecma262/#sec-reflect.isextensible
$({ target: 'Reflect', stat: true }, {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return objectIsExtensible ? objectIsExtensible(target) : true;
  }
});

},{"../internals/an-object":315,"../internals/export":361}],589:[function(require,module,exports){
var $ = require('../internals/export');
var ownKeys = require('../internals/own-keys');

// `Reflect.ownKeys` method
// https://tc39.github.io/ecma262/#sec-reflect.ownkeys
$({ target: 'Reflect', stat: true }, {
  ownKeys: ownKeys
});

},{"../internals/export":361,"../internals/own-keys":427}],590:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var FREEZING = require('../internals/freezing');

// `Reflect.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-reflect.preventextensions
$({ target: 'Reflect', stat: true, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
      if (objectPreventExtensions) objectPreventExtensions(target);
      return true;
    } catch (error) {
      return false;
    }
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/freezing":368,"../internals/get-built-in":372}],591:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');
var objectSetPrototypeOf = require('../internals/object-set-prototype-of');

// `Reflect.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
if (objectSetPrototypeOf) $({ target: 'Reflect', stat: true }, {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    anObject(target);
    aPossiblePrototype(proto);
    try {
      objectSetPrototypeOf(target, proto);
      return true;
    } catch (error) {
      return false;
    }
  }
});

},{"../internals/a-possible-prototype":311,"../internals/an-object":315,"../internals/export":361,"../internals/object-set-prototype-of":424}],592:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

// `Reflect.set` method
// https://tc39.github.io/ecma262/#sec-reflect.set
function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  var existingDescriptor, prototype;
  if (!ownDescriptor) {
    if (isObject(prototype = getPrototypeOf(target))) {
      return set(prototype, propertyKey, V, receiver);
    }
    ownDescriptor = createPropertyDescriptor(0);
  }
  if (has(ownDescriptor, 'value')) {
    if (ownDescriptor.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      definePropertyModule.f(receiver, propertyKey, existingDescriptor);
    } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
    return true;
  }
  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
}

$({ target: 'Reflect', stat: true }, {
  set: set
});

},{"../internals/an-object":315,"../internals/create-property-descriptor":351,"../internals/export":361,"../internals/has":378,"../internals/is-object":392,"../internals/object-define-property":415,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-prototype-of":420}],593:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var inheritIfRequired = require('../internals/inherit-if-required');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var isRegExp = require('../internals/is-regexp');
var getFlags = require('../internals/regexp-flags');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var setSpecies = require('../internals/set-species');
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern
      : inheritIfRequired(CORRECT_NEW
        ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags)
        : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper)
          ? pattern.source
          : pattern, patternIsRegExp && flagsAreUndefined ? getFlags.call(pattern) : flags)
      , thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

},{"../internals/descriptors":357,"../internals/fails":362,"../internals/global":377,"../internals/inherit-if-required":384,"../internals/is-forced":389,"../internals/is-regexp":394,"../internals/object-define-property":415,"../internals/object-get-own-property-names":418,"../internals/redefine":435,"../internals/regexp-flags":439,"../internals/set-species":444,"../internals/well-known-symbol":473}],594:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var exec = require('../internals/regexp-exec');

$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});

},{"../internals/export":361,"../internals/regexp-exec":438}],595:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModule = require('../internals/object-define-property');
var regExpFlags = require('../internals/regexp-flags');

// `RegExp.prototype.flags` getter
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
if (DESCRIPTORS && /./g.flags != 'g') {
  objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regExpFlags
  });
}

},{"../internals/descriptors":357,"../internals/object-define-property":415,"../internals/regexp-flags":439}],596:[function(require,module,exports){
'use strict';
var redefine = require('../internals/redefine');
var anObject = require('../internals/an-object');
var fails = require('../internals/fails');
var flags = require('../internals/regexp-flags');

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}

},{"../internals/an-object":315,"../internals/fails":362,"../internals/redefine":435,"../internals/regexp-flags":439}],597:[function(require,module,exports){
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');

// `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects
module.exports = collection('Set', function (get) {
  return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);

},{"../internals/collection":341,"../internals/collection-strong":339}],598:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.anchor` method
// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],599:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.big` method
// https://tc39.github.io/ecma262/#sec-string.prototype.big
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('big') }, {
  big: function big() {
    return createHTML(this, 'big', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],600:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.blink` method
// https://tc39.github.io/ecma262/#sec-string.prototype.blink
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('blink') }, {
  blink: function blink() {
    return createHTML(this, 'blink', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],601:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.bold` method
// https://tc39.github.io/ecma262/#sec-string.prototype.bold
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('bold') }, {
  bold: function bold() {
    return createHTML(this, 'b', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],602:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var codeAt = require('../internals/string-multibyte').codeAt;

// `String.prototype.codePointAt` method
// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
$({ target: 'String', proto: true }, {
  codePointAt: function codePointAt(pos) {
    return codeAt(this, pos);
  }
});

},{"../internals/export":361,"../internals/string-multibyte":451}],603:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toLength = require('../internals/to-length');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

var nativeEndsWith = ''.endsWith;
var min = Math.min;

// `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('endsWith') }, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith
      ? nativeEndsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"../internals/correct-is-regexp-logic":344,"../internals/export":361,"../internals/not-a-regexp":410,"../internals/require-object-coercible":440,"../internals/to-length":461}],604:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.fixed` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fixed') }, {
  fixed: function fixed() {
    return createHTML(this, 'tt', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],605:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.fontcolor` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fontcolor') }, {
  fontcolor: function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],606:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.fontsize` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fontsize') }, {
  fontsize: function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],607:[function(require,module,exports){
var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');

var fromCharCode = String.fromCharCode;
var nativeFromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

// `String.fromCodePoint` method
// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
$({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;
    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
      elements.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)
      );
    } return elements.join('');
  }
});

},{"../internals/export":361,"../internals/to-absolute-index":457}],608:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/correct-is-regexp-logic":344,"../internals/export":361,"../internals/not-a-regexp":410,"../internals/require-object-coercible":440}],609:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.italics` method
// https://tc39.github.io/ecma262/#sec-string.prototype.italics
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('italics') }, {
  italics: function italics() {
    return createHTML(this, 'i', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],610:[function(require,module,exports){
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});

},{"../internals/define-iterator":355,"../internals/internal-state":386,"../internals/string-multibyte":451}],611:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.link` method
// https://tc39.github.io/ecma262/#sec-string.prototype.link
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('link') }, {
  link: function link(url) {
    return createHTML(this, 'a', 'href', url);
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],612:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toLength = require('../internals/to-length');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var classof = require('../internals/classof');
var isRegExp = require('../internals/is-regexp');
var getRegExpFlags = require('../internals/regexp-flags');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var InternalStateModule = require('../internals/internal-state');
var IS_PURE = require('../internals/is-pure');

var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var regExpBuiltinExec = RegExpPrototype.exec;
var nativeMatchAll = ''.matchAll;

var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
  'a'.matchAll(/./);
});

var regExpExec = function (R, S) {
  var exec = R.exec;
  var result;
  if (typeof exec == 'function') {
    result = exec.call(R, S);
    if (typeof result != 'object') throw TypeError('Incorrect exec result');
    return result;
  } return regExpBuiltinExec.call(R, S);
};

// eslint-disable-next-line max-len
var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
  setInternalState(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState(this);
  if (state.done) return { value: undefined, done: true };
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec(R, S);
  if (match === null) return { value: undefined, done: state.done = true };
  if (state.global) {
    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
    return { value: match, done: false };
  }
  state.done = true;
  return { value: match, done: false };
});

var $matchAll = function (string) {
  var R = anObject(this);
  var S = String(string);
  var C, flagsValue, flags, matcher, global, fullUnicode;
  C = speciesConstructor(R, RegExp);
  flagsValue = R.flags;
  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) {
    flagsValue = getRegExpFlags.call(R);
  }
  flags = flagsValue === undefined ? '' : String(flagsValue);
  matcher = new C(C === RegExp ? R.source : R, flags);
  global = !!~flags.indexOf('g');
  fullUnicode = !!~flags.indexOf('u');
  matcher.lastIndex = toLength(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, global, fullUnicode);
};

// `String.prototype.matchAll` method
// https://github.com/tc39/proposal-string-matchall
$({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible(this);
    var flags, S, matcher, rx;
    if (regexp != null) {
      if (isRegExp(regexp)) {
        flags = String(requireObjectCoercible('flags' in RegExpPrototype
          ? regexp.flags
          : getRegExpFlags.call(regexp)
        ));
        if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
      matcher = regexp[MATCH_ALL];
      if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
      if (matcher != null) return aFunction(matcher).call(regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
    S = String(O);
    rx = new RegExp(regexp, 'g');
    return IS_PURE ? $matchAll.call(rx, S) : rx[MATCH_ALL](S);
  }
});

IS_PURE || MATCH_ALL in RegExpPrototype || createNonEnumerableProperty(RegExpPrototype, MATCH_ALL, $matchAll);

},{"../internals/a-function":310,"../internals/advance-string-index":313,"../internals/an-object":315,"../internals/classof":334,"../internals/create-iterator-constructor":348,"../internals/create-non-enumerable-property":350,"../internals/export":361,"../internals/fails":362,"../internals/internal-state":386,"../internals/is-pure":393,"../internals/is-regexp":394,"../internals/regexp-flags":439,"../internals/require-object-coercible":440,"../internals/species-constructor":450,"../internals/to-length":461,"../internals/well-known-symbol":473}],613:[function(require,module,exports){
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toLength = require('../internals/to-length');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"../internals/advance-string-index":313,"../internals/an-object":315,"../internals/fix-regexp-well-known-symbol-logic":363,"../internals/regexp-exec-abstract":437,"../internals/require-object-coercible":440,"../internals/to-length":461}],614:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $padEnd = require('../internals/string-pad').end;
var WEBKIT_BUG = require('../internals/webkit-string-pad-bug');

// `String.prototype.padEnd` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padend
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/export":361,"../internals/string-pad":452,"../internals/webkit-string-pad-bug":472}],615:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $padStart = require('../internals/string-pad').start;
var WEBKIT_BUG = require('../internals/webkit-string-pad-bug');

// `String.prototype.padStart` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/export":361,"../internals/string-pad":452,"../internals/webkit-string-pad-bug":472}],616:[function(require,module,exports){
var $ = require('../internals/export');
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');

// `String.raw` method
// https://tc39.github.io/ecma262/#sec-string.raw
$({ target: 'String', stat: true }, {
  raw: function raw(template) {
    var rawTemplate = toIndexedObject(template.raw);
    var literalSegments = toLength(rawTemplate.length);
    var argumentsLength = arguments.length;
    var elements = [];
    var i = 0;
    while (literalSegments > i) {
      elements.push(String(rawTemplate[i++]));
      if (i < argumentsLength) elements.push(String(arguments[i]));
    } return elements.join('');
  }
});

},{"../internals/export":361,"../internals/to-indexed-object":459,"../internals/to-length":461}],617:[function(require,module,exports){
var $ = require('../internals/export');
var repeat = require('../internals/string-repeat');

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
$({ target: 'String', proto: true }, {
  repeat: repeat
});

},{"../internals/export":361,"../internals/string-repeat":453}],618:[function(require,module,exports){
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"../internals/advance-string-index":313,"../internals/an-object":315,"../internals/fix-regexp-well-known-symbol-logic":363,"../internals/regexp-exec-abstract":437,"../internals/require-object-coercible":440,"../internals/to-integer":460,"../internals/to-length":461,"../internals/to-object":462}],619:[function(require,module,exports){
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var sameValue = require('../internals/same-value');
var regExpExec = require('../internals/regexp-exec-abstract');

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"../internals/an-object":315,"../internals/fix-regexp-well-known-symbol-logic":363,"../internals/regexp-exec-abstract":437,"../internals/require-object-coercible":440,"../internals/same-value":442}],620:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.small` method
// https://tc39.github.io/ecma262/#sec-string.prototype.small
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('small') }, {
  small: function small() {
    return createHTML(this, 'small', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],621:[function(require,module,exports){
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var isRegExp = require('../internals/is-regexp');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var toLength = require('../internals/to-length');
var callRegExpExec = require('../internals/regexp-exec-abstract');
var regexpExec = require('../internals/regexp-exec');
var fails = require('../internals/fails');

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);

},{"../internals/advance-string-index":313,"../internals/an-object":315,"../internals/fails":362,"../internals/fix-regexp-well-known-symbol-logic":363,"../internals/is-regexp":394,"../internals/regexp-exec":438,"../internals/regexp-exec-abstract":437,"../internals/require-object-coercible":440,"../internals/species-constructor":450,"../internals/to-length":461}],622:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toLength = require('../internals/to-length');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

var nativeStartsWith = ''.startsWith;
var min = Math.min;

// `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('startsWith') }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith
      ? nativeStartsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"../internals/correct-is-regexp-logic":344,"../internals/export":361,"../internals/not-a-regexp":410,"../internals/require-object-coercible":440,"../internals/to-length":461}],623:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.strike` method
// https://tc39.github.io/ecma262/#sec-string.prototype.strike
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('strike') }, {
  strike: function strike() {
    return createHTML(this, 'strike', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],624:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.sub` method
// https://tc39.github.io/ecma262/#sec-string.prototype.sub
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('sub') }, {
  sub: function sub() {
    return createHTML(this, 'sub', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],625:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/forced-string-html-method');

// `String.prototype.sup` method
// https://tc39.github.io/ecma262/#sec-string.prototype.sup
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('sup') }, {
  sup: function sup() {
    return createHTML(this, 'sup', '', '');
  }
});

},{"../internals/create-html":347,"../internals/export":361,"../internals/forced-string-html-method":366}],626:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $trimEnd = require('../internals/string-trim').end;
var forcedStringTrimMethod = require('../internals/forced-string-trim-method');

var FORCED = forcedStringTrimMethod('trimEnd');

var trimEnd = FORCED ? function trimEnd() {
  return $trimEnd(this);
} : ''.trimEnd;

// `String.prototype.{ trimEnd, trimRight }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
$({ target: 'String', proto: true, forced: FORCED }, {
  trimEnd: trimEnd,
  trimRight: trimEnd
});

},{"../internals/export":361,"../internals/forced-string-trim-method":367,"../internals/string-trim":454}],627:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $trimStart = require('../internals/string-trim').start;
var forcedStringTrimMethod = require('../internals/forced-string-trim-method');

var FORCED = forcedStringTrimMethod('trimStart');

var trimStart = FORCED ? function trimStart() {
  return $trimStart(this);
} : ''.trimStart;

// `String.prototype.{ trimStart, trimLeft }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
$({ target: 'String', proto: true, forced: FORCED }, {
  trimStart: trimStart,
  trimLeft: trimStart
});

},{"../internals/export":361,"../internals/forced-string-trim-method":367,"../internals/string-trim":454}],628:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $trim = require('../internals/string-trim').trim;
var forcedStringTrimMethod = require('../internals/forced-string-trim-method');

// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});

},{"../internals/export":361,"../internals/forced-string-trim-method":367,"../internals/string-trim":454}],629:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

},{"../internals/define-well-known-symbol":356}],630:[function(require,module,exports){
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var has = require('../internals/has');
var isObject = require('../internals/is-object');
var defineProperty = require('../internals/object-define-property').f;
var copyConstructorProperties = require('../internals/copy-constructor-properties');

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}

},{"../internals/copy-constructor-properties":343,"../internals/descriptors":357,"../internals/export":361,"../internals/global":377,"../internals/has":378,"../internals/is-object":392,"../internals/object-define-property":415}],631:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.hasInstance` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');

},{"../internals/define-well-known-symbol":356}],632:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');

},{"../internals/define-well-known-symbol":356}],633:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/define-well-known-symbol":356}],634:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var fails = require('../internals/fails');
var has = require('../internals/has');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var nativeObjectCreate = require('../internals/object-create');
var objectKeys = require('../internals/object-keys');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var shared = require('../internals/shared');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var uid = require('../internals/uid');
var wellKnownSymbol = require('../internals/well-known-symbol');
var wrappedWellKnownSymbolModule = require('../internals/wrapped-well-known-symbol');
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var $forEach = require('../internals/array-iteration').forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;

},{"../internals/an-object":315,"../internals/array-iteration":323,"../internals/create-non-enumerable-property":350,"../internals/create-property-descriptor":351,"../internals/define-well-known-symbol":356,"../internals/descriptors":357,"../internals/export":361,"../internals/fails":362,"../internals/get-built-in":372,"../internals/global":377,"../internals/has":378,"../internals/hidden-keys":379,"../internals/internal-state":386,"../internals/is-array":388,"../internals/is-object":392,"../internals/is-pure":393,"../internals/native-symbol":406,"../internals/object-create":413,"../internals/object-define-property":415,"../internals/object-get-own-property-descriptor":416,"../internals/object-get-own-property-names":418,"../internals/object-get-own-property-names-external":417,"../internals/object-get-own-property-symbols":419,"../internals/object-keys":422,"../internals/object-property-is-enumerable":423,"../internals/redefine":435,"../internals/set-to-string-tag":445,"../internals/shared":448,"../internals/shared-key":446,"../internals/to-indexed-object":459,"../internals/to-object":462,"../internals/to-primitive":465,"../internals/uid":469,"../internals/well-known-symbol":473,"../internals/wrapped-well-known-symbol":475}],635:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.matchAll` well-known symbol
defineWellKnownSymbol('matchAll');

},{"../internals/define-well-known-symbol":356}],636:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.match` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');

},{"../internals/define-well-known-symbol":356}],637:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.replace` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');

},{"../internals/define-well-known-symbol":356}],638:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.search` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');

},{"../internals/define-well-known-symbol":356}],639:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.species` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');

},{"../internals/define-well-known-symbol":356}],640:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.split` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');

},{"../internals/define-well-known-symbol":356}],641:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.toPrimitive` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

},{"../internals/define-well-known-symbol":356}],642:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.toStringTag` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

},{"../internals/define-well-known-symbol":356}],643:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.unscopables` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');

},{"../internals/define-well-known-symbol":356}],644:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $copyWithin = require('../internals/array-copy-within');

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
ArrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-copy-within":318}],645:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $every = require('../internals/array-iteration').every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
ArrayBufferViewCore.exportProto('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323}],646:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $fill = require('../internals/array-fill');

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-fill":319}],647:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filter = require('../internals/array-iteration').filter;
var speciesConstructor = require('../internals/species-constructor');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
ArrayBufferViewCore.exportProto('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323,"../internals/species-constructor":450}],648:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findIndex = require('../internals/array-iteration').findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
ArrayBufferViewCore.exportProto('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323}],649:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $find = require('../internals/array-iteration').find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
ArrayBufferViewCore.exportProto('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323}],650:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],651:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],652:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $forEach = require('../internals/array-iteration').forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
ArrayBufferViewCore.exportProto('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323}],653:[function(require,module,exports){
'use strict';
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-arrays-constructors-requires-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var typedArrayFrom = require('../internals/typed-array-from');

// `%TypedArray%.from` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.from
ArrayBufferViewCore.exportStatic('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/array-buffer-view-core":316,"../internals/typed-array-from":467,"../internals/typed-arrays-constructors-requires-wrappers":468}],654:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $includes = require('../internals/array-includes').includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
ArrayBufferViewCore.exportProto('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-includes":322}],655:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $indexOf = require('../internals/array-includes').indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
ArrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-includes":322}],656:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Int16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],657:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Int32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],658:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Int8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],659:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayIterators = require('../modules/es.array.iterator');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportProto = ArrayBufferViewCore.exportProto;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportProto('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportProto('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportProto('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

},{"../internals/array-buffer-view-core":316,"../internals/global":377,"../internals/well-known-symbol":473,"../modules/es.array.iterator":493}],660:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":316}],661:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $lastIndexOf = require('../internals/array-last-index-of');

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-last-index-of":324}],662:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $map = require('../internals/array-iteration').map;
var speciesConstructor = require('../internals/species-constructor');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
ArrayBufferViewCore.exportProto('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323,"../internals/species-constructor":450}],663:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-arrays-constructors-requires-wrappers');

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.of` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.of
ArrayBufferViewCore.exportStatic('of', function of(/* ...items */) {
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/array-buffer-view-core":316,"../internals/typed-arrays-constructors-requires-wrappers":468}],664:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduceRight = require('../internals/array-reduce').right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
ArrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-reduce":326}],665:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduce = require('../internals/array-reduce').left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
ArrayBufferViewCore.exportProto('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-reduce":326}],666:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
ArrayBufferViewCore.exportProto('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});

},{"../internals/array-buffer-view-core":316}],667:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toOffset = require('../internals/to-offset');
var toObject = require('../internals/to-object');
var fails = require('../internals/fails');

var aTypedArray = ArrayBufferViewCore.aTypedArray;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
ArrayBufferViewCore.exportProto('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);

},{"../internals/array-buffer-view-core":316,"../internals/fails":362,"../internals/to-length":461,"../internals/to-object":462,"../internals/to-offset":463}],668:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var speciesConstructor = require('../internals/species-constructor');
var fails = require('../internals/fails');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
ArrayBufferViewCore.exportProto('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);

},{"../internals/array-buffer-view-core":316,"../internals/fails":362,"../internals/species-constructor":450}],669:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $some = require('../internals/array-iteration').some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
ArrayBufferViewCore.exportProto('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":316,"../internals/array-iteration":323}],670:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
ArrayBufferViewCore.exportProto('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});

},{"../internals/array-buffer-view-core":316}],671:[function(require,module,exports){
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var speciesConstructor = require('../internals/species-constructor');

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
ArrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});

},{"../internals/array-buffer-view-core":316,"../internals/species-constructor":450,"../internals/to-absolute-index":457,"../internals/to-length":461}],672:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var fails = require('../internals/fails');

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
ArrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);

},{"../internals/array-buffer-view-core":316,"../internals/fails":362,"../internals/global":377}],673:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var fails = require('../internals/fails');

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype;
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
ArrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString);

},{"../internals/array-buffer-view-core":316,"../internals/fails":362,"../internals/global":377}],674:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],675:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],676:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"../internals/typed-array-constructor":466}],677:[function(require,module,exports){
var typedArrayConstructor = require('../internals/typed-array-constructor');

// `Uint8ClampedArray` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"../internals/typed-array-constructor":466}],678:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var redefineAll = require('../internals/redefine-all');
var InternalMetadataModule = require('../internals/internal-metadata');
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
var isObject = require('../internals/is-object');
var enforceIternalState = require('../internals/internal-state').enforce;
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.github.io/ecma262/#sec-weakmap-constructor
var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak, true, true);

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      } return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      } return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      } return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);
      return this;
    }
  });
}

},{"../internals/collection":341,"../internals/collection-weak":340,"../internals/global":377,"../internals/internal-metadata":385,"../internals/internal-state":386,"../internals/is-object":392,"../internals/native-weak-map":408,"../internals/redefine-all":434}],679:[function(require,module,exports){
'use strict';
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');

// `WeakSet` constructor
// https://tc39.github.io/ecma262/#sec-weakset-constructor
collection('WeakSet', function (get) {
  return function WeakSet() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak, false, true);

},{"../internals/collection":341,"../internals/collection-weak":340}],680:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var create = require('../internals/object-create');
var defineProperty = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var iterate = require('../internals/iterate');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var InternalStateModule = require('../internals/internal-state');

var setInternalState = InternalStateModule.set;
var getInternalAggregateErrorState = InternalStateModule.getterFor('AggregateError');

var $AggregateError = function AggregateError(errors, message) {
  var that = this;
  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
  if (setPrototypeOf) {
    that = setPrototypeOf(new Error(message), getPrototypeOf(that));
  }
  var errorsArray = [];
  iterate(errors, errorsArray.push, errorsArray);
  if (DESCRIPTORS) setInternalState(that, { errors: errorsArray, type: 'AggregateError' });
  else that.errors = errorsArray;
  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
  return that;
};

$AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(5, $AggregateError),
  message: createPropertyDescriptor(5, ''),
  name: createPropertyDescriptor(5, 'AggregateError')
});

if (DESCRIPTORS) defineProperty.f($AggregateError.prototype, 'errors', {
  get: function () {
    return getInternalAggregateErrorState(this).errors;
  },
  configurable: true
});

$({ global: true }, {
  AggregateError: $AggregateError
});

},{"../internals/create-non-enumerable-property":350,"../internals/create-property-descriptor":351,"../internals/descriptors":357,"../internals/export":361,"../internals/internal-state":386,"../internals/iterate":395,"../internals/object-create":413,"../internals/object-define-property":415,"../internals/object-get-prototype-of":420,"../internals/object-set-prototype-of":424}],681:[function(require,module,exports){
var $ = require('../internals/export');
var isArray = require('../internals/is-array');

var isFrozen = Object.isFrozen;

var isFrozenStringArray = function (array, allowUndefined) {
  if (!isFrozen || !isArray(array) || !isFrozen(array)) return false;
  var index = 0;
  var length = array.length;
  var element;
  while (index < length) {
    element = array[index++];
    if (!(typeof element === 'string' || (allowUndefined && typeof element === 'undefined'))) {
      return false;
    }
  } return length !== 0;
};

// `Array.isTemplateObject` method
// https://github.com/tc39/proposal-array-is-template-object
$({ target: 'Array', stat: true }, {
  isTemplateObject: function isTemplateObject(value) {
    if (!isFrozenStringArray(value, true)) return false;
    var raw = value.raw;
    if (raw.length !== value.length || !isFrozenStringArray(raw, false)) return false;
    return true;
  }
});

},{"../internals/export":361,"../internals/is-array":388}],682:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var addToUnscopables = require('../internals/add-to-unscopables');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var defineProperty = require('../internals/object-define-property').f;

// `Array.prototype.lastIndex` getter
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS && !('lastIndex' in [])) {
  defineProperty(Array.prototype, 'lastIndex', {
    configurable: true,
    get: function lastIndex() {
      var O = toObject(this);
      var len = toLength(O.length);
      return len == 0 ? 0 : len - 1;
    }
  });

  addToUnscopables('lastIndex');
}

},{"../internals/add-to-unscopables":312,"../internals/descriptors":357,"../internals/object-define-property":415,"../internals/to-length":461,"../internals/to-object":462}],683:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var addToUnscopables = require('../internals/add-to-unscopables');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var defineProperty = require('../internals/object-define-property').f;

// `Array.prototype.lastIndex` accessor
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS && !('lastItem' in [])) {
  defineProperty(Array.prototype, 'lastItem', {
    configurable: true,
    get: function lastItem() {
      var O = toObject(this);
      var len = toLength(O.length);
      return len == 0 ? undefined : O[len - 1];
    },
    set: function lastItem(value) {
      var O = toObject(this);
      var len = toLength(O.length);
      return O[len == 0 ? 0 : len - 1] = value;
    }
  });

  addToUnscopables('lastItem');
}

},{"../internals/add-to-unscopables":312,"../internals/descriptors":357,"../internals/object-define-property":415,"../internals/to-length":461,"../internals/to-object":462}],684:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anInstance = require('../internals/an-instance');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var AsyncIteratorPrototype = require('../internals/async-iterator-prototype');
var IS_PURE = require('../internals/is-pure');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var AsyncIteratorConstructor = function AsyncIterator() {
  anInstance(this, AsyncIteratorConstructor);
};

AsyncIteratorConstructor.prototype = AsyncIteratorPrototype;

if (!has(AsyncIteratorPrototype, TO_STRING_TAG)) {
  createNonEnumerableProperty(AsyncIteratorPrototype, TO_STRING_TAG, 'AsyncIterator');
}

if (!has(AsyncIteratorPrototype, 'constructor') || AsyncIteratorPrototype.constructor === Object) {
  createNonEnumerableProperty(AsyncIteratorPrototype, 'constructor', AsyncIteratorConstructor);
}

$({ global: true, forced: IS_PURE }, {
  AsyncIterator: AsyncIteratorConstructor
});

},{"../internals/an-instance":314,"../internals/async-iterator-prototype":329,"../internals/create-non-enumerable-property":350,"../internals/export":361,"../internals/has":378,"../internals/is-pure":393,"../internals/well-known-symbol":473}],685:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createAsyncIteratorProxy = require('../internals/create-async-iterator-proxy');

var AsyncIteratorProxy = createAsyncIteratorProxy(function (arg, Promise) {
  var state = this;

  return new Promise(function (resolve, reject) {
    var loop = function () {
      try {
        Promise.resolve(
          anObject(state.next.call(state.iterator, state.remaining ? undefined : arg))
        ).then(function (step) {
          try {
            if (anObject(step).done) {
              state.done = true;
              resolve({ done: true, value: undefined });
            } else if (state.remaining) {
              state.remaining--;
              loop();
            } else resolve({ done: false, value: step.value });
          } catch (err) { reject(err); }
        }, reject);
      } catch (error) { reject(error); }
    };

    loop();
  });
});

$({ target: 'AsyncIterator', proto: true, real: true }, {
  drop: function drop(limit) {
    return new AsyncIteratorProxy({
      iterator: anObject(this),
      remaining: toPositiveInteger(limit)
    });
  }
});

},{"../internals/an-object":315,"../internals/create-async-iterator-proxy":346,"../internals/export":361,"../internals/to-positive-integer":464}],686:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/create-async-iterator-proxy');

var AsyncIteratorProxy = createAsyncIteratorProxy(function (arg, Promise) {
  var state = this;
  var filterer = state.filterer;

  return new Promise(function (resolve, reject) {
    var loop = function () {
      try {
        Promise.resolve(anObject(state.next.call(state.iterator, arg))).then(function (step) {
          try {
            if (anObject(step).done) {
              state.done = true;
              resolve({ done: true, value: undefined });
            } else {
              var value = step.value;
              Promise.resolve(filterer(value)).then(function (selected) {
                selected ? resolve({ done: false, value: value }) : loop();
              }, reject);
            }
          } catch (err) { reject(err); }
        }, reject);
      } catch (error) { reject(error); }
    };

    loop();
  });
});

$({ target: 'AsyncIterator', proto: true, real: true }, {
  filter: function filter(filterer) {
    return new AsyncIteratorProxy({
      iterator: anObject(this),
      filterer: aFunction(filterer)
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-async-iterator-proxy":346,"../internals/export":361}],687:[function(require,module,exports){
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var path = require('../internals/path');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var createAsyncIteratorProxy = require('../internals/create-async-iterator-proxy');
var getAsyncIteratorMethod = require('../internals/get-async-iterator-method');

var AsyncIterator = path.AsyncIterator;

var AsyncIteratorProxy = createAsyncIteratorProxy(function (arg) {
  return anObject(this.next.call(this.iterator, arg));
}, true);

$({ target: 'AsyncIterator', stat: true }, {
  from: function from(O) {
    var object = toObject(O);
    var usingIterator = getAsyncIteratorMethod(object);
    var iterator;
    if (usingIterator != null) {
      iterator = aFunction(usingIterator).call(object);
      if (iterator instanceof AsyncIterator) return iterator;
    } else {
      iterator = object;
    } return new AsyncIteratorProxy({
      iterator: iterator
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-async-iterator-proxy":346,"../internals/export":361,"../internals/get-async-iterator-method":371,"../internals/path":430,"../internals/to-object":462}],688:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/create-async-iterator-proxy');

var AsyncIteratorProxy = createAsyncIteratorProxy(function (arg, Promise) {
  var state = this;
  var mapper = state.mapper;

  return Promise.resolve(anObject(state.next.call(state.iterator, arg))).then(function (step) {
    if (anObject(step).done) {
      state.done = true;
      return { done: true, value: undefined };
    }
    return Promise.resolve(mapper(step.value)).then(function (value) {
      return { done: false, value: value };
    });
  });
});

$({ target: 'AsyncIterator', proto: true, real: true }, {
  map: function map(mapper) {
    return new AsyncIteratorProxy({
      iterator: anObject(this),
      mapper: aFunction(mapper)
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-async-iterator-proxy":346,"../internals/export":361}],689:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createAsyncIteratorProxy = require('../internals/create-async-iterator-proxy');

var AsyncIteratorProxy = createAsyncIteratorProxy(function (arg) {
  if (!this.remaining--) {
    this.done = true;
    return { done: true, value: undefined };
  } return this.next.call(this.iterator, arg);
});

$({ target: 'AsyncIterator', proto: true, real: true }, {
  take: function take(limit) {
    return new AsyncIteratorProxy({
      iterator: anObject(this),
      remaining: toPositiveInteger(limit)
    });
  }
});

},{"../internals/an-object":315,"../internals/create-async-iterator-proxy":346,"../internals/export":361,"../internals/to-positive-integer":464}],690:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $toArray = require('../internals/async-iterator-iteration').toArray;

$({ target: 'AsyncIterator', proto: true, real: true }, {
  toArray: function toArray() {
    return $toArray(this);
  }
});

},{"../internals/async-iterator-iteration":328,"../internals/export":361}],691:[function(require,module,exports){
var $ = require('../internals/export');
var getCompositeKeyNode = require('../internals/composite-key');
var getBuiltIn = require('../internals/get-built-in');
var create = require('../internals/object-create');

var initializer = function () {
  var freeze = getBuiltIn('Object', 'freeze');
  return freeze ? freeze(create(null)) : create(null);
};

// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({ global: true }, {
  compositeKey: function compositeKey() {
    return getCompositeKeyNode.apply(Object, arguments).get('object', initializer);
  }
});

},{"../internals/composite-key":342,"../internals/export":361,"../internals/get-built-in":372,"../internals/object-create":413}],692:[function(require,module,exports){
var $ = require('../internals/export');
var getCompositeKeyNode = require('../internals/composite-key');
var getBuiltIn = require('../internals/get-built-in');

// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({ global: true }, {
  compositeSymbol: function compositeSymbol() {
    if (arguments.length === 1 && typeof arguments[0] === 'string') return getBuiltIn('Symbol')['for'](arguments[0]);
    return getCompositeKeyNode.apply(null, arguments).get('symbol', getBuiltIn('Symbol'));
  }
});

},{"../internals/composite-key":342,"../internals/export":361,"../internals/get-built-in":372}],693:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.global-this');

},{"./es.global-this":517}],694:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/create-iterator-proxy');

var IteratorProxy = createIteratorProxy(function (arg) {
  var result = anObject(this.next.call(this.iterator, arg));
  var done = this.done = !!result.done;
  if (!done) return [this.index++, result.value];
});

$({ target: 'Iterator', proto: true, real: true }, {
  asIndexedPairs: function asIndexedPairs() {
    return new IteratorProxy({
      iterator: anObject(this),
      index: 0
    });
  }
});

},{"../internals/an-object":315,"../internals/create-iterator-proxy":349,"../internals/export":361}],695:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var global = require('../internals/global');
var anInstance = require('../internals/an-instance');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var IS_PURE = require('../internals/is-pure');

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var NativeIterator = global.Iterator;

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE || typeof NativeIterator != 'function' || NativeIterator.prototype !== IteratorPrototype;

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorConstructor);
};

if (IS_PURE) {
  IteratorPrototype = {};
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

if (!has(IteratorPrototype, TO_STRING_TAG)) {
  createNonEnumerableProperty(IteratorPrototype, TO_STRING_TAG, 'Iterator');
}

if (!has(IteratorPrototype, 'constructor') || IteratorPrototype.constructor === Object) {
  createNonEnumerableProperty(IteratorPrototype, 'constructor', IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

$({ global: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});

},{"../internals/an-instance":314,"../internals/create-non-enumerable-property":350,"../internals/export":361,"../internals/global":377,"../internals/has":378,"../internals/is-pure":393,"../internals/iterators-core":396,"../internals/well-known-symbol":473}],696:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createIteratorProxy = require('../internals/create-iterator-proxy');

var IteratorProxy = createIteratorProxy(function (arg) {
  var iterator = this.iterator;
  var next = this.next;
  var result, done;
  while (this.remaining) {
    this.remaining--;
    result = anObject(next.call(iterator));
    done = this.done = !!result.done;
    if (done) return;
  }
  result = anObject(next.call(iterator, arg));
  done = this.done = !!result.done;
  if (!done) return result.value;
});

$({ target: 'Iterator', proto: true, real: true }, {
  drop: function drop(limit) {
    return new IteratorProxy({
      iterator: anObject(this),
      remaining: toPositiveInteger(limit)
    });
  }
});

},{"../internals/an-object":315,"../internals/create-iterator-proxy":349,"../internals/export":361,"../internals/to-positive-integer":464}],697:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');

$({ target: 'Iterator', proto: true, real: true }, {
  every: function every(fn) {
    anObject(this);
    aFunction(fn);
    return !iterate(this, function (value) {
      if (!fn(value)) return iterate.stop();
    }, undefined, false, true).stopped;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],698:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/create-iterator-proxy');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');

var IteratorProxy = createIteratorProxy(function (arg) {
  var iterator = this.iterator;
  var filterer = this.filterer;
  var next = this.next;
  var result, done, value;
  while (true) {
    result = anObject(next.call(iterator, arg));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing(iterator, filterer, value)) return value;
  }
});

$({ target: 'Iterator', proto: true, real: true }, {
  filter: function filter(filterer) {
    return new IteratorProxy({
      iterator: anObject(this),
      filterer: aFunction(filterer)
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/call-with-safe-iteration-closing":331,"../internals/create-iterator-proxy":349,"../internals/export":361}],699:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');

$({ target: 'Iterator', proto: true, real: true }, {
  find: function find(fn) {
    anObject(this);
    aFunction(fn);
    return iterate(this, function (value) {
      if (fn(value)) return iterate.stop(value);
    }, undefined, false, true).result;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],700:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var anObject = require('../internals/an-object');

$({ target: 'Iterator', proto: true, real: true }, {
  forEach: function forEach(fn) {
    iterate(anObject(this), fn, undefined, false, true);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],701:[function(require,module,exports){
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var path = require('../internals/path');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var createIteratorProxy = require('../internals/create-iterator-proxy');
var getIteratorMethod = require('../internals/get-iterator-method');

var Iterator = path.Iterator;

var IteratorProxy = createIteratorProxy(function (arg) {
  var result = anObject(this.next.call(this.iterator, arg));
  var done = this.done = !!result.done;
  if (!done) return result.value;
}, true);

$({ target: 'Iterator', stat: true }, {
  from: function from(O) {
    var object = toObject(O);
    var usingIterator = getIteratorMethod(object);
    var iterator;
    if (usingIterator != null) {
      iterator = aFunction(usingIterator).call(object);
      if (iterator instanceof Iterator) return iterator;
    } else {
      iterator = object;
    } return new IteratorProxy({
      iterator: iterator
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/create-iterator-proxy":349,"../internals/export":361,"../internals/get-iterator-method":373,"../internals/path":430,"../internals/to-object":462}],702:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/create-iterator-proxy');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');

var IteratorProxy = createIteratorProxy(function (arg) {
  var iterator = this.iterator;
  var result = anObject(this.next.call(iterator, arg));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, result.value);
});

$({ target: 'Iterator', proto: true, real: true }, {
  map: function map(mapper) {
    return new IteratorProxy({
      iterator: anObject(this),
      mapper: aFunction(mapper)
    });
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/call-with-safe-iteration-closing":331,"../internals/create-iterator-proxy":349,"../internals/export":361}],703:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');

$({ target: 'Iterator', proto: true, real: true }, {
  reduce: function reduce(reducer /* , initialValue */) {
    anObject(this);
    aFunction(reducer);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    iterate(this, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value);
      }
    }, undefined, false, true);
    if (noInitial) throw TypeError('Reduce of empty iterator with no initial value');
    return accumulator;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],704:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');

$({ target: 'Iterator', proto: true, real: true }, {
  some: function some(fn) {
    anObject(this);
    aFunction(fn);
    return iterate(this, function (value) {
      if (fn(value)) return iterate.stop();
    }, undefined, false, true).stopped;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],705:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createIteratorProxy = require('../internals/create-iterator-proxy');

var IteratorProxy = createIteratorProxy(function (arg) {
  if (!this.remaining--) {
    this.done = true;
    return;
  }
  var result = anObject(this.next.call(this.iterator, arg));
  var done = this.done = !!result.done;
  if (!done) return result.value;
});

$({ target: 'Iterator', proto: true, real: true }, {
  take: function take(limit) {
    return new IteratorProxy({
      iterator: anObject(this),
      remaining: toPositiveInteger(limit)
    });
  }
});

},{"../internals/an-object":315,"../internals/create-iterator-proxy":349,"../internals/export":361,"../internals/to-positive-integer":464}],706:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var anObject = require('../internals/an-object');

var push = [].push;

$({ target: 'Iterator', proto: true, real: true }, {
  toArray: function toArray() {
    var result = [];
    iterate(anObject(this), push, result, false, true);
    return result;
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395}],707:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionDeleteAll = require('../internals/collection-delete-all');

// `Map.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  deleteAll: function deleteAll(/* ...elements */) {
    return collectionDeleteAll.apply(this, arguments);
  }
});

},{"../internals/collection-delete-all":336,"../internals/export":361,"../internals/is-pure":393}],708:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  every: function every(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return !iterate(iterator, function (key, value) {
      if (!boundFunction(value, key, map)) return iterate.stop();
    }, undefined, true, true).stopped;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],709:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aFunction(newMap.set);
    iterate(iterator, function (key, value) {
      if (boundFunction(value, key, map)) setter.call(newMap, key, value);
    }, undefined, true, true);
    return newMap;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],710:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.findKey` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  findKey: function findKey(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return iterate(iterator, function (key, value) {
      if (boundFunction(value, key, map)) return iterate.stop(key);
    }, undefined, true, true).result;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],711:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  find: function find(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return iterate(iterator, function (key, value) {
      if (boundFunction(value, key, map)) return iterate.stop(value);
    }, undefined, true, true).result;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],712:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/collection-from');

// `Map.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
$({ target: 'Map', stat: true }, {
  from: from
});

},{"../internals/collection-from":337,"../internals/export":361}],713:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');

// `Map.groupBy` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', stat: true }, {
  groupBy: function groupBy(iterable, keyDerivative) {
    var newMap = new this();
    aFunction(keyDerivative);
    var has = aFunction(newMap.has);
    var get = aFunction(newMap.get);
    var set = aFunction(newMap.set);
    iterate(iterable, function (element) {
      var derivedKey = keyDerivative(element);
      if (!has.call(newMap, derivedKey)) set.call(newMap, derivedKey, [element]);
      else get.call(newMap, derivedKey).push(element);
    });
    return newMap;
  }
});

},{"../internals/a-function":310,"../internals/export":361,"../internals/iterate":395}],714:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var getMapIterator = require('../internals/get-map-iterator');
var sameValueZero = require('../internals/same-value-zero');
var iterate = require('../internals/iterate');

// `Map.prototype.includes` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  includes: function includes(searchElement) {
    return iterate(getMapIterator(anObject(this)), function (key, value) {
      if (sameValueZero(value, searchElement)) return iterate.stop();
    }, undefined, true, true).stopped;
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395,"../internals/same-value-zero":441}],715:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aFunction = require('../internals/a-function');

// `Map.keyBy` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', stat: true }, {
  keyBy: function keyBy(iterable, keyDerivative) {
    var newMap = new this();
    aFunction(keyDerivative);
    var setter = aFunction(newMap.set);
    iterate(iterable, function (element) {
      setter.call(newMap, keyDerivative(element), element);
    });
    return newMap;
  }
});

},{"../internals/a-function":310,"../internals/export":361,"../internals/iterate":395}],716:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.includes` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  keyOf: function keyOf(searchElement) {
    return iterate(getMapIterator(anObject(this)), function (key, value) {
      if (value === searchElement) return iterate.stop(key);
    }, undefined, true, true).result;
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],717:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.mapKeys` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aFunction(newMap.set);
    iterate(iterator, function (key, value) {
      setter.call(newMap, boundFunction(value, key, map), value);
    }, undefined, true, true);
    return newMap;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],718:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.mapValues` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  mapValues: function mapValues(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
    var setter = aFunction(newMap.set);
    iterate(iterator, function (key, value) {
      setter.call(newMap, key, boundFunction(value, key, map));
    }, undefined, true, true);
    return newMap;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],719:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var iterate = require('../internals/iterate');

// `Map.prototype.merge` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  // eslint-disable-next-line no-unused-vars
  merge: function merge(iterable /* ...iterbles */) {
    var map = anObject(this);
    var setter = aFunction(map.set);
    var i = 0;
    while (i < arguments.length) {
      iterate(arguments[i++], setter, map, true);
    }
    return map;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/is-pure":393,"../internals/iterate":395}],720:[function(require,module,exports){
var $ = require('../internals/export');
var of = require('../internals/collection-of');

// `Map.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
$({ target: 'Map', stat: true }, {
  of: of
});

},{"../internals/collection-of":338,"../internals/export":361}],721:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Map.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aFunction(callbackfn);
    iterate(iterator, function (key, value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map);
      }
    }, undefined, true, true);
    if (noInitial) throw TypeError('Reduce of empty map with no initial value');
    return accumulator;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],722:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  some: function some(callbackfn /* , thisArg */) {
    var map = anObject(this);
    var iterator = getMapIterator(map);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return iterate(iterator, function (key, value) {
      if (boundFunction(value, key, map)) return iterate.stop();
    }, undefined, true, true).stopped;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-map-iterator":375,"../internals/is-pure":393,"../internals/iterate":395}],723:[function(require,module,exports){
'use strict';
// TODO: remove from `core-js@4`
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var $upsert = require('../internals/map-upsert');

// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.upsert`)
// https://github.com/thumbsupep/proposal-upsert
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  updateOrInsert: $upsert
});

},{"../internals/export":361,"../internals/is-pure":393,"../internals/map-upsert":398}],724:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');

// `Set.prototype.update` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  update: function update(key, callback /* , thunk */) {
    var map = anObject(this);
    var length = arguments.length;
    aFunction(callback);
    var isPresentInMap = map.has(key);
    if (!isPresentInMap && length < 3) {
      throw TypeError('Updating absent value');
    }
    var value = isPresentInMap ? map.get(key) : aFunction(length > 2 ? arguments[2] : undefined)(key, map);
    map.set(key, callback(value, key, map));
    return map;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/is-pure":393}],725:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var $upsert = require('../internals/map-upsert');

// `Map.prototype.upsert` method
// https://github.com/thumbsupep/proposal-upsert
$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {
  upsert: $upsert
});

},{"../internals/export":361,"../internals/is-pure":393,"../internals/map-upsert":398}],726:[function(require,module,exports){
var $ = require('../internals/export');

var min = Math.min;
var max = Math.max;

// `Math.clamp` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  clamp: function clamp(x, lower, upper) {
    return min(upper, max(lower, x));
  }
});

},{"../internals/export":361}],727:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.DEG_PER_RAD` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  DEG_PER_RAD: Math.PI / 180
});

},{"../internals/export":361}],728:[function(require,module,exports){
var $ = require('../internals/export');

var RAD_PER_DEG = 180 / Math.PI;

// `Math.degrees` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"../internals/export":361}],729:[function(require,module,exports){
var $ = require('../internals/export');

var scale = require('../internals/math-scale');
var fround = require('../internals/math-fround');

// `Math.fscale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"../internals/export":361,"../internals/math-fround":400,"../internals/math-scale":402}],730:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.iaddh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true }, {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"../internals/export":361}],731:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.imulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true }, {
  imulh: function imulh(u, v) {
    var UINT16 = 0xFFFF;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"../internals/export":361}],732:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.isubh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true }, {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"../internals/export":361}],733:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.RAD_PER_DEG` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  RAD_PER_DEG: 180 / Math.PI
});

},{"../internals/export":361}],734:[function(require,module,exports){
var $ = require('../internals/export');

var DEG_PER_RAD = Math.PI / 180;

// `Math.radians` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"../internals/export":361}],735:[function(require,module,exports){
var $ = require('../internals/export');
var scale = require('../internals/math-scale');

// `Math.scale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true }, {
  scale: scale
});

},{"../internals/export":361,"../internals/math-scale":402}],736:[function(require,module,exports){
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var numberIsFinite = require('../internals/number-is-finite');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');

var SEEDED_RANDOM = 'Seeded Random';
var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + ' Generator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SEEDED_RANDOM_GENERATOR);
var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';

var $SeededRandomGenerator = createIteratorConstructor(function SeededRandomGenerator(seed) {
  setInternalState(this, {
    type: SEEDED_RANDOM_GENERATOR,
    seed: seed % 2147483647
  });
}, SEEDED_RANDOM, function next() {
  var state = getInternalState(this);
  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
  return { value: (seed & 1073741823) / 1073741823, done: false };
});

// `Math.seededPRNG` method
// https://github.com/tc39/proposal-seeded-random
// based on https://github.com/tc39/proposal-seeded-random/blob/78b8258835b57fc2100d076151ab506bc3202ae6/demo.html
$({ target: 'Math', stat: true, forced: true }, {
  seededPRNG: function seededPRNG(it) {
    var seed = anObject(it).seed;
    if (!numberIsFinite(seed)) throw TypeError(SEED_TYPE_ERROR);
    return new $SeededRandomGenerator(seed);
  }
});

},{"../internals/an-object":315,"../internals/create-iterator-constructor":348,"../internals/export":361,"../internals/internal-state":386,"../internals/number-is-finite":411}],737:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.signbit` method
// https://github.com/tc39/proposal-Math.signbit
$({ target: 'Math', stat: true }, {
  signbit: function signbit(x) {
    return (x = +x) == x && x == 0 ? 1 / x == -Infinity : x < 0;
  }
});

},{"../internals/export":361}],738:[function(require,module,exports){
var $ = require('../internals/export');

// `Math.umulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true }, {
  umulh: function umulh(u, v) {
    var UINT16 = 0xFFFF;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"../internals/export":361}],739:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toInteger = require('../internals/to-integer');
var parseInt = require('../internals/parse-int');

var INVALID_NUMBER_REPRESENTATION = 'Invalid number representation';
var INVALID_RADIX = 'Invalid radix';
var valid = /^[\da-z]+$/;

// `Number.fromString` method
// https://github.com/tc39/proposal-number-fromstring
$({ target: 'Number', stat: true }, {
  fromString: function fromString(string, radix) {
    var sign = 1;
    var R, mathNum;
    if (typeof string != 'string') throw TypeError(INVALID_NUMBER_REPRESENTATION);
    if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
    if (string.charAt(0) == '-') {
      sign = -1;
      string = string.slice(1);
      if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    R = radix === undefined ? 10 : toInteger(radix);
    if (R < 2 || R > 36) throw RangeError(INVALID_RADIX);
    if (!valid.test(string) || (mathNum = parseInt(string, R)).toString(R) !== string) {
      throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    return sign * mathNum;
  }
});

},{"../internals/export":361,"../internals/parse-int":429,"../internals/to-integer":460}],740:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-observable
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var setSpecies = require('../internals/set-species');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var defineProperty = require('../internals/object-define-property').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var getIterator = require('../internals/get-iterator');
var iterate = require('../internals/iterate');
var hostReportErrors = require('../internals/host-report-errors');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');

var OBSERVABLE = wellKnownSymbol('observable');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscriptionState) {
  var cleanup = subscriptionState.cleanup;
  if (cleanup) {
    subscriptionState.cleanup = undefined;
    try {
      cleanup();
    } catch (error) {
      hostReportErrors(error);
    }
  }
};

var subscriptionClosed = function (subscriptionState) {
  return subscriptionState.observer === undefined;
};

var close = function (subscription, subscriptionState) {
  if (!DESCRIPTORS) {
    subscription.closed = true;
    var subscriptionObserver = subscriptionState.subscriptionObserver;
    if (subscriptionObserver) subscriptionObserver.closed = true;
  } subscriptionState.observer = undefined;
};

var Subscription = function (observer, subscriber) {
  var subscriptionState = setInternalState(this, {
    cleanup: undefined,
    observer: anObject(observer),
    subscriptionObserver: undefined
  });
  var start;
  if (!DESCRIPTORS) this.closed = false;
  try {
    if (start = getMethod(observer.start)) start.call(observer, this);
  } catch (error) {
    hostReportErrors(error);
  }
  if (subscriptionClosed(subscriptionState)) return;
  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(subscriptionObserver);
    var subscription = cleanup;
    if (cleanup != null) subscriptionState.cleanup = typeof cleanup.unsubscribe === 'function'
      ? function () { subscription.unsubscribe(); }
      : aFunction(cleanup);
  } catch (error) {
    subscriptionObserver.error(error);
    return;
  } if (subscriptionClosed(subscriptionState)) cleanupSubscription(subscriptionState);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    var subscriptionState = getInternalState(this);
    if (!subscriptionClosed(subscriptionState)) {
      close(this, subscriptionState);
      cleanupSubscription(subscriptionState);
    }
  }
});

if (DESCRIPTORS) defineProperty(Subscription.prototype, 'closed', {
  configurable: true,
  get: function () {
    return subscriptionClosed(getInternalState(this));
  }
});

var SubscriptionObserver = function (subscription) {
  setInternalState(this, { subscription: subscription });
  if (!DESCRIPTORS) this.closed = false;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscriptionState = getInternalState(getInternalState(this).subscription);
    if (!subscriptionClosed(subscriptionState)) {
      var observer = subscriptionState.observer;
      try {
        var nextMethod = getMethod(observer.next);
        if (nextMethod) nextMethod.call(observer, value);
      } catch (error) {
        hostReportErrors(error);
      }
    }
  },
  error: function error(value) {
    var subscription = getInternalState(this).subscription;
    var subscriptionState = getInternalState(subscription);
    if (!subscriptionClosed(subscriptionState)) {
      var observer = subscriptionState.observer;
      close(subscription, subscriptionState);
      try {
        var errorMethod = getMethod(observer.error);
        if (errorMethod) errorMethod.call(observer, value);
        else hostReportErrors(value);
      } catch (err) {
        hostReportErrors(err);
      } cleanupSubscription(subscriptionState);
    }
  },
  complete: function complete() {
    var subscription = getInternalState(this).subscription;
    var subscriptionState = getInternalState(subscription);
    if (!subscriptionClosed(subscriptionState)) {
      var observer = subscriptionState.observer;
      close(subscription, subscriptionState);
      try {
        var completeMethod = getMethod(observer.complete);
        if (completeMethod) completeMethod.call(observer);
      } catch (error) {
        hostReportErrors(error);
      } cleanupSubscription(subscriptionState);
    }
  }
});

if (DESCRIPTORS) defineProperty(SubscriptionObserver.prototype, 'closed', {
  configurable: true,
  get: function () {
    return subscriptionClosed(getInternalState(getInternalState(this).subscription));
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable');
  setInternalState(this, { subscriber: aFunction(subscriber) });
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    var length = arguments.length;
    return new Subscription(typeof observer === 'function' ? {
      next: observer,
      error: length > 1 ? arguments[1] : undefined,
      complete: length > 2 ? arguments[2] : undefined
    } : isObject(observer) ? observer : {}, getInternalState(this).subscriber);
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var observableMethod = getMethod(anObject(x)[OBSERVABLE]);
    if (observableMethod) {
      var observable = anObject(observableMethod.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    var iterator = getIterator(x);
    return new C(function (observer) {
      iterate(iterator, function (it) {
        observer.next(it);
        if (observer.closed) return iterate.stop();
      }, undefined, false, true);
      observer.complete();
    });
  },
  of: function of() {
    var C = typeof this === 'function' ? this : $Observable;
    var length = arguments.length;
    var items = new Array(length);
    var index = 0;
    while (index < length) items[index] = arguments[index++];
    return new C(function (observer) {
      for (var i = 0; i < length; i++) {
        observer.next(items[i]);
        if (observer.closed) return;
      } observer.complete();
    });
  }
});

createNonEnumerableProperty($Observable.prototype, OBSERVABLE, function () { return this; });

$({ global: true }, {
  Observable: $Observable
});

setSpecies('Observable');

},{"../internals/a-function":310,"../internals/an-instance":314,"../internals/an-object":315,"../internals/create-non-enumerable-property":350,"../internals/descriptors":357,"../internals/export":361,"../internals/get-iterator":374,"../internals/host-report-errors":380,"../internals/internal-state":386,"../internals/is-object":392,"../internals/iterate":395,"../internals/object-define-property":415,"../internals/redefine-all":434,"../internals/set-species":444,"../internals/well-known-symbol":473}],741:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.promise.all-settled.js');

},{"./es.promise.all-settled.js":577}],742:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var getBuiltIn = require('../internals/get-built-in');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://github.com/tc39/proposal-promise-any
$({ target: 'Promise', stat: true }, {
  any: function any(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        errors.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (e) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = e;
          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":310,"../internals/export":361,"../internals/get-built-in":372,"../internals/iterate":395,"../internals/new-promise-capability":409,"../internals/perform":431}],743:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');

// `Promise.try` method
// https://github.com/tc39/proposal-promise-try
$({ target: 'Promise', stat: true }, {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    var result = perform(callbackfn);
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});

},{"../internals/export":361,"../internals/new-promise-capability":409,"../internals/perform":431}],744:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.defineMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */) {
    var targetKey = arguments.length < 4 ? undefined : toMetadataKey(arguments[3]);
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],745:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var toMetadataKey = ReflectMetadataModule.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
var store = ReflectMetadataModule.store;

// `Reflect.deleteMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],746:[function(require,module,exports){
var $ = require('../internals/export');
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var Set = require('../modules/es.set');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var iterate = require('../internals/iterate');

var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

var from = function (iter) {
  var result = [];
  iterate(iter, result.push, result);
  return result;
};

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

// `Reflect.getMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryMetadataKeys(anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/iterate":395,"../internals/object-get-prototype-of":420,"../internals/reflect-metadata":436,"../modules/es.set":597}],747:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

// `Reflect.getMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/object-get-prototype-of":420,"../internals/reflect-metadata":436}],748:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryOwnMetadataKeys(anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],749:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],750:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

// `Reflect.hasMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/object-get-prototype-of":420,"../internals/reflect-metadata":436}],751:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.hasOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],752:[function(require,module,exports){
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.metadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, key) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
    };
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/reflect-metadata":436}],753:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionAddAll = require('../internals/collection-add-all');

// `Set.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  addAll: function addAll(/* ...elements */) {
    return collectionAddAll.apply(this, arguments);
  }
});

},{"../internals/collection-add-all":335,"../internals/export":361,"../internals/is-pure":393}],754:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionDeleteAll = require('../internals/collection-delete-all');

// `Set.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  deleteAll: function deleteAll(/* ...elements */) {
    return collectionDeleteAll.apply(this, arguments);
  }
});

},{"../internals/collection-delete-all":336,"../internals/export":361,"../internals/is-pure":393}],755:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  difference: function difference(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    var remover = aFunction(newSet['delete']);
    iterate(iterable, function (value) {
      remover.call(newSet, value);
    });
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-built-in":372,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],756:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  every: function every(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return !iterate(iterator, function (value) {
      if (!boundFunction(value, value, set)) return iterate.stop();
    }, undefined, false, true).stopped;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395}],757:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var adder = aFunction(newSet.add);
    iterate(iterator, function (value) {
      if (boundFunction(value, value, set)) adder.call(newSet, value);
    }, undefined, false, true);
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],758:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  find: function find(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return iterate(iterator, function (value) {
      if (boundFunction(value, value, set)) return iterate.stop(value);
    }, undefined, false, true).result;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395}],759:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/collection-from');

// `Set.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
$({ target: 'Set', stat: true }, {
  from: from
});

},{"../internals/collection-from":337,"../internals/export":361}],760:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  intersection: function intersection(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var hasCheck = aFunction(set.has);
    var adder = aFunction(newSet.add);
    iterate(iterable, function (value) {
      if (hasCheck.call(set, value)) adder.call(newSet, value);
    });
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-built-in":372,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],761:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var iterate = require('../internals/iterate');

// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  isDisjointFrom: function isDisjointFrom(iterable) {
    var set = anObject(this);
    var hasCheck = aFunction(set.has);
    return !iterate(iterable, function (value) {
      if (hasCheck.call(set, value) === true) return iterate.stop();
    }).stopped;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/is-pure":393,"../internals/iterate":395}],762:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var getIterator = require('../internals/get-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  isSubsetOf: function isSubsetOf(iterable) {
    var iterator = getIterator(this);
    var otherSet = anObject(iterable);
    var hasCheck = otherSet.has;
    if (typeof hasCheck != 'function') {
      otherSet = new (getBuiltIn('Set'))(iterable);
      hasCheck = aFunction(otherSet.has);
    }
    return !iterate(iterator, function (value) {
      if (hasCheck.call(otherSet, value) === false) return iterate.stop();
    }, undefined, false, true).stopped;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-iterator":374,"../internals/is-pure":393,"../internals/iterate":395}],763:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var iterate = require('../internals/iterate');

// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  isSupersetOf: function isSupersetOf(iterable) {
    var set = anObject(this);
    var hasCheck = aFunction(set.has);
    return !iterate(iterable, function (value) {
      if (hasCheck.call(set, value) === false) return iterate.stop();
    }).stopped;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/is-pure":393,"../internals/iterate":395}],764:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.join` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  join: function join(separator) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var sep = separator === undefined ? ',' : String(separator);
    var result = [];
    iterate(iterator, result.push, result, false, true);
    return result.join(sep);
  }
});

},{"../internals/an-object":315,"../internals/export":361,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395}],765:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var bind = require('../internals/bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.map` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  map: function map(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
    var adder = aFunction(newSet.add);
    iterate(iterator, function (value) {
      adder.call(newSet, boundFunction(value, value, set));
    }, undefined, false, true);
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],766:[function(require,module,exports){
var $ = require('../internals/export');
var of = require('../internals/collection-of');

// `Set.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
$({ target: 'Set', stat: true }, {
  of: of
});

},{"../internals/collection-of":338,"../internals/export":361}],767:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aFunction(callbackfn);
    iterate(iterator, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, value, set);
      }
    }, undefined, false, true);
    if (noInitial) throw TypeError('Reduce of empty set with no initial value');
    return accumulator;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395}],768:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');

// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  some: function some(callbackfn /* , thisArg */) {
    var set = anObject(this);
    var iterator = getSetIterator(set);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
    return iterate(iterator, function (value) {
      if (boundFunction(value, value, set)) return iterate.stop();
    }, undefined, false, true).stopped;
  }
});

},{"../internals/an-object":315,"../internals/bind-context":330,"../internals/export":361,"../internals/get-set-iterator":376,"../internals/is-pure":393,"../internals/iterate":395}],769:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  symmetricDifference: function symmetricDifference(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    var remover = aFunction(newSet['delete']);
    var adder = aFunction(newSet.add);
    iterate(iterable, function (value) {
      remover.call(newSet, value) || adder.call(newSet, value);
    });
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-built-in":372,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],770:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {
  union: function union(iterable) {
    var set = anObject(this);
    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
    iterate(iterable, aFunction(newSet.add), newSet);
    return newSet;
  }
});

},{"../internals/a-function":310,"../internals/an-object":315,"../internals/export":361,"../internals/get-built-in":372,"../internals/is-pure":393,"../internals/iterate":395,"../internals/species-constructor":450}],771:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var charAt = require('../internals/string-multibyte').charAt;

// `String.prototype.at` method
// https://github.com/mathiasbynens/String.prototype.at
$({ target: 'String', proto: true }, {
  at: function at(pos) {
    return charAt(this, pos);
  }
});

},{"../internals/export":361,"../internals/string-multibyte":451}],772:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var requireObjectCoercible = require('../internals/require-object-coercible');
var InternalStateModule = require('../internals/internal-state');
var StringMultibyteModule = require('../internals/string-multibyte');

var codeAt = StringMultibyteModule.codeAt;
var charAt = StringMultibyteModule.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// TODO: unify with String#@@iterator
var $StringIterator = createIteratorConstructor(function StringIterator(string) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: string,
    index: 0
  });
}, 'String', function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: { codePoint: codeAt(point, 0), position: index }, done: false };
});

// `String.prototype.codePoints` method
// https://github.com/tc39/proposal-string-prototype-codepoints
$({ target: 'String', proto: true }, {
  codePoints: function codePoints() {
    return new $StringIterator(String(requireObjectCoercible(this)));
  }
});

},{"../internals/create-iterator-constructor":348,"../internals/export":361,"../internals/internal-state":386,"../internals/require-object-coercible":440,"../internals/string-multibyte":451}],773:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.string.match-all');

},{"./es.string.match-all":612}],774:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var requireObjectCoercible = require('../internals/require-object-coercible');
var isRegExp = require('../internals/is-regexp');
var getRegExpFlags = require('../internals/regexp-flags');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var REPLACE = wellKnownSymbol('replace');
var RegExpPrototype = RegExp.prototype;

// `String.prototype.replaceAll` method
// https://github.com/tc39/proposal-string-replace-all
$({ target: 'String', proto: true }, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var IS_REG_EXP, flags, replacer, string, searchString, template, result, position, index;
    if (searchValue != null) {
      IS_REG_EXP = isRegExp(searchValue);
      if (IS_REG_EXP) {
        flags = String(requireObjectCoercible('flags' in RegExpPrototype
          ? searchValue.flags
          : getRegExpFlags.call(searchValue)
        ));
        if (!~flags.indexOf('g')) throw TypeError('`.replaceAll` does not allow non-global regexes');
      }
      replacer = searchValue[REPLACE];
      if (replacer !== undefined) {
        return replacer.call(searchValue, O, replaceValue);
      } else if (IS_PURE && IS_REG_EXP) {
        return String(O).replace(searchValue, replaceValue);
      }
    }
    string = String(O);
    searchString = String(searchValue);
    if (searchString === '') return replaceAll.call(string, /(?:)/g, replaceValue);
    template = string.split(searchString);
    if (typeof replaceValue !== 'function') {
      return template.join(String(replaceValue));
    }
    result = template[0];
    position = result.length;
    for (index = 1; index < template.length; index++) {
      result += String(replaceValue(searchString, position, string));
      position += searchString.length + template[index].length;
      result += template[index];
    }
    return result;
  }
});

},{"../internals/export":361,"../internals/is-pure":393,"../internals/is-regexp":394,"../internals/regexp-flags":439,"../internals/require-object-coercible":440,"../internals/well-known-symbol":473}],775:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('asyncDispose');

},{"../internals/define-well-known-symbol":356}],776:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('dispose');

},{"../internals/define-well-known-symbol":356}],777:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');

},{"../internals/define-well-known-symbol":356}],778:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');

},{"../internals/define-well-known-symbol":356}],779:[function(require,module,exports){
// TODO: remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

defineWellKnownSymbol('replaceAll');

},{"../internals/define-well-known-symbol":356}],780:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionDeleteAll = require('../internals/collection-delete-all');

// `WeakMap.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakMap', proto: true, real: true, forced: IS_PURE }, {
  deleteAll: function deleteAll(/* ...elements */) {
    return collectionDeleteAll.apply(this, arguments);
  }
});

},{"../internals/collection-delete-all":336,"../internals/export":361,"../internals/is-pure":393}],781:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/collection-from');

// `WeakMap.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
$({ target: 'WeakMap', stat: true }, {
  from: from
});

},{"../internals/collection-from":337,"../internals/export":361}],782:[function(require,module,exports){
var $ = require('../internals/export');
var of = require('../internals/collection-of');

// `WeakMap.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
$({ target: 'WeakMap', stat: true }, {
  of: of
});

},{"../internals/collection-of":338,"../internals/export":361}],783:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var $upsert = require('../internals/map-upsert');

// `WeakMap.prototype.upsert` method
// https://github.com/thumbsupep/proposal-upsert
$({ target: 'WeakMap', proto: true, real: true, forced: IS_PURE }, {
  upsert: $upsert
});

},{"../internals/export":361,"../internals/is-pure":393,"../internals/map-upsert":398}],784:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionAddAll = require('../internals/collection-add-all');

// `WeakSet.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakSet', proto: true, real: true, forced: IS_PURE }, {
  addAll: function addAll(/* ...elements */) {
    return collectionAddAll.apply(this, arguments);
  }
});

},{"../internals/collection-add-all":335,"../internals/export":361,"../internals/is-pure":393}],785:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var collectionDeleteAll = require('../internals/collection-delete-all');

// `WeakSet.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakSet', proto: true, real: true, forced: IS_PURE }, {
  deleteAll: function deleteAll(/* ...elements */) {
    return collectionDeleteAll.apply(this, arguments);
  }
});

},{"../internals/collection-delete-all":336,"../internals/export":361,"../internals/is-pure":393}],786:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/collection-from');

// `WeakSet.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
$({ target: 'WeakSet', stat: true }, {
  from: from
});

},{"../internals/collection-from":337,"../internals/export":361}],787:[function(require,module,exports){
var $ = require('../internals/export');
var of = require('../internals/collection-of');

// `WeakSet.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
$({ target: 'WeakSet', stat: true }, {
  of: of
});

},{"../internals/collection-of":338,"../internals/export":361}],788:[function(require,module,exports){
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var forEach = require('../internals/array-for-each');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}

},{"../internals/array-for-each":320,"../internals/create-non-enumerable-property":350,"../internals/dom-iterables":359,"../internals/global":377}],789:[function(require,module,exports){
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var ArrayIteratorMethods = require('../modules/es.array.iterator');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

},{"../internals/create-non-enumerable-property":350,"../internals/dom-iterables":359,"../internals/global":377,"../internals/well-known-symbol":473,"../modules/es.array.iterator":493}],790:[function(require,module,exports){
var global = require('../internals/global');
var task = require('../internals/task');

var FORCED = !global.setImmediate || !global.clearImmediate;

// http://w3c.github.io/setImmediate/
require('../internals/export')({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  // `setImmediate` method
  // http://w3c.github.io/setImmediate/#si-setImmediate
  setImmediate: task.set,
  // `clearImmediate` method
  // http://w3c.github.io/setImmediate/#si-clearImmediate
  clearImmediate: task.clear
});

},{"../internals/export":361,"../internals/global":377,"../internals/task":455}],791:[function(require,module,exports){
var $ = require('../internals/export');
var global = require('../internals/global');
var microtask = require('../internals/microtask');
var classof = require('../internals/classof-raw');

var process = global.process;
var isNode = classof(process) == 'process';

// `queueMicrotask` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
$({ global: true, enumerable: true, noTargetGet: true }, {
  queueMicrotask: function queueMicrotask(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"../internals/classof-raw":333,"../internals/export":361,"../internals/global":377,"../internals/microtask":404}],792:[function(require,module,exports){
var $ = require('../internals/export');
var global = require('../internals/global');
var userAgent = require('../internals/user-agent');

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (scheduler) {
  return function (handler, timeout /* , ...arguments */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
    } : handler, timeout);
  };
};

// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
$({ global: true, bind: true, forced: MSIE }, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global.setInterval)
});

},{"../internals/export":361,"../internals/global":377,"../internals/user-agent":470}],793:[function(require,module,exports){
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.array.iterator');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var USE_NATIVE_URL = require('../internals/native-url');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');
var anInstance = require('../internals/an-instance');
var hasOwn = require('../internals/has');
var bind = require('../internals/bind-context');
var classof = require('../internals/classof');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var wellKnownSymbol = require('../internals/well-known-symbol');

var $fetch = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;
    while (index < attributes.length) {
      attribute = attributes[index++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function () { /* empty */ },
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        next = iterator.next;
        while (!(step = next.call(iterator)).done) {
          entryIterator = getIterator(anObject(step.value));
          entryNext = entryIterator.next;
          if (
            (first = entryNext.call(entryIterator)).done ||
            (second = entryNext.call(entryIterator)).done ||
            !entryNext.call(entryIterator).done
          ) throw TypeError('Expected sequence with length 2');
          entries.push({ key: first.value + '', value: second.value + '' });
        }
      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({ key: name + '', value: value + '' });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) entries.splice(index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({ key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;
    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];
      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }
      if (entriesIndex === sliceIndex) entries.push(entry);
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;
  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  } return result.join('&');
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674
if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {
  $({ global: true, enumerable: true, forced: true }, {
    fetch: function fetch(input /* , init */) {
      var args = [input];
      var init, body, headers;
      if (arguments.length > 1) {
        init = arguments[1];
        if (isObject(init)) {
          body = init.body;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();
            if (!headers.has('content-type')) {
              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
            init = create(init, {
              body: createPropertyDescriptor(0, String(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        args.push(init);
      } return $fetch.apply(this, args);
    }
  });
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};

},{"../internals/an-instance":314,"../internals/an-object":315,"../internals/bind-context":330,"../internals/classof":334,"../internals/create-iterator-constructor":348,"../internals/create-property-descriptor":351,"../internals/export":361,"../internals/get-built-in":372,"../internals/get-iterator":374,"../internals/get-iterator-method":373,"../internals/has":378,"../internals/internal-state":386,"../internals/is-object":392,"../internals/native-url":407,"../internals/object-create":413,"../internals/redefine":435,"../internals/redefine-all":434,"../internals/set-to-string-tag":445,"../internals/well-known-symbol":473,"../modules/es.array.iterator":493}],794:[function(require,module,exports){
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.string.iterator');
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var USE_NATIVE_URL = require('../internals/native-url');
var global = require('../internals/global');
var defineProperties = require('../internals/object-define-properties');
var redefine = require('../internals/redefine');
var anInstance = require('../internals/an-instance');
var has = require('../internals/has');
var assign = require('../internals/object-assign');
var arrayFrom = require('../internals/array-from');
var codeAt = require('../internals/string-multibyte').codeAt;
var toASCII = require('../internals/punycode-to-ascii');
var setToStringTag = require('../internals/set-to-string-tag');
var URLSearchParamsModule = require('../modules/web.url-search-params');
var InternalStateModule = require('../internals/internal-state');

var NativeURL = global.URL;
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+\-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, index;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
  // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }
    numbers.push(number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = numbers.pop();
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor(host / 256);
    } return result.join('.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (char, set) {
  var code = codeAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0))
    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
    string.length == 2 ||
    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');

  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride && (
            (isSpecial(url) != has(specialSchemes, buffer)) ||
            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
            (url.scheme == 'file' && !url.host)
          )) return;
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;

      case NO_SCHEME:
        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        } break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        } break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        } break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        } break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;
            else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;
          else if (char == ']') seenBracket = false;
          buffer += char;
        } break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url)) ||
          stateOverride
        ) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;
        else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        } break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
          else url.host = base.host;
        }
        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          } continue;
        } else buffer += char;
        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        } break;

      case PATH:
        if (
          char == EOF || char == '/' ||
          (char == '\\' && isSpecial(url)) ||
          (!stateOverride && (char == '?' || char == '#'))
        ) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }
            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        } break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';
          else if (char == '#') url.query += '%23';
          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, { type: 'URL' });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? ''
    : port === null ? serializeHost(host)
    : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;
      else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});

},{"../internals/an-instance":314,"../internals/array-from":321,"../internals/descriptors":357,"../internals/export":361,"../internals/global":377,"../internals/has":378,"../internals/internal-state":386,"../internals/native-url":407,"../internals/object-assign":412,"../internals/object-define-properties":414,"../internals/punycode-to-ascii":433,"../internals/redefine":435,"../internals/set-to-string-tag":445,"../internals/string-multibyte":451,"../modules/es.string.iterator":610,"../modules/web.url-search-params":793}],795:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});

},{"../internals/export":361}],796:[function(require,module,exports){
require('../modules/esnext.array.is-template-object');

},{"../modules/esnext.array.is-template-object":681}],797:[function(require,module,exports){
require('../modules/esnext.array.last-index');
require('../modules/esnext.array.last-item');

},{"../modules/esnext.array.last-index":682,"../modules/esnext.array.last-item":683}],798:[function(require,module,exports){
require('../modules/esnext.map.group-by');
require('../modules/esnext.map.key-by');
require('../modules/esnext.map.delete-all');
require('../modules/esnext.map.every');
require('../modules/esnext.map.filter');
require('../modules/esnext.map.find');
require('../modules/esnext.map.find-key');
require('../modules/esnext.map.includes');
require('../modules/esnext.map.key-of');
require('../modules/esnext.map.map-keys');
require('../modules/esnext.map.map-values');
require('../modules/esnext.map.merge');
require('../modules/esnext.map.reduce');
require('../modules/esnext.map.some');
require('../modules/esnext.map.update');
require('../modules/esnext.set.add-all');
require('../modules/esnext.set.delete-all');
require('../modules/esnext.set.every');
require('../modules/esnext.set.filter');
require('../modules/esnext.set.find');
require('../modules/esnext.set.join');
require('../modules/esnext.set.map');
require('../modules/esnext.set.reduce');
require('../modules/esnext.set.some');
require('../modules/esnext.weak-map.delete-all');
require('../modules/esnext.weak-set.add-all');
require('../modules/esnext.weak-set.delete-all');

},{"../modules/esnext.map.delete-all":707,"../modules/esnext.map.every":708,"../modules/esnext.map.filter":709,"../modules/esnext.map.find":711,"../modules/esnext.map.find-key":710,"../modules/esnext.map.group-by":713,"../modules/esnext.map.includes":714,"../modules/esnext.map.key-by":715,"../modules/esnext.map.key-of":716,"../modules/esnext.map.map-keys":717,"../modules/esnext.map.map-values":718,"../modules/esnext.map.merge":719,"../modules/esnext.map.reduce":721,"../modules/esnext.map.some":722,"../modules/esnext.map.update":724,"../modules/esnext.set.add-all":753,"../modules/esnext.set.delete-all":754,"../modules/esnext.set.every":756,"../modules/esnext.set.filter":757,"../modules/esnext.set.find":758,"../modules/esnext.set.join":764,"../modules/esnext.set.map":765,"../modules/esnext.set.reduce":767,"../modules/esnext.set.some":768,"../modules/esnext.weak-map.delete-all":780,"../modules/esnext.weak-set.add-all":784,"../modules/esnext.weak-set.delete-all":785}],799:[function(require,module,exports){
require('../modules/esnext.map.from');
require('../modules/esnext.map.of');
require('../modules/esnext.set.from');
require('../modules/esnext.set.of');
require('../modules/esnext.weak-map.from');
require('../modules/esnext.weak-map.of');
require('../modules/esnext.weak-set.from');
require('../modules/esnext.weak-set.of');

},{"../modules/esnext.map.from":712,"../modules/esnext.map.of":720,"../modules/esnext.set.from":759,"../modules/esnext.set.of":766,"../modules/esnext.weak-map.from":781,"../modules/esnext.weak-map.of":782,"../modules/esnext.weak-set.from":786,"../modules/esnext.weak-set.of":787}],800:[function(require,module,exports){
require('../modules/esnext.math.iaddh');
require('../modules/esnext.math.isubh');
require('../modules/esnext.math.imulh');
require('../modules/esnext.math.umulh');

},{"../modules/esnext.math.iaddh":730,"../modules/esnext.math.imulh":731,"../modules/esnext.math.isubh":732,"../modules/esnext.math.umulh":738}],801:[function(require,module,exports){
require('../modules/esnext.global-this');

module.exports = require('../internals/global');

},{"../internals/global":377,"../modules/esnext.global-this":693}],802:[function(require,module,exports){
require('../stage');

},{"../stage":828}],803:[function(require,module,exports){
require('../modules/esnext.async-iterator.constructor');
require('../modules/esnext.async-iterator.drop');
require('../modules/esnext.async-iterator.filter');
require('../modules/esnext.async-iterator.from');
require('../modules/esnext.async-iterator.map');
require('../modules/esnext.async-iterator.take');
require('../modules/esnext.async-iterator.to-array');
require('../modules/esnext.iterator.constructor');
require('../modules/esnext.iterator.as-indexed-pairs');
require('../modules/esnext.iterator.drop');
require('../modules/esnext.iterator.every');
require('../modules/esnext.iterator.filter');
require('../modules/esnext.iterator.find');
require('../modules/esnext.iterator.for-each');
require('../modules/esnext.iterator.from');
require('../modules/esnext.iterator.map');
require('../modules/esnext.iterator.reduce');
require('../modules/esnext.iterator.some');
require('../modules/esnext.iterator.take');
require('../modules/esnext.iterator.to-array');

},{"../modules/esnext.async-iterator.constructor":684,"../modules/esnext.async-iterator.drop":685,"../modules/esnext.async-iterator.filter":686,"../modules/esnext.async-iterator.from":687,"../modules/esnext.async-iterator.map":688,"../modules/esnext.async-iterator.take":689,"../modules/esnext.async-iterator.to-array":690,"../modules/esnext.iterator.as-indexed-pairs":694,"../modules/esnext.iterator.constructor":695,"../modules/esnext.iterator.drop":696,"../modules/esnext.iterator.every":697,"../modules/esnext.iterator.filter":698,"../modules/esnext.iterator.find":699,"../modules/esnext.iterator.for-each":700,"../modules/esnext.iterator.from":701,"../modules/esnext.iterator.map":702,"../modules/esnext.iterator.reduce":703,"../modules/esnext.iterator.some":704,"../modules/esnext.iterator.take":705,"../modules/esnext.iterator.to-array":706}],804:[function(require,module,exports){
require('../modules/esnext.composite-key');
require('../modules/esnext.composite-symbol');

},{"../modules/esnext.composite-key":691,"../modules/esnext.composite-symbol":692}],805:[function(require,module,exports){
// https://github.com/thumbsupep/proposal-upsert
// TODO: remove from `core-js@4`
require('../modules/esnext.map.update-or-insert');
require('../modules/esnext.map.upsert');
require('../modules/esnext.weak-map.upsert');

},{"../modules/esnext.map.update-or-insert":723,"../modules/esnext.map.upsert":725,"../modules/esnext.weak-map.upsert":783}],806:[function(require,module,exports){
require('../modules/esnext.math.clamp');
require('../modules/esnext.math.deg-per-rad');
require('../modules/esnext.math.degrees');
require('../modules/esnext.math.fscale');
require('../modules/esnext.math.rad-per-deg');
require('../modules/esnext.math.radians');
require('../modules/esnext.math.scale');

},{"../modules/esnext.math.clamp":726,"../modules/esnext.math.deg-per-rad":727,"../modules/esnext.math.degrees":728,"../modules/esnext.math.fscale":729,"../modules/esnext.math.rad-per-deg":733,"../modules/esnext.math.radians":734,"../modules/esnext.math.scale":735}],807:[function(require,module,exports){
require('../modules/esnext.math.signbit');

},{"../modules/esnext.math.signbit":737}],808:[function(require,module,exports){
require('../modules/esnext.number.from-string');

},{"../modules/esnext.number.from-string":739}],809:[function(require,module,exports){
require('../modules/esnext.observable');
require('../modules/esnext.symbol.observable');

},{"../modules/esnext.observable":740,"../modules/esnext.symbol.observable":777}],810:[function(require,module,exports){
require('../modules/esnext.symbol.pattern-match');

},{"../modules/esnext.symbol.pattern-match":778}],811:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('../modules/esnext.promise.all-settled');

},{"../modules/esnext.promise.all-settled":741}],812:[function(require,module,exports){
require('../modules/esnext.aggregate-error');
require('../modules/esnext.promise.any');

},{"../modules/esnext.aggregate-error":680,"../modules/esnext.promise.any":742}],813:[function(require,module,exports){
require('../modules/esnext.promise.try');

},{"../modules/esnext.promise.try":743}],814:[function(require,module,exports){
require('../modules/esnext.reflect.define-metadata');
require('../modules/esnext.reflect.delete-metadata');
require('../modules/esnext.reflect.get-metadata');
require('../modules/esnext.reflect.get-metadata-keys');
require('../modules/esnext.reflect.get-own-metadata');
require('../modules/esnext.reflect.get-own-metadata-keys');
require('../modules/esnext.reflect.has-metadata');
require('../modules/esnext.reflect.has-own-metadata');
require('../modules/esnext.reflect.metadata');

},{"../modules/esnext.reflect.define-metadata":744,"../modules/esnext.reflect.delete-metadata":745,"../modules/esnext.reflect.get-metadata":747,"../modules/esnext.reflect.get-metadata-keys":746,"../modules/esnext.reflect.get-own-metadata":749,"../modules/esnext.reflect.get-own-metadata-keys":748,"../modules/esnext.reflect.has-metadata":750,"../modules/esnext.reflect.has-own-metadata":751,"../modules/esnext.reflect.metadata":752}],815:[function(require,module,exports){
require('../modules/esnext.math.seeded-prng');

},{"../modules/esnext.math.seeded-prng":736}],816:[function(require,module,exports){
require('../modules/esnext.set.difference');
require('../modules/esnext.set.intersection');
require('../modules/esnext.set.is-disjoint-from');
require('../modules/esnext.set.is-subset-of');
require('../modules/esnext.set.is-superset-of');
require('../modules/esnext.set.union');
require('../modules/esnext.set.symmetric-difference');

},{"../modules/esnext.set.difference":755,"../modules/esnext.set.intersection":760,"../modules/esnext.set.is-disjoint-from":761,"../modules/esnext.set.is-subset-of":762,"../modules/esnext.set.is-superset-of":763,"../modules/esnext.set.symmetric-difference":769,"../modules/esnext.set.union":770}],817:[function(require,module,exports){
require('../modules/esnext.string.at');

},{"../modules/esnext.string.at":771}],818:[function(require,module,exports){
require('../modules/esnext.string.code-points');

},{"../modules/esnext.string.code-points":772}],819:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('../modules/esnext.string.match-all');

},{"../modules/esnext.string.match-all":773}],820:[function(require,module,exports){
require('../modules/esnext.string.replace-all');
require('../modules/esnext.symbol.replace-all');

},{"../modules/esnext.string.replace-all":774,"../modules/esnext.symbol.replace-all":779}],821:[function(require,module,exports){
require('../modules/web.url');
require('../modules/web.url.to-json');
require('../modules/web.url-search-params');

},{"../modules/web.url":794,"../modules/web.url-search-params":793,"../modules/web.url.to-json":795}],822:[function(require,module,exports){
// https://github.com/tc39/proposal-using-statement
require('../modules/esnext.symbol.async-dispose');
require('../modules/esnext.symbol.dispose');

},{"../modules/esnext.symbol.async-dispose":775,"../modules/esnext.symbol.dispose":776}],823:[function(require,module,exports){
require('../proposals/efficient-64-bit-arithmetic');
require('../proposals/string-at');
require('../proposals/url');

module.exports = require('./1');

},{"../proposals/efficient-64-bit-arithmetic":800,"../proposals/string-at":817,"../proposals/url":821,"./1":824}],824:[function(require,module,exports){
require('../proposals/array-last');
require('../proposals/collection-methods');
require('../proposals/collection-of-from');
require('../proposals/keys-composition');
require('../proposals/math-extensions');
require('../proposals/math-signbit');
require('../proposals/number-from-string');
require('../proposals/observable');
require('../proposals/pattern-matching');
require('../proposals/promise-try');
require('../proposals/seeded-random');
require('../proposals/string-code-points');

module.exports = require('./2');

},{"../proposals/array-last":797,"../proposals/collection-methods":798,"../proposals/collection-of-from":799,"../proposals/keys-composition":804,"../proposals/math-extensions":806,"../proposals/math-signbit":807,"../proposals/number-from-string":808,"../proposals/observable":809,"../proposals/pattern-matching":810,"../proposals/promise-try":813,"../proposals/seeded-random":815,"../proposals/string-code-points":818,"./2":825}],825:[function(require,module,exports){
require('../proposals/array-is-template-object');
require('../proposals/iterator-helpers');
require('../proposals/map-upsert');
require('../proposals/set-methods');
require('../proposals/using-statement');

module.exports = require('./3');

},{"../proposals/array-is-template-object":796,"../proposals/iterator-helpers":803,"../proposals/map-upsert":805,"../proposals/set-methods":816,"../proposals/using-statement":822,"./3":826}],826:[function(require,module,exports){
require('../proposals/promise-any');
require('../proposals/string-replace-all');

module.exports = require('./4');

},{"../proposals/promise-any":812,"../proposals/string-replace-all":820,"./4":827}],827:[function(require,module,exports){
require('../proposals/global-this');
require('../proposals/promise-all-settled');
require('../proposals/string-match-all');

module.exports = require('../internals/path');

},{"../internals/path":430,"../proposals/global-this":801,"../proposals/promise-all-settled":811,"../proposals/string-match-all":819}],828:[function(require,module,exports){
module.exports = require('./pre');

},{"./pre":829}],829:[function(require,module,exports){
require('../proposals/reflect-metadata');

module.exports = require('./0');

},{"../proposals/reflect-metadata":814,"./0":823}],830:[function(require,module,exports){
require('../modules/web.dom-collections.for-each');
require('../modules/web.dom-collections.iterator');
require('../modules/web.immediate');
require('../modules/web.queue-microtask');
require('../modules/web.timers');
require('../modules/web.url');
require('../modules/web.url.to-json');
require('../modules/web.url-search-params');

module.exports = require('../internals/path');

},{"../internals/path":430,"../modules/web.dom-collections.for-each":788,"../modules/web.dom-collections.iterator":789,"../modules/web.immediate":790,"../modules/web.queue-microtask":791,"../modules/web.timers":792,"../modules/web.url":794,"../modules/web.url-search-params":793,"../modules/web.url.to-json":795}],831:[function(require,module,exports){
"use strict";

module.exports = {
  "8.0": "79",
  "7.1": "78",
  "7.0": "78",
  "6.1": "76",
  "6.0": "76",
  "5.0": "72",
  "4.2": "69",
  "4.1": "69",
  "4.0": "69",
  "3.1": "66",
  "3.0": "66",
  "2.1": "61",
  "2.0": "61",
  "1.8": "59",
  "1.7": "58",
  "1.6": "56",
  "1.5": "54",
  "1.4": "53",
  "1.3": "52",
  "1.2": "51",
  "1.1": "50",
  "1.0": "49",
  "0.37": "49",
  "0.36": "47",
  "0.35": "45",
  "0.34": "45",
  "0.33": "45",
  "0.32": "45",
  "0.31": "44",
  "0.30": "44",
  "0.29": "43",
  "0.28": "43",
  "0.27": "42",
  "0.26": "42",
  "0.25": "42",
  "0.24": "41",
  "0.23": "41",
  "0.22": "41",
  "0.21": "40",
  "0.20": "39"
};

},{}],832:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  return str.replace(matchOperatorsRe, '\\$&');
};

},{}],833:[function(require,module,exports){
"use strict";

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  function isExpression(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'ArrayExpression':
      case 'AssignmentExpression':
      case 'BinaryExpression':
      case 'CallExpression':
      case 'ConditionalExpression':
      case 'FunctionExpression':
      case 'Identifier':
      case 'Literal':
      case 'LogicalExpression':
      case 'MemberExpression':
      case 'NewExpression':
      case 'ObjectExpression':
      case 'SequenceExpression':
      case 'ThisExpression':
      case 'UnaryExpression':
      case 'UpdateExpression':
        return true;
    }

    return false;
  }

  function isIterationStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'DoWhileStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'WhileStatement':
        return true;
    }

    return false;
  }

  function isStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
        return true;
    }

    return false;
  }

  function isSourceElement(node) {
    return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
  }

  function trailingStatement(node) {
    switch (node.type) {
      case 'IfStatement':
        if (node.alternate != null) {
          return node.alternate;
        }

        return node.consequent;

      case 'LabeledStatement':
      case 'ForStatement':
      case 'ForInStatement':
      case 'WhileStatement':
      case 'WithStatement':
        return node.body;
    }

    return null;
  }

  function isProblematicIfStatement(node) {
    var current;

    if (node.type !== 'IfStatement') {
      return false;
    }

    if (node.alternate == null) {
      return false;
    }

    current = node.consequent;

    do {
      if (current.type === 'IfStatement') {
        if (current.alternate == null) {
          return true;
        }
      }

      current = trailingStatement(current);
    } while (current);

    return false;
  }

  module.exports = {
    isExpression: isExpression,
    isStatement: isStatement,
    isIterationStatement: isIterationStatement,
    isSourceElement: isSourceElement,
    isProblematicIfStatement: isProblematicIfStatement,
    trailingStatement: trailingStatement
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],834:[function(require,module,exports){
"use strict";

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.

  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };

  function isDecimalDigit(ch) {
    return 0x30 <= ch && ch <= 0x39; // 0..9
  }

  function isHexDigit(ch) {
    return 0x30 <= ch && ch <= 0x39 || // 0..9
    0x61 <= ch && ch <= 0x66 || // a..f
    0x41 <= ch && ch <= 0x46; // A..F
  }

  function isOctalDigit(ch) {
    return ch >= 0x30 && ch <= 0x37; // 0..7
  } // 7.2 White Space


  NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

  function isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
  } // 7.3 Line Terminators


  function isLineTerminator(ch) {
    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
  } // 7.6 Identifier Names and Identifiers


  function fromCodePoint(cp) {
    if (cp <= 0xFFFF) {
      return String.fromCharCode(cp);
    }

    var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
    var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
    return cu1 + cu2;
  }

  IDENTIFIER_START = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  IDENTIFIER_PART = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch >= 0x30 && ch <= 0x39 || // 0..9
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  function isIdentifierStartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  function isIdentifierStartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  module.exports = {
    isDecimalDigit: isDecimalDigit,
    isHexDigit: isHexDigit,
    isOctalDigit: isOctalDigit,
    isWhiteSpace: isWhiteSpace,
    isLineTerminator: isLineTerminator,
    isIdentifierStartES5: isIdentifierStartES5,
    isIdentifierPartES5: isIdentifierPartES5,
    isIdentifierStartES6: isIdentifierStartES6,
    isIdentifierPartES6: isIdentifierPartES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],835:[function(require,module,exports){
"use strict";

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  var code = require('./code');

  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'let':
        return true;

      default:
        return false;
    }
  }

  function isKeywordES5(id, strict) {
    // yield should not be treated as keyword under non-strict mode.
    if (!strict && id === 'yield') {
      return false;
    }

    return isKeywordES6(id, strict);
  }

  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }

    switch (id.length) {
      case 2:
        return id === 'if' || id === 'in' || id === 'do';

      case 3:
        return id === 'var' || id === 'for' || id === 'new' || id === 'try';

      case 4:
        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';

      case 5:
        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';

      case 6:
        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';

      case 7:
        return id === 'default' || id === 'finally' || id === 'extends';

      case 8:
        return id === 'function' || id === 'continue' || id === 'debugger';

      case 10:
        return id === 'instanceof';

      default:
        return false;
    }
  }

  function isReservedWordES5(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
  }

  function isReservedWordES6(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
  }

  function isRestrictedWord(id) {
    return id === 'eval' || id === 'arguments';
  }

  function isIdentifierNameES5(id) {
    var i, iz, ch;

    if (id.length === 0) {
      return false;
    }

    ch = id.charCodeAt(0);

    if (!code.isIdentifierStartES5(ch)) {
      return false;
    }

    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (!code.isIdentifierPartES5(ch)) {
        return false;
      }
    }

    return true;
  }

  function decodeUtf16(lead, trail) {
    return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  }

  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;

    if (id.length === 0) {
      return false;
    }

    check = code.isIdentifierStartES6;

    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (0xD800 <= ch && ch <= 0xDBFF) {
        ++i;

        if (i >= iz) {
          return false;
        }

        lowCh = id.charCodeAt(i);

        if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
          return false;
        }

        ch = decodeUtf16(ch, lowCh);
      }

      if (!check(ch)) {
        return false;
      }

      check = code.isIdentifierPartES6;
    }

    return true;
  }

  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }

  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }

  module.exports = {
    isKeywordES5: isKeywordES5,
    isKeywordES6: isKeywordES6,
    isReservedWordES5: isReservedWordES5,
    isReservedWordES6: isReservedWordES6,
    isRestrictedWord: isRestrictedWord,
    isIdentifierNameES5: isIdentifierNameES5,
    isIdentifierNameES6: isIdentifierNameES6,
    isIdentifierES5: isIdentifierES5,
    isIdentifierES6: isIdentifierES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":834}],836:[function(require,module,exports){
"use strict";

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  exports.ast = require('./ast');
  exports.code = require('./code');
  exports.keyword = require('./keyword');
})();
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":833,"./code":834,"./keyword":835}],837:[function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Atomics": false,
		"BigInt": false,
		"BigInt64Array": false,
		"BigUint64Array": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"globalThis": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"SharedArrayBuffer": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es5": {
		"Array": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"propertyIsEnumerable": false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false
	},
	"es2015": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es2017": {
		"Array": false,
		"ArrayBuffer": false,
		"Atomics": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"SharedArrayBuffer": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"browser": {
		"AbortController": false,
		"AbortSignal": false,
		"addEventListener": false,
		"alert": false,
		"AnalyserNode": false,
		"Animation": false,
		"AnimationEffectReadOnly": false,
		"AnimationEffectTiming": false,
		"AnimationEffectTimingReadOnly": false,
		"AnimationEvent": false,
		"AnimationPlaybackEvent": false,
		"AnimationTimeline": false,
		"applicationCache": false,
		"ApplicationCache": false,
		"ApplicationCacheErrorEvent": false,
		"atob": false,
		"Attr": false,
		"Audio": false,
		"AudioBuffer": false,
		"AudioBufferSourceNode": false,
		"AudioContext": false,
		"AudioDestinationNode": false,
		"AudioListener": false,
		"AudioNode": false,
		"AudioParam": false,
		"AudioProcessingEvent": false,
		"AudioScheduledSourceNode": false,
		"AudioWorkletGlobalScope ": false,
		"AudioWorkletNode": false,
		"AudioWorkletProcessor": false,
		"BarProp": false,
		"BaseAudioContext": false,
		"BatteryManager": false,
		"BeforeUnloadEvent": false,
		"BiquadFilterNode": false,
		"Blob": false,
		"BlobEvent": false,
		"blur": false,
		"BroadcastChannel": false,
		"btoa": false,
		"BudgetService": false,
		"ByteLengthQueuingStrategy": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"cancelAnimationFrame": false,
		"cancelIdleCallback": false,
		"CanvasCaptureMediaStreamTrack": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"ChannelMergerNode": false,
		"ChannelSplitterNode": false,
		"CharacterData": false,
		"clearInterval": false,
		"clearTimeout": false,
		"clientInformation": false,
		"ClipboardEvent": false,
		"close": false,
		"closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"ConstantSourceNode": false,
		"ConvolverNode": false,
		"CountQueuingStrategy": false,
		"createImageBitmap": false,
		"Credential": false,
		"CredentialsContainer": false,
		"crypto": false,
		"Crypto": false,
		"CryptoKey": false,
		"CSS": false,
		"CSSConditionRule": false,
		"CSSFontFaceRule": false,
		"CSSGroupingRule": false,
		"CSSImportRule": false,
		"CSSKeyframeRule": false,
		"CSSKeyframesRule": false,
		"CSSMediaRule": false,
		"CSSNamespaceRule": false,
		"CSSPageRule": false,
		"CSSRule": false,
		"CSSRuleList": false,
		"CSSStyleDeclaration": false,
		"CSSStyleRule": false,
		"CSSStyleSheet": false,
		"CSSSupportsRule": false,
		"CustomElementRegistry": false,
		"customElements": false,
		"CustomEvent": false,
		"DataTransfer": false,
		"DataTransferItem": false,
		"DataTransferItemList": false,
		"defaultstatus": false,
		"defaultStatus": false,
		"DelayNode": false,
		"DeviceMotionEvent": false,
		"DeviceOrientationEvent": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DocumentType": false,
		"DOMError": false,
		"DOMException": false,
		"DOMImplementation": false,
		"DOMMatrix": false,
		"DOMMatrixReadOnly": false,
		"DOMParser": false,
		"DOMPoint": false,
		"DOMPointReadOnly": false,
		"DOMQuad": false,
		"DOMRect": false,
		"DOMRectReadOnly": false,
		"DOMStringList": false,
		"DOMStringMap": false,
		"DOMTokenList": false,
		"DragEvent": false,
		"DynamicsCompressorNode": false,
		"Element": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"EventSource": false,
		"EventTarget": false,
		"external": false,
		"fetch": false,
		"File": false,
		"FileList": false,
		"FileReader": false,
		"find": false,
		"focus": false,
		"FocusEvent": false,
		"FontFace": false,
		"FontFaceSetLoadEvent": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GainNode": false,
		"Gamepad": false,
		"GamepadButton": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"Headers": false,
		"history": false,
		"History": false,
		"HTMLAllCollection": false,
		"HTMLAnchorElement": false,
		"HTMLAreaElement": false,
		"HTMLAudioElement": false,
		"HTMLBaseElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLCollection": false,
		"HTMLContentElement": false,
		"HTMLDataElement": false,
		"HTMLDataListElement": false,
		"HTMLDetailsElement": false,
		"HTMLDialogElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLDocument": false,
		"HTMLElement": false,
		"HTMLEmbedElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormControlsCollection": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLLabelElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMarqueeElement": false,
		"HTMLMediaElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLMeterElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLOptionsCollection": false,
		"HTMLOutputElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPictureElement": false,
		"HTMLPreElement": false,
		"HTMLProgressElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLShadowElement": false,
		"HTMLSlotElement": false,
		"HTMLSourceElement": false,
		"HTMLSpanElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTemplateElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTimeElement": false,
		"HTMLTitleElement": false,
		"HTMLTrackElement": false,
		"HTMLUListElement": false,
		"HTMLUnknownElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"IdleDeadline": false,
		"IIRFilterNode": false,
		"Image": false,
		"ImageBitmap": false,
		"ImageBitmapRenderingContext": false,
		"ImageCapture": false,
		"ImageData": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"IntersectionObserver": false,
		"IntersectionObserverEntry": false,
		"Intl": false,
		"isSecureContext": false,
		"KeyboardEvent": false,
		"KeyframeEffect": false,
		"KeyframeEffectReadOnly": false,
		"length": false,
		"localStorage": false,
		"location": true,
		"Location": false,
		"locationbar": false,
		"matchMedia": false,
		"MediaDeviceInfo": false,
		"MediaDevices": false,
		"MediaElementAudioSourceNode": false,
		"MediaEncryptedEvent": false,
		"MediaError": false,
		"MediaKeyMessageEvent": false,
		"MediaKeySession": false,
		"MediaKeyStatusMap": false,
		"MediaKeySystemAccess": false,
		"MediaList": false,
		"MediaQueryList": false,
		"MediaQueryListEvent": false,
		"MediaRecorder": false,
		"MediaSettingsRange": false,
		"MediaSource": false,
		"MediaStream": false,
		"MediaStreamAudioDestinationNode": false,
		"MediaStreamAudioSourceNode": false,
		"MediaStreamEvent": false,
		"MediaStreamTrack": false,
		"MediaStreamTrackEvent": false,
		"menubar": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MIDIAccess": false,
		"MIDIConnectionEvent": false,
		"MIDIInput": false,
		"MIDIInputMap": false,
		"MIDIMessageEvent": false,
		"MIDIOutput": false,
		"MIDIOutputMap": false,
		"MIDIPort": false,
		"MimeType": false,
		"MimeTypeArray": false,
		"MouseEvent": false,
		"moveBy": false,
		"moveTo": false,
		"MutationEvent": false,
		"MutationObserver": false,
		"MutationRecord": false,
		"name": false,
		"NamedNodeMap": false,
		"NavigationPreloadManager": false,
		"navigator": false,
		"Navigator": false,
		"NetworkInformation": false,
		"Node": false,
		"NodeFilter": false,
		"NodeIterator": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"OfflineAudioContext": false,
		"offscreenBuffering": false,
		"OffscreenCanvas": true,
		"onabort": true,
		"onafterprint": true,
		"onanimationend": true,
		"onanimationiteration": true,
		"onanimationstart": true,
		"onappinstalled": true,
		"onauxclick": true,
		"onbeforeinstallprompt": true,
		"onbeforeprint": true,
		"onbeforeunload": true,
		"onblur": true,
		"oncancel": true,
		"oncanplay": true,
		"oncanplaythrough": true,
		"onchange": true,
		"onclick": true,
		"onclose": true,
		"oncontextmenu": true,
		"oncuechange": true,
		"ondblclick": true,
		"ondevicemotion": true,
		"ondeviceorientation": true,
		"ondeviceorientationabsolute": true,
		"ondrag": true,
		"ondragend": true,
		"ondragenter": true,
		"ondragleave": true,
		"ondragover": true,
		"ondragstart": true,
		"ondrop": true,
		"ondurationchange": true,
		"onemptied": true,
		"onended": true,
		"onerror": true,
		"onfocus": true,
		"ongotpointercapture": true,
		"onhashchange": true,
		"oninput": true,
		"oninvalid": true,
		"onkeydown": true,
		"onkeypress": true,
		"onkeyup": true,
		"onlanguagechange": true,
		"onload": true,
		"onloadeddata": true,
		"onloadedmetadata": true,
		"onloadstart": true,
		"onlostpointercapture": true,
		"onmessage": true,
		"onmessageerror": true,
		"onmousedown": true,
		"onmouseenter": true,
		"onmouseleave": true,
		"onmousemove": true,
		"onmouseout": true,
		"onmouseover": true,
		"onmouseup": true,
		"onmousewheel": true,
		"onoffline": true,
		"ononline": true,
		"onpagehide": true,
		"onpageshow": true,
		"onpause": true,
		"onplay": true,
		"onplaying": true,
		"onpointercancel": true,
		"onpointerdown": true,
		"onpointerenter": true,
		"onpointerleave": true,
		"onpointermove": true,
		"onpointerout": true,
		"onpointerover": true,
		"onpointerup": true,
		"onpopstate": true,
		"onprogress": true,
		"onratechange": true,
		"onrejectionhandled": true,
		"onreset": true,
		"onresize": true,
		"onscroll": true,
		"onsearch": true,
		"onseeked": true,
		"onseeking": true,
		"onselect": true,
		"onstalled": true,
		"onstorage": true,
		"onsubmit": true,
		"onsuspend": true,
		"ontimeupdate": true,
		"ontoggle": true,
		"ontransitionend": true,
		"onunhandledrejection": true,
		"onunload": true,
		"onvolumechange": true,
		"onwaiting": true,
		"onwheel": true,
		"open": false,
		"openDatabase": false,
		"opener": false,
		"Option": false,
		"origin": false,
		"OscillatorNode": false,
		"outerHeight": false,
		"outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"PannerNode": false,
		"parent": false,
		"Path2D": false,
		"PaymentAddress": false,
		"PaymentRequest": false,
		"PaymentRequestUpdateEvent": false,
		"PaymentResponse": false,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceLongTaskTiming": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceNavigationTiming": false,
		"PerformanceObserver": false,
		"PerformanceObserverEntryList": false,
		"PerformancePaintTiming": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"PeriodicWave": false,
		"Permissions": false,
		"PermissionStatus": false,
		"personalbar": false,
		"PhotoCapabilities": false,
		"Plugin": false,
		"PluginArray": false,
		"PointerEvent": false,
		"PopStateEvent": false,
		"postMessage": false,
		"Presentation": false,
		"PresentationAvailability": false,
		"PresentationConnection": false,
		"PresentationConnectionAvailableEvent": false,
		"PresentationConnectionCloseEvent": false,
		"PresentationConnectionList": false,
		"PresentationReceiver": false,
		"PresentationRequest": false,
		"print": false,
		"ProcessingInstruction": false,
		"ProgressEvent": false,
		"PromiseRejectionEvent": false,
		"prompt": false,
		"PushManager": false,
		"PushSubscription": false,
		"PushSubscriptionOptions": false,
		"queueMicrotask": false,
		"RadioNodeList": false,
		"Range": false,
		"ReadableStream": false,
		"registerProcessor": false,
		"RemotePlayback": false,
		"removeEventListener": false,
		"Request": false,
		"requestAnimationFrame": false,
		"requestIdleCallback": false,
		"resizeBy": false,
		"ResizeObserver": false,
		"ResizeObserverEntry": false,
		"resizeTo": false,
		"Response": false,
		"RTCCertificate": false,
		"RTCDataChannel": false,
		"RTCDataChannelEvent": false,
		"RTCDtlsTransport": false,
		"RTCIceCandidate": false,
		"RTCIceGatherer": false,
		"RTCIceTransport": false,
		"RTCPeerConnection": false,
		"RTCPeerConnectionIceEvent": false,
		"RTCRtpContributingSource": false,
		"RTCRtpReceiver": false,
		"RTCRtpSender": false,
		"RTCSctpTransport": false,
		"RTCSessionDescription": false,
		"RTCStatsReport": false,
		"RTCTrackEvent": false,
		"screen": false,
		"Screen": false,
		"screenLeft": false,
		"ScreenOrientation": false,
		"screenTop": false,
		"screenX": false,
		"screenY": false,
		"ScriptProcessorNode": false,
		"scroll": false,
		"scrollbars": false,
		"scrollBy": false,
		"scrollTo": false,
		"scrollX": false,
		"scrollY": false,
		"SecurityPolicyViolationEvent": false,
		"Selection": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerRegistration": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"ShadowRoot": false,
		"SharedWorker": false,
		"SourceBuffer": false,
		"SourceBufferList": false,
		"speechSynthesis": false,
		"SpeechSynthesisEvent": false,
		"SpeechSynthesisUtterance": false,
		"StaticRange": false,
		"status": false,
		"statusbar": false,
		"StereoPannerNode": false,
		"stop": false,
		"Storage": false,
		"StorageEvent": false,
		"StorageManager": false,
		"styleMedia": false,
		"StyleSheet": false,
		"StyleSheetList": false,
		"SubtleCrypto": false,
		"SVGAElement": false,
		"SVGAngle": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDiscardElement": false,
		"SVGElement": false,
		"SVGEllipseElement": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEDropShadowElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGeometryElement": false,
		"SVGGradientElement": false,
		"SVGGraphicsElement": false,
		"SVGImageElement": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPathElement": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformList": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"TaskAttributionTiming": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TextEvent": false,
		"TextMetrics": false,
		"TextTrack": false,
		"TextTrackCue": false,
		"TextTrackCueList": false,
		"TextTrackList": false,
		"TimeRanges": false,
		"toolbar": false,
		"top": false,
		"Touch": false,
		"TouchEvent": false,
		"TouchList": false,
		"TrackEvent": false,
		"TransitionEvent": false,
		"TreeWalker": false,
		"UIEvent": false,
		"URL": false,
		"URLSearchParams": false,
		"ValidityState": false,
		"visualViewport": false,
		"VisualViewport": false,
		"VTTCue": false,
		"WaveShaperNode": false,
		"WebAssembly": false,
		"WebGL2RenderingContext": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLQuery": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLSampler": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLSync": false,
		"WebGLTexture": false,
		"WebGLTransformFeedback": false,
		"WebGLUniformLocation": false,
		"WebGLVertexArrayObject": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"WritableStream": false,
		"XMLDocument": false,
		"XMLHttpRequest": false,
		"XMLHttpRequestEventTarget": false,
		"XMLHttpRequestUpload": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathExpression": false,
		"XPathResult": false,
		"XSLTProcessor": false
	},
	"worker": {
		"addEventListener": false,
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": true,
		"console": false,
		"fetch": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": true,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onoffline": true,
		"ononline": true,
		"onrejectionhandled": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"queueMicrotask": false,
		"removeEventListener": false,
		"Request": false,
		"Response": false,
		"self": true,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"URLSearchParams": false,
		"WebSocket": false,
		"Worker": false,
		"WorkerGlobalScope": false,
		"XMLHttpRequest": false
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"exports": true,
		"global": false,
		"Intl": false,
		"module": false,
		"process": false,
		"queueMicrotask": false,
		"require": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"URLSearchParams": false
	},
	"commonjs": {
		"exports": true,
		"global": false,
		"module": false,
		"require": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"mocha": false,
		"run": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"spyOnProperty": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"jest": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jest": false,
		"pit": false,
		"require": false,
		"test": false,
		"xdescribe": false,
		"xit": false,
		"xtest": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notOk": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"nashorn": {
		"__DIR__": false,
		"__FILE__": false,
		"__LINE__": false,
		"com": false,
		"edu": false,
		"exit": false,
		"java": false,
		"Java": false,
		"javafx": false,
		"JavaImporter": false,
		"javax": false,
		"JSAdapter": false,
		"load": false,
		"loadWithNewGlobal": false,
		"org": false,
		"Packages": false,
		"print": false,
		"quit": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"YAHOO": false,
		"YAHOO_config": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ln": false,
		"ls": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"set": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"touch": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"_": false,
		"$": false,
		"Accounts": false,
		"AccountsClient": false,
		"AccountsCommon": false,
		"AccountsServer": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPRateLimiter": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"ServiceConfiguration": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"ISODate": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"NumberInt": false,
		"NumberLong": false,
		"ObjectId": false,
		"PlanCache": false,
		"print": false,
		"printjson": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	},
	"applescript": {
		"$": false,
		"Application": false,
		"Automation": false,
		"console": false,
		"delay": false,
		"Library": false,
		"ObjC": false,
		"ObjectSpecifier": false,
		"Path": false,
		"Progress": false,
		"Ref": false
	},
	"serviceworker": {
		"addEventListener": false,
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"clearInterval": false,
		"clearTimeout": false,
		"Client": false,
		"clients": false,
		"Clients": false,
		"close": true,
		"console": false,
		"ExtendableEvent": false,
		"ExtendableMessageEvent": false,
		"fetch": false,
		"FetchEvent": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": false,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onfetch": true,
		"oninstall": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onmessageerror": true,
		"onnotificationclick": true,
		"onnotificationclose": true,
		"onoffline": true,
		"ononline": true,
		"onpush": true,
		"onpushsubscriptionchange": true,
		"onrejectionhandled": true,
		"onsync": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"queueMicrotask": false,
		"registration": false,
		"removeEventListener": false,
		"Request": false,
		"Response": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerGlobalScope": false,
		"ServiceWorkerMessageEvent": false,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"skipWaiting": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"URLSearchParams": false,
		"WebSocket": false,
		"WindowClient": false,
		"Worker": false,
		"WorkerGlobalScope": false,
		"XMLHttpRequest": false
	},
	"atomtest": {
		"advanceClock": false,
		"fakeClearInterval": false,
		"fakeClearTimeout": false,
		"fakeSetInterval": false,
		"fakeSetTimeout": false,
		"resetTimeouts": false,
		"waitsForPromise": false
	},
	"embertest": {
		"andThen": false,
		"click": false,
		"currentPath": false,
		"currentRouteName": false,
		"currentURL": false,
		"fillIn": false,
		"find": false,
		"findAll": false,
		"findWithAssert": false,
		"keyEvent": false,
		"pauseTest": false,
		"resumeTest": false,
		"triggerEvent": false,
		"visit": false,
		"wait": false
	},
	"protractor": {
		"$": false,
		"$$": false,
		"browser": false,
		"by": false,
		"By": false,
		"DartObject": false,
		"element": false,
		"protractor": false
	},
	"shared-node-browser": {
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"setInterval": false,
		"setTimeout": false,
		"URL": false,
		"URLSearchParams": false
	},
	"webextensions": {
		"browser": false,
		"chrome": false,
		"opr": false
	},
	"greasemonkey": {
		"cloneInto": false,
		"createObjectIn": false,
		"exportFunction": false,
		"GM": false,
		"GM_addStyle": false,
		"GM_deleteValue": false,
		"GM_getResourceText": false,
		"GM_getResourceURL": false,
		"GM_getValue": false,
		"GM_info": false,
		"GM_listValues": false,
		"GM_log": false,
		"GM_openInTab": false,
		"GM_registerMenuCommand": false,
		"GM_setClipboard": false,
		"GM_setValue": false,
		"GM_xmlhttpRequest": false,
		"unsafeWindow": false
	},
	"devtools": {
		"$": false,
		"$_": false,
		"$$": false,
		"$0": false,
		"$1": false,
		"$2": false,
		"$3": false,
		"$4": false,
		"$x": false,
		"chrome": false,
		"clear": false,
		"copy": false,
		"debug": false,
		"dir": false,
		"dirxml": false,
		"getEventListeners": false,
		"inspect": false,
		"keys": false,
		"monitor": false,
		"monitorEvents": false,
		"profile": false,
		"profileEnd": false,
		"queryObjects": false,
		"table": false,
		"undebug": false,
		"unmonitor": false,
		"unmonitorEvents": false,
		"values": false
	}
}

},{}],838:[function(require,module,exports){
'use strict';

module.exports = require('./globals.json');

},{"./globals.json":837}],839:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],840:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';
/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":1054}],841:[function(require,module,exports){
"use strict";

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],842:[function(require,module,exports){
'use strict';

module.exports = function () {
  function _min(d0, d1, d2, bx, ay) {
    return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
  }

  return function (a, b) {
    if (a === b) {
      return 0;
    }

    if (a.length > b.length) {
      var tmp = a;
      a = b;
      b = tmp;
    }

    var la = a.length;
    var lb = b.length;

    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
      la--;
      lb--;
    }

    var offset = 0;

    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
      offset++;
    }

    la -= offset;
    lb -= offset;

    if (la === 0 || lb < 3) {
      return lb;
    }

    var x = 0;
    var y;
    var d0;
    var d1;
    var d2;
    var d3;
    var dd;
    var dy;
    var ay;
    var bx0;
    var bx1;
    var bx2;
    var bx3;
    var vector = [];

    for (y = 0; y < la; y++) {
      vector.push(y + 1);
      vector.push(a.charCodeAt(offset + y));
    }

    var len = vector.length - 1;

    for (; x < lb - 3;) {
      bx0 = b.charCodeAt(offset + (d0 = x));
      bx1 = b.charCodeAt(offset + (d1 = x + 1));
      bx2 = b.charCodeAt(offset + (d2 = x + 2));
      bx3 = b.charCodeAt(offset + (d3 = x + 3));
      dd = x += 4;

      for (y = 0; y < len; y += 2) {
        dy = vector[y];
        ay = vector[y + 1];
        d0 = _min(dy, d0, d1, bx0, ay);
        d1 = _min(d0, d1, d2, bx1, ay);
        d2 = _min(d1, d2, d3, bx2, ay);
        dd = _min(d2, d3, dd, bx3, ay);
        vector[y] = dd;
        d3 = d2;
        d2 = d1;
        d1 = d0;
        d0 = dy;
      }
    }

    for (; x < lb;) {
      bx0 = b.charCodeAt(offset + (d0 = x));
      dd = ++x;

      for (y = 0; y < len; y += 2) {
        dy = vector[y];
        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
        d0 = dy;
      }
    }

    return dd;
  };
}();

},{}],843:[function(require,module,exports){
"use strict";

// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
// License: MIT. (See LICENSE.)
Object.defineProperty(exports, "__esModule", {
  value: true
}); // This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).

exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

exports.matchToToken = function (match) {
  var token = {
    type: "invalid",
    value: match[0],
    closed: undefined
  };
  if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
  return token;
};

},{}],844:[function(require,module,exports){
(function (Buffer){
'use strict';

var object = {};
var hasOwnProperty = object.hasOwnProperty;

var forOwn = function forOwn(object, callback) {
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      callback(key, object[key]);
    }
  }
};

var extend = function extend(destination, source) {
  if (!source) {
    return destination;
  }

  forOwn(source, function (key, value) {
    destination[key] = value;
  });
  return destination;
};

var forEach = function forEach(array, callback) {
  var length = array.length;
  var index = -1;

  while (++index < length) {
    callback(array[index]);
  }
};

var toString = object.toString;
var isArray = Array.isArray;
var isBuffer = Buffer.isBuffer;

var isObject = function isObject(value) {
  // This is a very simple check, but its good enough for what we need.
  return toString.call(value) == '[object Object]';
};

var isString = function isString(value) {
  return typeof value == 'string' || toString.call(value) == '[object String]';
};

var isNumber = function isNumber(value) {
  return typeof value == 'number' || toString.call(value) == '[object Number]';
};

var isFunction = function isFunction(value) {
  return typeof value == 'function';
};

var isMap = function isMap(value) {
  return toString.call(value) == '[object Map]';
};

var isSet = function isSet(value) {
  return toString.call(value) == '[object Set]';
};
/*--------------------------------------------------------------------------*/
// https://mathiasbynens.be/notes/javascript-escapes#single


var singleEscapes = {
  '"': '\\"',
  '\'': '\\\'',
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t' // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  // '\v': '\\x0B'

};
var regexSingleEscape = /["'\\\b\f\n\r\t]/;
var regexDigit = /[0-9]/;
var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

var jsesc = function jsesc(argument, options) {
  var increaseIndentation = function increaseIndentation() {
    oldIndent = indent;
    ++options.indentLevel;
    indent = options.indent.repeat(options.indentLevel);
  }; // Handle options


  var defaults = {
    'escapeEverything': false,
    'minimal': false,
    'isScriptContext': false,
    'quotes': 'single',
    'wrap': false,
    'es6': false,
    'json': false,
    'compact': true,
    'lowercaseHex': false,
    'numbers': 'decimal',
    'indent': '\t',
    'indentLevel': 0,
    '__inline1__': false,
    '__inline2__': false
  };
  var json = options && options.json;

  if (json) {
    defaults.quotes = 'double';
    defaults.wrap = true;
  }

  options = extend(defaults, options);

  if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
    options.quotes = 'single';
  }

  var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
  var compact = options.compact;
  var lowercaseHex = options.lowercaseHex;
  var indent = options.indent.repeat(options.indentLevel);
  var oldIndent = '';
  var inline1 = options.__inline1__;
  var inline2 = options.__inline2__;
  var newLine = compact ? '' : '\n';
  var result;
  var isEmpty = true;
  var useBinNumbers = options.numbers == 'binary';
  var useOctNumbers = options.numbers == 'octal';
  var useDecNumbers = options.numbers == 'decimal';
  var useHexNumbers = options.numbers == 'hexadecimal';

  if (json && argument && isFunction(argument.toJSON)) {
    argument = argument.toJSON();
  }

  if (!isString(argument)) {
    if (isMap(argument)) {
      if (argument.size == 0) {
        return 'new Map()';
      }

      if (!compact) {
        options.__inline1__ = true;
        options.__inline2__ = false;
      }

      return 'new Map(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isSet(argument)) {
      if (argument.size == 0) {
        return 'new Set()';
      }

      return 'new Set(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isBuffer(argument)) {
      if (argument.length == 0) {
        return 'Buffer.from([])';
      }

      return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isArray(argument)) {
      result = [];
      options.wrap = true;

      if (inline1) {
        options.__inline1__ = false;
        options.__inline2__ = true;
      }

      if (!inline2) {
        increaseIndentation();
      }

      forEach(argument, function (value) {
        isEmpty = false;

        if (inline2) {
          options.__inline2__ = false;
        }

        result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
      });

      if (isEmpty) {
        return '[]';
      }

      if (inline2) {
        return '[' + result.join(', ') + ']';
      }

      return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
    } else if (isNumber(argument)) {
      if (json) {
        // Some number values (e.g. `Infinity`) cannot be represented in JSON.
        return JSON.stringify(argument);
      }

      if (useDecNumbers) {
        return String(argument);
      }

      if (useHexNumbers) {
        var hexadecimal = argument.toString(16);

        if (!lowercaseHex) {
          hexadecimal = hexadecimal.toUpperCase();
        }

        return '0x' + hexadecimal;
      }

      if (useBinNumbers) {
        return '0b' + argument.toString(2);
      }

      if (useOctNumbers) {
        return '0o' + argument.toString(8);
      }
    } else if (!isObject(argument)) {
      if (json) {
        // For some values (e.g. `undefined`, `function` objects),
        // `JSON.stringify(value)` returns `undefined` (which isnt valid
        // JSON) instead of `'null'`.
        return JSON.stringify(argument) || 'null';
      }

      return String(argument);
    } else {
      // its an object
      result = [];
      options.wrap = true;
      increaseIndentation();
      forOwn(argument, function (key, value) {
        isEmpty = false;
        result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
      });

      if (isEmpty) {
        return '{}';
      }

      return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
    }
  }

  var string = argument; // Loop over each code unit in the string and escape it

  var index = -1;
  var length = string.length;
  result = '';

  while (++index < length) {
    var character = string.charAt(index);

    if (options.es6) {
      var first = string.charCodeAt(index);

      if ( // check if its the start of a surrogate pair
      first >= 0xD800 && first <= 0xDBFF && // high surrogate
      length > index + 1 // there is a next code unit
      ) {
          var second = string.charCodeAt(index + 1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            // low surrogate
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

            var _hexadecimal2 = codePoint.toString(16);

            if (!lowercaseHex) {
              _hexadecimal2 = _hexadecimal2.toUpperCase();
            }

            result += "\\u{" + _hexadecimal2 + '}';
            ++index;
            continue;
          }
        }
    }

    if (!options.escapeEverything) {
      if (regexWhitelist.test(character)) {
        // Its a printable ASCII character that is not `"`, `'` or `\`,
        // so dont escape it.
        result += character;
        continue;
      }

      if (character == '"') {
        result += quote == character ? '\\"' : character;
        continue;
      }

      if (character == '`') {
        result += quote == character ? '\\`' : character;
        continue;
      }

      if (character == '\'') {
        result += quote == character ? '\\\'' : character;
        continue;
      }
    }

    if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
      result += '\\0';
      continue;
    }

    if (regexSingleEscape.test(character)) {
      // no need for a `hasOwnProperty` check here
      result += singleEscapes[character];
      continue;
    }

    var charCode = character.charCodeAt(0);

    if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
      result += character;
      continue;
    }

    var _hexadecimal = charCode.toString(16);

    if (!lowercaseHex) {
      _hexadecimal = _hexadecimal.toUpperCase();
    }

    var longhand = _hexadecimal.length > 2 || json;

    var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

    result += escaped;
    continue;
  }

  if (options.wrap) {
    result = quote + result + quote;
  }

  if (quote == '`') {
    result = result.replace(/\$\{/g, '\\\$\{');
  }

  if (options.isScriptContext) {
    // https://mathiasbynens.be/notes/etago
    return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
  }

  return result;
};

jsesc.version = '2.5.2';
module.exports = jsesc;

}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":841}],845:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

},{"./_getNative":943,"./_root":987}],846:[function(require,module,exports){
"use strict";

var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

},{"./_hashClear":951,"./_hashDelete":952,"./_hashGet":953,"./_hashHas":954,"./_hashSet":955}],847:[function(require,module,exports){
"use strict";

var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

},{"./_listCacheClear":967,"./_listCacheDelete":968,"./_listCacheGet":969,"./_listCacheHas":970,"./_listCacheSet":971}],848:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

},{"./_getNative":943,"./_root":987}],849:[function(require,module,exports){
"use strict";

var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

},{"./_mapCacheClear":972,"./_mapCacheDelete":973,"./_mapCacheGet":974,"./_mapCacheHas":975,"./_mapCacheSet":976}],850:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

},{"./_getNative":943,"./_root":987}],851:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

},{"./_getNative":943,"./_root":987}],852:[function(require,module,exports){
"use strict";

var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

},{"./_MapCache":849,"./_setCacheAdd":988,"./_setCacheHas":989}],853:[function(require,module,exports){
"use strict";

var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

},{"./_ListCache":847,"./_stackClear":993,"./_stackDelete":994,"./_stackGet":995,"./_stackHas":996,"./_stackSet":997}],854:[function(require,module,exports){
"use strict";

var root = require('./_root');
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

},{"./_root":987}],855:[function(require,module,exports){
"use strict";

var root = require('./_root');
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

},{"./_root":987}],856:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

},{"./_getNative":943,"./_root":987}],857:[function(require,module,exports){
"use strict";

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],858:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

},{}],859:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

},{}],860:[function(require,module,exports){
"use strict";

var baseIndexOf = require('./_baseIndexOf');
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":883}],861:[function(require,module,exports){
"use strict";

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

},{}],862:[function(require,module,exports){
"use strict";

var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":910,"./_isIndex":960,"./isArguments":1016,"./isArray":1017,"./isBuffer":1019,"./isTypedArray":1031}],863:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

},{}],864:[function(require,module,exports){
"use strict";

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

},{}],865:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

},{}],866:[function(require,module,exports){
"use strict";

var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":870,"./eq":1008}],867:[function(require,module,exports){
"use strict";

var eq = require('./eq');
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

},{"./eq":1008}],868:[function(require,module,exports){
"use strict";

var copyObject = require('./_copyObject'),
    keys = require('./keys');
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":926,"./keys":1032}],869:[function(require,module,exports){
"use strict";

var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":926,"./keysIn":1033}],870:[function(require,module,exports){
"use strict";

var defineProperty = require('./_defineProperty');
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":934}],871:[function(require,module,exports){
"use strict";

var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys');
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":853,"./_arrayEach":858,"./_assignValue":866,"./_baseAssign":868,"./_baseAssignIn":869,"./_cloneBuffer":918,"./_copyArray":925,"./_copySymbols":927,"./_copySymbolsIn":928,"./_getAllKeys":939,"./_getAllKeysIn":940,"./_getTag":948,"./_initCloneArray":956,"./_initCloneByTag":957,"./_initCloneObject":958,"./isArray":1017,"./isBuffer":1019,"./isMap":1023,"./isObject":1024,"./isSet":1028,"./keys":1032}],872:[function(require,module,exports){
"use strict";

var isObject = require('./isObject');
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

},{"./isObject":1024}],873:[function(require,module,exports){
"use strict";

var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

},{"./_baseForOwn":877,"./_createBaseEach":931}],874:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

},{}],875:[function(require,module,exports){
"use strict";

var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":864,"./_isFlattenable":959}],876:[function(require,module,exports){
"use strict";

var createBaseFor = require('./_createBaseFor');
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

},{"./_createBaseFor":932}],877:[function(require,module,exports){
"use strict";

var baseFor = require('./_baseFor'),
    keys = require('./keys');
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":876,"./keys":1032}],878:[function(require,module,exports){
"use strict";

var castPath = require('./_castPath'),
    toKey = require('./_toKey');
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":916,"./_toKey":1000}],879:[function(require,module,exports){
"use strict";

var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":864,"./isArray":1017}],880:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":854,"./_getRawTag":945,"./_objectToString":984}],881:[function(require,module,exports){
"use strict";

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

},{}],882:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],883:[function(require,module,exports){
"use strict";

var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":874,"./_baseIsNaN":890,"./_strictIndexOf":998}],884:[function(require,module,exports){
"use strict";

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseIndexOfWith;

},{}],885:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":880,"./isObjectLike":1025}],886:[function(require,module,exports){
"use strict";

var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":887,"./isObjectLike":1025}],887:[function(require,module,exports){
"use strict";

var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":853,"./_equalArrays":935,"./_equalByTag":936,"./_equalObjects":937,"./_getTag":948,"./isArray":1017,"./isBuffer":1019,"./isTypedArray":1031}],888:[function(require,module,exports){
"use strict";

var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":948,"./isObjectLike":1025}],889:[function(require,module,exports){
"use strict";

var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":853,"./_baseIsEqual":886}],890:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],891:[function(require,module,exports){
"use strict";

var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":964,"./_toSource":1001,"./isFunction":1020,"./isObject":1024}],892:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var regexpTag = '[object RegExp]';
/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */

function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

},{"./_baseGetTag":880,"./isObjectLike":1025}],893:[function(require,module,exports){
"use strict";

var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":948,"./isObjectLike":1025}],894:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":880,"./isLength":1022,"./isObjectLike":1025}],895:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":899,"./_baseMatchesProperty":900,"./identity":1014,"./isArray":1017,"./property":1036}],896:[function(require,module,exports){
"use strict";

var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":965,"./_nativeKeys":981}],897:[function(require,module,exports){
"use strict";

var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":965,"./_nativeKeysIn":982,"./isObject":1024}],898:[function(require,module,exports){
"use strict";

var baseEach = require('./_baseEach'),
    isArrayLike = require('./isArrayLike');
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":873,"./isArrayLike":1018}],899:[function(require,module,exports){
"use strict";

var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":889,"./_getMatchData":942,"./_matchesStrictComparable":978}],900:[function(require,module,exports){
"use strict";

var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":886,"./_isKey":962,"./_isStrictComparable":966,"./_matchesStrictComparable":978,"./_toKey":1000,"./get":1011,"./hasIn":1013}],901:[function(require,module,exports){
"use strict";

var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    baseSortBy = require('./_baseSortBy'),
    baseUnary = require('./_baseUnary'),
    compareMultiple = require('./_compareMultiple'),
    identity = require('./identity');
/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */


function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;

},{"./_arrayMap":863,"./_baseIteratee":895,"./_baseMap":898,"./_baseSortBy":909,"./_baseUnary":912,"./_compareMultiple":924,"./identity":1014}],902:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],903:[function(require,module,exports){
"use strict";

var baseGet = require('./_baseGet');
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":878}],904:[function(require,module,exports){
"use strict";

var arrayMap = require('./_arrayMap'),
    baseIndexOf = require('./_baseIndexOf'),
    baseIndexOfWith = require('./_baseIndexOfWith'),
    baseUnary = require('./_baseUnary'),
    copyArray = require('./_copyArray');
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */

function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (array === values) {
    values = copyArray(values);
  }

  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }

  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }

      splice.call(array, fromIndex, 1);
    }
  }

  return array;
}

module.exports = basePullAll;

},{"./_arrayMap":863,"./_baseIndexOf":883,"./_baseIndexOfWith":884,"./_baseUnary":912,"./_copyArray":925}],905:[function(require,module,exports){
"use strict";

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeFloor = Math.floor;
/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */

function baseRepeat(string, n) {
  var result = '';

  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  } // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.


  do {
    if (n % 2) {
      result += string;
    }

    n = nativeFloor(n / 2);

    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;

},{}],906:[function(require,module,exports){
"use strict";

var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":986,"./_setToString":991,"./identity":1014}],907:[function(require,module,exports){
"use strict";

var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

},{"./_defineProperty":934,"./constant":1006,"./identity":1014}],908:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

module.exports = baseSlice;

},{}],909:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

module.exports = baseSortBy;

},{}],910:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

},{}],911:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":854,"./_arrayMap":863,"./isArray":1017,"./isSymbol":1030}],912:[function(require,module,exports){
"use strict";

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],913:[function(require,module,exports){
"use strict";

var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

},{"./_SetCache":852,"./_arrayIncludes":860,"./_arrayIncludesWith":861,"./_cacheHas":915,"./_createSet":933,"./_setToArray":990}],914:[function(require,module,exports){
"use strict";

var arrayMap = require('./_arrayMap');
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":863}],915:[function(require,module,exports){
"use strict";

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],916:[function(require,module,exports){
"use strict";

var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":962,"./_stringToPath":999,"./isArray":1017,"./toString":1046}],917:[function(require,module,exports){
"use strict";

var Uint8Array = require('./_Uint8Array');
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":855}],918:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = require('./_root');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":987}],919:[function(require,module,exports){
"use strict";

var cloneArrayBuffer = require('./_cloneArrayBuffer');
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":917}],920:[function(require,module,exports){
"use strict";

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],921:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol');
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":854}],922:[function(require,module,exports){
"use strict";

var cloneArrayBuffer = require('./_cloneArrayBuffer');
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":917}],923:[function(require,module,exports){
"use strict";

var isSymbol = require('./isSymbol');
/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */


function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

module.exports = compareAscending;

},{"./isSymbol":1030}],924:[function(require,module,exports){
"use strict";

var compareAscending = require('./_compareAscending');
/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */


function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

module.exports = compareMultiple;

},{"./_compareAscending":923}],925:[function(require,module,exports){
"use strict";

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

},{}],926:[function(require,module,exports){
"use strict";

var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

},{"./_assignValue":866,"./_baseAssignValue":870}],927:[function(require,module,exports){
"use strict";

var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":926,"./_getSymbols":946}],928:[function(require,module,exports){
"use strict";

var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":926,"./_getSymbolsIn":947}],929:[function(require,module,exports){
"use strict";

var root = require('./_root');
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

},{"./_root":987}],930:[function(require,module,exports){
"use strict";

var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":906,"./_isIterateeCall":961}],931:[function(require,module,exports){
"use strict";

var isArrayLike = require('./isArrayLike');
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":1018}],932:[function(require,module,exports){
"use strict";

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

},{}],933:[function(require,module,exports){
"use strict";

var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

},{"./_Set":851,"./_setToArray":990,"./noop":1035}],934:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative');

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

},{"./_getNative":943}],935:[function(require,module,exports){
"use strict";

var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":852,"./_arraySome":865,"./_cacheHas":915}],936:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

},{"./_Symbol":854,"./_Uint8Array":855,"./_equalArrays":935,"./_mapToArray":977,"./_setToArray":990,"./eq":1008}],937:[function(require,module,exports){
"use strict";

var getAllKeys = require('./_getAllKeys');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":939}],938:[function(require,module,exports){
(function (global){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],939:[function(require,module,exports){
"use strict";

var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":879,"./_getSymbols":946,"./keys":1032}],940:[function(require,module,exports){
"use strict";

var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":879,"./_getSymbolsIn":947,"./keysIn":1033}],941:[function(require,module,exports){
"use strict";

var isKeyable = require('./_isKeyable');
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":963}],942:[function(require,module,exports){
"use strict";

var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":966,"./keys":1032}],943:[function(require,module,exports){
"use strict";

var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":891,"./_getValue":949}],944:[function(require,module,exports){
"use strict";

var overArg = require('./_overArg');
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

},{"./_overArg":985}],945:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

},{"./_Symbol":854}],946:[function(require,module,exports){
"use strict";

var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

},{"./_arrayFilter":859,"./stubArray":1041}],947:[function(require,module,exports){
"use strict";

var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

},{"./_arrayPush":864,"./_getPrototype":944,"./_getSymbols":946,"./stubArray":1041}],948:[function(require,module,exports){
"use strict";

var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

},{"./_DataView":845,"./_Map":848,"./_Promise":850,"./_Set":851,"./_WeakMap":856,"./_baseGetTag":880,"./_toSource":1001}],949:[function(require,module,exports){
"use strict";

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],950:[function(require,module,exports){
"use strict";

var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":916,"./_isIndex":960,"./_toKey":1000,"./isArguments":1016,"./isArray":1017,"./isLength":1022}],951:[function(require,module,exports){
"use strict";

var nativeCreate = require('./_nativeCreate');
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":980}],952:[function(require,module,exports){
"use strict";

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],953:[function(require,module,exports){
"use strict";

var nativeCreate = require('./_nativeCreate');
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":980}],954:[function(require,module,exports){
"use strict";

var nativeCreate = require('./_nativeCreate');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":980}],955:[function(require,module,exports){
"use strict";

var nativeCreate = require('./_nativeCreate');
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":980}],956:[function(require,module,exports){
"use strict";

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

},{}],957:[function(require,module,exports){
"use strict";

var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":917,"./_cloneDataView":919,"./_cloneRegExp":920,"./_cloneSymbol":921,"./_cloneTypedArray":922}],958:[function(require,module,exports){
"use strict";

var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":872,"./_getPrototype":944,"./_isPrototype":965}],959:[function(require,module,exports){
"use strict";

var _Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":854,"./isArguments":1016,"./isArray":1017}],960:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],961:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":960,"./eq":1008,"./isArrayLike":1018,"./isObject":1024}],962:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

},{"./isArray":1017,"./isSymbol":1030}],963:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

},{}],964:[function(require,module,exports){
"use strict";

var coreJsData = require('./_coreJsData');
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

},{"./_coreJsData":929}],965:[function(require,module,exports){
"use strict";

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

},{}],966:[function(require,module,exports){
"use strict";

var isObject = require('./isObject');
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":1024}],967:[function(require,module,exports){
"use strict";

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],968:[function(require,module,exports){
"use strict";

var assocIndexOf = require('./_assocIndexOf');
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":867}],969:[function(require,module,exports){
"use strict";

var assocIndexOf = require('./_assocIndexOf');
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":867}],970:[function(require,module,exports){
"use strict";

var assocIndexOf = require('./_assocIndexOf');
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":867}],971:[function(require,module,exports){
"use strict";

var assocIndexOf = require('./_assocIndexOf');
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":867}],972:[function(require,module,exports){
"use strict";

var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

},{"./_Hash":846,"./_ListCache":847,"./_Map":848}],973:[function(require,module,exports){
"use strict";

var getMapData = require('./_getMapData');
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":941}],974:[function(require,module,exports){
"use strict";

var getMapData = require('./_getMapData');
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":941}],975:[function(require,module,exports){
"use strict";

var getMapData = require('./_getMapData');
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":941}],976:[function(require,module,exports){
"use strict";

var getMapData = require('./_getMapData');
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":941}],977:[function(require,module,exports){
"use strict";

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],978:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

},{}],979:[function(require,module,exports){
"use strict";

var memoize = require('./memoize');
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":1034}],980:[function(require,module,exports){
"use strict";

var getNative = require('./_getNative');
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

},{"./_getNative":943}],981:[function(require,module,exports){
"use strict";

var overArg = require('./_overArg');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

},{"./_overArg":985}],982:[function(require,module,exports){
"use strict";

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

},{}],983:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = require('./_freeGlobal');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;

},{"./_freeGlobal":938}],984:[function(require,module,exports){
"use strict";

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],985:[function(require,module,exports){
"use strict";

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],986:[function(require,module,exports){
"use strict";

var apply = require('./_apply');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":857}],987:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = require('./_freeGlobal');
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

},{"./_freeGlobal":938}],988:[function(require,module,exports){
"use strict";

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

},{}],989:[function(require,module,exports){
"use strict";

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],990:[function(require,module,exports){
"use strict";

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],991:[function(require,module,exports){
"use strict";

var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

},{"./_baseSetToString":907,"./_shortOut":992}],992:[function(require,module,exports){
"use strict";

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],993:[function(require,module,exports){
"use strict";

var ListCache = require('./_ListCache');
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":847}],994:[function(require,module,exports){
"use strict";

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],995:[function(require,module,exports){
"use strict";

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],996:[function(require,module,exports){
"use strict";

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],997:[function(require,module,exports){
"use strict";

var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":847,"./_Map":848,"./_MapCache":849}],998:[function(require,module,exports){
"use strict";

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

},{}],999:[function(require,module,exports){
"use strict";

var memoizeCapped = require('./_memoizeCapped');
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

},{"./_memoizeCapped":979}],1000:[function(require,module,exports){
"use strict";

var isSymbol = require('./isSymbol');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":1030}],1001:[function(require,module,exports){
"use strict";

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

},{}],1002:[function(require,module,exports){
"use strict";

var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');
/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */


var assignIn = createAssigner(function (object, source) {
  copyObject(source, keysIn(source), object);
});
module.exports = assignIn;

},{"./_copyObject":926,"./_createAssigner":930,"./keysIn":1033}],1003:[function(require,module,exports){
"use strict";

var baseSlice = require('./_baseSlice'),
    isIterateeCall = require('./_isIterateeCall'),
    toInteger = require('./toInteger');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeCeil = Math.ceil,
    nativeMax = Math.max;
/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */

function chunk(array, size, guard) {
  if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }

  var length = array == null ? 0 : array.length;

  if (!length || size < 1) {
    return [];
  }

  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, index += size);
  }

  return result;
}

module.exports = chunk;

},{"./_baseSlice":908,"./_isIterateeCall":961,"./toInteger":1044}],1004:[function(require,module,exports){
"use strict";

var baseClone = require('./_baseClone');
/** Used to compose bitmasks for cloning. */


var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":871}],1005:[function(require,module,exports){
"use strict";

var baseClone = require('./_baseClone');
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":871}],1006:[function(require,module,exports){
"use strict";

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

},{}],1007:[function(require,module,exports){
"use strict";

var baseRest = require('./_baseRest'),
    eq = require('./eq'),
    isIterateeCall = require('./_isIterateeCall'),
    keysIn = require('./keysIn');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var defaults = baseRest(function (object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        object[key] = source[key];
      }
    }
  }

  return object;
});
module.exports = defaults;

},{"./_baseRest":906,"./_isIterateeCall":961,"./eq":1008,"./keysIn":1033}],1008:[function(require,module,exports){
"use strict";

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

},{}],1009:[function(require,module,exports){
"use strict";

var toString = require('./toString');
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);
/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */

function escapeRegExp(string) {
  string = toString(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
}

module.exports = escapeRegExp;

},{"./toString":1046}],1010:[function(require,module,exports){
"use strict";

module.exports = require('./assignIn');

},{"./assignIn":1002}],1011:[function(require,module,exports){
"use strict";

var baseGet = require('./_baseGet');
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":878}],1012:[function(require,module,exports){
"use strict";

var baseHas = require('./_baseHas'),
    hasPath = require('./_hasPath');
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

},{"./_baseHas":881,"./_hasPath":950}],1013:[function(require,module,exports){
"use strict";

var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":882,"./_hasPath":950}],1014:[function(require,module,exports){
"use strict";

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],1015:[function(require,module,exports){
"use strict";

var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */

function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
  var length = collection.length;

  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }

  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}

module.exports = includes;

},{"./_baseIndexOf":883,"./isArrayLike":1018,"./isString":1029,"./toInteger":1044,"./values":1048}],1016:[function(require,module,exports){
"use strict";

var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

},{"./_baseIsArguments":885,"./isObjectLike":1025}],1017:[function(require,module,exports){
"use strict";

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

},{}],1018:[function(require,module,exports){
"use strict";

var isFunction = require('./isFunction'),
    isLength = require('./isLength');
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":1020,"./isLength":1022}],1019:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = require('./_root'),
    stubFalse = require('./stubFalse');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

},{"./_root":987,"./stubFalse":1042}],1020:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":880,"./isObject":1024}],1021:[function(require,module,exports){
"use strict";

var toInteger = require('./toInteger');
/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */


function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

module.exports = isInteger;

},{"./toInteger":1044}],1022:[function(require,module,exports){
"use strict";

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],1023:[function(require,module,exports){
"use strict";

var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

},{"./_baseIsMap":888,"./_baseUnary":912,"./_nodeUtil":983}],1024:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],1025:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

},{}],1026:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":880,"./_getPrototype":944,"./isObjectLike":1025}],1027:[function(require,module,exports){
"use strict";

var baseIsRegExp = require('./_baseIsRegExp'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */

var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
module.exports = isRegExp;

},{"./_baseIsRegExp":892,"./_baseUnary":912,"./_nodeUtil":983}],1028:[function(require,module,exports){
"use strict";

var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

},{"./_baseIsSet":893,"./_baseUnary":912,"./_nodeUtil":983}],1029:[function(require,module,exports){
"use strict";

var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

module.exports = isString;

},{"./_baseGetTag":880,"./isArray":1017,"./isObjectLike":1025}],1030:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

},{"./_baseGetTag":880,"./isObjectLike":1025}],1031:[function(require,module,exports){
"use strict";

var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

},{"./_baseIsTypedArray":894,"./_baseUnary":912,"./_nodeUtil":983}],1032:[function(require,module,exports){
"use strict";

var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":862,"./_baseKeys":896,"./isArrayLike":1018}],1033:[function(require,module,exports){
"use strict";

var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":862,"./_baseKeysIn":897,"./isArrayLike":1018}],1034:[function(require,module,exports){
"use strict";

var MapCache = require('./_MapCache');
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

},{"./_MapCache":849}],1035:[function(require,module,exports){
"use strict";

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

},{}],1036:[function(require,module,exports){
"use strict";

var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":902,"./_basePropertyDeep":903,"./_isKey":962,"./_toKey":1000}],1037:[function(require,module,exports){
"use strict";

var baseRest = require('./_baseRest'),
    pullAll = require('./pullAll');
/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pull(array, 'a', 'c');
 * console.log(array);
 * // => ['b', 'b']
 */


var pull = baseRest(pullAll);
module.exports = pull;

},{"./_baseRest":906,"./pullAll":1038}],1038:[function(require,module,exports){
"use strict";

var basePullAll = require('./_basePullAll');
/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pullAll(array, ['a', 'c']);
 * console.log(array);
 * // => ['b', 'b']
 */


function pullAll(array, values) {
  return array && array.length && values && values.length ? basePullAll(array, values) : array;
}

module.exports = pullAll;

},{"./_basePullAll":904}],1039:[function(require,module,exports){
"use strict";

var baseRepeat = require('./_baseRepeat'),
    isIterateeCall = require('./_isIterateeCall'),
    toInteger = require('./toInteger'),
    toString = require('./toString');
/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */


function repeat(string, n, guard) {
  if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = toInteger(n);
  }

  return baseRepeat(toString(string), n);
}

module.exports = repeat;

},{"./_baseRepeat":905,"./_isIterateeCall":961,"./toInteger":1044,"./toString":1046}],1040:[function(require,module,exports){
"use strict";

var baseFlatten = require('./_baseFlatten'),
    baseOrderBy = require('./_baseOrderBy'),
    baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */


var sortBy = baseRest(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }

  var length = iteratees.length;

  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }

  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
module.exports = sortBy;

},{"./_baseFlatten":875,"./_baseOrderBy":901,"./_baseRest":906,"./_isIterateeCall":961}],1041:[function(require,module,exports){
"use strict";

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],1042:[function(require,module,exports){
"use strict";

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],1043:[function(require,module,exports){
"use strict";

var toNumber = require('./toNumber');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":1045}],1044:[function(require,module,exports){
"use strict";

var toFinite = require('./toFinite');
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */


function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

module.exports = toInteger;

},{"./toFinite":1043}],1045:[function(require,module,exports){
"use strict";

var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

},{"./isObject":1024,"./isSymbol":1030}],1046:[function(require,module,exports){
"use strict";

var baseToString = require('./_baseToString');
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":911}],1047:[function(require,module,exports){
"use strict";

var baseUniq = require('./_baseUniq');
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */


function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

module.exports = uniq;

},{"./_baseUniq":913}],1048:[function(require,module,exports){
"use strict";

var baseValues = require('./_baseValues'),
    keys = require('./keys');
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":914,"./keys":1032}],1049:[function(require,module,exports){
module.exports=[
  {
    "name": "nodejs",
    "version": "0.2.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.3.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.4.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.5.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.6.0",
    "date": "2011-11-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.7.0",
    "date": "2012-01-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.8.0",
    "date": "2012-06-22",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.9.0",
    "date": "2012-07-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.10.0",
    "date": "2013-03-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.11.0",
    "date": "2013-03-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.12.0",
    "date": "2015-02-06",
    "lts": false,
    "security": false
  },
  {
    "name": "iojs",
    "version": "1.0.0",
    "date": "2015-01-14"
  },
  {
    "name": "iojs",
    "version": "1.1.0",
    "date": "2015-02-03"
  },
  {
    "name": "iojs",
    "version": "1.2.0",
    "date": "2015-02-11"
  },
  {
    "name": "iojs",
    "version": "1.3.0",
    "date": "2015-02-20"
  },
  {
    "name": "iojs",
    "version": "1.5.0",
    "date": "2015-03-06"
  },
  {
    "name": "iojs",
    "version": "1.6.0",
    "date": "2015-03-20"
  },
  {
    "name": "iojs",
    "version": "2.0.0",
    "date": "2015-05-04"
  },
  {
    "name": "iojs",
    "version": "2.1.0",
    "date": "2015-05-24"
  },
  {
    "name": "iojs",
    "version": "2.2.0",
    "date": "2015-06-01"
  },
  {
    "name": "iojs",
    "version": "2.3.0",
    "date": "2015-06-13"
  },
  {
    "name": "iojs",
    "version": "2.4.0",
    "date": "2015-07-17"
  },
  {
    "name": "iojs",
    "version": "2.5.0",
    "date": "2015-07-28"
  },
  {
    "name": "iojs",
    "version": "3.0.0",
    "date": "2015-08-04"
  },
  {
    "name": "iojs",
    "version": "3.1.0",
    "date": "2015-08-19"
  },
  {
    "name": "iojs",
    "version": "3.2.0",
    "date": "2015-08-25"
  },
  {
    "name": "iojs",
    "version": "3.3.0",
    "date": "2015-09-02"
  },
  {
    "name": "nodejs",
    "version": "4.0.0",
    "date": "2015-09-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.1.0",
    "date": "2015-09-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.2.0",
    "date": "2015-10-12",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.3.0",
    "date": "2016-02-09",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.4.0",
    "date": "2016-03-08",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.5.0",
    "date": "2016-08-16",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.6.0",
    "date": "2016-09-27",
    "lts": "Argon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "4.7.0",
    "date": "2016-12-06",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.8.0",
    "date": "2017-02-21",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.9.0",
    "date": "2018-03-28",
    "lts": "Argon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "5.0.0",
    "date": "2015-10-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.1.0",
    "date": "2015-11-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.2.0",
    "date": "2015-12-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.3.0",
    "date": "2015-12-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.4.0",
    "date": "2016-01-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.5.0",
    "date": "2016-01-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.6.0",
    "date": "2016-02-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.7.0",
    "date": "2016-02-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.8.0",
    "date": "2016-03-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.9.0",
    "date": "2016-03-16",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.10.0",
    "date": "2016-04-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.11.0",
    "date": "2016-04-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.12.0",
    "date": "2016-06-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.0.0",
    "date": "2016-04-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.1.0",
    "date": "2016-05-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.2.0",
    "date": "2016-05-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.3.0",
    "date": "2016-07-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.4.0",
    "date": "2016-08-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.5.0",
    "date": "2016-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.6.0",
    "date": "2016-09-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.7.0",
    "date": "2016-09-27",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.8.0",
    "date": "2016-10-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.9.0",
    "date": "2016-10-18",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.10.0",
    "date": "2017-02-21",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.11.0",
    "date": "2017-06-06",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.12.0",
    "date": "2017-11-06",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.13.0",
    "date": "2018-02-10",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.14.0",
    "date": "2018-03-28",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.15.0",
    "date": "2018-11-27",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.16.0",
    "date": "2018-12-26",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.17.0",
    "date": "2019-02-28",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "7.0.0",
    "date": "2016-10-25",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.1.0",
    "date": "2016-11-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.2.0",
    "date": "2016-11-22",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.3.0",
    "date": "2016-12-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.4.0",
    "date": "2017-01-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.5.0",
    "date": "2017-01-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.6.0",
    "date": "2017-02-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.7.0",
    "date": "2017-02-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.8.0",
    "date": "2017-03-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.9.0",
    "date": "2017-04-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.10.0",
    "date": "2017-05-02",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.0.0",
    "date": "2017-05-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.1.0",
    "date": "2017-06-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.2.0",
    "date": "2017-07-19",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.3.0",
    "date": "2017-08-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.4.0",
    "date": "2017-08-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.5.0",
    "date": "2017-09-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.6.0",
    "date": "2017-09-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.7.0",
    "date": "2017-10-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.8.0",
    "date": "2017-10-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.9.0",
    "date": "2017-10-31",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.10.0",
    "date": "2018-03-06",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.11.0",
    "date": "2018-03-28",
    "lts": "Carbon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "8.12.0",
    "date": "2018-09-10",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.13.0",
    "date": "2018-11-20",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.14.0",
    "date": "2018-11-27",
    "lts": "Carbon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "8.15.0",
    "date": "2018-12-26",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.16.0",
    "date": "2019-04-16",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.0.0",
    "date": "2017-10-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.1.0",
    "date": "2017-11-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.2.0",
    "date": "2017-11-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.3.0",
    "date": "2017-12-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.4.0",
    "date": "2018-01-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.5.0",
    "date": "2018-01-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.6.0",
    "date": "2018-02-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.7.0",
    "date": "2018-03-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.8.0",
    "date": "2018-03-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.9.0",
    "date": "2018-03-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.10.0",
    "date": "2018-03-28",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "9.11.0",
    "date": "2018-04-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.0.0",
    "date": "2018-04-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.1.0",
    "date": "2018-05-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.2.0",
    "date": "2018-05-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.3.0",
    "date": "2018-05-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.4.0",
    "date": "2018-06-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.5.0",
    "date": "2018-06-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.6.0",
    "date": "2018-07-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.7.0",
    "date": "2018-07-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.8.0",
    "date": "2018-08-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.9.0",
    "date": "2018-08-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.10.0",
    "date": "2018-09-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.11.0",
    "date": "2018-09-19",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.12.0",
    "date": "2018-10-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.13.0",
    "date": "2018-10-30",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.14.0",
    "date": "2018-11-27",
    "lts": "Dubnium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "10.15.0",
    "date": "2018-12-26",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.16.0",
    "date": "2019-05-28",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.17.0",
    "date": "2019-10-21",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.0.0",
    "date": "2018-10-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.1.0",
    "date": "2018-10-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.2.0",
    "date": "2018-11-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.3.0",
    "date": "2018-11-27",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "11.4.0",
    "date": "2018-12-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.5.0",
    "date": "2018-12-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.6.0",
    "date": "2018-12-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.7.0",
    "date": "2019-01-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.8.0",
    "date": "2019-01-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.9.0",
    "date": "2019-01-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.10.0",
    "date": "2019-02-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.11.0",
    "date": "2019-03-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.12.0",
    "date": "2019-03-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.13.0",
    "date": "2019-03-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.14.0",
    "date": "2019-04-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.15.0",
    "date": "2019-04-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.0.0",
    "date": "2019-04-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.1.0",
    "date": "2019-04-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.2.0",
    "date": "2019-05-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.3.0",
    "date": "2019-05-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.4.0",
    "date": "2019-06-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.5.0",
    "date": "2019-06-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.6.0",
    "date": "2019-07-03",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.7.0",
    "date": "2019-07-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.8.0",
    "date": "2019-08-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.9.0",
    "date": "2019-08-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.10.0",
    "date": "2019-09-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.11.0",
    "date": "2019-09-25",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.12.0",
    "date": "2019-10-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.13.0",
    "date": "2019-10-21",
    "lts": "Erbium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.0.0",
    "date": "2019-10-10",
    "lts": false,
    "security": false
  }
]
},{}],1050:[function(require,module,exports){
module.exports={
  "v0.10": {
    "start": "2013-03-11",
    "end": "2016-10-31"
  },
  "v0.12": {
    "start": "2015-02-06",
    "end": "2016-12-31"
  },
  "v4": {
    "start": "2015-09-08",
    "lts": "2015-10-12",
    "maintenance": "2017-04-01",
    "end": "2018-04-30",
    "codename": "Argon"
  },
  "v5": {
    "start": "2015-10-29",
    "maintenance": "2016-04-30",
    "end": "2016-06-30"
  },
  "v6": {
    "start": "2016-04-26",
    "lts": "2016-10-18",
    "maintenance": "2018-04-30",
    "end": "2019-04-30",
    "codename": "Boron"
  },
  "v7": {
    "start": "2016-10-25",
    "maintenance": "2017-04-30",
    "end": "2017-06-30"
  },
  "v8": {
    "start": "2017-05-30",
    "lts": "2017-10-31",
    "maintenance": "2019-01-01",
    "end": "2019-12-31",
    "codename": "Carbon"
  },
  "v9": {
    "start": "2017-10-01",
    "maintenance": "2018-04-01",
    "end": "2018-06-30"
  },
  "v10": {
    "start": "2018-04-24",
    "lts": "2018-10-30",
    "maintenance": "2020-04-01",
    "end": "2021-04-30",
    "codename": "Dubnium"
  },
  "v11": {
    "start": "2018-10-23",
    "maintenance": "2019-04-22",
    "end": "2019-06-01"
  },
  "v12": {
    "start": "2019-04-23",
    "lts": "2019-10-21",
    "maintenance": "2020-10-21",
    "end": "2022-04-30",
    "codename": "Erbium"
  },
  "v13": {
    "start": "2019-10-22",
    "maintenance": "2020-04-01",
    "end": "2020-06-01"
  },
  "v14": {
    "start": "2020-04-21",
    "lts": "2020-10-20",
    "maintenance": "2021-10-20",
    "end": "2023-04-30",
    "codename": ""
  }
}

},{}],1051:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

},{}],1052:[function(require,module,exports){
(function (process){
"use strict";

// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47
  /*/*/
  ;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';

  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }

  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';
  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
} // Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here


exports.basename = function (path, ext) {
  var f = basename(path);

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find

  var preDotState = 0;

  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }

    if (code === 46
    /*.*/
    ) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }

  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};

}).call(this,require('_process'))
},{"_process":1054}],1053:[function(require,module,exports){
"use strict";

var originalObject = Object;
var originalDefProp = Object.defineProperty;
var originalCreate = Object.create;

function defProp(obj, name, value) {
  if (originalDefProp) try {
    originalDefProp.call(originalObject, obj, name, {
      value: value
    });
  } catch (definePropertyIsBrokenInIE8) {
    obj[name] = value;
  } else {
    obj[name] = value;
  }
} // For functions that will be invoked using .call or .apply, we need to
// define those methods on the function objects themselves, rather than
// inheriting them from Function.prototype, so that a malicious or clumsy
// third party cannot interfere with the functionality of this module by
// redefining Function.prototype.call or .apply.


function makeSafeToCall(fun) {
  if (fun) {
    defProp(fun, "call", fun.call);
    defProp(fun, "apply", fun.apply);
  }

  return fun;
}

makeSafeToCall(originalDefProp);
makeSafeToCall(originalCreate);
var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
var numToStr = makeSafeToCall(Number.prototype.toString);
var strSlice = makeSafeToCall(String.prototype.slice);

var cloner = function cloner() {};

function create(prototype) {
  if (originalCreate) {
    return originalCreate.call(originalObject, prototype);
  }

  cloner.prototype = prototype || null;
  return new cloner();
}

var rand = Math.random;
var uniqueKeys = create(null);

function makeUniqueKey() {
  // Collisions are highly unlikely, but this module is in the business of
  // making guarantees rather than safe bets.
  do {
    var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
  } while (hasOwn.call(uniqueKeys, uniqueKey));

  return uniqueKeys[uniqueKey] = uniqueKey;
}

function internString(str) {
  var obj = {};
  obj[str] = true;
  return Object.keys(obj)[0];
} // External users might find this function useful, but it is not necessary
// for the typical use of this module.


exports.makeUniqueKey = makeUniqueKey; // Object.getOwnPropertyNames is the only way to enumerate non-enumerable
// properties, so if we wrap it to ignore our secret keys, there should be
// no way (except guessing) to access those properties.

var originalGetOPNs = Object.getOwnPropertyNames;

Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
  for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
    if (!hasOwn.call(uniqueKeys, names[src])) {
      if (src > dst) {
        names[dst] = names[src];
      }

      ++dst;
    }
  }

  names.length = dst;
  return names;
};

function defaultCreatorFn(object) {
  return create(null);
}

function makeAccessor(secretCreatorFn) {
  var brand = makeUniqueKey();
  var passkey = create(null);
  secretCreatorFn = secretCreatorFn || defaultCreatorFn;

  function register(object) {
    var secret; // Created lazily.

    function vault(key, forget) {
      // Only code that has access to the passkey can retrieve (or forget)
      // the secret object.
      if (key === passkey) {
        return forget ? secret = null : secret || (secret = secretCreatorFn(object));
      }
    }

    defProp(object, brand, vault);
  }

  function accessor(object) {
    if (!hasOwn.call(object, brand)) register(object);
    return object[brand](passkey);
  }

  accessor.forget = function (object) {
    if (hasOwn.call(object, brand)) object[brand](passkey, true);
  };

  return accessor;
}

exports.makeAccessor = makeAccessor;

},{}],1054:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

},{}],1055:[function(require,module,exports){
(function (global){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! https://mths.be/regenerate v1.3.3 by @mathias | MIT license */
;

(function (root) {
  // Detect free variables `exports`.
  var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports; // Detect free variable `module`.

  var freeModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js/io.js or Browserified code,
  // and use it as `root`.

  var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }
  /*--------------------------------------------------------------------------*/


  var ERRORS = {
    'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
    'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
  }; // https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs

  var HIGH_SURROGATE_MIN = 0xD800;
  var HIGH_SURROGATE_MAX = 0xDBFF;
  var LOW_SURROGATE_MIN = 0xDC00;
  var LOW_SURROGATE_MAX = 0xDFFF; // In Regenerate output, `\0` is never preceded by `\` because we sort by
  // code point value, so lets keep this regular expression simple.

  var regexNull = /\\x00([^0123456789]|$)/g;
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;

  var extend = function extend(destination, source) {
    var key;

    for (key in source) {
      if (hasOwnProperty.call(source, key)) {
        destination[key] = source[key];
      }
    }

    return destination;
  };

  var forEach = function forEach(array, callback) {
    var index = -1;
    var length = array.length;

    while (++index < length) {
      callback(array[index], index);
    }
  };

  var toString = object.toString;

  var isArray = function isArray(value) {
    return toString.call(value) == '[object Array]';
  };

  var isNumber = function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == '[object Number]';
  }; // This assumes that `number` is a positive integer that `toString()`s nicely
  // (which is the case for all code point values).


  var zeroes = '0000';

  var pad = function pad(number, totalCharacters) {
    var string = String(number);
    return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
  };

  var hex = function hex(number) {
    return Number(number).toString(16).toUpperCase();
  };

  var slice = [].slice;
  /*--------------------------------------------------------------------------*/

  var dataFromCodePoints = function dataFromCodePoints(codePoints) {
    var index = -1;
    var length = codePoints.length;
    var max = length - 1;
    var result = [];
    var isStart = true;
    var tmp;
    var previous = 0;

    while (++index < length) {
      tmp = codePoints[index];

      if (isStart) {
        result.push(tmp);
        previous = tmp;
        isStart = false;
      } else {
        if (tmp == previous + 1) {
          if (index != max) {
            previous = tmp;
            continue;
          } else {
            isStart = true;
            result.push(tmp + 1);
          }
        } else {
          // End the previous range and start a new one.
          result.push(previous + 1, tmp);
          previous = tmp;
        }
      }
    }

    if (!isStart) {
      result.push(tmp + 1);
    }

    return result;
  };

  var dataRemove = function dataRemove(data, codePoint) {
    // Iterate over the data per `(start, end)` pair.
    var index = 0;
    var start;
    var end;
    var length = data.length;

    while (index < length) {
      start = data[index];
      end = data[index + 1];

      if (codePoint >= start && codePoint < end) {
        // Modify this pair.
        if (codePoint == start) {
          if (end == start + 1) {
            // Just remove `start` and `end`.
            data.splice(index, 2);
            return data;
          } else {
            // Just replace `start` with a new value.
            data[index] = codePoint + 1;
            return data;
          }
        } else if (codePoint == end - 1) {
          // Just replace `end` with a new value.
          data[index + 1] = codePoint;
          return data;
        } else {
          // Replace `[start, end]` with `[startA, endA, startB, endB]`.
          data.splice(index, 2, start, codePoint, codePoint + 1, end);
          return data;
        }
      }

      index += 2;
    }

    return data;
  };

  var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
    if (rangeEnd < rangeStart) {
      throw Error(ERRORS.rangeOrder);
    } // Iterate over the data per `(start, end)` pair.


    var index = 0;
    var start;
    var end;

    while (index < data.length) {
      start = data[index];
      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
      // Exit as soon as no more matching pairs can be found.

      if (start > rangeEnd) {
        return data;
      } // Check if this range pair is equal to, or forms a subset of, the range
      // to be removed.
      // E.g. we have `[0, 11, 40, 51]` and want to remove 0-10  `[40, 51]`.
      // E.g. we have `[40, 51]` and want to remove 0-100  `[]`.


      if (rangeStart <= start && rangeEnd >= end) {
        // Remove this pair.
        data.splice(index, 2);
        continue;
      } // Check if both `rangeStart` and `rangeEnd` are within the bounds of
      // this pair.
      // E.g. we have `[0, 11]` and want to remove 4-6  `[0, 4, 7, 11]`.


      if (rangeStart >= start && rangeEnd < end) {
        if (rangeStart == start) {
          // Replace `[start, end]` with `[startB, endB]`.
          data[index] = rangeEnd + 1;
          data[index + 1] = end + 1;
          return data;
        } // Replace `[start, end]` with `[startA, endA, startB, endB]`.


        data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
        return data;
      } // Check if only `rangeStart` is within the bounds of this pair.
      // E.g. we have `[0, 11]` and want to remove 4-20  `[0, 4]`.


      if (rangeStart >= start && rangeStart <= end) {
        // Replace `end` with `rangeStart`.
        data[index + 1] = rangeStart; // Note: we cannot `return` just yet, in case any following pairs still
        // contain matching code points.
        // E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
        //  `[0, 4, 21, 31]`.
      } // Check if only `rangeEnd` is within the bounds of this pair.
      // E.g. we have `[14, 31]` and want to remove 4-20  `[21, 31]`.
      else if (rangeEnd >= start && rangeEnd <= end) {
          // Just replace `start`.
          data[index] = rangeEnd + 1;
          return data;
        }

      index += 2;
    }

    return data;
  };

  var dataAdd = function dataAdd(data, codePoint) {
    // Iterate over the data per `(start, end)` pair.
    var index = 0;
    var start;
    var end;
    var lastIndex = null;
    var length = data.length;

    if (codePoint < 0x0 || codePoint > 0x10FFFF) {
      throw RangeError(ERRORS.codePointRange);
    }

    while (index < length) {
      start = data[index];
      end = data[index + 1]; // Check if the code point is already in the set.

      if (codePoint >= start && codePoint < end) {
        return data;
      }

      if (codePoint == start - 1) {
        // Just replace `start` with a new value.
        data[index] = codePoint;
        return data;
      } // At this point, if `start` is `greater` than `codePoint`, insert a new
      // `[start, end]` pair before the current pair, or after the current pair
      // if there is a known `lastIndex`.


      if (start > codePoint) {
        data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
        return data;
      }

      if (codePoint == end) {
        // Check if adding this code point causes two separate ranges to become
        // a single range, e.g. `dataAdd([0, 4, 5, 10], 4)`  `[0, 10]`.
        if (codePoint + 1 == data[index + 2]) {
          data.splice(index, 4, start, data[index + 3]);
          return data;
        } // Else, just replace `end` with a new value.


        data[index + 1] = codePoint + 1;
        return data;
      }

      lastIndex = index;
      index += 2;
    } // The loop has finished; add the new pair to the end of the data set.


    data.push(codePoint, codePoint + 1);
    return data;
  };

  var dataAddData = function dataAddData(dataA, dataB) {
    // Iterate over the data per `(start, end)` pair.
    var index = 0;
    var start;
    var end;
    var data = dataA.slice();
    var length = dataB.length;

    while (index < length) {
      start = dataB[index];
      end = dataB[index + 1] - 1;

      if (start == end) {
        data = dataAdd(data, start);
      } else {
        data = dataAddRange(data, start, end);
      }

      index += 2;
    }

    return data;
  };

  var dataRemoveData = function dataRemoveData(dataA, dataB) {
    // Iterate over the data per `(start, end)` pair.
    var index = 0;
    var start;
    var end;
    var data = dataA.slice();
    var length = dataB.length;

    while (index < length) {
      start = dataB[index];
      end = dataB[index + 1] - 1;

      if (start == end) {
        data = dataRemove(data, start);
      } else {
        data = dataRemoveRange(data, start, end);
      }

      index += 2;
    }

    return data;
  };

  var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
    if (rangeEnd < rangeStart) {
      throw Error(ERRORS.rangeOrder);
    }

    if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
      throw RangeError(ERRORS.codePointRange);
    } // Iterate over the data per `(start, end)` pair.


    var index = 0;
    var start;
    var end;
    var added = false;
    var length = data.length;

    while (index < length) {
      start = data[index];
      end = data[index + 1];

      if (added) {
        // The range has already been added to the set; at this point, we just
        // need to get rid of the following ranges in case they overlap.
        // Check if this range can be combined with the previous range.
        if (start == rangeEnd + 1) {
          data.splice(index - 1, 2);
          return data;
        } // Exit as soon as no more possibly overlapping pairs can be found.


        if (start > rangeEnd) {
          return data;
        } // E.g. `[0, 11, 12, 16]` and weve added 5-15, so we now have
        // `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
        // `0,16` range that was previously added.


        if (start >= rangeStart && start <= rangeEnd) {
          // `start` lies within the range that was previously added.
          if (end > rangeStart && end - 1 <= rangeEnd) {
            // `end` lies within the range that was previously added as well,
            // so remove this pair.
            data.splice(index, 2);
            index -= 2; // Note: we cannot `return` just yet, as there may still be other
            // overlapping pairs.
          } else {
            // `start` lies within the range that was previously added, but
            // `end` doesnt. E.g. `[0, 11, 12, 31]` and weve added 5-15, so
            // now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
            // Remove the previously added `end` and the current `start`.
            data.splice(index - 1, 2);
            index -= 2;
          } // Note: we cannot return yet.

        }
      } else if (start == rangeEnd + 1) {
        data[index] = rangeStart;
        return data;
      } // Check if a new pair must be inserted *before* the current one.
      else if (start > rangeEnd) {
          data.splice(index, 0, rangeStart, rangeEnd + 1);
          return data;
        } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
          // The new range lies entirely within an existing range pair. No action
          // needed.
          return data;
        } else if ( // E.g. `[0, 11]` and you add 5-15  `[0, 16]`.
        rangeStart >= start && rangeStart < end || // E.g. `[0, 3]` and you add 3-6  `[0, 7]`.
        end == rangeStart) {
          // Replace `end` with the new value.
          data[index + 1] = rangeEnd + 1; // Make sure the next range pair doesnt overlap, e.g. `[0, 11, 12, 14]`
          // and you add 5-15  `[0, 16]`, i.e. remove the `12,14` part.

          added = true; // Note: we cannot `return` just yet.
        } else if (rangeStart <= start && rangeEnd + 1 >= end) {
          // The new range is a superset of the old range.
          data[index] = rangeStart;
          data[index + 1] = rangeEnd + 1;
          added = true;
        }

      index += 2;
    } // The loop has finished without doing anything; add the new pair to the end
    // of the data set.


    if (!added) {
      data.push(rangeStart, rangeEnd + 1);
    }

    return data;
  };

  var dataContains = function dataContains(data, codePoint) {
    var index = 0;
    var length = data.length; // Exit early if `codePoint` is not within `data`s overall range.

    var start = data[index];
    var end = data[length - 1];

    if (length >= 2) {
      if (codePoint < start || codePoint > end) {
        return false;
      }
    } // Iterate over the data per `(start, end)` pair.


    while (index < length) {
      start = data[index];
      end = data[index + 1];

      if (codePoint >= start && codePoint < end) {
        return true;
      }

      index += 2;
    }

    return false;
  };

  var dataIntersection = function dataIntersection(data, codePoints) {
    var index = 0;
    var length = codePoints.length;
    var codePoint;
    var result = [];

    while (index < length) {
      codePoint = codePoints[index];

      if (dataContains(data, codePoint)) {
        result.push(codePoint);
      }

      ++index;
    }

    return dataFromCodePoints(result);
  };

  var dataIsEmpty = function dataIsEmpty(data) {
    return !data.length;
  };

  var dataIsSingleton = function dataIsSingleton(data) {
    // Check if the set only represents a single code point.
    return data.length == 2 && data[0] + 1 == data[1];
  };

  var dataToArray = function dataToArray(data) {
    // Iterate over the data per `(start, end)` pair.
    var index = 0;
    var start;
    var end;
    var result = [];
    var length = data.length;

    while (index < length) {
      start = data[index];
      end = data[index + 1];

      while (start < end) {
        result.push(start);
        ++start;
      }

      index += 2;
    }

    return result;
  };
  /*--------------------------------------------------------------------------*/
  // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae


  var floor = Math.floor;

  var highSurrogate = function highSurrogate(codePoint) {
    return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
  };

  var lowSurrogate = function lowSurrogate(codePoint) {
    return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
  };

  var stringFromCharCode = String.fromCharCode;

  var codePointToString = function codePointToString(codePoint) {
    var string; // https://mathiasbynens.be/notes/javascript-escapes#single
    // Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
    // different meaning in regular expressions (word boundary), so it cannot
    // be used here.

    if (codePoint == 0x09) {
      string = '\\t';
    } // Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
    // else if (codePoint == 0x0B) {
    // 	string = '\\v';
    // }
    else if (codePoint == 0x0A) {
        string = '\\n';
      } else if (codePoint == 0x0C) {
        string = '\\f';
      } else if (codePoint == 0x0D) {
        string = '\\r';
      } else if (codePoint == 0x2D) {
        // https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
        // Note: `-` (U+002D HYPHEN-MINUS) is escaped in this way rather
        // than by backslash-escaping, in case the output is used outside
        // of a character class in a `u` RegExp. /\-/u throws, but
        // /\x2D/u is fine.
        string = '\\x2D';
      } else if (codePoint == 0x5C) {
        string = '\\\\';
      } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
        // The code point maps to an unsafe printable ASCII character;
        // backslash-escape it. Heres the list of those symbols:
        //
        //     $()*+./?[\]^{|}
        //
        // This matches SyntaxCharacters as well as `/` (U+002F SOLIDUS).
        // https://tc39.github.io/ecma262/#prod-SyntaxCharacter
        string = '\\' + stringFromCharCode(codePoint);
      } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
        // The code point maps to one of these printable ASCII symbols
        // (including the space character):
        //
        //      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
        //     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
        //
        // These can safely be used directly.
        string = stringFromCharCode(codePoint);
      } else if (codePoint <= 0xFF) {
        string = '\\x' + pad(hex(codePoint), 2);
      } else {
        // `codePoint <= 0xFFFF` holds true.
        // https://mathiasbynens.be/notes/javascript-escapes#unicode
        string = "\\u" + pad(hex(codePoint), 4);
      } // Theres no need to account for astral symbols / surrogate pairs here,
    // since `codePointToString` is private and only used for BMP code points.
    // But if thats what you need, just add an `else` block with this code:
    //
    //     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
    //     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);


    return string;
  };

  var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
    if (codePoint <= 0xFFFF) {
      return codePointToString(codePoint);
    }

    return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
  };

  var symbolToCodePoint = function symbolToCodePoint(symbol) {
    var length = symbol.length;
    var first = symbol.charCodeAt(0);
    var second;

    if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1 // There is a next code unit.
    ) {
        // `first` is a high surrogate, and there is a next character. Assume
        // its a low surrogate (else its invalid usage of Regenerate anyway).
        second = symbol.charCodeAt(1); // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae

        return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
      }

    return first;
  };

  var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
    // Iterate over the data per `(start, end)` pair.
    var result = '';
    var index = 0;
    var start;
    var end;
    var length = data.length;

    if (dataIsSingleton(data)) {
      return codePointToString(data[0]);
    }

    while (index < length) {
      start = data[index];
      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

      if (start == end) {
        result += codePointToString(start);
      } else if (start + 1 == end) {
        result += codePointToString(start) + codePointToString(end);
      } else {
        result += codePointToString(start) + '-' + codePointToString(end);
      }

      index += 2;
    }

    return '[' + result + ']';
  };

  var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
    // Iterate over the data per `(start, end)` pair.
    var result = '';
    var index = 0;
    var start;
    var end;
    var length = data.length;

    if (dataIsSingleton(data)) {
      return codePointToStringUnicode(data[0]);
    }

    while (index < length) {
      start = data[index];
      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

      if (start == end) {
        result += codePointToStringUnicode(start);
      } else if (start + 1 == end) {
        result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
      } else {
        result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
      }

      index += 2;
    }

    return '[' + result + ']';
  };

  var splitAtBMP = function splitAtBMP(data) {
    // Iterate over the data per `(start, end)` pair.
    var loneHighSurrogates = [];
    var loneLowSurrogates = [];
    var bmp = [];
    var astral = [];
    var index = 0;
    var start;
    var end;
    var length = data.length;

    while (index < length) {
      start = data[index];
      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

      if (start < HIGH_SURROGATE_MIN) {
        // The range starts and ends before the high surrogate range.
        // E.g. (0, 0x10).
        if (end < HIGH_SURROGATE_MIN) {
          bmp.push(start, end + 1);
        } // The range starts before the high surrogate range and ends within it.
        // E.g. (0, 0xD855).


        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
          bmp.push(start, HIGH_SURROGATE_MIN);
          loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
        } // The range starts before the high surrogate range and ends in the low
        // surrogate range. E.g. (0, 0xDCFF).


        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
          bmp.push(start, HIGH_SURROGATE_MIN);
          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
        } // The range starts before the high surrogate range and ends after the
        // low surrogate range. E.g. (0, 0x10FFFF).


        if (end > LOW_SURROGATE_MAX) {
          bmp.push(start, HIGH_SURROGATE_MIN);
          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

          if (end <= 0xFFFF) {
            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
          } else {
            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
            astral.push(0xFFFF + 1, end + 1);
          }
        }
      } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
        // The range starts and ends in the high surrogate range.
        // E.g. (0xD855, 0xD866).
        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
          loneHighSurrogates.push(start, end + 1);
        } // The range starts in the high surrogate range and ends in the low
        // surrogate range. E.g. (0xD855, 0xDCFF).


        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
        } // The range starts in the high surrogate range and ends after the low
        // surrogate range. E.g. (0xD855, 0x10FFFF).


        if (end > LOW_SURROGATE_MAX) {
          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

          if (end <= 0xFFFF) {
            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
          } else {
            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
            astral.push(0xFFFF + 1, end + 1);
          }
        }
      } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
        // The range starts and ends in the low surrogate range.
        // E.g. (0xDCFF, 0xDDFF).
        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
          loneLowSurrogates.push(start, end + 1);
        } // The range starts in the low surrogate range and ends after the low
        // surrogate range. E.g. (0xDCFF, 0x10FFFF).


        if (end > LOW_SURROGATE_MAX) {
          loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

          if (end <= 0xFFFF) {
            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
          } else {
            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
            astral.push(0xFFFF + 1, end + 1);
          }
        }
      } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
        // The range starts and ends after the low surrogate range.
        // E.g. (0xFFAA, 0x10FFFF).
        if (end <= 0xFFFF) {
          bmp.push(start, end + 1);
        } else {
          bmp.push(start, 0xFFFF + 1);
          astral.push(0xFFFF + 1, end + 1);
        }
      } else {
        // The range starts and ends in the astral range.
        astral.push(start, end + 1);
      }

      index += 2;
    }

    return {
      'loneHighSurrogates': loneHighSurrogates,
      'loneLowSurrogates': loneLowSurrogates,
      'bmp': bmp,
      'astral': astral
    };
  };

  var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
    var result = [];
    var tmpLow = [];
    var addLow = false;
    var mapping;
    var nextMapping;
    var highSurrogates;
    var lowSurrogates;
    var nextHighSurrogates;
    var nextLowSurrogates;
    var index = -1;
    var length = surrogateMappings.length;

    while (++index < length) {
      mapping = surrogateMappings[index];
      nextMapping = surrogateMappings[index + 1];

      if (!nextMapping) {
        result.push(mapping);
        continue;
      }

      highSurrogates = mapping[0];
      lowSurrogates = mapping[1];
      nextHighSurrogates = nextMapping[0];
      nextLowSurrogates = nextMapping[1]; // Check for identical high surrogate ranges.

      tmpLow = lowSurrogates;

      while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
        // Merge with the next item.
        if (dataIsSingleton(nextLowSurrogates)) {
          tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
        } else {
          tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
        }

        ++index;
        mapping = surrogateMappings[index];
        highSurrogates = mapping[0];
        lowSurrogates = mapping[1];
        nextMapping = surrogateMappings[index + 1];
        nextHighSurrogates = nextMapping && nextMapping[0];
        nextLowSurrogates = nextMapping && nextMapping[1];
        addLow = true;
      }

      result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
      addLow = false;
    }

    return optimizeByLowSurrogates(result);
  };

  var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
    if (surrogateMappings.length == 1) {
      return surrogateMappings;
    }

    var index = -1;
    var innerIndex = -1;

    while (++index < surrogateMappings.length) {
      var mapping = surrogateMappings[index];
      var lowSurrogates = mapping[1];
      var lowSurrogateStart = lowSurrogates[0];
      var lowSurrogateEnd = lowSurrogates[1];
      innerIndex = index; // Note: the loop starts at the next index.

      while (++innerIndex < surrogateMappings.length) {
        var otherMapping = surrogateMappings[innerIndex];
        var otherLowSurrogates = otherMapping[1];
        var otherLowSurrogateStart = otherLowSurrogates[0];
        var otherLowSurrogateEnd = otherLowSurrogates[1];

        if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
          // Add the code points in the other item to this one.
          if (dataIsSingleton(otherMapping[0])) {
            mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
          } else {
            mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
          } // Remove the other, now redundant, item.


          surrogateMappings.splice(innerIndex, 1);
          --innerIndex;
        }
      }
    }

    return surrogateMappings;
  };

  var surrogateSet = function surrogateSet(data) {
    // Exit early if `data` is an empty set.
    if (!data.length) {
      return [];
    } // Iterate over the data per `(start, end)` pair.


    var index = 0;
    var start;
    var end;
    var startHigh;
    var startLow;
    var endHigh;
    var endLow;
    var surrogateMappings = [];
    var length = data.length;

    while (index < length) {
      start = data[index];
      end = data[index + 1] - 1;
      startHigh = highSurrogate(start);
      startLow = lowSurrogate(start);
      endHigh = highSurrogate(end);
      endLow = lowSurrogate(end);
      var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
      var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
      var complete = false; // Append the previous high-surrogate-to-low-surrogate mappings.
      // Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.

      if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
        surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
        complete = true;
      } else {
        surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
      } // Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
      // `(endHigh - 1, LOW_SURROGATE_MAX)`.


      if (!complete && startHigh + 1 < endHigh) {
        if (endsWithHighestLowSurrogate) {
          // Combine step 2 and step 3.
          surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
          complete = true;
        } else {
          surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
        }
      } // Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.


      if (!complete) {
        surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
      }

      index += 2;
    } // The format of `surrogateMappings` is as follows:
    //
    //     [ surrogateMapping1, surrogateMapping2 ]
    //
    // i.e.:
    //
    //     [
    //       [ highSurrogates1, lowSurrogates1 ],
    //       [ highSurrogates2, lowSurrogates2 ]
    //     ]


    return optimizeSurrogateMappings(surrogateMappings);
  };

  var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
    var result = [];
    forEach(surrogateMappings, function (surrogateMapping) {
      var highSurrogates = surrogateMapping[0];
      var lowSurrogates = surrogateMapping[1];
      result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
    });
    return result.join('|');
  };

  var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
    if (hasUnicodeFlag) {
      return createUnicodeCharacterClasses(data);
    }

    var result = [];
    var parts = splitAtBMP(data);
    var loneHighSurrogates = parts.loneHighSurrogates;
    var loneLowSurrogates = parts.loneLowSurrogates;
    var bmp = parts.bmp;
    var astral = parts.astral;
    var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
    var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
    var surrogateMappings = surrogateSet(astral);

    if (bmpOnly) {
      bmp = dataAddData(bmp, loneHighSurrogates);
      hasLoneHighSurrogates = false;
      bmp = dataAddData(bmp, loneLowSurrogates);
      hasLoneLowSurrogates = false;
    }

    if (!dataIsEmpty(bmp)) {
      // The data set contains BMP code points that are not high surrogates
      // needed for astral code points in the set.
      result.push(createBMPCharacterClasses(bmp));
    }

    if (surrogateMappings.length) {
      // The data set contains astral code points; append character classes
      // based on their surrogate pairs.
      result.push(createSurrogateCharacterClasses(surrogateMappings));
    } // https://gist.github.com/mathiasbynens/bbe7f870208abcfec860


    if (hasLoneHighSurrogates) {
      result.push(createBMPCharacterClasses(loneHighSurrogates) + // Make sure the high surrogates arent part of a surrogate pair.
      "(?![\\uDC00-\\uDFFF])");
    }

    if (hasLoneLowSurrogates) {
      result.push( // It is not possible to accurately assert the low surrogates arent
      // part of a surrogate pair, since JavaScript regular expressions do
      // not support lookbehind.
      "(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
    }

    return result.join('|');
  };
  /*--------------------------------------------------------------------------*/
  // `regenerate` can be used as a constructor (and new methods can be added to
  // its prototype) but also as a regular function, the latter of which is the
  // documented and most common usage. For that reason, its not capitalized.


  var regenerate = function regenerate(value) {
    if (arguments.length > 1) {
      value = slice.call(arguments);
    }

    if (this instanceof regenerate) {
      this.data = [];
      return value ? this.add(value) : this;
    }

    return new regenerate().add(value);
  };

  regenerate.version = '1.3.3';
  var proto = regenerate.prototype;
  extend(proto, {
    'add': function add(value) {
      var $this = this;

      if (value == null) {
        return $this;
      }

      if (value instanceof regenerate) {
        // Allow passing other Regenerate instances.
        $this.data = dataAddData($this.data, value.data);
        return $this;
      }

      if (arguments.length > 1) {
        value = slice.call(arguments);
      }

      if (isArray(value)) {
        forEach(value, function (item) {
          $this.add(item);
        });
        return $this;
      }

      $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
      return $this;
    },
    'remove': function remove(value) {
      var $this = this;

      if (value == null) {
        return $this;
      }

      if (value instanceof regenerate) {
        // Allow passing other Regenerate instances.
        $this.data = dataRemoveData($this.data, value.data);
        return $this;
      }

      if (arguments.length > 1) {
        value = slice.call(arguments);
      }

      if (isArray(value)) {
        forEach(value, function (item) {
          $this.remove(item);
        });
        return $this;
      }

      $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
      return $this;
    },
    'addRange': function addRange(start, end) {
      var $this = this;
      $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
      return $this;
    },
    'removeRange': function removeRange(start, end) {
      var $this = this;
      var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
      var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
      $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
      return $this;
    },
    'intersection': function intersection(argument) {
      var $this = this; // Allow passing other Regenerate instances.
      // TODO: Optimize this by writing and using `dataIntersectionData()`.

      var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
      $this.data = dataIntersection($this.data, array);
      return $this;
    },
    'contains': function contains(codePoint) {
      return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
    },
    'clone': function clone() {
      var set = new regenerate();
      set.data = this.data.slice(0);
      return set;
    },
    'toString': function toString(options) {
      var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

      if (!result) {
        // For an empty set, return something that can be inserted `/here/` to
        // form a valid regular expression. Avoid `(?:)` since that matches the
        // empty string.
        return '[]';
      } // Use `\0` instead of `\x00` where possible.


      return result.replace(regexNull, '\\0$1');
    },
    'toRegExp': function toRegExp(flags) {
      var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
        'hasUnicodeFlag': true
      } : null);
      return RegExp(pattern, flags || '');
    },
    'valueOf': function valueOf() {
      // Note: `valueOf` is aliased as `toArray`.
      return dataToArray(this.data);
    }
  });
  proto.toArray = proto.valueOf; // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
    define(function () {
      return regenerate;
    });
  } else if (freeExports && !freeExports.nodeType) {
    if (freeModule) {
      // in Node.js, io.js, or RingoJS v0.8.0+
      freeModule.exports = regenerate;
    } else {
      // in Narwhal or RingoJS v0.7.0-
      freeExports.regenerate = regenerate;
    }
  } else {
    // in Rhino or a web browser
    root.regenerate = regenerate;
  }
})(void 0);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1056:[function(require,module,exports){
"use strict";

var _assert = _interopRequireDefault(require("assert"));

var leap = _interopRequireWildcard(require("./leap"));

var meta = _interopRequireWildcard(require("./meta"));

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var hasOwn = Object.prototype.hasOwnProperty;

function Emitter(contextId) {
  _assert["default"].ok(this instanceof Emitter);

  util.getTypes().assertIdentifier(contextId); // Used to generate unique temporary names.

  this.nextTempId = 0; // In order to make sure the context object does not collide with
  // anything in the local scope, we might have to rename it, so we
  // refer to it symbolically instead of just assuming that it will be
  // called "context".

  this.contextId = contextId; // An append-only list of Statements that grows each time this.emit is
  // called.

  this.listing = []; // A sparse array whose keys correspond to locations in this.listing
  // that have been marked as branch/jump targets.

  this.marked = [true];
  this.insertedLocs = new Set(); // The last location will be marked when this.getDispatchLoop is
  // called.

  this.finalLoc = this.loc(); // A list of all leap.TryEntry statements emitted.

  this.tryEntries = []; // Each time we evaluate the body of a loop, we tell this.leapManager
  // to enter a nested loop context that determines the meaning of break
  // and continue statements therein.

  this.leapManager = new leap.LeapManager(this);
}

var Ep = Emitter.prototype;
exports.Emitter = Emitter; // Offsets into this.listing that could be used as targets for branches or
// jumps are represented as numeric Literal nodes. This representation has
// the amazingly convenient benefit of allowing the exact value of the
// location to be determined at any time, even after generating code that
// refers to the location.

Ep.loc = function () {
  var l = util.getTypes().numericLiteral(-1);
  this.insertedLocs.add(l);
  return l;
};

Ep.getInsertedLocs = function () {
  return this.insertedLocs;
};

Ep.getContextId = function () {
  return util.getTypes().clone(this.contextId);
}; // Sets the exact value of the given location to the offset of the next
// Statement emitted.


Ep.mark = function (loc) {
  util.getTypes().assertLiteral(loc);
  var index = this.listing.length;

  if (loc.value === -1) {
    loc.value = index;
  } else {
    // Locations can be marked redundantly, but their values cannot change
    // once set the first time.
    _assert["default"].strictEqual(loc.value, index);
  }

  this.marked[index] = true;
  return loc;
};

Ep.emit = function (node) {
  var t = util.getTypes();

  if (t.isExpression(node)) {
    node = t.expressionStatement(node);
  }

  t.assertStatement(node);
  this.listing.push(node);
}; // Shorthand for emitting assignment statements. This will come in handy
// for assignments to temporary variables.


Ep.emitAssign = function (lhs, rhs) {
  this.emit(this.assign(lhs, rhs));
  return lhs;
}; // Shorthand for an assignment statement.


Ep.assign = function (lhs, rhs) {
  var t = util.getTypes();
  return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
}; // Convenience function for generating expressions like context.next,
// context.sent, and context.rval.


Ep.contextProperty = function (name, computed) {
  var t = util.getTypes();
  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
}; // Shorthand for setting context.rval and jumping to `context.stop()`.


Ep.stop = function (rval) {
  if (rval) {
    this.setReturnValue(rval);
  }

  this.jump(this.finalLoc);
};

Ep.setReturnValue = function (valuePath) {
  util.getTypes().assertExpression(valuePath.value);
  this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
};

Ep.clearPendingException = function (tryLoc, assignee) {
  var t = util.getTypes();
  t.assertLiteral(tryLoc);
  var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);

  if (assignee) {
    this.emitAssign(assignee, catchCall);
  } else {
    this.emit(catchCall);
  }
}; // Emits code for an unconditional jump to the given location, even if the
// exact value of the location is not yet known.


Ep.jump = function (toLoc) {
  this.emitAssign(this.contextProperty("next"), toLoc);
  this.emit(util.getTypes().breakStatement());
}; // Conditional jump.


Ep.jumpIf = function (test, toLoc) {
  var t = util.getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
}; // Conditional jump, with the condition negated.


Ep.jumpIfNot = function (test, toLoc) {
  var t = util.getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  var negatedTest;

  if (t.isUnaryExpression(test) && test.operator === "!") {
    // Avoid double negation.
    negatedTest = test.argument;
  } else {
    negatedTest = t.unaryExpression("!", test);
  }

  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
}; // Returns a unique MemberExpression that can be used to store and
// retrieve temporary values. Since the object of the member expression is
// the context object, which is presumed to coexist peacefully with all
// other local variables, and since we just increment `nextTempId`
// monotonically, uniqueness is assured.


Ep.makeTempVar = function () {
  return this.contextProperty("t" + this.nextTempId++);
};

Ep.getContextFunction = function (id) {
  var t = util.getTypes();
  return t.functionExpression(id || null
  /*Anonymous*/
  , [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!
  false // Nor an expression.
  );
}; // Turns this.listing into a loop of the form
//
//   while (1) switch (context.next) {
//   case 0:
//   ...
//   case n:
//     return context.stop();
//   }
//
// Each marked location in this.listing will correspond to one generated
// case statement.


Ep.getDispatchLoop = function () {
  var self = this;
  var t = util.getTypes();
  var cases = [];
  var current; // If we encounter a break, continue, or return statement in a switch
  // case, we can skip the rest of the statements until the next case.

  var alreadyEnded = false;
  self.listing.forEach(function (stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(t.switchCase(t.numericLiteral(i), current = []));
      alreadyEnded = false;
    }

    if (!alreadyEnded) {
      current.push(stmt);
      if (t.isCompletionStatement(stmt)) alreadyEnded = true;
    }
  }); // Now that we know how many statements there will be in this.listing,
  // we can finally resolve this.finalLoc.value.

  this.finalLoc.value = this.listing.length;
  cases.push(t.switchCase(this.finalLoc, [// Intentionally fall through to the "end" case...
  ]), // So that the runtime can jump to the final location without having
  // to know its offset, we provide the "end" case as a synonym.
  t.switchCase(t.stringLiteral("end"), [// This will check/clear both context.thrown and context.rval.
  t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
};

Ep.getTryLocsList = function () {
  if (this.tryEntries.length === 0) {
    // To avoid adding a needless [] to the majority of runtime.wrap
    // argument lists, force the caller to handle this case specially.
    return null;
  }

  var t = util.getTypes();
  var lastLocValue = 0;
  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
    var thisLocValue = tryEntry.firstLoc.value;

    _assert["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");

    lastLocValue = thisLocValue;
    var ce = tryEntry.catchEntry;
    var fe = tryEntry.finallyEntry;
    var locs = [tryEntry.firstLoc, // The null here makes a hole in the array.
    ce ? ce.firstLoc : null];

    if (fe) {
      locs[2] = fe.firstLoc;
      locs[3] = fe.afterLoc;
    }

    return t.arrayExpression(locs.map(function (loc) {
      return loc && t.clone(loc);
    }));
  }));
}; // All side effects must be realized in order.
// If any subexpression harbors a leap, all subexpressions must be
// neutered of side effects.
// No destructive modification of AST nodes.


Ep.explode = function (path, ignoreResult) {
  var t = util.getTypes();
  var node = path.node;
  var self = this;
  t.assertNode(node);
  if (t.isDeclaration(node)) throw getDeclError(node);
  if (t.isStatement(node)) return self.explodeStatement(path);
  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);

  switch (node.type) {
    case "Program":
      return path.get("body").map(self.explodeStatement, self);

    case "VariableDeclarator":
      throw getDeclError(node);
    // These node types should be handled by their parent nodes
    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).

    case "Property":
    case "SwitchCase":
    case "CatchClause":
      throw new Error(node.type + " nodes should be handled by their parents");

    default:
      throw new Error("unknown Node of type " + JSON.stringify(node.type));
  }
};

function getDeclError(node) {
  return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
}

Ep.explodeStatement = function (path, labelId) {
  var t = util.getTypes();
  var stmt = path.node;
  var self = this;
  var before, after, head;
  t.assertStatement(stmt);

  if (labelId) {
    t.assertIdentifier(labelId);
  } else {
    labelId = null;
  } // Explode BlockStatement nodes even if they do not contain a yield,
  // because we don't want or need the curly braces.


  if (t.isBlockStatement(stmt)) {
    path.get("body").forEach(function (path) {
      self.explodeStatement(path);
    });
    return;
  }

  if (!meta.containsLeap(stmt)) {
    // Technically we should be able to avoid emitting the statement
    // altogether if !meta.hasSideEffects(stmt), but that leads to
    // confusing generated code (for instance, `while (true) {}` just
    // disappears) and is probably a more appropriate job for a dedicated
    // dead code elimination pass.
    self.emit(stmt);
    return;
  }

  switch (stmt.type) {
    case "ExpressionStatement":
      self.explodeExpression(path.get("expression"), true);
      break;

    case "LabeledStatement":
      after = this.loc(); // Did you know you can break from any labeled block statement or
      // control structure? Well, you can! Note: when a labeled loop is
      // encountered, the leap.LabeledEntry created here will immediately
      // enclose a leap.LoopEntry on the leap manager's stack, and both
      // entries will have the same label. Though this works just fine, it
      // may seem a bit redundant. In theory, we could check here to
      // determine if stmt knows how to handle its own label; for example,
      // stmt happens to be a WhileStatement and so we know it's going to
      // establish its own LoopEntry when we explode it (below). Then this
      // LabeledEntry would be unnecessary. Alternatively, we might be
      // tempted not to pass stmt.label down into self.explodeStatement,
      // because we've handled the label here, but that's a mistake because
      // labeled loops may contain labeled continue statements, which is not
      // something we can handle in this generic case. All in all, I think a
      // little redundancy greatly simplifies the logic of this case, since
      // it's clear that we handle all possible LabeledStatements correctly
      // here, regardless of whether they interact with the leap manager
      // themselves. Also remember that labels and break/continue-to-label
      // statements are rare, and all of this logic happens at transform
      // time, so it has no additional runtime cost.

      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {
        self.explodeStatement(path.get("body"), stmt.label);
      });
      self.mark(after);
      break;

    case "WhileStatement":
      before = this.loc();
      after = this.loc();
      self.mark(before);
      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(before);
      self.mark(after);
      break;

    case "DoWhileStatement":
      var first = this.loc();
      var test = this.loc();
      after = this.loc();
      self.mark(first);
      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
        self.explode(path.get("body"));
      });
      self.mark(test);
      self.jumpIf(self.explodeExpression(path.get("test")), first);
      self.mark(after);
      break;

    case "ForStatement":
      head = this.loc();
      var update = this.loc();
      after = this.loc();

      if (stmt.init) {
        // We pass true here to indicate that if stmt.init is an expression
        // then we do not care about its result.
        self.explode(path.get("init"), true);
      }

      self.mark(head);

      if (stmt.test) {
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
      } else {// No test means continue unconditionally.
      }

      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.mark(update);

      if (stmt.update) {
        // We pass true here to indicate that if stmt.update is an
        // expression then we do not care about its result.
        self.explode(path.get("update"), true);
      }

      self.jump(head);
      self.mark(after);
      break;

    case "TypeCastExpression":
      return self.explodeExpression(path.get("expression"));

    case "ForInStatement":
      head = this.loc();
      after = this.loc();
      var keyIterNextFn = self.makeTempVar();
      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
      self.mark(head);
      var keyInfoTmpVar = self.makeTempVar();
      self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(head);
      self.mark(after);
      break;

    case "BreakStatement":
      self.emitAbruptCompletion({
        type: "break",
        target: self.leapManager.getBreakLoc(stmt.label)
      });
      break;

    case "ContinueStatement":
      self.emitAbruptCompletion({
        type: "continue",
        target: self.leapManager.getContinueLoc(stmt.label)
      });
      break;

    case "SwitchStatement":
      // Always save the discriminant into a temporary variable in case the
      // test expressions overwrite values like context.sent.
      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
      after = this.loc();
      var defaultLoc = this.loc();
      var condition = defaultLoc;
      var caseLocs = []; // If there are no cases, .cases might be undefined.

      var cases = stmt.cases || [];

      for (var i = cases.length - 1; i >= 0; --i) {
        var c = cases[i];
        t.assertSwitchCase(c);

        if (c.test) {
          condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
        } else {
          caseLocs[i] = defaultLoc;
        }
      }

      var discriminant = path.get("discriminant");
      util.replaceWithOrRemove(discriminant, condition);
      self.jump(self.explodeExpression(discriminant));
      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
        path.get("cases").forEach(function (casePath) {
          var i = casePath.key;
          self.mark(caseLocs[i]);
          casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          });
        });
      });
      self.mark(after);

      if (defaultLoc.value === -1) {
        self.mark(defaultLoc);

        _assert["default"].strictEqual(after.value, defaultLoc.value);
      }

      break;

    case "IfStatement":
      var elseLoc = stmt.alternate && this.loc();
      after = this.loc();
      self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
      self.explodeStatement(path.get("consequent"));

      if (elseLoc) {
        self.jump(after);
        self.mark(elseLoc);
        self.explodeStatement(path.get("alternate"));
      }

      self.mark(after);
      break;

    case "ReturnStatement":
      self.emitAbruptCompletion({
        type: "return",
        value: self.explodeExpression(path.get("argument"))
      });
      break;

    case "WithStatement":
      throw new Error("WithStatement not supported in generator functions.");

    case "TryStatement":
      after = this.loc();
      var handler = stmt.handler;
      var catchLoc = handler && this.loc();
      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
      var finallyLoc = stmt.finalizer && this.loc();
      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
      self.tryEntries.push(tryEntry);
      self.updateContextPrevLoc(tryEntry.firstLoc);
      self.leapManager.withEntry(tryEntry, function () {
        self.explodeStatement(path.get("block"));

        if (catchLoc) {
          if (finallyLoc) {
            // If we have both a catch block and a finally block, then
            // because we emit the catch block first, we need to jump over
            // it to the finally block.
            self.jump(finallyLoc);
          } else {
            // If there is no finally block, then we need to jump over the
            // catch block to the fall-through location.
            self.jump(after);
          }

          self.updateContextPrevLoc(self.mark(catchLoc));
          var bodyPath = path.get("handler.body");
          var safeParam = self.makeTempVar();
          self.clearPendingException(tryEntry.firstLoc, safeParam);
          bodyPath.traverse(catchParamVisitor, {
            getSafeParam: function getSafeParam() {
              return t.cloneDeep(safeParam);
            },
            catchParamName: handler.param.name
          });
          self.leapManager.withEntry(catchEntry, function () {
            self.explodeStatement(bodyPath);
          });
        }

        if (finallyLoc) {
          self.updateContextPrevLoc(self.mark(finallyLoc));
          self.leapManager.withEntry(finallyEntry, function () {
            self.explodeStatement(path.get("finalizer"));
          });
          self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
        }
      });
      self.mark(after);
      break;

    case "ThrowStatement":
      self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
      break;

    default:
      throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
  }
};

var catchParamVisitor = {
  Identifier: function Identifier(path, state) {
    if (path.node.name === state.catchParamName && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.getSafeParam());
    }
  },
  Scope: function Scope(path, state) {
    if (path.scope.hasOwnBinding(state.catchParamName)) {
      // Don't descend into nested scopes that shadow the catch
      // parameter with their own declarations.
      path.skip();
    }
  }
};

Ep.emitAbruptCompletion = function (record) {
  if (!isValidCompletion(record)) {
    _assert["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
  }

  _assert["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");

  var t = util.getTypes();
  var abruptArgs = [t.stringLiteral(record.type)];

  if (record.type === "break" || record.type === "continue") {
    t.assertLiteral(record.target);
    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
  } else if (record.type === "return" || record.type === "throw") {
    if (record.value) {
      t.assertExpression(record.value);
      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
    }
  }

  this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
};

function isValidCompletion(record) {
  var type = record.type;

  if (type === "normal") {
    return !hasOwn.call(record, "target");
  }

  if (type === "break" || type === "continue") {
    return !hasOwn.call(record, "value") && util.getTypes().isLiteral(record.target);
  }

  if (type === "return" || type === "throw") {
    return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
  }

  return false;
} // Not all offsets into emitter.listing are potential jump targets. For
// example, execution typically falls into the beginning of a try block
// without jumping directly there. This method returns the current offset
// without marking it, so that a switch case will not necessarily be
// generated for this offset (I say "not necessarily" because the same
// location might end up being marked in the process of emitting other
// statements). There's no logical harm in marking such locations as jump
// targets, but minimizing the number of switch cases keeps the generated
// code shorter.


Ep.getUnmarkedCurrentLoc = function () {
  return util.getTypes().numericLiteral(this.listing.length);
}; // The context.prev property takes the value of context.next whenever we
// evaluate the switch statement discriminant, which is generally good
// enough for tracking the last location we jumped to, but sometimes
// context.prev needs to be more precise, such as when we fall
// successfully out of a try block and into a finally block without
// jumping. This method exists to update context.prev to the freshest
// available location. If we were implementing a full interpreter, we
// would know the location of the current instruction with complete
// precision at all times, but we don't have that luxury here, as it would
// be costly and verbose to set context.prev before every statement.


Ep.updateContextPrevLoc = function (loc) {
  var t = util.getTypes();

  if (loc) {
    t.assertLiteral(loc);

    if (loc.value === -1) {
      // If an uninitialized location literal was passed in, set its value
      // to the current this.listing.length.
      loc.value = this.listing.length;
    } else {
      // Otherwise assert that the location matches the current offset.
      _assert["default"].strictEqual(loc.value, this.listing.length);
    }
  } else {
    loc = this.getUnmarkedCurrentLoc();
  } // Make sure context.prev is up to date in case we fell into this try
  // statement without jumping to it. TODO Consider avoiding this
  // assignment when we know control must have jumped here.


  this.emitAssign(this.contextProperty("prev"), loc);
};

Ep.explodeExpression = function (path, ignoreResult) {
  var t = util.getTypes();
  var expr = path.node;

  if (expr) {
    t.assertExpression(expr);
  } else {
    return expr;
  }

  var self = this;
  var result; // Used optionally by several cases below.

  var after;

  function finish(expr) {
    t.assertExpression(expr);

    if (ignoreResult) {
      self.emit(expr);
    } else {
      return expr;
    }
  } // If the expression does not contain a leap, then we either emit the
  // expression as a standalone statement or return it whole.


  if (!meta.containsLeap(expr)) {
    return finish(expr);
  } // If any child contains a leap (such as a yield or labeled continue or
  // break statement), then any sibling subexpressions will almost
  // certainly have to be exploded in order to maintain the order of their
  // side effects relative to the leaping child(ren).


  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr); // In order to save the rest of explodeExpression from a combinatorial
  // trainwreck of special cases, explodeViaTempVar is responsible for
  // deciding when a subexpression needs to be "exploded," which is my
  // very technical term for emitting the subexpression as an assignment
  // to a temporary variable and the substituting the temporary variable
  // for the original subexpression. Think of exploded view diagrams, not
  // Michael Bay movies. The point of exploding subexpressions is to
  // control the precise order in which the generated code realizes the
  // side effects of those subexpressions.

  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
    _assert["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");

    var result = self.explodeExpression(childPath, ignoreChildResult);

    if (ignoreChildResult) {// Side effects already emitted above.
    } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
      // If tempVar was provided, then the result will always be assigned
      // to it, even if the result does not otherwise need to be assigned
      // to a temporary variable.  When no tempVar is provided, we have
      // the flexibility to decide whether a temporary variable is really
      // necessary.  Unfortunately, in general, a temporary variable is
      // required whenever any child contains a yield expression, since it
      // is difficult to prove (at all, let alone efficiently) whether
      // this result would evaluate to the same value before and after the
      // yield (see #206).  One narrow case where we can prove it doesn't
      // matter (and thus we do not need a temporary variable) is when the
      // result in question is a Literal value.
      result = self.emitAssign(tempVar || self.makeTempVar(), result);
    }

    return result;
  } // If ignoreResult is true, then we must take full responsibility for
  // emitting the expression with all its side effects, and we should not
  // return a result.


  switch (expr.type) {
    case "MemberExpression":
      return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

    case "CallExpression":
      var calleePath = path.get("callee");
      var argsPath = path.get("arguments");
      var newCallee;
      var newArgs = [];
      var hasLeapingArgs = false;
      argsPath.forEach(function (argPath) {
        hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.node);
      });

      if (t.isMemberExpression(calleePath.node)) {
        if (hasLeapingArgs) {
          // If the arguments of the CallExpression contained any yield
          // expressions, then we need to be sure to evaluate the callee
          // before evaluating the arguments, but if the callee was a member
          // expression, then we must be careful that the object of the
          // member expression still gets bound to `this` for the call.
          var newObject = explodeViaTempVar( // Assign the exploded callee.object expression to a temporary
          // variable so that we can use it twice without reevaluating it.
          self.makeTempVar(), calleePath.get("object"));
          var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
          newArgs.unshift(newObject);
          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
        } else {
          newCallee = self.explodeExpression(calleePath);
        }
      } else {
        newCallee = explodeViaTempVar(null, calleePath);

        if (t.isMemberExpression(newCallee)) {
          // If the callee was not previously a MemberExpression, then the
          // CallExpression was "unqualified," meaning its `this` object
          // should be the global object. If the exploded expression has
          // become a MemberExpression (e.g. a context property, probably a
          // temporary variable), then we need to force it to be unqualified
          // by using the (0, object.property)(...) trick; otherwise, it
          // will receive the object of the MemberExpression as its `this`
          // object.
          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
        }
      }

      argsPath.forEach(function (argPath) {
        newArgs.push(explodeViaTempVar(null, argPath));
      });
      return finish(t.callExpression(newCallee, newArgs.map(function (arg) {
        return t.cloneDeep(arg);
      })));

    case "NewExpression":
      return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function (argPath) {
        return explodeViaTempVar(null, argPath);
      })));

    case "ObjectExpression":
      return finish(t.objectExpression(path.get("properties").map(function (propPath) {
        if (propPath.isObjectProperty()) {
          return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed);
        } else {
          return propPath.node;
        }
      })));

    case "ArrayExpression":
      return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
        return explodeViaTempVar(null, elemPath);
      })));

    case "SequenceExpression":
      var lastIndex = expr.expressions.length - 1;
      path.get("expressions").forEach(function (exprPath) {
        if (exprPath.key === lastIndex) {
          result = self.explodeExpression(exprPath, ignoreResult);
        } else {
          self.explodeExpression(exprPath, true);
        }
      });
      return result;

    case "LogicalExpression":
      after = this.loc();

      if (!ignoreResult) {
        result = self.makeTempVar();
      }

      var left = explodeViaTempVar(result, path.get("left"));

      if (expr.operator === "&&") {
        self.jumpIfNot(left, after);
      } else {
        _assert["default"].strictEqual(expr.operator, "||");

        self.jumpIf(left, after);
      }

      explodeViaTempVar(result, path.get("right"), ignoreResult);
      self.mark(after);
      return result;

    case "ConditionalExpression":
      var elseLoc = this.loc();
      after = this.loc();
      var test = self.explodeExpression(path.get("test"));
      self.jumpIfNot(test, elseLoc);

      if (!ignoreResult) {
        result = self.makeTempVar();
      }

      explodeViaTempVar(result, path.get("consequent"), ignoreResult);
      self.jump(after);
      self.mark(elseLoc);
      explodeViaTempVar(result, path.get("alternate"), ignoreResult);
      self.mark(after);
      return result;

    case "UnaryExpression":
      return finish(t.unaryExpression(expr.operator, // Can't (and don't need to) break up the syntax of the argument.
      // Think about delete a[b].
      self.explodeExpression(path.get("argument")), !!expr.prefix));

    case "BinaryExpression":
      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

    case "AssignmentExpression":
      if (expr.operator === "=") {
        // If this is a simple assignment, the left hand side does not need
        // to be read before the right hand side is evaluated, so we can
        // avoid the more complicated logic below.
        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
      }

      var lhs = self.explodeExpression(path.get("left"));
      var temp = self.emitAssign(self.makeTempVar(), lhs); // For example,
      //
      //   x += yield y
      //
      // becomes
      //
      //   context.t0 = x
      //   x = context.t0 += yield y
      //
      // so that the left-hand side expression is read before the yield.
      // Fixes https://github.com/facebook/regenerator/issues/345.

      return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

    case "UpdateExpression":
      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

    case "YieldExpression":
      after = this.loc();
      var arg = expr.argument && self.explodeExpression(path.get("argument"));

      if (arg && expr.delegate) {
        var _result = self.makeTempVar();

        var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));

        _ret.loc = expr.loc;
        self.emit(_ret);
        self.mark(after);
        return _result;
      }

      self.emitAssign(self.contextProperty("next"), after);
      var ret = t.returnStatement(t.cloneDeep(arg) || null); // Preserve the `yield` location so that source mappings for the statements
      // link back to the yield properly.

      ret.loc = expr.loc;
      self.emit(ret);
      self.mark(after);
      return self.contextProperty("sent");

    default:
      throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
  }
};

},{"./leap":1059,"./meta":1060,"./util":1062,"assert":278}],1057:[function(require,module,exports){
"use strict";

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var hasOwn = Object.prototype.hasOwnProperty; // The hoist function takes a FunctionExpression or FunctionDeclaration
// and replaces any Declaration nodes in its body with assignments, then
// returns a VariableDeclaration containing just the names of the removed
// declarations.

exports.hoist = function (funPath) {
  var t = util.getTypes();
  t.assertFunction(funPath.node);
  var vars = {};

  function varDeclToExpr(_ref, includeIdentifiers) {
    var vdec = _ref.node,
        scope = _ref.scope;
    t.assertVariableDeclaration(vdec); // TODO assert.equal(vdec.kind, "var");

    var exprs = [];
    vdec.declarations.forEach(function (dec) {
      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't
      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.
      vars[dec.id.name] = t.identifier(dec.id.name); // Remove the binding, to avoid "duplicate declaration" errors when it will
      // be injected again.

      scope.removeBinding(dec.id.name);

      if (dec.init) {
        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });
    if (exprs.length === 0) return null;
    if (exprs.length === 1) return exprs[0];
    return t.sequenceExpression(exprs);
  }

  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function exit(path) {
        var expr = varDeclToExpr(path, false);

        if (expr === null) {
          path.remove();
        } else {
          // We don't need to traverse this expression any further because
          // there can't be any new declarations inside an expression.
          util.replaceWithOrRemove(path, t.expressionStatement(expr));
        } // Since the original node has been either removed or replaced,
        // avoid traversing it any further.


        path.skip();
      }
    },
    ForStatement: function ForStatement(path) {
      var init = path.get("init");

      if (init.isVariableDeclaration()) {
        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
      }
    },
    ForXStatement: function ForXStatement(path) {
      var left = path.get("left");

      if (left.isVariableDeclaration()) {
        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
      }
    },
    FunctionDeclaration: function FunctionDeclaration(path) {
      var node = path.node;
      vars[node.id.name] = node.id;
      var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));

      if (path.parentPath.isBlockStatement()) {
        // Insert the assignment form before the first statement in the
        // enclosing block.
        path.parentPath.unshiftContainer("body", assignment); // Remove the function declaration now that we've inserted the
        // equivalent assignment form at the beginning of the block.

        path.remove();
      } else {
        // If the parent node is not a block statement, then we can just
        // replace the declaration with the equivalent assignment form
        // without worrying about hoisting it.
        util.replaceWithOrRemove(path, assignment);
      } // Remove the binding, to avoid "duplicate declaration" errors when it will
      // be injected again.


      path.scope.removeBinding(node.id.name); // Don't hoist variables out of inner functions.

      path.skip();
    },
    FunctionExpression: function FunctionExpression(path) {
      // Don't descend into nested function expressions.
      path.skip();
    },
    ArrowFunctionExpression: function ArrowFunctionExpression(path) {
      // Don't descend into nested function expressions.
      path.skip();
    }
  });
  var paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    var param = paramPath.node;

    if (t.isIdentifier(param)) {
      paramNames[param.name] = param;
    } else {// Variables declared by destructuring parameter patterns will be
      // harmlessly re-declared.
    }
  });
  var declarations = [];
  Object.keys(vars).forEach(function (name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(t.variableDeclarator(vars[name], null));
    }
  });

  if (declarations.length === 0) {
    return null; // Be sure to handle this case!
  }

  return t.variableDeclaration("var", declarations);
};

},{"./util":1062}],1058:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = _default;

var _visit = require("./visit");
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _default(context) {
  var plugin = {
    visitor: (0, _visit.getVisitor)(context)
  }; // Some presets manually call child presets, but fail to pass along the
  // context object. Out of an abundance of caution, we verify that it
  // exists first to avoid causing unnecessary breaking changes.

  var version = context && context.version; // The "name" property is not allowed in older versions of Babel (6.x)
  // and will cause the plugin validator to throw an exception.

  if (version && parseInt(version, 10) >= 7) {
    plugin.name = "regenerator-transform";
  }

  return plugin;
}

},{"./visit":1063}],1059:[function(require,module,exports){
"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _emit = require("./emit");

var _util = require("util");

var _util2 = require("./util");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function Entry() {
  _assert["default"].ok(this instanceof Entry);
}

function FunctionEntry(returnLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(returnLoc);
  this.returnLoc = returnLoc;
}

(0, _util.inherits)(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;

function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(breakLoc);
  t.assertLiteral(continueLoc);

  if (label) {
    t.assertIdentifier(label);
  } else {
    label = null;
  }

  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}

(0, _util.inherits)(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;

function SwitchEntry(breakLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(breakLoc);
  this.breakLoc = breakLoc;
}

(0, _util.inherits)(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;

function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);

  if (catchEntry) {
    _assert["default"].ok(catchEntry instanceof CatchEntry);
  } else {
    catchEntry = null;
  }

  if (finallyEntry) {
    _assert["default"].ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  } // Have to have one or the other (or both).


  _assert["default"].ok(catchEntry || finallyEntry);

  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}

(0, _util.inherits)(TryEntry, Entry);
exports.TryEntry = TryEntry;

function CatchEntry(firstLoc, paramId) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertIdentifier(paramId);
  this.firstLoc = firstLoc;
  this.paramId = paramId;
}

(0, _util.inherits)(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;

function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertLiteral(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}

(0, _util.inherits)(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;

function LabeledEntry(breakLoc, label) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(breakLoc);
  t.assertIdentifier(label);
  this.breakLoc = breakLoc;
  this.label = label;
}

(0, _util.inherits)(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;

function LeapManager(emitter) {
  _assert["default"].ok(this instanceof LeapManager);

  _assert["default"].ok(emitter instanceof _emit.Emitter);

  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}

var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;

LMp.withEntry = function (entry, callback) {
  _assert["default"].ok(entry instanceof Entry);

  this.entryStack.push(entry);

  try {
    callback.call(this.emitter);
  } finally {
    var popped = this.entryStack.pop();

    _assert["default"].strictEqual(popped, entry);
  }
};

LMp._findLeapLocation = function (property, label) {
  for (var i = this.entryStack.length - 1; i >= 0; --i) {
    var entry = this.entryStack[i];
    var loc = entry[property];

    if (loc) {
      if (label) {
        if (entry.label && entry.label.name === label.name) {
          return loc;
        }
      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to
        // a label.
      } else {
        return loc;
      }
    }
  }

  return null;
};

LMp.getBreakLoc = function (label) {
  return this._findLeapLocation("breakLoc", label);
};

LMp.getContinueLoc = function (label) {
  return this._findLeapLocation("continueLoc", label);
};

},{"./emit":1056,"./util":1062,"assert":278,"util":1091}],1060:[function(require,module,exports){
"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _util = require("./util.js");

var _private = require("private");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var m = (0, _private.makeAccessor)();
var hasOwn = Object.prototype.hasOwnProperty;

function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    var t = (0, _util.getTypes)();
    t.assertNode(node); // Assume no side effects until we find out otherwise.

    var result = false;

    function check(child) {
      if (result) {// Do nothing.
      } else if (Array.isArray(child)) {
        child.some(check);
      } else if (t.isNode(child)) {
        _assert["default"].strictEqual(result, false);

        result = predicate(child);
      }

      return result;
    }

    var keys = t.VISITOR_KEYS[node.type];

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var child = node[key];
        check(child);
      }
    }

    return result;
  }

  function predicate(node) {
    (0, _util.getTypes)().assertNode(node);
    var meta = m(node);
    if (hasOwn.call(meta, propertyName)) return meta[propertyName]; // Certain types are "opaque," which means they have no side
    // effects or leaps and we don't care about their subexpressions.

    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;
    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;
    return meta[propertyName] = onlyChildren(node);
  }

  predicate.onlyChildren = onlyChildren;
  return predicate;
}

var opaqueTypes = {
  FunctionExpression: true,
  ArrowFunctionExpression: true
}; // These types potentially have side effects regardless of what side
// effects their subexpressions have.

var sideEffectTypes = {
  CallExpression: true,
  // Anything could happen!
  ForInStatement: true,
  // Modifies the key variable.
  UnaryExpression: true,
  // Think delete.
  BinaryExpression: true,
  // Might invoke .toString() or .valueOf().
  AssignmentExpression: true,
  // Side-effecting by definition.
  UpdateExpression: true,
  // Updates are essentially assignments.
  NewExpression: true // Similar to CallExpression.

}; // These types are the direct cause of all leaps in control flow.

var leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
}; // All leap types are also side effect types.

for (var type in leapTypes) {
  if (hasOwn.call(leapTypes, type)) {
    sideEffectTypes[type] = leapTypes[type];
  }
}

exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
exports.containsLeap = makePredicate("containsLeap", leapTypes);

},{"./util.js":1062,"assert":278,"private":1053}],1061:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = replaceShorthandObjectMethod;

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// this function converts a shorthand object generator method into a normal
// (non-shorthand) object property which is a generator function expression. for
// example, this:
//
//  var foo = {
//    *bar(baz) { return 5; }
//  }
//
// should be replaced with:
//
//  var foo = {
//    bar: function*(baz) { return 5; }
//  }
//
// to do this, it clones the parameter array and the body of the object generator
// method into a new FunctionExpression.
//
// this method can be passed any Function AST node path, and it will return
// either:
//   a) the path that was passed in (iff the path did not need to be replaced) or
//   b) the path of the new FunctionExpression that was created as a replacement
//     (iff the path did need to be replaced)
//
// In either case, though, the caller can count on the fact that the return value
// is a Function AST node path.
//
// If this function is called with an AST node path that is not a Function (or with an
// argument that isn't an AST node path), it will throw an error.


function replaceShorthandObjectMethod(path) {
  var t = util.getTypes();

  if (!path.node || !t.isFunction(path.node)) {
    throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
  } // this function only replaces shorthand object methods (called ObjectMethod
  // in Babel-speak).


  if (!t.isObjectMethod(path.node)) {
    return path;
  } // this function only replaces generators.


  if (!path.node.generator) {
    return path;
  }

  var parameters = path.node.params.map(function (param) {
    return t.cloneDeep(param);
  });
  var functionExpression = t.functionExpression(null, // id
  parameters, // params
  t.cloneDeep(path.node.body), // body
  path.node.generator, path.node.async);
  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key
  functionExpression, //value
  path.node.computed, // computed
  false // shorthand
  )); // path now refers to the ObjectProperty AST node path, but we want to return a
  // Function AST node path for the function expression we created. we know that
  // the FunctionExpression we just created is the value of the ObjectProperty,
  // so return the "value" path off of this path.

  return path.get("value");
}

},{"./util":1062}],1062:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.wrapWithTypes = wrapWithTypes;
exports.getTypes = getTypes;
exports.runtimeProperty = runtimeProperty;
exports.isReference = isReference;
exports.replaceWithOrRemove = replaceWithOrRemove;
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var currentTypes = null;

function wrapWithTypes(types, fn) {
  return function () {
    var oldTypes = currentTypes;
    currentTypes = types;

    try {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return fn.apply(this, args);
    } finally {
      currentTypes = oldTypes;
    }
  };
}

function getTypes() {
  return currentTypes;
}

function runtimeProperty(name) {
  var t = getTypes();
  return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
}

function isReference(path) {
  return path.isReferenced() || path.parentPath.isAssignmentExpression({
    left: path.node
  });
}

function replaceWithOrRemove(path, replacement) {
  if (replacement) {
    path.replaceWith(replacement);
  } else {
    path.remove();
  }
}

},{}],1063:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _hoist = require("./hoist");

var _emit = require("./emit");

var _replaceShorthandObjectMethod = _interopRequireDefault(require("./replaceShorthandObjectMethod"));

var util = _interopRequireWildcard(require("./util"));

var _private = require("private");

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports.getVisitor = function (_ref) {
  var t = _ref.types;
  return {
    Method: function Method(path, state) {
      var node = path.node;
      if (!shouldRegenerate(node, state)) return;
      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
      path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method
      // or generator the outer function should not be

      node.async = false;
      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.

      path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
    },
    Function: {
      exit: util.wrapWithTypes(t, function (path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty

        path = (0, _replaceShorthandObjectMethod["default"])(path);
        node = path.node;
        var contextId = path.scope.generateUidIdentifier("context");
        var argsId = path.scope.generateUidIdentifier("args");
        path.ensureBlock();
        var bodyBlockPath = path.get("body");

        if (node.async) {
          bodyBlockPath.traverse(awaitVisitor);
        }

        bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        });
        var outerBody = [];
        var innerBody = [];
        bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;

          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" as elements
            // of a bodyBlockPath.node.directives array, but they could just
            // as easily be represented (by other parsers) as traditional
            // string-literal-valued expression statements, so we need to
            // handle that here. (#248)
            outerBody.push(node);
          } else if (node && node._blockHoist != null) {
            outerBody.push(node);
          } else {
            innerBody.push(node);
          }
        });

        if (outerBody.length > 0) {
          // Only replace the inner body if we actually hoisted any statements
          // to the outer body.
          bodyBlockPath.node.body = innerBody;
        }

        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the
        // function has a name (so node.id will always be an Identifier), even
        // if a temporary name has to be synthesized.

        t.assertIdentifier(node.id);
        var innerFnId = t.identifier(node.id.name + "$"); // Turn all declarations into vars, and replace the original
        // declarations with equivalent assignment expressions.

        var vars = (0, _hoist.hoist)(path);
        var context = {
          usesThis: false,
          usesArguments: false,
          getArgsId: function getArgsId() {
            return t.clone(argsId);
          }
        };
        path.traverse(argumentsThisVisitor, context);

        if (context.usesArguments) {
          vars = vars || t.variableDeclaration("var", []);
          var argumentIdentifier = t.identifier("arguments"); // we need to do this as otherwise arguments in arrow functions gets hoisted

          argumentIdentifier._shadowedFunctionLiteral = path;
          vars.declarations.push(t.variableDeclarator(t.clone(argsId), argumentIdentifier));
        }

        var emitter = new _emit.Emitter(contextId);
        emitter.explode(path.get("body"));

        if (vars && vars.declarations.length > 0) {
          outerBody.push(vars);
        }

        var wrapArgs = [emitter.getContextFunction(innerFnId)];
        var tryLocsList = emitter.getTryLocsList();

        if (node.generator) {
          wrapArgs.push(outerFnExpr);
        } else if (context.usesThis || tryLocsList) {
          // Async functions that are not generators don't care about the
          // outer function because they don't need it to be marked and don't
          // inherit from its .prototype.
          wrapArgs.push(t.nullLiteral());
        }

        if (context.usesThis) {
          wrapArgs.push(t.thisExpression());
        } else if (tryLocsList) {
          wrapArgs.push(t.nullLiteral());
        }

        if (tryLocsList) {
          wrapArgs.push(tryLocsList);
        }

        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
        outerBody.push(t.returnStatement(wrapCall));
        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),
        // so we need to add them to the scope.

        path.get("body.body").forEach(function (p) {
          return p.scope.registerDeclaration(p);
        });
        var oldDirectives = bodyBlockPath.node.directives;

        if (oldDirectives) {
          // Babylon represents directives like "use strict" as elements of
          // a bodyBlockPath.node.directives array. (#248)
          node.body.directives = oldDirectives;
        }

        var wasGeneratorFunction = node.generator;

        if (wasGeneratorFunction) {
          node.generator = false;
        }

        if (node.async) {
          node.async = false;
        }

        if (wasGeneratorFunction && t.isExpression(node)) {
          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [node]));
          path.addComment("leading", "#__PURE__");
        }

        var insertedLocs = emitter.getInsertedLocs();
        path.traverse({
          NumericLiteral: function NumericLiteral(path) {
            if (!insertedLocs.has(path.node)) {
              return;
            }

            path.replaceWith(t.numericLiteral(path.node.value));
          }
        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on
        // an ES5 AST, but that means traversal will not pick up newly inserted references
        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.

        path.requeue();
      })
    }
  };
}; // Check if a node should be transformed by regenerator


function shouldRegenerate(node, state) {
  if (node.generator) {
    if (node.async) {
      // Async generator
      return state.opts.asyncGenerators !== false;
    } else {
      // Plain generator
      return state.opts.generators !== false;
    }
  } else if (node.async) {
    // Async function
    return state.opts.async !== false;
  } else {
    // Not a generator or async function.
    return false;
  }
} // Given a NodePath for a Function, return an Expression node that can be
// used to refer reliably to the function object from inside the function.
// This expression is essentially a replacement for arguments.callee, with
// the key advantage that it works in strict mode.


function getOuterFnExpr(funPath) {
  var t = util.getTypes();
  var node = funPath.node;
  t.assertFunction(node);

  if (!node.id) {
    // Default-exported function declarations, and function expressions may not
    // have a name to reference, so we explicitly add one.
    node.id = funPath.scope.parent.generateUidIdentifier("callee");
  }

  if (node.generator && // Non-generator functions don't need to be marked.
  t.isFunctionDeclaration(node)) {
    // Return the identifier returned by runtime.mark(<node.id>).
    return getMarkedFunctionId(funPath);
  }

  return t.clone(node.id);
}

var getMarkInfo = (0, _private.makeAccessor)();

function getMarkedFunctionId(funPath) {
  var t = util.getTypes();
  var node = funPath.node;
  t.assertIdentifier(node.id);
  var blockPath = funPath.findParent(function (path) {
    return path.isProgram() || path.isBlockStatement();
  });

  if (!blockPath) {
    return node.id;
  }

  var block = blockPath.node;

  _assert["default"].ok(Array.isArray(block.body));

  var info = getMarkInfo(block);

  if (!info.decl) {
    info.decl = t.variableDeclaration("var", []);
    blockPath.unshiftContainer("body", info.decl);
    info.declPath = blockPath.get("body.0");
  }

  _assert["default"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.


  var markedId = blockPath.scope.generateUidIdentifier("marked");
  var markCallExp = t.callExpression(util.runtimeProperty("mark"), [t.clone(node.id)]);
  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
  var markCallExpPath = info.declPath.get("declarations." + index + ".init");

  _assert["default"].strictEqual(markCallExpPath.node, markCallExp);

  markCallExpPath.addComment("leading", "#__PURE__");
  return t.clone(markedId);
}

var argumentsThisVisitor = {
  "FunctionExpression|FunctionDeclaration|Method": function FunctionExpressionFunctionDeclarationMethod(path) {
    path.skip();
  },
  Identifier: function Identifier(path, state) {
    if (path.node.name === "arguments" && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.getArgsId());
      state.usesArguments = true;
    }
  },
  ThisExpression: function ThisExpression(path, state) {
    state.usesThis = true;
  }
};
var functionSentVisitor = {
  MetaProperty: function MetaProperty(path) {
    var node = path.node;

    if (node.meta.name === "function" && node.property.name === "sent") {
      var t = util.getTypes();
      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
    }
  }
};
var awaitVisitor = {
  Function: function Function(path) {
    path.skip(); // Don't descend into nested function scopes.
  },
  AwaitExpression: function AwaitExpression(path) {
    var t = util.getTypes(); // Convert await expressions to yield expressions.

    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`
    // causes the argument to be wrapped in such a way that the runtime
    // can distinguish between awaited and merely yielded values.

    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty("awrap"), [argument]), false));
  }
};

},{"./emit":1056,"./hoist":1057,"./replaceShorthandObjectMethod":1061,"./util":1062,"assert":278,"private":1053}],1064:[function(require,module,exports){
// Generated using `npm run build`. Do not edit.
'use strict';

var regenerate = require('regenerate');

exports.REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
exports.UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
exports.UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);

},{"regenerate":1055}],1065:[function(require,module,exports){
"use strict";

module.exports = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x26A, 0xA7AE], [0x282, 0xA7C5], [0x29D, 0xA7B2], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x432, 0x1C80], [0x434, 0x1C81], [0x43E, 0x1C82], [0x441, 0x1C83], [0x442, [0x1C84, 0x1C85]], [0x44A, 0x1C86], [0x462, 0x1C87], [0x463, 0x1C87], [0x10D0, 0x1C90], [0x10D1, 0x1C91], [0x10D2, 0x1C92], [0x10D3, 0x1C93], [0x10D4, 0x1C94], [0x10D5, 0x1C95], [0x10D6, 0x1C96], [0x10D7, 0x1C97], [0x10D8, 0x1C98], [0x10D9, 0x1C99], [0x10DA, 0x1C9A], [0x10DB, 0x1C9B], [0x10DC, 0x1C9C], [0x10DD, 0x1C9D], [0x10DE, 0x1C9E], [0x10DF, 0x1C9F], [0x10E0, 0x1CA0], [0x10E1, 0x1CA1], [0x10E2, 0x1CA2], [0x10E3, 0x1CA3], [0x10E4, 0x1CA4], [0x10E5, 0x1CA5], [0x10E6, 0x1CA6], [0x10E7, 0x1CA7], [0x10E8, 0x1CA8], [0x10E9, 0x1CA9], [0x10EA, 0x1CAA], [0x10EB, 0x1CAB], [0x10EC, 0x1CAC], [0x10ED, 0x1CAD], [0x10EE, 0x1CAE], [0x10EF, 0x1CAF], [0x10F0, 0x1CB0], [0x10F1, 0x1CB1], [0x10F2, 0x1CB2], [0x10F3, 0x1CB3], [0x10F4, 0x1CB4], [0x10F5, 0x1CB5], [0x10F6, 0x1CB6], [0x10F7, 0x1CB7], [0x10F8, 0x1CB8], [0x10F9, 0x1CB9], [0x10FA, 0x1CBA], [0x10FD, 0x1CBD], [0x10FE, 0x1CBE], [0x10FF, 0x1CBF], [0x13A0, 0xAB70], [0x13A1, 0xAB71], [0x13A2, 0xAB72], [0x13A3, 0xAB73], [0x13A4, 0xAB74], [0x13A5, 0xAB75], [0x13A6, 0xAB76], [0x13A7, 0xAB77], [0x13A8, 0xAB78], [0x13A9, 0xAB79], [0x13AA, 0xAB7A], [0x13AB, 0xAB7B], [0x13AC, 0xAB7C], [0x13AD, 0xAB7D], [0x13AE, 0xAB7E], [0x13AF, 0xAB7F], [0x13B0, 0xAB80], [0x13B1, 0xAB81], [0x13B2, 0xAB82], [0x13B3, 0xAB83], [0x13B4, 0xAB84], [0x13B5, 0xAB85], [0x13B6, 0xAB86], [0x13B7, 0xAB87], [0x13B8, 0xAB88], [0x13B9, 0xAB89], [0x13BA, 0xAB8A], [0x13BB, 0xAB8B], [0x13BC, 0xAB8C], [0x13BD, 0xAB8D], [0x13BE, 0xAB8E], [0x13BF, 0xAB8F], [0x13C0, 0xAB90], [0x13C1, 0xAB91], [0x13C2, 0xAB92], [0x13C3, 0xAB93], [0x13C4, 0xAB94], [0x13C5, 0xAB95], [0x13C6, 0xAB96], [0x13C7, 0xAB97], [0x13C8, 0xAB98], [0x13C9, 0xAB99], [0x13CA, 0xAB9A], [0x13CB, 0xAB9B], [0x13CC, 0xAB9C], [0x13CD, 0xAB9D], [0x13CE, 0xAB9E], [0x13CF, 0xAB9F], [0x13D0, 0xABA0], [0x13D1, 0xABA1], [0x13D2, 0xABA2], [0x13D3, 0xABA3], [0x13D4, 0xABA4], [0x13D5, 0xABA5], [0x13D6, 0xABA6], [0x13D7, 0xABA7], [0x13D8, 0xABA8], [0x13D9, 0xABA9], [0x13DA, 0xABAA], [0x13DB, 0xABAB], [0x13DC, 0xABAC], [0x13DD, 0xABAD], [0x13DE, 0xABAE], [0x13DF, 0xABAF], [0x13E0, 0xABB0], [0x13E1, 0xABB1], [0x13E2, 0xABB2], [0x13E3, 0xABB3], [0x13E4, 0xABB4], [0x13E5, 0xABB5], [0x13E6, 0xABB6], [0x13E7, 0xABB7], [0x13E8, 0xABB8], [0x13E9, 0xABB9], [0x13EA, 0xABBA], [0x13EB, 0xABBB], [0x13EC, 0xABBC], [0x13ED, 0xABBD], [0x13EE, 0xABBE], [0x13EF, 0xABBF], [0x13F0, 0x13F8], [0x13F1, 0x13F9], [0x13F2, 0x13FA], [0x13F3, 0x13FB], [0x13F4, 0x13FC], [0x13F5, 0x13FD], [0x13F8, 0x13F0], [0x13F9, 0x13F1], [0x13FA, 0x13F2], [0x13FB, 0x13F3], [0x13FC, 0x13F4], [0x13FD, 0x13F5], [0x1C80, [0x412, 0x432]], [0x1C81, [0x414, 0x434]], [0x1C82, [0x41E, 0x43E]], [0x1C83, [0x421, 0x441]], [0x1C84, [0x1C85, 0x442]], [0x1C85, [0x422, 0x1C84, 0x442]], [0x1C86, [0x42A, 0x44A]], [0x1C87, [0x462, 0x463]], [0x1C88, [0xA64A, 0xA64B]], [0x1C90, 0x10D0], [0x1C91, 0x10D1], [0x1C92, 0x10D2], [0x1C93, 0x10D3], [0x1C94, 0x10D4], [0x1C95, 0x10D5], [0x1C96, 0x10D6], [0x1C97, 0x10D7], [0x1C98, 0x10D8], [0x1C99, 0x10D9], [0x1C9A, 0x10DA], [0x1C9B, 0x10DB], [0x1C9C, 0x10DC], [0x1C9D, 0x10DD], [0x1C9E, 0x10DE], [0x1C9F, 0x10DF], [0x1CA0, 0x10E0], [0x1CA1, 0x10E1], [0x1CA2, 0x10E2], [0x1CA3, 0x10E3], [0x1CA4, 0x10E4], [0x1CA5, 0x10E5], [0x1CA6, 0x10E6], [0x1CA7, 0x10E7], [0x1CA8, 0x10E8], [0x1CA9, 0x10E9], [0x1CAA, 0x10EA], [0x1CAB, 0x10EB], [0x1CAC, 0x10EC], [0x1CAD, 0x10ED], [0x1CAE, 0x10EE], [0x1CAF, 0x10EF], [0x1CB0, 0x10F0], [0x1CB1, 0x10F1], [0x1CB2, 0x10F2], [0x1CB3, 0x10F3], [0x1CB4, 0x10F4], [0x1CB5, 0x10F5], [0x1CB6, 0x10F6], [0x1CB7, 0x10F7], [0x1CB8, 0x10F8], [0x1CB9, 0x10F9], [0x1CBA, 0x10FA], [0x1CBD, 0x10FD], [0x1CBE, 0x10FE], [0x1CBF, 0x10FF], [0x1D8E, 0xA7C6], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0xA64A, 0x1C88], [0xA64B, 0x1C88], [0xA794, 0xA7C4], [0xA7AE, 0x26A], [0xA7B2, 0x29D], [0xA7B3, 0xAB53], [0xA7B4, 0xA7B5], [0xA7B5, 0xA7B4], [0xA7B6, 0xA7B7], [0xA7B7, 0xA7B6], [0xA7B8, 0xA7B9], [0xA7B9, 0xA7B8], [0xA7BA, 0xA7BB], [0xA7BB, 0xA7BA], [0xA7BC, 0xA7BD], [0xA7BD, 0xA7BC], [0xA7BE, 0xA7BF], [0xA7BF, 0xA7BE], [0xA7C2, 0xA7C3], [0xA7C3, 0xA7C2], [0xA7C4, 0xA794], [0xA7C5, 0x282], [0xA7C6, 0x1D8E], [0xAB53, 0xA7B3], [0xAB70, 0x13A0], [0xAB71, 0x13A1], [0xAB72, 0x13A2], [0xAB73, 0x13A3], [0xAB74, 0x13A4], [0xAB75, 0x13A5], [0xAB76, 0x13A6], [0xAB77, 0x13A7], [0xAB78, 0x13A8], [0xAB79, 0x13A9], [0xAB7A, 0x13AA], [0xAB7B, 0x13AB], [0xAB7C, 0x13AC], [0xAB7D, 0x13AD], [0xAB7E, 0x13AE], [0xAB7F, 0x13AF], [0xAB80, 0x13B0], [0xAB81, 0x13B1], [0xAB82, 0x13B2], [0xAB83, 0x13B3], [0xAB84, 0x13B4], [0xAB85, 0x13B5], [0xAB86, 0x13B6], [0xAB87, 0x13B7], [0xAB88, 0x13B8], [0xAB89, 0x13B9], [0xAB8A, 0x13BA], [0xAB8B, 0x13BB], [0xAB8C, 0x13BC], [0xAB8D, 0x13BD], [0xAB8E, 0x13BE], [0xAB8F, 0x13BF], [0xAB90, 0x13C0], [0xAB91, 0x13C1], [0xAB92, 0x13C2], [0xAB93, 0x13C3], [0xAB94, 0x13C4], [0xAB95, 0x13C5], [0xAB96, 0x13C6], [0xAB97, 0x13C7], [0xAB98, 0x13C8], [0xAB99, 0x13C9], [0xAB9A, 0x13CA], [0xAB9B, 0x13CB], [0xAB9C, 0x13CC], [0xAB9D, 0x13CD], [0xAB9E, 0x13CE], [0xAB9F, 0x13CF], [0xABA0, 0x13D0], [0xABA1, 0x13D1], [0xABA2, 0x13D2], [0xABA3, 0x13D3], [0xABA4, 0x13D4], [0xABA5, 0x13D5], [0xABA6, 0x13D6], [0xABA7, 0x13D7], [0xABA8, 0x13D8], [0xABA9, 0x13D9], [0xABAA, 0x13DA], [0xABAB, 0x13DB], [0xABAC, 0x13DC], [0xABAD, 0x13DD], [0xABAE, 0x13DE], [0xABAF, 0x13DF], [0xABB0, 0x13E0], [0xABB1, 0x13E1], [0xABB2, 0x13E2], [0xABB3, 0x13E3], [0xABB4, 0x13E4], [0xABB5, 0x13E5], [0xABB6, 0x13E6], [0xABB7, 0x13E7], [0xABB8, 0x13E8], [0xABB9, 0x13E9], [0xABBA, 0x13EA], [0xABBB, 0x13EB], [0xABBC, 0x13EC], [0xABBD, 0x13ED], [0xABBE, 0x13EE], [0xABBF, 0x13EF], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

},{}],1066:[function(require,module,exports){
'use strict';

var generate = require('regjsgen').generate;

var parse = require('regjsparser').parse;

var regenerate = require('regenerate');

var unicodeMatchProperty = require('unicode-match-property-ecmascript');

var unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');

var iuMappings = require('./data/iu-mappings.js');

var ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative
// character classes (if any).


var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.
// https://mths.be/es6#sec-pattern-semantics

var BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be
// matched by `/./u`. https://mths.be/es6#sec-atom

var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
0x000A, // Line Feed <LF>
0x000D, // Carriage Return <CR>
0x2028, // Line Separator <LS>
0x2029 // Paragraph Separator <PS>
);

var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
  if (unicode) {
    if (ignoreCase) {
      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);
    }

    return ESCAPE_SETS.UNICODE.get(character);
  }

  return ESCAPE_SETS.REGULAR.get(character);
};

var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
};

var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
  var path = value ? "".concat(property, "/").concat(value) : "Binary_Property/".concat(property);

  try {
    return require("regenerate-unicode-properties/".concat(path, ".js"));
  } catch (exception) {
    throw new Error("Failed to recognize value `".concat(value, "` for property ") + "`".concat(property, "`."));
  }
};

var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
  // It could be a `General_Category` value or a binary property.
  // Note: `unicodeMatchPropertyValue` throws on invalid values.
  try {
    var _property = 'General_Category';
    var category = unicodeMatchPropertyValue(_property, value);
    return getUnicodePropertyValueSet(_property, category);
  } catch (exception) {} // Its not a `General_Category` value, so check if its a binary
  // property. Note: `unicodeMatchProperty` throws on invalid properties.


  var property = unicodeMatchProperty(value);
  return getUnicodePropertyValueSet(property);
};

var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
  var parts = value.split('=');
  var firstPart = parts[0];
  var set;

  if (parts.length == 1) {
    set = handleLoneUnicodePropertyNameOrValue(firstPart);
  } else {
    // The pattern consists of two parts, i.e. `Property=Value`.
    var property = unicodeMatchProperty(firstPart);

    var _value = unicodeMatchPropertyValue(property, parts[1]);

    set = getUnicodePropertyValueSet(property, _value);
  }

  if (isNegative) {
    return UNICODE_SET.clone().remove(set);
  }

  return set.clone();
}; // Given a range of code points, add any case-folded code points in that range
// to a set.


regenerate.prototype.iuAddRange = function (min, max) {
  var $this = this;

  do {
    var folded = caseFold(min);

    if (folded) {
      $this.add(folded);
    }
  } while (++min <= max);

  return $this;
};

var update = function update(item, pattern) {
  var tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');

  switch (tree.type) {
    case 'characterClass':
    case 'group':
    case 'value':
      // No wrapping needed.
      break;

    default:
      // Wrap the pattern in a non-capturing group.
      tree = wrap(tree, pattern);
  }

  Object.assign(item, tree);
};

var wrap = function wrap(tree, pattern) {
  // Wrap the pattern in a non-capturing group.
  return {
    'type': 'group',
    'behavior': 'ignore',
    'body': [tree],
    'raw': "(?:".concat(pattern, ")")
  };
};

var caseFold = function caseFold(codePoint) {
  return iuMappings.get(codePoint) || false;
};

var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
  var set = regenerate();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = characterClassItem.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;

      switch (item.type) {
        case 'value':
          set.add(item.codePoint);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            var folded = caseFold(item.codePoint);

            if (folded) {
              set.add(folded);
            }
          }

          break;

        case 'characterClassRange':
          var min = item.min.codePoint;
          var max = item.max.codePoint;
          set.addRange(min, max);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            set.iuAddRange(min, max);
          }

          break;

        case 'characterClassEscape':
          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));
          break;

        case 'unicodePropertyEscape':
          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
          break;
        // The `default` clause is only here as a safeguard; it should never be
        // reached. Code coverage tools should ignore it.

        /* istanbul ignore next */

        default:
          throw new Error("Unknown term type: ".concat(item.type));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (characterClassItem.negative) {
    set = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
  }

  update(characterClassItem, set.toString(regenerateOptions));
  return characterClassItem;
};

var updateNamedReference = function updateNamedReference(item, index) {
  delete item.name;
  item.matchIndex = index;
};

var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
  var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

  if (unmatchedReferencesNames.length > 0) {
    throw new Error("Unknown group names: ".concat(unmatchedReferencesNames));
  }
};

var processTerm = function processTerm(item, regenerateOptions, groups) {
  switch (item.type) {
    case 'dot':
      if (config.unicode) {
        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));
      } else if (config.dotAll) {
        // TODO: consider changing this at the regenerate level.
        update(item, '[\\s\\S]');
      }

      break;

    case 'characterClass':
      item = processCharacterClass(item, regenerateOptions);
      break;

    case 'unicodePropertyEscape':
      update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
      break;

    case 'characterClassEscape':
      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));
      break;

    case 'group':
      if (item.behavior == 'normal') {
        groups.lastIndex++;
      }

      if (item.name) {
        var name = item.name.value;

        if (groups.names[name]) {
          throw new Error("Multiple groups with the same name (".concat(name, ") are not allowed."));
        }

        var index = groups.lastIndex;
        delete item.name;
        groups.names[name] = index;

        if (groups.onNamedGroup) {
          groups.onNamedGroup.call(null, name, index);
        }

        if (groups.unmatchedReferences[name]) {
          groups.unmatchedReferences[name].forEach(function (reference) {
            updateNamedReference(reference, index);
          });
          delete groups.unmatchedReferences[name];
        }
      }

    /* falls through */

    case 'alternative':
    case 'disjunction':
    case 'quantifier':
      item.body = item.body.map(function (term) {
        return processTerm(term, regenerateOptions, groups);
      });
      break;

    case 'value':
      var codePoint = item.codePoint;
      var set = regenerate(codePoint);

      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
        var folded = caseFold(codePoint);

        if (folded) {
          set.add(folded);
        }
      }

      update(item, set.toString(regenerateOptions));
      break;

    case 'reference':
      if (item.name) {
        var _name = item.name.value;
        var _index = groups.names[_name];

        if (_index) {
          updateNamedReference(item, _index);
          break;
        }

        if (!groups.unmatchedReferences[_name]) {
          groups.unmatchedReferences[_name] = [];
        } // Keep track of references used before the corresponding group.


        groups.unmatchedReferences[_name].push(item);
      }

      break;

    case 'anchor':
    case 'empty':
    case 'group':
      // Nothing to do here.
      break;
    // The `default` clause is only here as a safeguard; it should never be
    // reached. Code coverage tools should ignore it.

    /* istanbul ignore next */

    default:
      throw new Error("Unknown term type: ".concat(item.type));
  }

  return item;
};

var config = {
  'ignoreCase': false,
  'unicode': false,
  'dotAll': false,
  'useUnicodeFlag': false
};

var rewritePattern = function rewritePattern(pattern, flags, options) {
  var regjsparserFeatures = {
    'unicodePropertyEscape': options && options.unicodePropertyEscape,
    'namedGroups': options && options.namedGroup,
    'lookbehind': options && options.lookbehind
  };
  config.ignoreCase = flags && flags.includes('i');
  config.unicode = flags && flags.includes('u');
  var supportDotAllFlag = options && options.dotAllFlag;
  config.dotAll = supportDotAllFlag && flags && flags.includes('s');
  config.useUnicodeFlag = options && options.useUnicodeFlag;
  var regenerateOptions = {
    'hasUnicodeFlag': config.useUnicodeFlag,
    'bmpOnly': !config.unicode
  };
  var groups = {
    'onNamedGroup': options && options.onNamedGroup,
    'lastIndex': 0,
    'names': Object.create(null),
    // { [name]: index }
    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }

  };
  var tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.

  processTerm(tree, regenerateOptions, groups);
  assertNoUnmatchedReferences(groups);
  return generate(tree);
};

module.exports = rewritePattern;

},{"./data/character-class-escape-sets.js":1064,"./data/iu-mappings.js":1065,"regenerate":1055,"regjsgen":1067,"regjsparser":1068,"unicode-match-property-ecmascript":1085,"unicode-match-property-value-ecmascript":1087}],1067:[function(require,module,exports){
(function (global){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * regjsgen 0.5.1
 * Copyright 2014-2019 Benjamin Tan <https://bnjmnt4n.now.sh/>
 * Available under MIT license <https://github.com/bnjmnt4n/regjsgen/blob/master/LICENSE>
 */
;
(function () {
  'use strict'; // Used to determine if values are of the language type `Object`.

  var objectTypes = {
    'function': true,
    'object': true
  }; // Used as a reference to the global object.

  var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this; // Detect free variable `exports`.

  var freeExports = objectTypes[typeof exports === "undefined" ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports; // Detect free variable `module`.

  var hasFreeModule = objectTypes[typeof module === "undefined" ? "undefined" : _typeof(module)] && module && !module.nodeType; // Detect free variable `global` from Node.js or Browserified code and use it as `root`.

  var freeGlobal = freeExports && hasFreeModule && (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;

  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  } // Used to check objects for own properties.


  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /*--------------------------------------------------------------------------*/
  // Generates a string based on the given code point.
  // Based on https://mths.be/fromcodepoint by @mathias.

  function fromCodePoint() {
    var codePoint = Number(arguments[0]);

    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
    codePoint < 0 || // not a valid Unicode code point
    codePoint > 0x10FFFF || // not a valid Unicode code point
    Math.floor(codePoint) != codePoint // not an integer
    ) {
        throw RangeError('Invalid code point: ' + codePoint);
      }

    if (codePoint <= 0xFFFF) {
      // BMP code point
      return String.fromCharCode(codePoint);
    } else {
      // Astral code point; split in surrogate halves
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      codePoint -= 0x10000;
      var highSurrogate = (codePoint >> 10) + 0xD800;
      var lowSurrogate = codePoint % 0x400 + 0xDC00;
      return String.fromCharCode(highSurrogate, lowSurrogate);
    }
  }
  /*--------------------------------------------------------------------------*/
  // Ensures that nodes have the correct types.


  var assertTypeRegexMap = {};

  function assertType(type, expected) {
    if (expected.indexOf('|') == -1) {
      if (type == expected) {
        return;
      }

      throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
    }

    expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

    if (expected.test(type)) {
      return;
    }

    throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
  }
  /*--------------------------------------------------------------------------*/
  // Generates a regular expression string based on an AST.


  function generate(node) {
    var type = node.type;

    if (hasOwnProperty.call(generators, type)) {
      return generators[type](node);
    }

    throw Error('Invalid node type: ' + type);
  }
  /*--------------------------------------------------------------------------*/


  function generateAlternative(node) {
    assertType(node.type, 'alternative');
    var terms = node.body,
        i = -1,
        length = terms.length,
        result = '';

    while (++i < length) {
      result += generateTerm(terms[i]);
    }

    return result;
  }

  function generateAnchor(node) {
    assertType(node.type, 'anchor');

    switch (node.kind) {
      case 'start':
        return '^';

      case 'end':
        return '$';

      case 'boundary':
        return '\\b';

      case 'not-boundary':
        return '\\B';

      default:
        throw Error('Invalid assertion');
    }
  }

  function generateAtom(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
    return generate(node);
  }

  function generateCharacterClass(node) {
    assertType(node.type, 'characterClass');
    var classRanges = node.body,
        i = -1,
        length = classRanges.length,
        result = '';

    if (node.negative) {
      result += '^';
    }

    while (++i < length) {
      result += generateClassAtom(classRanges[i]);
    }

    return '[' + result + ']';
  }

  function generateCharacterClassEscape(node) {
    assertType(node.type, 'characterClassEscape');
    return '\\' + node.value;
  }

  function generateUnicodePropertyEscape(node) {
    assertType(node.type, 'unicodePropertyEscape');
    return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
  }

  function generateCharacterClassRange(node) {
    assertType(node.type, 'characterClassRange');
    var min = node.min,
        max = node.max;

    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
      throw Error('Invalid character class range');
    }

    return generateClassAtom(min) + '-' + generateClassAtom(max);
  }

  function generateClassAtom(node) {
    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
    return generate(node);
  }

  function generateDisjunction(node) {
    assertType(node.type, 'disjunction');
    var body = node.body,
        i = -1,
        length = body.length,
        result = '';

    while (++i < length) {
      if (i != 0) {
        result += '|';
      }

      result += generate(body[i]);
    }

    return result;
  }

  function generateDot(node) {
    assertType(node.type, 'dot');
    return '.';
  }

  function generateGroup(node) {
    assertType(node.type, 'group');
    var result = '';

    switch (node.behavior) {
      case 'normal':
        if (node.name) {
          result += '?<' + generateIdentifier(node.name) + '>';
        }

        break;

      case 'ignore':
        result += '?:';
        break;

      case 'lookahead':
        result += '?=';
        break;

      case 'negativeLookahead':
        result += '?!';
        break;

      case 'lookbehind':
        result += '?<=';
        break;

      case 'negativeLookbehind':
        result += '?<!';
        break;

      default:
        throw Error('Invalid behaviour: ' + node.behaviour);
    }

    var body = node.body,
        i = -1,
        length = body.length;

    while (++i < length) {
      result += generate(body[i]);
    }

    return '(' + result + ')';
  }

  function generateIdentifier(node) {
    assertType(node.type, 'identifier');
    return node.value;
  }

  function generateQuantifier(node) {
    assertType(node.type, 'quantifier');
    var quantifier = '',
        min = node.min,
        max = node.max;

    if (max == null) {
      if (min == 0) {
        quantifier = '*';
      } else if (min == 1) {
        quantifier = '+';
      } else {
        quantifier = '{' + min + ',}';
      }
    } else if (min == max) {
      quantifier = '{' + min + '}';
    } else if (min == 0 && max == 1) {
      quantifier = '?';
    } else {
      quantifier = '{' + min + ',' + max + '}';
    }

    if (!node.greedy) {
      quantifier += '?';
    }

    return generateAtom(node.body[0]) + quantifier;
  }

  function generateReference(node) {
    assertType(node.type, 'reference');

    if (node.matchIndex) {
      return '\\' + node.matchIndex;
    }

    if (node.name) {
      return '\\k<' + generateIdentifier(node.name) + '>';
    }

    throw new Error('Unknown reference type');
  }

  function generateTerm(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
    return generate(node);
  }

  function generateValue(node) {
    assertType(node.type, 'value');
    var kind = node.kind,
        codePoint = node.codePoint;

    if (typeof codePoint != 'number') {
      throw new Error('Invalid code point: ' + codePoint);
    }

    switch (kind) {
      case 'controlLetter':
        return '\\c' + fromCodePoint(codePoint + 64);

      case 'hexadecimalEscape':
        return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

      case 'identifier':
        return '\\' + fromCodePoint(codePoint);

      case 'null':
        return '\\' + codePoint;

      case 'octal':
        return '\\' + codePoint.toString(8);

      case 'singleEscape':
        switch (codePoint) {
          case 0x0008:
            return '\\b';

          case 0x0009:
            return '\\t';

          case 0x000A:
            return '\\n';

          case 0x000B:
            return '\\v';

          case 0x000C:
            return '\\f';

          case 0x000D:
            return '\\r';

          default:
            throw Error('Invalid code point: ' + codePoint);
        }

      case 'symbol':
        return fromCodePoint(codePoint);

      case 'unicodeEscape':
        return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

      case 'unicodeCodePointEscape':
        return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

      default:
        throw Error('Unsupported node kind: ' + kind);
    }
  }
  /*--------------------------------------------------------------------------*/
  // Used to generate strings for each node type.


  var generators = {
    'alternative': generateAlternative,
    'anchor': generateAnchor,
    'characterClass': generateCharacterClass,
    'characterClassEscape': generateCharacterClassEscape,
    'characterClassRange': generateCharacterClassRange,
    'unicodePropertyEscape': generateUnicodePropertyEscape,
    'disjunction': generateDisjunction,
    'dot': generateDot,
    'group': generateGroup,
    'quantifier': generateQuantifier,
    'reference': generateReference,
    'value': generateValue
  };
  /*--------------------------------------------------------------------------*/
  // Export regjsgen.

  var regjsgen = {
    'generate': generate
  }; // Some AMD build optimizers, like r.js, check for condition patterns like the following:

  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
    // Define as an anonymous module so it can be aliased through path mapping.
    define(function () {
      return regjsgen;
    });
    root.regjsgen = regjsgen;
  } // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && hasFreeModule) {
      // Export for CommonJS support.
      freeExports.generate = generate;
    } else {
      // Export to the global object.
      root.regjsgen = regjsgen;
    }
}).call(void 0);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1068:[function(require,module,exports){
"use strict";

// regjsparser
//
// ==================================================================
//
// See ECMA-262 Standard: 15.10.1
//
// NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
//   term "Anchor" is used.
//
// Pattern ::
//      Disjunction
//
// Disjunction ::
//      Alternative
//      Alternative | Disjunction
//
// Alternative ::
//      [empty]
//      Alternative Term
//
// Term ::
//      Anchor
//      Atom
//      Atom Quantifier
//
// Anchor ::
//      ^
//      $
//      \ b
//      \ B
//      ( ? = Disjunction )
//      ( ? ! Disjunction )
//      ( ? < = Disjunction )
//      ( ? < ! Disjunction )
//
// Quantifier ::
//      QuantifierPrefix
//      QuantifierPrefix ?
//
// QuantifierPrefix ::
//      *
//      +
//      ?
//      { DecimalDigits }
//      { DecimalDigits , }
//      { DecimalDigits , DecimalDigits }
//
// Atom ::
//      PatternCharacter
//      .
//      \ AtomEscape
//      CharacterClass
//      ( GroupSpecifier Disjunction )
//      ( ? : Disjunction )
//
// PatternCharacter ::
//      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
//
// AtomEscape ::
//      DecimalEscape
//      CharacterEscape
//      CharacterClassEscape
//      k GroupName
//
// CharacterEscape[U] ::
//      ControlEscape
//      c ControlLetter
//      HexEscapeSequence
//      RegExpUnicodeEscapeSequence[?U] (ES6)
//      IdentityEscape[?U]
//
// ControlEscape ::
//      one of f n r t v
// ControlLetter ::
//      one of
//          a b c d e f g h i j k l m n o p q r s t u v w x y z
//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
//
// IdentityEscape ::
//      SourceCharacter but not c
//
// DecimalEscape ::
//      DecimalIntegerLiteral [lookahead  DecimalDigit]
//
// CharacterClassEscape ::
//      one of d D s S w W
//
// CharacterClass ::
//      [ [lookahead  {^}] ClassRanges ]
//      [ ^ ClassRanges ]
//
// ClassRanges ::
//      [empty]
//      NonemptyClassRanges
//
// NonemptyClassRanges ::
//      ClassAtom
//      ClassAtom NonemptyClassRangesNoDash
//      ClassAtom - ClassAtom ClassRanges
//
// NonemptyClassRangesNoDash ::
//      ClassAtom
//      ClassAtomNoDash NonemptyClassRangesNoDash
//      ClassAtomNoDash - ClassAtom ClassRanges
//
// ClassAtom ::
//      -
//      ClassAtomNoDash
//
// ClassAtomNoDash ::
//      SourceCharacter but not one of \ or ] or -
//      \ ClassEscape
//
// ClassEscape ::
//      DecimalEscape
//      b
//      CharacterEscape
//      CharacterClassEscape
//
// GroupSpecifier ::
//      [empty]
//      ? GroupName
//
// GroupName ::
//      < RegExpIdentifierName >
//
// RegExpIdentifierName ::
//      RegExpIdentifierStart
//      RegExpIdentifierName RegExpIdentifierContinue
//
// RegExpIdentifierStart ::
//      UnicodeIDStart
//      $
//      _
//      \ RegExpUnicodeEscapeSequence
//
// RegExpIdentifierContinue ::
//      UnicodeIDContinue
//      $
//      _
//      \ RegExpUnicodeEscapeSequence
//      <ZWNJ>
//      <ZWJ>
(function () {
  var fromCodePoint = String.fromCodePoint || function () {
    // Implementation taken from
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint
    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;
    return function fromCodePoint() {
      var MAX_SIZE = 0x4000;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;

      if (!length) {
        return '';
      }

      var result = '';

      while (++index < length) {
        var codePoint = Number(arguments[index]);

        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 0x10FFFF || // not a valid Unicode code point
        floor(codePoint) != codePoint // not an integer
        ) {
            throw RangeError('Invalid code point: ' + codePoint);
          }

        if (codePoint <= 0xFFFF) {
          // BMP code point
          codeUnits.push(codePoint);
        } else {
          // Astral code point; split in surrogate halves
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = codePoint % 0x400 + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }

        if (index + 1 == length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }

      return result;
    };
  }();

  function parse(str, flags, features) {
    if (!features) {
      features = {};
    }

    function addRaw(node) {
      node.raw = str.substring(node.range[0], node.range[1]);
      return node;
    }

    function updateRawStart(node, start) {
      node.range[0] = start;
      return addRaw(node);
    }

    function createAnchor(kind, rawLength) {
      return addRaw({
        type: 'anchor',
        kind: kind,
        range: [pos - rawLength, pos]
      });
    }

    function createValue(kind, codePoint, from, to) {
      return addRaw({
        type: 'value',
        kind: kind,
        codePoint: codePoint,
        range: [from, to]
      });
    }

    function createEscaped(kind, codePoint, value, fromOffset) {
      fromOffset = fromOffset || 0;
      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
    }

    function createCharacter(matches) {
      var _char = matches[0];

      var first = _char.charCodeAt(0);

      if (hasUnicodeFlag) {
        var second;

        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
          second = lookahead().charCodeAt(0);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            pos++;
            return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
          }
        }
      }

      return createValue('symbol', first, pos - 1, pos);
    }

    function createDisjunction(alternatives, from, to) {
      return addRaw({
        type: 'disjunction',
        body: alternatives,
        range: [from, to]
      });
    }

    function createDot() {
      return addRaw({
        type: 'dot',
        range: [pos - 1, pos]
      });
    }

    function createCharacterClassEscape(value) {
      return addRaw({
        type: 'characterClassEscape',
        value: value,
        range: [pos - 2, pos]
      });
    }

    function createReference(matchIndex) {
      return addRaw({
        type: 'reference',
        matchIndex: parseInt(matchIndex, 10),
        range: [pos - 1 - matchIndex.length, pos]
      });
    }

    function createNamedReference(name) {
      return addRaw({
        type: 'reference',
        name: name,
        range: [name.range[0] - 3, pos]
      });
    }

    function createGroup(behavior, disjunction, from, to) {
      return addRaw({
        type: 'group',
        behavior: behavior,
        body: disjunction,
        range: [from, to]
      });
    }

    function createQuantifier(min, max, from, to) {
      if (to == null) {
        from = pos - 1;
        to = pos;
      }

      return addRaw({
        type: 'quantifier',
        min: min,
        max: max,
        greedy: true,
        body: null,
        // set later on
        range: [from, to]
      });
    }

    function createAlternative(terms, from, to) {
      return addRaw({
        type: 'alternative',
        body: terms,
        range: [from, to]
      });
    }

    function createCharacterClass(classRanges, negative, from, to) {
      return addRaw({
        type: 'characterClass',
        body: classRanges,
        negative: negative,
        range: [from, to]
      });
    }

    function createClassRange(min, max, from, to) {
      // See 15.10.2.15:
      if (min.codePoint > max.codePoint) {
        bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
      }

      return addRaw({
        type: 'characterClassRange',
        min: min,
        max: max,
        range: [from, to]
      });
    }

    function flattenBody(body) {
      if (body.type === 'alternative') {
        return body.body;
      } else {
        return [body];
      }
    }

    function isEmpty(obj) {
      return obj.type === 'empty';
    }

    function incr(amount) {
      amount = amount || 1;
      var res = str.substring(pos, pos + amount);
      pos += amount || 1;
      return res;
    }

    function skip(value) {
      if (!match(value)) {
        bail('character', value);
      }
    }

    function match(value) {
      if (str.indexOf(value, pos) === pos) {
        return incr(value.length);
      }
    }

    function lookahead() {
      return str[pos];
    }

    function current(value) {
      return str.indexOf(value, pos) === pos;
    }

    function next(value) {
      return str[pos + 1] === value;
    }

    function matchReg(regExp) {
      var subStr = str.substring(pos);
      var res = subStr.match(regExp);

      if (res) {
        res.range = [];
        res.range[0] = pos;
        incr(res[0].length);
        res.range[1] = pos;
      }

      return res;
    }

    function parseDisjunction() {
      // Disjunction ::
      //      Alternative
      //      Alternative | Disjunction
      var res = [],
          from = pos;
      res.push(parseAlternative());

      while (match('|')) {
        res.push(parseAlternative());
      }

      if (res.length === 1) {
        return res[0];
      }

      return createDisjunction(res, from, pos);
    }

    function parseAlternative() {
      var res = [],
          from = pos;
      var term; // Alternative ::
      //      [empty]
      //      Alternative Term

      while (term = parseTerm()) {
        res.push(term);
      }

      if (res.length === 1) {
        return res[0];
      }

      return createAlternative(res, from, pos);
    }

    function parseTerm() {
      // Term ::
      //      Anchor
      //      Atom
      //      Atom Quantifier
      if (pos >= str.length || current('|') || current(')')) {
        return null;
        /* Means: The term is empty */
      }

      var anchor = parseAnchor();

      if (anchor) {
        return anchor;
      }

      var atom = parseAtom();

      if (!atom) {
        bail('Expected atom');
      }

      var quantifier = parseQuantifier() || false;

      if (quantifier) {
        quantifier.body = flattenBody(atom); // The quantifier contains the atom. Therefore, the beginning of the
        // quantifier range is given by the beginning of the atom.

        updateRawStart(quantifier, atom.range[0]);
        return quantifier;
      }

      return atom;
    }

    function parseGroup(matchA, typeA, matchB, typeB) {
      var type = null,
          from = pos;

      if (match(matchA)) {
        type = typeA;
      } else if (match(matchB)) {
        type = typeB;
      } else {
        return false;
      }

      return finishGroup(type, from);
    }

    function finishGroup(type, from) {
      var body = parseDisjunction();

      if (!body) {
        bail('Expected disjunction');
      }

      skip(')');
      var group = createGroup(type, flattenBody(body), from, pos);

      if (type == 'normal') {
        // Keep track of the number of closed groups. This is required for
        // parseDecimalEscape(). In case the string is parsed a second time the
        // value already holds the total count and no incrementation is required.
        if (firstIteration) {
          closedCaptureCounter++;
        }
      }

      return group;
    }

    function parseAnchor() {
      // Anchor ::
      //      ^
      //      $
      //      \ b
      //      \ B
      //      ( ? = Disjunction )
      //      ( ? ! Disjunction )
      var res,
          from = pos;

      if (match('^')) {
        return createAnchor('start', 1
        /* rawLength */
        );
      } else if (match('$')) {
        return createAnchor('end', 1
        /* rawLength */
        );
      } else if (match('\\b')) {
        return createAnchor('boundary', 2
        /* rawLength */
        );
      } else if (match('\\B')) {
        return createAnchor('not-boundary', 2
        /* rawLength */
        );
      } else {
        return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
      }
    }

    function parseQuantifier() {
      // Quantifier ::
      //      QuantifierPrefix
      //      QuantifierPrefix ?
      //
      // QuantifierPrefix ::
      //      *
      //      +
      //      ?
      //      { DecimalDigits }
      //      { DecimalDigits , }
      //      { DecimalDigits , DecimalDigits }
      var res,
          from = pos;
      var quantifier;
      var min, max;

      if (match('*')) {
        quantifier = createQuantifier(0);
      } else if (match('+')) {
        quantifier = createQuantifier(1);
      } else if (match('?')) {
        quantifier = createQuantifier(0, 1);
      } else if (res = matchReg(/^\{([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
      } else if (res = matchReg(/^\{([0-9]+),\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
      } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        max = parseInt(res[2], 10);

        if (min > max) {
          bail('numbers out of order in {} quantifier', '', from, pos);
        }

        quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
      }

      if (quantifier) {
        if (match('?')) {
          quantifier.greedy = false;
          quantifier.range[1] += 1;
        }
      }

      return quantifier;
    }

    function parseAtom() {
      // Atom ::
      //      PatternCharacter
      //      .
      //      \ AtomEscape
      //      CharacterClass
      //      ( GroupSpecifier Disjunction )
      //      ( ? : Disjunction )
      var res; // jviereck: allow ']', '}' here as well to be compatible with browser's
      //   implementations: ']'.match(/]/);
      // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {

      if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
        //      PatternCharacter
        return createCharacter(res);
      } else if (match('.')) {
        //      .
        return createDot();
      } else if (match('\\')) {
        //      \ AtomEscape
        res = parseAtomEscape();

        if (!res) {
          if (!hasUnicodeFlag && lookahead() == 'c') {
            // B.1.4 ExtendedAtom
            // \[lookahead = c]
            return createValue('symbol', 92, pos - 1, pos);
          }

          bail('atomEscape');
        }

        return res;
      } else if (res = parseCharacterClass()) {
        return res;
      } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
        return res;
      } else if (features.namedGroups && match("(?<")) {
        var name = parseIdentifier();
        skip(">");
        var group = finishGroup("normal", name.range[0] - 3);
        group.name = name;
        return group;
      } else {
        //      ( Disjunction )
        //      ( ? : Disjunction )
        return parseGroup('(?:', 'ignore', '(', 'normal');
      }
    }

    function parseUnicodeSurrogatePairEscape(firstEscape) {
      if (hasUnicodeFlag) {
        var first, second;

        if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
          var prevPos = pos;
          pos++;
          var secondEscape = parseClassEscape();

          if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            firstEscape.range[1] = secondEscape.range[1];
            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            firstEscape.type = 'value';
            firstEscape.kind = 'unicodeCodePointEscape';
            addRaw(firstEscape);
          } else {
            pos = prevPos;
          }
        }
      }

      return firstEscape;
    }

    function parseClassEscape() {
      return parseAtomEscape(true);
    }

    function parseAtomEscape(insideCharacterClass) {
      // AtomEscape ::
      //      DecimalEscape
      //      CharacterEscape
      //      CharacterClassEscape
      //      k GroupName
      var res,
          from = pos;
      res = parseDecimalEscape() || parseNamedReference();

      if (res) {
        return res;
      } // For ClassEscape


      if (insideCharacterClass) {
        if (match('b')) {
          // 15.10.2.19
          // The production ClassEscape :: b evaluates by returning the
          // CharSet containing the one character <BS> (Unicode value 0008).
          return createEscaped('singleEscape', 0x0008, '\\b');
        } else if (match('B')) {
          bail('\\B not possible inside of CharacterClass', '', from);
        } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
          // B.1.4
          // c ClassControlLetter
          return createEscaped('controlLetter', res[1] + 16, res[1], 2);
        }
      }

      res = parseCharacterEscape();
      return res;
    }

    function parseDecimalEscape() {
      // DecimalEscape ::
      //      DecimalIntegerLiteral [lookahead  DecimalDigit]
      //      CharacterClassEscape :: one of d D s S w W
      var res, match;

      if (res = matchReg(/^(?!0)\d+/)) {
        match = res[0];
        var refIdx = parseInt(res[0], 10);

        if (refIdx <= closedCaptureCounter) {
          // If the number is smaller than the normal-groups found so
          // far, then it is a reference...
          return createReference(res[0]);
        } else {
          // ... otherwise it needs to be interpreted as a octal (if the
          // number is in an octal format). If it is NOT octal format,
          // then the slash is ignored and the number is matched later
          // as normal characters.
          // Recall the negative decision to decide if the input must be parsed
          // a second time with the total normal-groups.
          backrefDenied.push(refIdx); // Reset the position again, as maybe only parts of the previous
          // matched numbers are actual octal numbers. E.g. in '019' only
          // the '01' should be matched.

          incr(-res[0].length);

          if (res = matchReg(/^[0-7]{1,3}/)) {
            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
          } else {
            // If we end up here, we have a case like /\91/. Then the
            // first slash is to be ignored and the 9 & 1 to be treated
            // like ordinary characters. Create a character for the
            // first number only here - other number-characters
            // (if available) will be matched later.
            res = createCharacter(matchReg(/^[89]/));
            return updateRawStart(res, res.range[0] - 1);
          }
        }
      } // Only allow octal numbers in the following. All matched numbers start
      // with a zero (if the do not, the previous if-branch is executed).
      // If the number is not octal format and starts with zero (e.g. `091`)
      // then only the zeros `0` is treated here and the `91` are ordinary
      // characters.
      // Example:
      //   /\091/.exec('\091')[0].length === 3
      else if (res = matchReg(/^[0-7]{1,3}/)) {
          match = res[0];

          if (/^0{1,3}$/.test(match)) {
            // If they are all zeros, then only take the first one.
            return createEscaped('null', 0x0000, '0', match.length + 1);
          } else {
            return createEscaped('octal', parseInt(match, 8), match, 1);
          }
        } else if (res = matchReg(/^[dDsSwW]/)) {
          return createCharacterClassEscape(res[0]);
        }

      return false;
    }

    function parseNamedReference() {
      if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
        var name = parseIdentifier();
        skip('>');
        return createNamedReference(name);
      }
    }

    function parseRegExpUnicodeEscapeSequence() {
      var res;

      if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
        // UnicodeEscapeSequence
        return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
      } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
      }
    }

    function parseCharacterEscape() {
      // CharacterEscape ::
      //      ControlEscape
      //      c ControlLetter
      //      HexEscapeSequence
      //      UnicodeEscapeSequence
      //      IdentityEscape
      var res;
      var from = pos;

      if (res = matchReg(/^[fnrtv]/)) {
        // ControlEscape
        var codePoint = 0;

        switch (res[0]) {
          case 't':
            codePoint = 0x009;
            break;

          case 'n':
            codePoint = 0x00A;
            break;

          case 'v':
            codePoint = 0x00B;
            break;

          case 'f':
            codePoint = 0x00C;
            break;

          case 'r':
            codePoint = 0x00D;
            break;
        }

        return createEscaped('singleEscape', codePoint, '\\' + res[0]);
      } else if (res = matchReg(/^c([a-zA-Z])/)) {
        // c ControlLetter
        return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
      } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
        // HexEscapeSequence
        return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
      } else if (res = parseRegExpUnicodeEscapeSequence()) {
        if (!res || res.codePoint > 0x10FFFF) {
          bail('Invalid escape sequence', null, from, pos);
        }

        return res;
      } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
        // https://github.com/jviereck/regjsparser/issues/77
        return addRaw({
          type: 'unicodePropertyEscape',
          negative: res[1] === 'P',
          value: res[2],
          range: [res.range[0] - 1, res.range[1]],
          raw: res[0]
        });
      } else {
        // IdentityEscape
        return parseIdentityEscape();
      }
    }

    function parseIdentifierAtom(check) {
      var ch = lookahead();
      var from = pos;

      if (ch === '\\') {
        incr();
        var esc = parseRegExpUnicodeEscapeSequence();

        if (!esc || !check(esc.codePoint)) {
          bail('Invalid escape sequence', null, from, pos);
        }

        return fromCodePoint(esc.codePoint);
      }

      var code = ch.charCodeAt(0);

      if (code >= 0xD800 && code <= 0xDBFF) {
        ch += str[pos + 1];
        var second = ch.charCodeAt(1);

        if (second >= 0xDC00 && second <= 0xDFFF) {
          // Unicode surrogate pair
          code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }

      if (!check(code)) return;
      incr();
      if (code > 0xFFFF) incr();
      return ch;
    }

    function parseIdentifier() {
      // RegExpIdentifierName ::
      //      RegExpIdentifierStart
      //      RegExpIdentifierName RegExpIdentifierContinue
      //
      // RegExpIdentifierStart ::
      //      UnicodeIDStart
      //      $
      //      _
      //      \ RegExpUnicodeEscapeSequence
      //
      // RegExpIdentifierContinue ::
      //      UnicodeIDContinue
      //      $
      //      _
      //      \ RegExpUnicodeEscapeSequence
      //      <ZWNJ>
      //      <ZWJ>
      var start = pos;
      var res = parseIdentifierAtom(isIdentifierStart);

      if (!res) {
        bail('Invalid identifier');
      }

      var ch;

      while (ch = parseIdentifierAtom(isIdentifierPart)) {
        res += ch;
      }

      return addRaw({
        type: 'identifier',
        value: res,
        range: [start, pos]
      });
    }

    function isIdentifierStart(ch) {
      // Generated by `tools/generate-identifier-regex.js`.
      var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
      return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
      ch >= 65 && ch <= 90 || // A..Z
      ch >= 97 && ch <= 122 || // a..z
      ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
    } // Taken from the Esprima parser.


    function isIdentifierPart(ch) {
      // Generated by `tools/generate-identifier-regex.js`.
      var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
      return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || // 0..9
      ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
    }

    function parseIdentityEscape() {
      // IdentityEscape ::
      //      SourceCharacter but not c
      var tmp;

      if (lookahead() !== 'c') {
        tmp = incr();
        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
      }

      return null;
    }

    function parseCharacterClass() {
      // CharacterClass ::
      //      [ [lookahead  {^}] ClassRanges ]
      //      [ ^ ClassRanges ]
      var res,
          from = pos;

      if (res = matchReg(/^\[\^/)) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, true, from, pos);
      } else if (match('[')) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, false, from, pos);
      }

      return null;
    }

    function parseClassRanges() {
      // ClassRanges ::
      //      [empty]
      //      NonemptyClassRanges
      var res;

      if (current(']')) {
        // Empty array means nothing insinde of the ClassRange.
        return [];
      } else {
        res = parseNonemptyClassRanges();

        if (!res) {
          bail('nonEmptyClassRanges');
        }

        return res;
      }
    }

    function parseHelperClassRanges(atom) {
      var from, to, res;

      if (current('-') && !next(']')) {
        // ClassAtom - ClassAtom ClassRanges
        skip('-');
        res = parseClassAtom();

        if (!res) {
          bail('classAtom');
        }

        to = pos;
        var classRanges = parseClassRanges();

        if (!classRanges) {
          bail('classRanges');
        }

        from = atom.range[0];

        if (classRanges.type === 'empty') {
          return [createClassRange(atom, res, from, to)];
        }

        return [createClassRange(atom, res, from, to)].concat(classRanges);
      }

      res = parseNonemptyClassRangesNoDash();

      if (!res) {
        bail('nonEmptyClassRangesNoDash');
      }

      return [atom].concat(res);
    }

    function parseNonemptyClassRanges() {
      // NonemptyClassRanges ::
      //      ClassAtom
      //      ClassAtom NonemptyClassRangesNoDash
      //      ClassAtom - ClassAtom ClassRanges
      var atom = parseClassAtom();

      if (!atom) {
        bail('classAtom');
      }

      if (current(']')) {
        // ClassAtom
        return [atom];
      } // ClassAtom NonemptyClassRangesNoDash
      // ClassAtom - ClassAtom ClassRanges


      return parseHelperClassRanges(atom);
    }

    function parseNonemptyClassRangesNoDash() {
      // NonemptyClassRangesNoDash ::
      //      ClassAtom
      //      ClassAtomNoDash NonemptyClassRangesNoDash
      //      ClassAtomNoDash - ClassAtom ClassRanges
      var res = parseClassAtom();

      if (!res) {
        bail('classAtom');
      }

      if (current(']')) {
        //      ClassAtom
        return res;
      } // ClassAtomNoDash NonemptyClassRangesNoDash
      // ClassAtomNoDash - ClassAtom ClassRanges


      return parseHelperClassRanges(res);
    }

    function parseClassAtom() {
      // ClassAtom ::
      //      -
      //      ClassAtomNoDash
      if (match('-')) {
        return createCharacter('-');
      } else {
        return parseClassAtomNoDash();
      }
    }

    function parseClassAtomNoDash() {
      // ClassAtomNoDash ::
      //      SourceCharacter but not one of \ or ] or -
      //      \ ClassEscape
      var res;

      if (res = matchReg(/^[^\\\]-]/)) {
        return createCharacter(res[0]);
      } else if (match('\\')) {
        res = parseClassEscape();

        if (!res) {
          bail('classEscape');
        }

        return parseUnicodeSurrogatePairEscape(res);
      }
    }

    function bail(message, details, from, to) {
      from = from == null ? pos : from;
      to = to == null ? from : to;
      var contextStart = Math.max(0, from - 10);
      var contextEnd = Math.min(to + 10, str.length); // Output a bit of context and a line pointing to where our error is.
      //
      // We are assuming that there are no actual newlines in the content as this is a regular expression.

      var context = '    ' + str.substring(contextStart, contextEnd);
      var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
      throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
    }

    var backrefDenied = [];
    var closedCaptureCounter = 0;
    var firstIteration = true;
    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
    var pos = 0; // Convert the input to a string and treat the empty string special.

    str = String(str);

    if (str === '') {
      str = '(?:)';
    }

    var result = parseDisjunction();

    if (result.range[1] !== str.length) {
      bail('Could not parse entire input - got stuck', '', result.range[1]);
    } // The spec requires to interpret the `\2` in `/\2()()/` as backreference.
    // As the parser collects the number of capture groups as the string is
    // parsed it is impossible to make these decisions at the point when the
    // `\2` is handled. In case the local decision turns out to be wrong after
    // the parsing has finished, the input string is parsed a second time with
    // the total number of capture groups set.
    //
    // SEE: https://github.com/jviereck/regjsparser/issues/70


    for (var i = 0; i < backrefDenied.length; i++) {
      if (backrefDenied[i] <= closedCaptureCounter) {
        // Parse the input a second time.
        pos = 0;
        firstIteration = false;
        return parseDisjunction();
      }
    }

    return result;
  }

  var regjsparser = {
    parse: parse
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = regjsparser;
  } else {
    window.regjsparser = regjsparser;
  }
})();

},{}],1069:[function(require,module,exports){
"use strict";

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

},{"buffer":289}],1070:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function debug() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function debug() {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var R = 0; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
src[FULL] = '^' + FULLPLAIN + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';
var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])'; // Tilde ranges.
// Meaning is "reasonably at or greater than"

var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';
var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

var LONECARET = R++;
src[LONECARET] = '(?:\\^)';
var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';
var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[LOOSE] : re[FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a === b;

    case '!==':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1];

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[STAR], '');
} // This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  var match = version.match(re[COERCE]);

  if (match == null) {
    return null;
  }

  return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
}

}).call(this,require('_process'))
},{"_process":1054}],1071:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":1080}],1072:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var base64 = require('./base64'); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011


var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":1073}],1073:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


exports.decode = function (charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};

},{}],1074:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */

function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);

  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    } // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    } // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */


exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

  if (index < 0) {
    return -1;
  } // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.


  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }

    --index;
  }

  return index;
};

},{}],1075:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */


function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

exports.MappingList = MappingList;

},{"./util":1080}],1076:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],1077:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var binarySearch = require('./binary-search');

var ArraySet = require('./array-set').ArraySet;

var base64VLQ = require('./base64-vlq');

var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function get() {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function get() {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);

    if (source != null && sourceRoot != null) {
      source = util.join(sourceRoot, source);
    }

    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */


SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };

  if (this.sourceRoot != null) {
    needle.source = util.relative(this.sourceRoot, needle.source);
  }

  if (!this._sources.has(needle.source)) {
    return [];
  }

  needle.source = this._sources.indexOf(needle.source);
  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */

BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);

        if (this.sourceRoot != null) {
          source = util.join(this.sourceRoot, source);
        }
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  if (this.sourceRoot != null) {
    aSource = util.relative(this.sourceRoot, aSource);
  }

  if (this._sources.has(aSource)) {
    return this.sourcesContent[this._sources.indexOf(aSource)];
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + aSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');

  if (this.sourceRoot != null) {
    source = util.relative(this.sourceRoot, source);
  }

  if (!this._sources.has(source)) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  source = this._sources.indexOf(source);
  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      if (section.consumer.sourceRoot !== null) {
        source = util.join(section.consumer.sourceRoot, source);
      }

      this._sources.add(source);

      source = this._sources.indexOf(source);

      var name = section.consumer._names.at(mapping.name);

      this._names.add(name);

      name = this._names.indexOf(name); // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.

      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":1071,"./base64-vlq":1072,"./binary-search":1074,"./quick-sort":1076,"./util":1080}],1078:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var base64VLQ = require('./base64-vlq');

var util = require('./util');

var ArraySet = require('./array-set').ArraySet;

var MappingList = require('./mapping-list').MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */


function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet();
  var newNames = new ArraySet(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":1071,"./base64-vlq":1072,"./mapping-list":1075,"./util":1080}],1079:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;

var util = require('./util'); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).


var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function shiftNextLine() {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex];
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex];
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":1078,"./util":1080}],1080:[function(require,module,exports){
"use strict";

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}

exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);

  if (!match) {
    return null;
  }

  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}

exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';

  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }

  url += '//';

  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }

  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }

  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }

  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }

  return url;
}

exports.urlGenerate = urlGenerate;
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */

function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);

  if (url) {
    if (!url.path) {
      return aPath;
    }

    path = url.path;
  }

  var isAbsolute = exports.isAbsolute(path);
  var parts = path.split(/\/+/);

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];

    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }

  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }

  return path;
}

exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */

function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  if (aPath === "") {
    aPath = ".";
  }

  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);

  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  } // `join(foo, '//www.example.org')`


  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }

    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  } // `join('http://', 'www.example.com')`


  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }

  return joined;
}

exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */


function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.

  var level = 0;

  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");

    if (index < 0) {
      return aPath;
    } // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.


    aRoot = aRoot.slice(0, index);

    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  } // Make sure we add a "../" for each component we removed from the root.


  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}

exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */


function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}

exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}

exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9
  /* "__proto__".length */
  ) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95
  /* '_' */
  || s.charCodeAt(length - 2) !== 95
  /* '_' */
  || s.charCodeAt(length - 3) !== 111
  /* 'o' */
  || s.charCodeAt(length - 4) !== 116
  /* 't' */
  || s.charCodeAt(length - 5) !== 111
  /* 'o' */
  || s.charCodeAt(length - 6) !== 114
  /* 'r' */
  || s.charCodeAt(length - 7) !== 112
  /* 'p' */
  || s.charCodeAt(length - 8) !== 95
  /* '_' */
  || s.charCodeAt(length - 9) !== 95
  /* '_' */
  ) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36
    /* '$' */
    ) {
        return false;
      }
  }

  return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */


function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}

exports.compareByOriginalPositions = compareByOriginalPositions;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */

function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}

exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */


function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],1081:[function(require,module,exports){
"use strict";

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":1077,"./lib/source-map-generator":1078,"./lib/source-node":1079}],1082:[function(require,module,exports){
'use strict';

module.exports = {
  stdout: false,
  stderr: false
};

},{}],1083:[function(require,module,exports){
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var fastProto = null; // Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.

function FastObject(o) {
  // A prototype object will have "fast properties" enabled once it is checked
  // against the inline property cache of a function, e.g. fastProto.property:
  // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
  if (fastProto !== null && _typeof(fastProto.property)) {
    var result = fastProto;
    fastProto = FastObject.prototype = null;
    return result;
  }

  fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
  return new FastObject();
} // Initialize the inline property cache of FastObject


FastObject();

module.exports = function toFastproperties(o) {
  return FastObject(o);
};

},{}],1084:[function(require,module,exports){
"use strict";

module.exports = new Set([// Non-binary properties:
'General_Category', 'Script', 'Script_Extensions', // Binary properties:
'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

},{}],1085:[function(require,module,exports){
'use strict';

var canonicalProperties = require('unicode-canonical-property-names-ecmascript');

var propertyAliases = require('unicode-property-aliases-ecmascript');

var matchProperty = function matchProperty(property) {
  if (canonicalProperties.has(property)) {
    return property;
  }

  if (propertyAliases.has(property)) {
    return propertyAliases.get(property);
  }

  throw new Error("Unknown property: ".concat(property));
};

module.exports = matchProperty;

},{"unicode-canonical-property-names-ecmascript":1084,"unicode-property-aliases-ecmascript":1088}],1086:[function(require,module,exports){
"use strict";

module.exports = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

},{}],1087:[function(require,module,exports){
'use strict';

var propertyToValueAliases = require('./data/mappings.js');

var matchPropertyValue = function matchPropertyValue(property, value) {
  var aliasToValue = propertyToValueAliases.get(property);

  if (!aliasToValue) {
    throw new Error("Unknown property `".concat(property, "`."));
  }

  var canonicalValue = aliasToValue.get(value);

  if (canonicalValue) {
    return canonicalValue;
  }

  throw new Error("Unknown value `".concat(value, "` for property `").concat(property, "`."));
};

module.exports = matchPropertyValue;

},{"./data/mappings.js":1086}],1088:[function(require,module,exports){
"use strict";

// Generated using `npm run build`. Do not edit!
module.exports = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['Ext', 'Extender'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

},{}],1089:[function(require,module,exports){
arguments[4][279][0].apply(exports,arguments)
},{"dup":279}],1090:[function(require,module,exports){
arguments[4][280][0].apply(exports,arguments)
},{"dup":280}],1091:[function(require,module,exports){
arguments[4][281][0].apply(exports,arguments)
},{"./support/isBuffer":1090,"_process":1054,"dup":281,"inherits":1089}],1092:[function(require,module,exports){
"use strict";

// Polyfills needed for Babel to function
require("core-js");

var babelTransform = require('@babel/core').transform;

var babelTransformDynamicImport = require('@babel/plugin-syntax-dynamic-import');

var babelTransformModulesSystemJS = require('@babel/plugin-transform-modules-systemjs');

var babelPresetEnv = require('@babel/preset-env');

self.onmessage = function (evt) {
  // transform source with Babel
  var output = babelTransform(evt.data.source, {
    compact: false,
    filename: evt.data.key + '!transpiled',
    sourceFileName: evt.data.key,
    moduleIds: false,
    sourceMaps: 'inline',
    babelrc: false,
    plugins: [babelTransformDynamicImport, babelTransformModulesSystemJS],
    presets: [[babelPresetEnv, {
      targets: 'ie >= 11'
    }]]
  });
  self.postMessage({
    key: evt.data.key,
    code: output.code,
    source: evt.data.source
  });
};

},{"@babel/core":19,"@babel/plugin-syntax-dynamic-import":99,"@babel/plugin-transform-modules-systemjs":122,"@babel/preset-env":149,"core-js":309}]},{},[1092]);
